{"pages":[{"title":"About","text":"I‚Äôm Uy Nguyen.I‚Äôm a Software Engineer, creating awesome and effective softwares to serve people around the world.Let‚Äôs start scrolling and learn more about me. Education:University of Science - Vietnam National UniversityBachelor in Software Engineering, GPA 8.87 / 10.0Thesis: Question and Answer system integrated with an online IDE.This system allows users to create projects, build, run and debug applications online with an IDE that supports three majors programming languages: C/C++, C#, and Java. If there are any problems while development, users can post questions linked to their projects, other members will help them to solve the problems by answering the questions directly. By using this system, users will not have to spend time installing IDEs on their computers and reducing debugging time thanks to the help of the community. ProjectsSoftware Development Kit ‚Äì Fossil GroupThe Fossil App is the companion app for Fossil‚Äôs line of smartwatches. Receive alerts from your favorite contacts and apps, compare multiple time zones and track everything from steps to sleep through the app. Turn your smartwatch into a remote control with customizable buttons that can control your music, check your commute time and more.As a Device Integration Engineer, I develop an SDK built in Bluetooth Low Energy technology in iOS. The SDK lets the application communicate with smartwatches or trackers.Link to App Store Working Experiences: Device Integration Engineer at Fossil Vietnam - MisfitDesign and implement software components to talk with Misfit/Fossil smartwatches, trackers and other wearable products.Detailed achievements: Develop advanced services and SDK (Software Development Kit) on iOS platform to work with Bluetooth Low Energy in Swift and Objective-C. Build iOS apps to demonstrate SDK‚Äôs functions. Analyzing and solving problems of the SDK by using Fabric, Firebase. Build an automation testing system: Support create test cases and run them automatically, then report the result in NodeJs and ReactJs. Continuously investigate new technologies and new frameworks to improve the library Former internship, Full stack developer, taembe.comWork with NodeJs and ReactJs.Detailed achievements: Work on implementing features and improving the back-end side in NodeJs. Work on Implementing and maintaining the front-end code in ReactJs. Work with database in CouchDB, PouchDB and MySQL. Former internship at Renesas Design VietnamWork on embedded system and embedded architecture.Detailed achievements: Develop and verify eight modules of RX chip series: I2C Bus Interface, CRC Calculator,D/A Converter, Data Operation Circuit, Data Transfer Controller, 8 Bit Timer, Compare Match Timer, Clock Frequency Accuracy Measurement Circuit. Technical Stacks: Solid computer science fundamentals with good knowledge of algorithms, data structure and design patterns. Proficiency in Swift and Objective-C. Deep understanding of memory management and multi-threading, including GCD, blocks and dispatch queues. Familiar with iOS SDKs (UIKit, Cocoa Touch, Core Data, Core Location, Core Bluetooth). Familiar with Unit Testing on iOS. Experience releasing applications into the App Store. Deep understanding of RESTful API designs. Experience building web apps in NodeJs, ReactJs, and Redux. Experience building cross-platform apps in React Native. Familiarity with continuous integration (Jenkins), application monitoring (Crashlytics and fabric.io). Experience developing applications on EC2. Familiar with Unix (Mac OSX and Linux command line). Familiar with source version control: Github / Bitbucket. Familiar with Alatsian, Jira.","link":"/about/index.html"}],"posts":[{"title":"ANCS: Apple Notification Center Service","text":"PrefaceANCS, stands for Apple Notification Center Service, is designed by Apple. It allows Bluetooth accessories that connect to iOS devices via BLE a simple way to access notifications that happend on iOS devices. Technical details","link":"/2018/09/20/ANCS-Apple-Notification-Center-Service/"},{"title":"Advanced iOS Concurrency: Async Operations [2]","text":"In the previous post, Advanced iOS Concurrency: Operations, we walked through the Operation concepts on iOS and made a demo application that fetches some posts of mine. After downloading the cover images, they will be applied to a simple filter, then be displayed in a table view. The application, however, has not been completed yet. There‚Äôs something that went wrong with our app making the app did not show downloaded images properly. In this tutorial, we will continue where we left off.Get ready! Operation life cycleTo find out why our app did not function properly, let‚Äôs review the current source code 123456789101112class DownloadImageOperation: Operation { override func main() { guard !isCancelled else { return } URLSession.shared.dataTask(with: self.url, completionHandler: { (data, res, error) in guard error == nil, let data = data else { return } self.outputImage = UIImage(data: data) }).resume() }} The following image describes the changes in states of operations. When the main method gets called, it will execute our asynchronous task and then exit immediately making the state of the operation switch to isFinish. At that point, our asynchronous task actually has not completed yet.Currently, we‚Äôre calling to download an image inside the main method of the Operation. The root cause is related to the Operation Life Cycle itself. Thus, to support asynchronous operations in our app, we need to manually manage states of operations. Key-Value ObservingBefore implementing our custom Async Operation class, we need to learn a new concept first: KVO. I assume that you‚Äôve not heard about this concept so we will have a quick look at it first.Key-Value Observing, aka KVO, is one of the techniques for observing the state changes of an object in Objective-C and Swift. Whenever the value of the observed properties changed, the observing block of code will execute. At the heart of KVO, the main concept is based on the Observer Pattern.Swift classes that are inherited from NSObject class have methods to allow other objects to observe their properties. Key-value observing provides a mechanism that allows objects to be notified of changes to specific properties of other objects. It is particularly useful for communication between model and controller layers in an application. Let‚Äôs create a Playground to test it. 1234567891011121314151617181920212223242526272829class CreditCard: NSObject { @objc dynamic private(set) var number: Int = 1000 func increaseNumber(by value: Int) { self.number += value }}class Person: NSObject { let cretdit: CreditCard var kvoToken: NSKeyValueObservation? init(cretdit: CreditCard) { self.cretdit = cretdit kvoToken = self.cretdit.observe(\\.number, options: .new) { (credit, change) in guard let newNumber = change.newValue else { return } print(\"New number is \\(newNumber)\") } } deinit { kvoToken?.invalidate() }}let credit = CreditCard()let person = Person(cretdit: credit)credit.increaseNumber(by: 500) Here, I define two classes: CreditCard and Person. A Person object holds a CreditCard object as a property. What I want is whenever the number property of the credit card gets changed, the person will be notified. Here is KVO comes.Run the above code in the playground, you should see the log New number is \\(newNumber) print out on your console. Why should we need to know about KVO? The answer is because the Operation class uses KVO notification. Whenever the state of Operation changes, a KVO notification will be sent.Without KVO notifications, the OperationQueue won‚Äôt be able to observe the state of our operations so that it can not get updated correctly. Thus, when we manage the state of operation by ourselves, we must ensure those KVO notifications are sent properly. Async OperationLet‚Äôs create AsyncOperation class inherited from the Operation class. 12345678910class AsyncOperation: Operation { enum State: String { case ready, executing, finished var keyPath: String { return \"is\\(rawValue.capitalized)\" } } // The rest of code} Next, We declare a property to keep track the state of the object. 12345678910var state = State.ready { willSet { willChangeValue(forKey: newValue.keyPath) willChangeValue(forKey: state.keyPath) } didSet { didChangeValue(forKey: oldValue.keyPath) didChangeValue(forKey: state.keyPath) }} The Operation base class needs to know the changes of both the old state and new state.Take a specified case as an example, the state currently is ready, then we set the state to executing. There are 4 KVO notifications should be sent: Firstly, notify the willChangeValue for isReady. Then. notify the willChangeValue for executing. After that, notfiy the willChange for isReady. Finally, notfiy the willChange for executing. After that, We override the properties of states. 123456789101112131415override var isReady: Bool { return super.isReady &amp;&amp; state == .ready}override var isExecuting: Bool { return state == .executing}override var isFinished: Bool { return state == .finished}override var isAsynchronous: Bool { return true} It‚Äôs all for managing the state of Async Operation class. When adding an operation to an operation queue, the start method is what gets called first. then it will call the main method of the operation executing the main block of code you have assigned to the operation. 1234override func start() { main() state = .executing} Remember when I mentioned that Operation has killer features that make it surpass GDC? The first one is dependencies and the other one is the capability of canceling a running operation. It‚Äôs very useful in a case where we want to stop operations that are irrelevant at a certain time. For example, to cancel downloading data when the user scrolls the table making some cells disappear.Let‚Äôs add this feature to our Async Operation class.First, we need to modify the start method to check the isCancelled property before actually calling the main method. 123456789override func start() { if isCancelled { state = .finished return } main() state = .executing} And then override the cancel method to update the state to finished 123override func cancel() { state = .finished} At this point, we‚Äôve finished implementing our Async Operation class. It‚Äôs time to mix everything together in our app. Adding this all togetherBecause the DownloadImageOperation class executes asynchronously, we can not set Operation class as its base class, we now set AsyncOperation instead. Kindly note that to support canceling in DownloadImageOperation class, we will keep the return value of creating a data task as a property of this class so that we can cancel this URLSessionDataTask later.The DownloadImageOperation class will look like below. 123456789101112131415161718192021222324252627282930class DownloadImageOperation: AsyncOperation { let url: URL var outputImage: UIImage? private var task: URLSessionDataTask? init(url: URL) { self.url = url } override func main() { self.task = URLSession.shared.dataTask(with: self.url, completionHandler: { [weak self] (data, res, error) in guard let `self` = self else { return } defer { self.state = .finished } guard !self.isCancelled else { return } guard error == nil, let data = data else { return } self.outputImage = UIImage(data: data) }) task?.resume() } override func cancel() { super.cancel() task?.cancel() }} Let‚Äôs back to our main ViewController. To cancel the running operations, we first add new dictionary as a property of ViewController which tracks all running operations for each table view cell at a corresponding index path. 1private var operations: [IndexPath: [Operation]] = [:] Inside the func tableView(_ tableView:cellForRowAt indexPath:) delegate, after adding two operations to the operation queue, we will also add them to the operations dictionary for tracking. Additionally, if there is an operation for this index path, cancel it before holding the new one. 123456if let existingOperations = operations[indexPath] { for operation in existingOperations { operation.cancel() }}operations[indexPath] = [grayScaleOpt, downloadOpt] When the user scrolls the table, some cells disappear and the delegate func tableView(_ tableView:didEndDisplaying cell:indexPath:) gets called. At that point, we‚Äôll also cancel the running operations for that cell ensuring that only operations of visible cells are executing. 1234567func tableView(_ tableView: UITableView, didEndDisplaying cell: UITableViewCell, forRowAt indexPath: IndexPath) { if let operations = operations[indexPath] { for operation in operations { operation.cancel() } }} Now, you should see the app now works properly. Additionally, by starting and canceling the operations wisely, we‚Äôre saving the network traffic as well as reduce the battery consumption. Those things can make our app run faster. ConclusionThere are some benefits of Operation over GCD that keep our source code maintainable and reusable.The last to mention, please careful when using Operation or GCD because Concurrency sometimes introduces bugs that are not always transparent to find and fix. In Clean Code Book, Robert C. Martin states some important points when working with multiple threads There are some basic definitions we should know when we talk about concurrency and threads: Bound resources, mutual exclusion, starvation, deadlock, and livelock. Concurrency does not always improve performance. It sometimes incurs some overhead and bugs come from it are not usually repeatable. Limit the access of the data that is shared between more than two threads. Use copies of data if there is a chance. Keep the synchronized sections as small as possible because Locks create delays and add overhead. They are expensive. Multithreaded code behaves differently in different environments: Run tests in every potential deployment environment. You can find the final project via the linkThank you for reading. References Chapter 6: Operations, Concurrency By Tutorials - Multithreading in Swift with GCD and Operations, Raywenderlich, Chapter 7: Concurrency and Multitasking, iOS 8 Swift Programming Cookbook, O‚ÄôReilly.","link":"/2020/05/30/Advanced-iOS-Concurrency-Async-Operations-2/"},{"title":"Asynchronous Programming in Swift","text":"Promise Kit, one of the best frameworks to deal with asynchronous programming in Swift In this post, I will use these following third parties to complete the project: Alamofire: A HTTP networking framework in Swift. SwiftyJSON: To process JSON data. SwiftGifOrigin: An UIImage extension to display Gif files. Bolts-Swift: Was designed by Parse and Facebook, I use it to create asynchronous methods. PromiseKit: A framework helps us to simplify asynchronous programming. Giphy‚Äôs APIs for searching and downloading gif images. Getting Started Asynchronous methods, (Async for short), are the methods that not immediately returning results like most method, the async methods take some time to produce results.I often use callbacks to deal with asynchronous methods like scanning Bluetooth devices or retrieving some resources from the internet. In fact, callback is a bad programming technique. Callback will make our code hard to read, hard to debug and take much more time to maintain later. In the end, our code will turn into something that we call the callback hell.In this post, I will create a project using one by one technique to explain why I said callback is bad.Firstly, go ahead and create a project, named it as whatever you like, then install these Pod frameworks to your project. You also need to edit the NSAllowsArbitraryLoads key to YES in NSAppTransportSecurity dictionary in the info.plist file to specify which domains are excepted from the rules you define for App Transport Security. In our case, this is the giphy domain. Allow HTTP requests for only giphy domain 1234567891011&lt;key&gt;NSAppTransportSecurity&lt;/key&gt; &lt;dict&gt; &lt;key&gt;NSExceptionDomains&lt;/key&gt; &lt;dict&gt; &lt;key&gt;api.giphy.com&lt;/key&gt; &lt;dict&gt; &lt;key&gt;NSExceptionAllowsInsecureHTTPLoads&lt;/key&gt; &lt;true/&gt; &lt;/dict&gt; &lt;/dict&gt;&lt;/dict&gt; Or allow HTTP requests for all domains, it is not a good idea. 12345&lt;key&gt;NSAppTransportSecurity&lt;/key&gt;&lt;dict&gt; &lt;key&gt;NSAllowsArbitraryLoads&lt;/key&gt; &lt;true/&gt;&lt;/dict&gt; Let‚Äôs create a class named ImageLoader. This class contains two methods that help us to fetch and download gif images from the Giphy server. 123456789101112//// ImageLoader.swift//class ImageLoader { func fetchImage(keyword: String) { // Searching images that matched keyword on Giphy server } func downloadImage(url: URL) { // Download the image at url }} The first version: Using callbackFirstly, we need to define two callbacks, which will be passed to the fetchImage and downloadImage methods. 12public typealias FetchImageBlock = (URL?, Error?) -&gt; Voidpublic typealias DownloadImageBlock = (URL?, Error?) -&gt; Void Then, we implement these two methods: fetchImage takes a keyword and a callback as params, sends a request to the Giphy server to query all images that match the keyword, gets the first one and finally returns the download url via the callback. downloadImage takes an url and a callback as params, then uses the Alamofire framework to download the image. Finally, returning the destination url, where the image is saved, via the callback. 123456789101112131415161718192021func fetchImage(keyword: String, callback: @escaping FetchImageBlock) { let endPoint = \"http://api.giphy.com/v1/gifs/search?q=\\(keyword)&amp;limit=1&amp;api_key=q4N1oD5jw3xvH2hIOkFAyHXWTTrh0D30\" let headers: HTTPHeaders = [ \"Content-Type\": \"application/json\" ] Alamofire.request(endPoint, headers: headers).responseData { (response) in if let error = response.error { return callback(nil, error) } let jsonData = JSON.init(data: response.data!) let dataArray = jsonData[\"data\"].array if let dataArray = dataArray, dataArray.count &gt; 0 { let imagesList = dataArray[0][\"images\"] let downsized_large = imagesList[\"downsized_large\"][\"url\"].stringValue return callback(URL.init(string: downsized_large), nil) } else { return callback(nil, nil) } }} 123456789101112131415func downloadImage(url: URL, callback: @escaping DownloadImageBlock) { let destination: DownloadRequest.DownloadFileDestination = { _, _ in let documentsURL = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)[0] let fileURL = documentsURL.appendingPathComponent(url.lastPathComponent) return (fileURL, [.removePreviousFile, .createIntermediateDirectories]) } Alamofire.download(url, to: destination).downloadProgress(closure: { (progress) in print(\"\\(progress)\") }).responseData(completionHandler: { (response) in if let error = response.error { return callback(nil, error) } callback(response.destinationURL, nil) })} Inside the main view controller, let‚Äôs define a method called searchImageWithKeyword. This method takes a keyword as a param, then pass the param to the fetchImage method of an instance of the ImageLoader class. We also need to pass a callback to handle the results.Inside the fetchImage callback, let‚Äôs check if there are any errors. If it is, then we stop calling the next method, downloadImage. Otherwise, we call the downloadImage of the imageLoader object. Then pass the url and a callback as params.Inside the downloadImage callback, let‚Äôs check if there are any errors. If it is, then we stop calling the next one. Otherwise, we update the image view on the main view by calling the updateImageAtURL method. 12345678910111213141516171819202122232425262728func searchImageWithKeyword(keyword: String) { let imageLoader = ImageLoader() imageLoader.fetchImage(keyword: keyword, callback: {downloadLink, error in if let error = error { print(\"Error \\(error)\") } else { if let downloadLink = downloadLink { imageLoader.downloadImage(url: downloadLink, callback: {downloadedURL, error in if let error = error { print(\"Error \\(error)\") } else { if let downloadedURL = downloadedURL { self.updateImageAtURL(url: downloadedURL) } else { print(\"Error: downloadedURL is nil\") } } }) } else { print(\"Error: downloadLink is nil\") } } })} 123456789101112131415func updateImageAtURL(url: URL) { guard Thread.isMainThread else { DispatchQueue.main.async { self.updateImageAtURL(url: url) } return } do { let data = try Data.init(contentsOf: url) self.imgImage.image = UIImage.gif(data: data) } catch { print(\"Error \\(error)\") }} As you can see, the searchImageWithKeyword is quite complex with many if and else statements inside the method. We have to check errors in many lines of codes. Imagine how complex it would be if we had more than three methods inside itself? A callback hell in another language, Javascript Build and run the project. Enter a keyword you want to search on the Giphy server, press search button then you will see the first result. The async programming project A better solution: Using BoltsBolts is a framework that was designed by Parse and Facebook, I use it to create asynchronous methods, without using callback. Bolts framework lets we write code as a series of actions based on events. 123456789101112131415161718192021222324func fetchImage(keyword: String) -&gt; Task&lt;URL&gt;! { let mainTask = TaskCompletionSource&lt;URL&gt;() let endPoint = \"http://api.giphy.com/v1/gifs/search?q=\\(keyword)&amp;limit=1&amp;api_key=q4N1oD5jw3xvH2hIOkFAyHXWTTrh0D30\" let headers: HTTPHeaders = [ \"Content-Type\": \"application/json\" ] Alamofire.request(endPoint, headers: headers).responseData { (response) in if let error = response.error { return mainTask.set(error: error) } let jsonData = JSON.init(data: response.data!) let dataArray = jsonData[\"data\"].array if let dataArray = dataArray, dataArray.count &gt; 0 { let imagesList = dataArray[0][\"images\"] let fixed_height_still = imagesList[\"downsized_large\"][\"url\"].stringValue return mainTask.set(result: URL.init(string: fixed_height_still)!) } else { return mainTask.set(error: NSError.init(domain: \"myDomain\", code: 0, userInfo: nil)) } } return mainTask.task} 1234567891011121314151617181920212223func downloadImage(url: URL) -&gt; Task&lt;URL&gt;! { let mainTask = TaskCompletionSource&lt;URL&gt;() let destination: DownloadRequest.DownloadFileDestination = { _, _ in let documentsURL = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)[0] let fileURL = documentsURL.appendingPathComponent(url.lastPathComponent) return (fileURL, [.removePreviousFile, .createIntermediateDirectories]) } Alamofire.download(url, to: destination).downloadProgress(closure: { (progress) in print(\"\\(progress)\") }).responseData(completionHandler: { (response) in if let error = response.error { return mainTask.set(error: error) } if let destinationURL = response.destinationURL { return mainTask.set(result: destinationURL) } else { return mainTask.set(error: NSError.init(domain: \"myDomain\", code: 0, userInfo: nil)) } }) return mainTask.task} Let‚Äôs see how simple the searchImageWithKeyword would be by using Bolts. 12345678910func searchImageWithKeyword(keyword: String) { let imageLoader = ImageLoader() imageLoader.fetchImage(keyword: keyword).continueOnSuccessWith { (linkDownload) -&gt; Void in imageLoader.downloadImage(url: linkDownload).continueOnSuccessWith(continuation: { (downloadedURL) -&gt; Void in self.updateImageAtURL(url: downloadedURL) }) }.continueOnErrorWith { (error) in print(\"Error \\(error)\") }} Build and run the project, nothing changed. But the code is more readable than the first one, isn‚Äôt it? We gather all the errors in one place, also separate error handling and success code. A much better solution: Using PromiseKitOne thing I do not like about Bolts framework is the lack of documentation and example projects. When I first use Bolts framework, I was very hard to get used to with the APIs of the Task object.At the Swift Summit conference 2017, there was one speaker introduced a Framework to deal with async methods, PromiseKit. After the conference, I replaced the code using Bolts framework by PromiseKit at the projects in my company. I realize my code now more readable. I think PromiseKit‚Äôs writing will be more familiar to developers than Bolts‚Äôs writing, especially those who have worked with Javascript like me.An async method created by using PromiseKit returns a new generic Promise, which is the primary class provided by PromiseKit. Its constructor takes a simple execution block with two parameters: fulfill: A function to call when the desired value is ready to fulfill the promise. reject: A function to call if there is an error. Let‚Äôs apply PromiseKit to our project 12345678910111213141516171819202122func fetchImage(keyword: String) -&gt; Promise&lt;URL&gt; { return Promise { fullfil, reject in let endPoint = \"http://api.giphy.com/v1/gifs/search?q=\\(keyword)&amp;limit=1&amp;api_key=q4N1oD5jw3xvH2hIOkFAyHXWTTrh0D30\" let headers: HTTPHeaders = [ \"Content-Type\": \"application/json\" ] Alamofire.request(endPoint, headers: headers).responseData { (response) in if let error = response.error { return reject(error) } let jsonData = JSON.init(data: response.data!) let dataArray = jsonData[\"data\"].array if let dataArray = dataArray, dataArray.count &gt; 0 { let imagesList = dataArray[0][\"images\"] let fixed_height_still = imagesList[\"downsized_large\"][\"url\"].stringValue return fullfil(URL.init(string: fixed_height_still)!) } return reject(NSError.init(domain: \"myDomain\", code: 0, userInfo: nil)) } }} 12345678910111213141516171819202122func downloadImage(url: URL) -&gt; Promise&lt;URL&gt; { return Promise { fullfil, reject in let destination: DownloadRequest.DownloadFileDestination = { _, _ in let documentsURL = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)[0] let fileURL = documentsURL.appendingPathComponent(url.lastPathComponent) return (fileURL, [.removePreviousFile, .createIntermediateDirectories]) } Alamofire.download(url, to: destination).downloadProgress(closure: { (progress) in print(\"\\(progress)\") }).responseData(completionHandler: { (response) in if let error = response.error { return reject(error) } if let destinationURL = response.destinationURL { return fullfil(destinationURL) } reject(NSError.init(domain: \"myDomain\", code: 0, userInfo: nil)) }) }} And the final result, what a beautiful code! :)) 123456789101112func searchImageWithKeyword(keyword: String) { let imageLoader = ImageLoader() firstly { imageLoader.fetchImage(keyword: keyword) }.then { downloadLink -&gt; Promise&lt;URL&gt; in return imageLoader.downloadImage(url: downloadLink) }.then {downloadedURL -&gt; Void in self.updateImageAtURL(url: downloadedURL) }.catch { error in print(\"Error \\(error)\") }} A feature that I find very interesting in both frameworks, Bolts and PromiseKit, is that they allow our code run on a given thread (Main thread or background thread). This is a great feature as most of the work done in the view controller has been to update the UI. Sometimes, long-running tasks are best handled on a background thread, so as not to tie up the UI. For more details about this Thread feature, please refer to their documents: #Threading ConclusionSince I am working on CoreBluetooth, I often have to work with async methods. Too many callbacks make my project more difficult to understand and difficult to debug if errors occur. Promise make my code become a more beautiful girl ;).You can download the fully finished sample project here.Feel free to leave out your comments on my post.","link":"/2018/01/16/Asynchronous-Programming-in-Swift/"},{"title":"Best practice: Core Data Concurrency","text":"Some applications can survive without any data storage. Most other useful applications, however, save some state such as user configurations, user profile, goals, etc. on iOS, Apple provides Core Data as a framework to persist your valuable data. One thing to keep in mind that although CoreData can store data in a relational database it‚Äôs actually not a database engine.In this tutorial, I will share with you a bad experience I faced when I work with Core Data. Hopefully, after reading my sharing, you will avoid facing the same problem in your projects.Let‚Äôs get started. Three main components of core data stackFirst of all, I will list down the three main components of core data stack, you might or might not familiar with these terms but it‚Äôs better to get a deep understand of core data stack before digging deeper.The Core Data API, also called the stack, consists of three main components: NSManagedObjectModel: The data model describes an entity (object). NSManagedObjectContext: The objects when fetched from the persistent storage are placed in managed object context. It performs validations and keeps track of the changes made to the object‚Äôs attributes so that undo and redo operations can be applied to it, if needed. In a given context, a managed object provides a representation of a record in a persistent store. Depending on a situation, there may be multiple contexts, each containing a separate managed object representing that record. All managed objects are registered with a managed object context. NSPersistentStoreCoordinator: NSManagedObjectContext does not work directly with NSPersistentStore to store and retrieve data, but NSPersistentStoreCoordinator will do so. The main roles of NSPersistentStoreCoordinator are to managed the state of managed object context and to serialize calls to NSPersistenStore to avoid redundancy. You can find the main roles of each component by the following image We have enough knowledge of Core Data and its different components. Now, let‚Äôs move forward to the main section. Core data supports concurrencyCore Data supports multi-threading in an application, which means more than one thread can be executed in parallel to increase performance. Even some tasks can be performed in the background using a separate thread.As you might know, when working with CoreData, there are two ways to define a managed object context: NSMainQueueConcurrencyType and NSPrivateQueueConcurrencyType. It depends on us to decide which type of MOC we should create in our applications. Mainly we will work on the main one, but to avoid doing data processing on the main queue, as it might affect the user experience when doing heavy tasks on the main thread, we sometimes need to create a private queue context and perform those heavy tasks on this private context.Concurrency absolutely makes the app more effective as tasks now can do in parallel, but there are some strict rules defined by Apple we must follow otherwise we will face some unexpected behaviors, including crashes and losing data. Rule 1: Managed object contexts are stuck with the thread that they are associated with upon declaration. The first rule states that do not use the main queue context in a background thread. Most of the time, there are no-fail at all if we violate the rule. When it comes to production, however, you will soon face crashes on your dashboard, resulting in bad user experiences and more importantly, leading to losing data. Rule 2: Managed objects retrieved from a context are stuck with the same queue that the context associated with. That means do not pass any objects retrived from main context to private one and vise versa. Violate this rule will lead to the same result as rule 1. Crash, crash, crash! üò±It has been the first time I use CoreData to store valuable data of users in our app. On one hand, I did not take core data concurrency seriously at that time. On the other hand, I do not know there are some strick rules when working with concurrency in Core Data. As a result, when the app comes to production, the number of crashes had been reported to the monitor dashboard. At that time, I had no idea how they come. I could not reproduce these issues to find out the root cause was. Additionally, the crash reported by Firebase did not have enough information for an investigation. I tried reviewing the flow of my app, searching on StackOverFlow and then reading deeply Apple‚Äôs document of Core Data. Finally, the root cause comes from accessing Core Data from multiple threads. As I‚Äôm working with Core Bluetooth, the key point is that Core Bluetooth dispatches Bluetooth events in the main thread by default. However, I configurated the Bluetooth queue to a background queue to avoid locking the UI queue. Here crashes come as Core Data does not allow to access NSManagedObject among different queues strictly. To simulate this issue, I created a non-stop loop to run inserting and deleting actions in a background queue continuously. The following code illustrates how I performed the test. 1234567891011121314override func viewDidLoad() { super.viewDidLoad() // Do any additional setup after loading the view. self.doSomething()}func doSomething() { self.managedContext?.insert(person: self.person) self.managedContext?.delete(person: self.person) DispatchQueue.global(qos: .background).asyncAfter(deadline: .now() + 0.1, execute: { self.doSomething() })} Sooner or later, the crash will come to us. 1232019-10-13 12:31:55.497690+0700 CoreData-Concurrency[90636:1151728] [error] error: Serious application error. Exception was caught during Core Data change processing. This is usually a bug within an observer of NSManagedObjectContextObjectsDidChangeNotification. -[__NSCFSet addObject:]: attempt to insert nil with userInfo (null)CoreData: error: Serious application error. Exception was caught during Core Data change processing. This is usually a bug within an observer of NSManagedObjectContextObjectsDidChangeNotification. -[__NSCFSet addObject:]: attempt to insert nil with userInfo (null)2019-10-13 12:31:55.569306+0700 CoreData-Concurrency[90636:1151728] *** Terminating app due to uncaught exception 'NSInvalidArgumentException', reason: '-[__NSCFSet addObject:]: attempt to insert nil' Here are some answers from the community you can find on Stackoverflow:https://stackoverflow.com/questions/36402366/core-data-crash-attempt-to-insert-nil-with-userinfo-nullhttps://stackoverflow.com/questions/55517083/ios-core-data-serious-application-error-attempt-to-insert-nil-in-less-than Avoid crashingTo avoid the crash, the are two techniques we can apply, both of them make sure that we do not violate concurrent-confinement rules. #1The first one is to ensure that the managedObjectContext is performed on the queue that it is associated with upon initialization, which is the main queue in this case. 1234567func doSomething() { self.managedContext?.insert(person: self.person) self.managedContext?.delete(person: self.person) DispatchQueue.main.asyncAfter(deadline: .now() + 0.1, execute: { // Dispatch to main queue self.doSomething() })} In case for some reason, we can not execute the actions on the main queue (e.g importing huge data to disk) we can create multiple contexts to solve this problem. Move to #2. #2Using Core data multiple context technique.A child managed object context (MOC) does not hold a reference to the persistent store coordinator (PSC). Instead, it keeps a reference to another (MOC) as its parent. Whenever a child performs saveContext, the changes will be pushed to its parent, and keep pushing to other parents (If had). It is only when the root parent MOC performs saveContext, the changes are saved to the PSC. Let‚Äôs create a private MOC inside our PersonManagedObject class. 1private let privateMOC = NSManagedObjectContext(concurrencyType: .privateQueueConcurrencyType) Then set its parent as the main MOC. 12345init?() { ... privateMOC.parent = self.managedObjectContext} From now on, all action will be performed on this privateMOC. The method performAndWait blocks the caller from returning until the block is executed.The perform(_:) method returns immediately and the context executes the block methods on its own thread. With the performAndWait(_:) method, the context still executes the block methods on its own thread, but the method doesn‚Äôt return until the block is executed. 12345678func insert(person: Person) { ... // Some code are obmitted self.privateMOC.performAndWait { self.privateMOC.insert(object) synchronize() }} Don‚Äôt forget to call saveContext method of the parent context to save the changes to PSC. 1234567891011121314private func synchronize() { do { try self.privateMOC.save() // We call save on the private context, which moves all of the changes into the main queue context without blocking the main queue. self.managedObjectContext.performAndWait { do { try self.managedObjectContext.save() } catch { print(\"Could not synchonize data. \\(error), \\(error.localizedDescription)\") } } } catch { print(\"Could not synchonize data. \\(error), \\(error.localizedDescription)\") }} After modifying the code by using either #1 or #2, I ran the program again in a long time but there were no more crashes! ConclusionCore data is a very useful framework and certainly is indispensable in most mobile applications today. To avoid the same bad situations as I just went through, make sure you dig into its components before starting your code, especially core data concurrency.You can find my completed project at Github - Core Data ConcurrencyThanks for reading. References[1] B.M. Harwani - Core Data iOS Essentials-Packt Publishing (2011)[2] Core Data, Multithreading, and the Main Thread[3] [Multiple context CoreData] https://www.cocoanetics.com/2012/07/multi-context-coredata/","link":"/2019/09/01/Best-practice-Core-Data-Concurrency/"},{"title":"Best practice: How to deal with Bluetooth Low Energy in background","text":"PrefaceWhen working with CoreBluetooth, have you ever concerned that how the BLE app on iOS can survive when it is terminated by the system? How can we bring it back to the background? Is there anything like a service on Android that can last forever? You can find the answer to all these questions in this post. Read on! Application life cycle on iOSBefore getting a deep understanding of how we can survive our app in the background, it‚Äôs good to start with the application life-cycle on iOS.As you might know, there are five main states of every iOS app.Not running The app either has not been launched or was running but was terminated by the system or the user.Inactive It is the initial state before the app actually transitions to a different state.Active The app is running in the foreground and receiving events from the user.Background The app is in the background and be invisible to the user. However, an app that requests extra execution time may remain in this state for a period of time. In addition, the app will transit into the inactive state before entering into the background mode.Suspended The app is in the background but it does not allow to execute any code. The app is moved to this state automatically by the system and it will not receive any events before the system does so. When the foreground apps need more memory, the system may terminate the suspended apps to make more space for the foreground apps. Note that we can not predict when the suspended app will be terminated by the system. After being terminated, the app returns to the not running state. BLE issues with the application life cycleAs mentioned, when the app enters to the background, the app might be terminated by the system if it need evict resources for other applications. Unlike Android OS, after being killed by the system, we can re-start a service to keep your app alive. On iOS, once the app is terminated by the system, there is no way to bring it back to the background. As a result, any Bluetooth events that dispatch from the device will never come to the app. It means your app might miss the indications that are triggered by users, such as play a track of music on their phone when pressing physical buttons from a BLE device. Apple gives out an example called ‚ÄúSmart door‚Äù. The main idea of this example is to have an automatic interaction between the app and the lock of the door. Imagine we‚Äôre developing an application that can automatically lock and unlock the door when the user goes in and go out their home, respectively. However, the main problem of this implementation is to keep the connection between the two, the phone and the lock of the door. While using their phone, users do a variety of actions on the phone: open / close applications, toggle the Bluetooth setting, enter the airplane mode, reboot the phone, etc. These interactions can lead to our app is killed by the system, forever. In this case, the app will not be able to reconnect to the lock when the user returns home, and the user may not be able to unlock the door. To deal with this issue, Apple provides a method called State Preservation and Restoration (CoreBluetooth background processing). State Preservation and Restoration is built-in to CoreBluetooth that allows our app can be relaunched into the background when it‚Äôs terminated by the system.At the bottom line, iOS takes a snapshot of all the Bluetooth-related objects that were going on in our app. Subsequently, if there is any Bluetooth event which related to the Bluetooth-related objects our app were interacting with comes to the phone, our app will be waked up from the grave. That‚Äôs amazing! Implement State Preservation and RestorationTo demonstrate State Preservation and Restoration technique on iOS, I‚Äôm going to reuse the source code from the previous post Play Central And Peripheral Roles With CoreBluetooth but we‚Äôll add some more code to the projects to make it become magical.First, I set my iPad act as a Peripheral with a uuid ‚Äú1FA2FD8A-17E0-4D3B-AF45-305DA6130E39‚Äù, which is generated via uuidgen command on Mac. Then, make it start advertising with local name ‚ÄúiPad‚Äù. If there is a connection established by a central manager, the in/out logs will print so we know whether the connection is made successfully. When the ‚ÄúSend Notify‚Äù button is touched, the app will notify a data string ‚ÄúSay something cool!‚Äù via the ‚Äú463FED21-DA93-45E7-B00F-B5CD99775150‚Äù that is defined as an encrypted notifiable characteristic of the app to the connected central manager. The next thing we need to do is go back to the Central Manager app and create a Restore Identifier for the CBCentralManager objects to be taken over by the operating system when the application is terminated, I chose ‚ÄúYourUniqueIdentifierKey‚Äù string. Next, we will implement the willRestoreState provided by Apple. 123456789101112131415161718public func centralManager(_ central: CBCentralManager, willRestoreState dict: [String : Any]) { LocalNotification.shared.showNotification(id: \"willrestorestate\", title: \"Manager will restore state\", body: \"\", timeInterval: 1.0) let systemSoundID: SystemSoundID = 1321 AudioServicesPlaySystemSound (systemSoundID) if let peripherals = dict[CBCentralManagerRestoredStatePeripheralsKey] as? [CBPeripheral] { peripherals.forEach { (awakedPeripheral) in print(\"\\(Date.now). - Awaked peripheral \\(String(describing: awakedPeripheral.name))\") guard let localName = awakedPeripheral.name, localName == \"iPad\" else { return } self.connectedDevice = Device.init(peripheral: awakedPeripheral) } }} Here, when the centralManager(_:, willRestoreState) is called, I will play a soundtrack and show a pop-up with the name of awaked peripheral to inform that the app is actually awaked by the system. Inside the method, we also can get a dictionary full of state information. When we retrieved with the CBCentralManagerRestoredStatePeripheralsKey key, this holds things like an array of CBPeripheral, containing all peripherals that were connected or pending connection at the time the application was terminated by the system. Here, I iterate through the array of peripherals, check if there is my interested peripheral, then initialize a Device and set it back to the connectedDevice variable so that I can receive updated values from the peripheral. I also add the code that will popup a local notification at the appDidFinishLaunching delegate and at peripheral(:didUpdateValueFor:chacracteristic) method for testing. 123456func peripheral(_ peripheral: CBPeripheral, didUpdateValueFor characteristic: CBCharacteristic, error: Error?) { if let data = characteristic.value { let str = String.init(data: data, encoding: .utf8) ?? \"\" LocalNotification.shared.showNotification(id: \"DidUpdateValue\", title: \"Peripheral did update value from grave!\", body: \"\\(str)\", timeInterval: 1.0) }} 12345678func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) -&gt; Bool { let _ = BluetoothManager.sharedInstance let _ = LocalNotification.shared LocalNotification.shared.showNotification(id: \"didfinishlaunch\", title: \"App did finish launching\", body: \"Options: \\(launchOptions?[UIApplicationLaunchOptionsKey.bluetoothCentrals] ?? \"nil\")\", timeInterval: 1.0) return true} It‚Äôs time to run our experiment! I‚Äôm going to use two methods to simulate background app termination by the system.The first one is using XCode. Run the app from Xcode. Stop the app by pressing the ‚ÄúStop‚Äù button from Xcode. Restart the app from Xcode. The second one is doing the following steps: Press the home button to enter the app to background. Long press the power button until you see ‚Äúslide to power off‚Äù. Release the power button and long press the home button for about 5s (until you see your home screen reappeared). In the below demonstration, you will see I use both of them for testing. Let‚Äôs see something cool happens! Here is the log printed from Xcode. 123456789102018-08-18 19:46:35.6560 App did finish lauching with option nil2018-08-18 19:46:35.6620 Manager will restore state2018-08-18 19:46:35.6650. - Awaked peripheral Optional(\"iPad\")2018-08-18 19:46:35.6660 Manager did update state 52018-08-18 19:46:35.6950 App did become active2018-08-18 19:46:35.7080 Found iPad2018-08-18 19:46:35.7100 Did connect.2018-08-18 19:46:51.5170 App will resign active2018-08-18 19:46:52.1100 App did enter backgroundMessage from debugger: Terminated due to signal 9 First, I connected to the iPad device, then simulated the termination by Xcode (Relaunch the app from Xcode), after that you see the centralManager(_:, willRestoreState) delegate is triggered by the popup. Later, I simulated the termination by using the second method, when the home screen reappeared, one thing for sure that the app was terminated. Next, I pressed the ‚ÄúSend notify‚Äù button from the iPad (Which was playing as a Peripheral) to send a BLE event to the app. Surprisingly, the centralManager(_:, willRestoreState) was called immediately as we can see a local notification showed up, then another one showed the BLE data received from the peripheral (The ‚ÄúSay something cool!‚Äù string). It really worked! The app now can last forever! But wait a minute, it‚Äôs not so simple as so. This approach still has some limitations that we will discuss later on this post. As you may notice that there is a difference between the two ways I used to simulate background termination, when the app was relaunched from the first way, the option value of the delegate application(application:didFinishLaunchingWithOptions:) always nil, while we could extract the [UIApplicationLaunchOptionsKey.bluetoothCentrals by using the second way (The value of launchOptions?[UIApplicationLaunchOptionsKey.bluetoothCentrals] will return ‚ÄúYourUniqueIdentifierKey‚Äù string). I don‚Äôt know the reason why it happened. But one thing for sure that the second approach is better than the first one since it matches with the Apple doc. *‚ÄùWhen your app is relaunched by system, you can retrieve all the restoration identifiers for the central manager objects the system was preserving for your app‚Äù.* So, in application(application:didFinishLaunchingWithOptions:), we‚Äôre able to get a list of UUID that represent all of the CBCentralManager objects that were active when application was terminated and that Core Bluetooth and iOS took over while you were terminated. Use UIApplicationLaunchOptionsBluetoothCentralsKey to get any central we may have instantiated before being zapped. Loop through the array of centralManagerUUID and find the one matched the Restoration Identifier we‚Äôre interested in. LimitationsWhen the user force kill the app from the multiple task viewIf the user force quit the app from the multiple task view, there is no chance so that the app can wake up from the restoration event. But luckily, there is another technology we can leverage to put the app back into the background named ‚ÄúiBeacon‚Äù. In the next post, I will guide you how to implement this interesting technology into our app. When the user reboots phoneIf the user resets the phone, the app will be killed forever. By leveraging the CoreLocation, we can solve the problem. In the next part, I will show you how to do that. Final thoughtsIn this post, we walked through the iOS app life cycle, also I showed you how to keep the app survive even it was terminated by the system. The contents of this post are really interesting and they are formed from my real working experiments.Hope you will find this post useful.","link":"/2018/07/23/Best-practice-How-to-deal-with-Bluetooth-Low-Energy-in-background/"},{"title":"Beta Test and TestFlight","text":"As an iOS developer, you might have heard about TestFlight - a product of Apple that allows you to distribute your apps to beta users. So what can we do with it? Is it useful?In this tutorial, we will walk through steps uploading a build to TestFlight, and invite users to test your app.You also need to refer the previous post Shipping your app to Store to complete this tutorial.Let‚Äôs have fun! What is TestFlight?TestFlight is a product of Apple that allows developers to distribute their apps to beta users before rolling to production. With the latest update of TestFlight app on iOS 13, testers can give feedback directly from the app with screenshots, crashes and other useful information provided. Using TestFlight is a great way to help to test your apps and improve the performance before it goes live.TestFlight provides two types of testers: Internal Tester: It takes up to 25 members of your team who have been assigned a specified role to test your app. Each member can test on up to 30 devices. Once a beta build is submitted to App Store Connect and is available for testing, internal testers will be notified so that they can update the app. External Tester: You can invite up to 10,000 testers using just their email address or by sharing a public link. The main difference from the two is to let External Tester test your app, you must submit your app to Apple for review. The reviewing process is the same as an official submission but it‚Äôs usually going faster than normal app reviews. By contract, testing your app with internal testers does not require review by Apple. Select build for testingAfter completing the final step at Shipping your app to Store, your app is successfully submitted to App Store Connect. Now, navigate to your Apple developer page and sign in with your Apple Id, then select ‚ÄúMy Apps‚Äù to see all available apps &gt; Select a specified app &gt; From the top toolbar &gt; Select TestFlight &gt; You will see all builds that are available for testing.The following image gives you a quick look of TestFlight dashboard From the main window, you can see all available versions of your app; when it expires; how many invitations sent; how many installations succeeded. etc.To add new users, click on ‚ÄúApp Store Connect Users‚Äù at the left sidebar &gt; Press ‚Äú+‚Äù button &gt; Then fill in your tester information including there App Id. After that, you can add your tester to your build. TestFlight AppTesters need install TestFlight app on their device. This app is free and available on App Store. After adding your testers to the build, testers will use their invitation email or a public link to enroll in the testing.Open the TestFlight app, the tester needs to sign in with their App Id. After that, they will see all available apps that they can install which just be the same as App Store. A small note that you will see a small orange dot near the name of the app to indicate this build installing from TestFlight. Easy, huh? From now on, whenever a build of this app is available, your tester will receive a notification and an email from TestFlight. They then can update this app via TestFlight and enjoy the latest version. After testingWhen you are done testing, you can stop the app from testing, and then go to publishing an app for the process of submitting your app to the App Store. Your beta build will become unavailable in TestFlight after 90 days by default.In this post, we had a quick look at TestFlight and how to distribute your beta test to your testers. In practice, beta testing is a common term in the software development process. Having knowledge of how to distribute your app will be useful in some situations.Happy coding!!!","link":"/2020/04/14/Beta-Test-and-TestFlight/"},{"title":"Best practice: iBeacon","text":"Welcome to the next part of the series of ‚ÄúHow to deal with BLE in the background‚Äú.In the previous part, I guided you how to keep your app alive as long as possible when your app enters to background mode by using State Preservation and Restoration technique supported by Apple. However, there are some usecases this technique can not handle, as described below (refer to Apple document: Conditions Under Which Bluetooth State Restoration Will Relaunch An App)As you can see, there is a common case when users force quit the app from the multiple task view (Whether accidentally or intentionally), the Restoration technique can not awake your app. Let‚Äôs imagine that your app has a feature allows users to press a button on your BLE-connected devices to find where their phone is, but if your app is not running or is not able to wake up to handle the BLE signal sent from your devices, this feature would be useless.In this post, I will show you a technique using iBeacon to deal with this case, which makes your app another chance to wake up despite it is terminated by users. Let‚Äôs drive-in! Welcome to the world of iBeaconiBeacon is a protocol first introduced by Apple in WWDC 2013. ‚ÄúiBeacon is based on Bluetooth low energy proximity sensing by transmitting a universally unique identifier picked up by a compatible app or operating system. The identifier and several bytes sent with it can be used to determine the device‚Äôs physical location, track customers, or trigger a location-based action on the device such as a check-in on social media or a push notification‚Äù (Wiki).iBeacon application is very diverse like location-based services, mobile commerce or advertising, to name a few.‚ÄúThe Automatic Museum Guide‚Äù is a project that is very impressed me built on iBeacon technology. The app allows visitors to explore exhibits by showing the appropriate contents by tracking their location and their distance with the beacon. That‚Äôs a brilliant idea! How it worksApple has standardized the content of iBeacon advertisement data. It consists of a 16 byte UUID, the major and minor version. These three factors are unique for each beacon. A last field in the packet is TX power used to determine how close you are to the beacon.A beacon broadcasts this packet in its range, far from 20m to 300m, at regular intervals of time. These packets are automatically detected by nearby phones, then the app will perform a pre-defined action like showing a notification or pop-up a promotion code. Although iBeacon is based on Bluetooth low energy technology, one of the main differences between the two is iBeacon is one-way transmit technology, by which I mean only the phone can receive data from iBeacon devices. iOS integration: start advertising as an iBeaconFirstly, we need a beacon so that we can do the next step. I‚Äôm going to use my iPad to act as a beacon by using a CLBeaconRegion object in CoreBluetooth on iOS.The main UI just simply contains two main buttons that will start and stop the advertisement of the iBeacon, respectively. 123456let region = CLBeaconRegion(proximityUUID: self.uuid!, major: self.major, minor: self.minor, identifier: self.identifier)let peripheralData = region.peripheralData(withMeasuredPower: nil)peripheral.startAdvertising(((peripheralData as NSDictionary) as! [String : Any])) Then, we implement the peripheralManagerDidStartAdvertising(CBPeripheralManager, Error?) delegate to check if the beacon advertises successfully. 1234567func peripheralManagerDidStartAdvertising(_ peripheral: CBPeripheralManager, error: Error?) { if error == nil { print(\"Successfully started advertising our beacon data.\") } else { print(\"Failed to advertise our beacon. Error = \\(String(describing: error))\") }} To stop advertising 1peripheralManager?.stopAdvertising() Leverate iBeacon technology to make our app last foreverFirstly, Inside the didFinishLaunchingWithOptions method of AppDelegate class, I will show a notification to get notified whenever our app is relaunched. 1234func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -&gt; Bool { NotificationHandler.shared.showNotification(title: \"App did launch\", body: \"\") return true} After the main view appears, I then tell the location manager to start monitoring the given region and to start ranging iBeacons within that region 1234func startMonitoring() { locationManager.startMonitoring(for: beaconRegion) locationManager.startRangingBeacons(in: beaconRegion)} By default, monitoring notifies you when the region is entered or exited regardless of whether your app is running. Ranging, on the other hand, monitors the proximity of the region only while your app is running. That‚Äôs all for setting up. In the following demonstration, you will see I open the app then terminate it from the multiple task view. After that, I press the ‚ÄúStart advertising‚Äù button on my iPad (The beacon). You will see the app was relaunched immediately even it had been killed (The ‚ÄúApp did launch‚Äù notification showed up). That‚Äôs amazing. Note: Don‚Äôt expect to receive an event right away, because only boundary crossings generate an event. In particular, if the user‚Äôs location is already inside the region at registration time, the location manager doesn‚Äôt automatically generate an event. Instead, your app must wait for the user to cross the region boundary before an event is generated and sent to the delegate. ConclusionsOne of the most interesting things of iBeacon is iBeacon applications can be waked up event it has been terminated by the user. It means iBeacon applications can last forever. To download the completed projects, please click to the following Github links: Act as an iBeacon: https://github.com/uynguyen/iBeaconDevice Central manager app: https://github.com/uynguyen/CentralManager-iBeacon Feel free to shot me an email if you have any questions. References[1] Region Monitoring and iBeacon","link":"/2018/08/18/Best-practice-iBeacon/"},{"title":"Big Endian vs Little Endian","text":"In computer science, a bit is the smallest piece of information. It represents a digit of the binary numeral system. A string of 8 bits called a byte. There are two ways to store a string of data in computers: Big Endian and Little Endian. If your tasks are working with data in a piece of bytes, you ought to know how to deal with bytes in these two formats. In this post, I will explain how data is stored in computers, what are the main differences between these two, then provide some useful code to work with bytes in Swift and Objective-C. Basic conceptsTo understand Big Endian and Little Endian, you need to know what the Least Significant Byte (LSB) and the Most Significant Byte (MSB) are. The LSB is the right-most bit in a string, it is called that because it has the least effect on the value of the binary number. In contrast, the left-most byte is the MSB that carries the greatest numerical value.After understanding these two, it is easy to distinguish between Big Endian and Little Endian: In Big Endian, the MSB of the data is placed at the byte with the lowest address. In Little Endian, the LSB of the data is placed at the byte with the lowest address. That‚Äôs all! The advantages of Big Endian and Little Endian in a computer architectureAccording to Wiki, Big endian is ‚Äúthe most common format in data networking‚Äù, many network protocols like TCP, UPD, IPv4 and IPv6 are using Big endian order to transmit data. Little endian is mainly using on microprocessors. But the point is why do they do that?Well, when working with byte order on iOS, I also ask the question to myself and my colleagues, ‚Äúwhy do they do that?‚Äù, ‚ÄúWhy do they choose Big Endian instead of Little Endian?‚Äù. After researching on the internet, and getting answers from a senior firmware engineer in my office, I gradually understand the up-side of these both order ways.The advantages of Little Endian are: It‚Äôs easy to read the value in a variety of type sizes. For example, the variable A = 0x13 in 64-bit value in memory at the address B will be 1300 0000 0000 0000. A will always be read as 19 regardless of using 8, 16, 32, 64-bit reads. By contrast, in Big Endian we have to know in which size we have written the value to read it correctly. It‚Äôs easy to cast the value to a smaller type like from int16_t to int8_t since int8_t is the byte at the beginning of int16_t. Easily to do mathematical computations ‚Äúbecause of the 1:1 relationship between address offset and byte number (offset 0 is byte 0), multiple precision math routines are correspondingly easy to write.‚Äù Some main advantages of Big Endian are We can always test whether the number is positive or negative by looking at the byte at offset zero, so it‚Äôs easy to do a comparison. The numbers are also stored in the order in which they are printed out, so binary to decimal routines are particularly efficient. Byte order on iOSBoth Swift and Objective-C support methods that help us read and write data in the two ways Litte Endian and Big Endian. The following sections demonstrate how we use these methods to interact with data on memory. Byte order in Objective-C1234567891011121314NSString *strData = @\"001E653A\";NSData *data = [NSData dataWithHexString:strData];uint8_t *bytes = (uint8_t *)data.bytes;/* Functions for loading little endian to host endianess. */uint16_t firstInLittle = OSReadLittleInt16(bytes, 0); // 0x1E00 = 7680uint16_t secondInLittle = OSReadLittleInt16(bytes, 2); // 0x3A65 = 14949uint16_t firstInBig = OSReadBigInt16(bytes, 0); // 0x001E = 30uint16_t secondInBig = OSReadBigInt16(bytes, 2); // 0x653A = 25914 /* Functions for storing host endianess to little endian. */uint8_t byte16[2];OSWriteLittleInt16(byte16, 0, firstInLittle); // byte16 = [0x00, 0x1E] Byte order in Swift123456789101112let strData = \"3A651E00\"if let data = strData.hexadecimal() { let bytesArr = [UInt8](data) /* Functions for loading native endian values. */ let little = _OSReadInt16(bytesArr, 0) // 0x653A = 25914 let big = first.bigEndian // 0x3A65 = 14949 /* Functions for storing native endian values. */ let bytes = [UInt8](repeating: 0, count: 2) _OSWriteInt16(UnsafeMutableRawPointer(mutating:bytes), 0, second) // bytes = [0x65, 0x3A]} Final thoughtsIn this post, I showed you how differences between endianness formats and provided some useful code to work with bytes in iOS. If you have any suggestions, just let me know.Happy weekend.","link":"/2018/04/30/Big-Endian-vs-Little-Endian/"},{"title":"Bluetooth Low Energy On iOS","text":"The Core Bluetooth (CB) framework allows iOS and MacOS apps communicate with BLE devices. Your apps can discover, explore, and control the BLE devices, such as heart rate monitors, trackers or hybrid watches. Image 1. BLE devices (Source from Google) On MacOS 10.9 and iOS 6, Mac and iOS devices also play the roles of BLE peripherals to serve data to other devices, including other Mac and iOS devices. In this tutorial, I will introduce the key concepts of the Core Bluetooth framework and how to use the framework to discover, connect, and retrieve data from compatible devices. Feel free to leave out your comments on my post. ## At a glance BLE was introduced in early 2010 and based on Bluetooth 4.0 specification. BLE uses the same 2.4 GHz radio frequency as classical Bluetooth. In theory and in ideal conditions (Without obstacles), BLE‚Äôs range get over 100m but in fact, the maximum distance is 10m. Image 2. BLE in reality (Source from Google) This technology is power-friendly because it uses less power than other wireless technologies. Thanks to its low power consumption, BLE is used to integrate into electrical devices that required less power consumption such as heart rate monitors, trackers, watches, shoes to make them smarter.So, what are the cons of BLE technology? It‚Äôs data transfer rate. In order to decrease power consumption, BLE chips only transmit data in some time called interval (Whereas Classical Bluetooth can transfer data at any time they want), and the amount of transferred data in an interval is also limited in a few dozen of bytes. Some more information about maximum throughput on iOS and MacOS (Provided by PunchThrough) iPhone 6, 6+, 6S, 6S+: 12Normal Connection Interval of 30mSecs: 2,667 bytes/secConnection Interval for HID Over GATT is Present 11.25mSecs: 7,111 bytes/sec MacBook Pro - OS X (Varies on models): 1Maximum Connection Interval range of (11.25 - 15mSecs): 7,111 bytes/sec - 5334 bytes/sec To get more technical details about Bluetooth technology, please refer to Bluetooth Special Interest Group (SIG). Basic Concepts1. The playersThere are two major roles involved in all BLE communication: The Central and The Peripheral: Peripheral: are devices having data that is needed by other devices. Central: typically use the information served up by a peripheral to accomplish some tasks. For examples, reading heart rate or temperature information from monitors (A peripheral).Image 3. The Central and the Peripheral (Source from [Apple doc](https://developer.apple.com/library/content/documentation/NetworkingInternetWeb/Conceptual/CoreBluetooth_concepts/AboutCoreBluetooth/Introduction.html)) 2. The connection parametersThe connection parameters for a BLE connection is a set of parameters that determine when and how the Central and a Peripheral perform data transferring. The Central will actively set the connection parameters used, but the Peripheral can send another parameter that the Central can then accept or reject. Both sides will continue to request connection parameters until they find a reasonable number that they accept.There are 3 different parameters: Connection interval: This value determines how often the Central and the Peripheral transfer data to each other. Slave latency (Latency, shortly): If we set a non-zero latency value, the Peripheral can skip requests from the Central when the Central asks for data up to the slave latency number of times. However, if the Peripheral want to transmit data to the Central, it can send data at any time. This allows a peripheral to stay sleeping for a longer time to decrease power consumption. Connection supervision timeout: This value determines the timeout from the last package exchange until the transference is considered lost. The Central will not start trying to reconnect before the timeout has passed. For example, if you set {interval, latency, timeout} = {15, 0, 720} as connection params for the peripheral: In every 15 (ms), the peripheral will be wake-up and listen to requests from the central, also transmit data if needed. Latency equal 0, it means that the Peripheral have to answer the Central at any time the Central requests in an interval (15 ms). After 720 (ms) from the last packet was sent, if the Central still does not receive the packet, the Central will determine that the packet was lost and requests the Peripheral re-send the last packet. 3. Bluetooth Low Energy Protocol StackCoreBluetooth hides many of the low-level details of the specification from developers, making it much easier to develop apps that interact with BLE devices. Advertising and General Advertising Profile (GAP)BLE devices let other devices know that they exist by advertising using the GAP. Advertising packets contain some basic information such as device name, serial number, or RSSI value, and also a list of the services it provides. The limited size of advertising packets is 128 bit.RSSI stands for Received Signal Strength Indicator. RSSI value represents the strength of the transmitting signal. We can estimate the current distance between the central and the peripheral based on the value. The greater the value, the closer the device is. Image 4. Advertising and discovery in BLE General Attribute Profile (GATT)GATT is the layer that defines services and characteristics which is used to transmit data between the Central and the Peripheral, also enables read, write, notify operations on them.In most case, the Peripheral is also called GATT server since it provides the services and the characteristics whereas the Central is the GATT client. ServicesServices are identified by unique numbers known as UUIDs. Standard services like Device Information Service (0x180A), which exposes manufacturer and basic information about the device (Firmware version, serial number, model number), have a 16-bit UUID and custom services have a 128-bit UUID. (E.g: 0x3dda0000957f7d4a34a674696673696d, etc.) CharacteristicsA characteristic contains a characteristic declaration, characteristic properties (ReadWrite, ReadOnly, Notify, WriteWithoutResponse and so on), and a value. Characteristics allow us to access the value and the information that they contain. A service can have more than one characteristic.The following picture shows the relationship between Profile, Services, Characteristics. Image 5. Relationship between Profile, Services, Characteristics 4. Bluetooth Concepts and CoreBluetooth on iOSIn the CoreBluetooth framework A Central is represented by the CBCentralManager class and is used to discover, establish a connection and control the peripheral. A peripheral is represented by the CBPeripheral class, the services relating to a specific peripheral are represented by the CBService class and characteristics of a peripheral‚Äôs service are represented by the CBPeripheral class. The following image shows the structure of a Services and its Characteristics on iOS: Image 6. Relationship between CBPeripheral, CBService and CBCharacteristic objects on iOS SummaryBLE is a revolutionary technology of Classical Bluetooth. In reality, BLE is used to integrate into small devices like lockers, trackers, watches, shoes and some kind of jewelry (rings) to make them smarter, towards IoT environment.In the next section, I will guide you how to use CoreBluetooth to create your own services on an iOS device, also use CoreBluetooth on another device to discover, connect and control your BLE services. If you liked this post and would like to see more in the future, please let me know. References[1] Bluetooth Special Interest Group[2] Apple document: Core Bluetooth Concepts[3] Maximizing BLE Throughput on iOS and Android","link":"/2017/10/13/Bluetooth-Low-Energy-On-iOS/"},{"title":"All About Alamofire","text":"If you ever have a chance to work with networking on iOS, you definately have heard about Alamofire, a networking library written in Swift for iOS and MacOS. It simplifies all of the common networking jobs in your app.If you have not meet Alamofire yet, no worries, this tutorial will introduce you all tasks that Alamofire can handle for you. If you‚Äôre familiar with it, never mind, take this post as a summarize and a centralize of your Alamofire handbook.Let‚Äôs drive in! Coming soon! Build your own serverDesign the networking layerDependencies SwiftyJSON, a library supports to deal with JSON data. [SnapKit][https://github.com/SnapKit/SnapKit], Swift based Autolayout. Advanced topicFinal thought","link":"/2020/07/12/All-About-Alamofire/"},{"title":"Building your personal page with Hexo","text":"As I build this personal site, my first aim is to enjoy my hobby of writing. I write whatever I learn on along with my daily working, and share it. I hope my share will help someone when they need it. In return, I will have a deep of understanding what I write, and sometimes, receive ‚Äúa cup of coffee‚Äù (Buy me Coffee) from a friend I‚Äôve never met. ‚ò∫Ô∏è Power is gained by sharing knowledge, not hoarding it Some friends come to me asking how to build a page like mine. I‚Äôm happy to share with you how I build it.After this tutorial, you can build your own site within 5 minutes.I hope to see your page launching soon! Set up toolsNodeJs for macNavigate to NodeJS page, download, and install NodeJs package for macOS.For those who don‚Äôt know what NodeJs is, NodeJs is an open-source, cross-platform (OS X, Window, Linux), Js runtime environment for writing service-side in Javascript.By using the non-blocking I/O model, NodeJS is a great choice for real-time applications, chat, data streaming, etc.With a large community, NodeJs package ecosystem is more and more various and efficiency making NodeJS become one of the best development trends in recent years. You can find more info of NodeJs on the internet if you find it interesting. HexoHexo is a blog framework powered by NodeJs. Simple and fast features of Hexo make it become a dominate among other blog frameworks such as Hugo, Wordpress, Grav, etc.I choose Hexo to build my blog because I get used to with NodeJS commands. Moreover, Hexo provides many themes that you can easily integrate to your blog with a full of customization.After installing NodeJs successfully, open your terminal and type these following lines 12345npm install hexo-cli -g [1]hexo init blog [2]cd blog [3]npm install [4]hexo server [5] Here is the step-by-step: Install hexo command line as a global command. Create your blog folder. Move to the folder. Install node dependencies. Run your server. Hexo will be run at localhost:4000 by default. Now open http://localhost:4000 in your browser to see the result. Personalize your websiteAt the root of your folder, there is a _config.yml file that contains your page configs. You can modify something like page title, page author, article format, etc. For more information, please refer to Hexo documents. Start writingTo create new artical, type 1hexo new \"My first blog\" Here, you create a post named ‚ÄúMy first blog‚Äù. Reload your browser, you will see the result. Please note that Hexo uses Markdown syntax for editing, so please make sure you‚Äôre familiar with Markdown syntax. ThemesThe community of Hexo provides a lot of themes that you can choose by your favorite and personalize this theme as yours. It saves your time a lot thank to the great community.Navigate to Hexo themes and find the one you like, follow their instruction to download to your blog folder.Next, modify the _config.yml file, search and replace the themes config with your new theme name. 1theme: whatever DeploymentBy using the command line hexo generate, Hexo will automatically generate all your static files which you can upload to your server and distribute it to your users.In case you don‚Äôt own a server, no worry! There are a lot of free-host servers out there. You might have heard about Github page. Basically, Github page provides a free host and domain for your page, like mine ‚Äúuynguyen.github.io‚Äù. If you want to use Github page as your host, please follow the instructions to create your github page repository.After having your own repository, install npm install hexo-deployer-git that allows you to deploy your site.Next, edit the _config.yml file, from the ‚Äúdeploy‚Äù section &gt; add your deployment target information 12345deploy: type: git repo: &lt;repository url&gt; branch: [branch] message: [message] From now on, once you finish writing, you can publish your posts via command 1hexo clean &amp;&amp; hexo deploy You can also use Heroku for deployment instead of using github. For more information, please refer to Hexo deployment ConclusionIf you want a simple - personal page to share your ideas and contents, Hexo and Github page become such a great tool for you. With its simplicity and its community, It‚Äôs easy to set up, allowing you to just focus on what matters: Your sharing.I hope you find this post useful.","link":"/2020/04/27/Building-your-personal-page-with-Hexo/"},{"title":"Crash early in Swift","text":"Last night, I read a chapter of a book as one of my favorite books: &quot;The pragmatic programmer&quot; (By Andrew Hunt and David Thomas). This chapter discusses how to use assertion to make the code easier for debugging. We all know that assertion is an essential tool for writing tests, but It does more than that. Let‚Äôs go with me to meet this guy: Assertion. Crash, don‚Äôt trashDo you ever have one of the following conversations to yourself or with your colleagues in a technical discussion? ‚ÄúThis case will never happen so we don‚Äôt need to process this one.‚Äù ‚ÄúThis class must be ‚ÄúDog‚Äù, it can never be ‚ÄúCat‚Äù, let‚Äôs force unwrap this object.‚Äù ‚ÄúThis error will never occur, just ignore it.‚Äù ‚ÄúYou idiot! why do we handle this case when your code never reach out to this line?‚Äù But what if ‚Äúthis case‚Äù happen somehow? Does the app still response in the way that we expect? Is there any chance that the unexpected situation will damage our essential database?At the very beginning of this chapter, the author introduces some situations that I can see myself in those examples: ‚ÄúThis code won‚Äôt be used 30 years from now, so two-digit dates are fine.‚Äù ‚ÄúThis application will never be used abroad, so why internationalize it?‚Äù ‚Äúcount can‚Äôt be negative.‚Äù ‚ÄúThis printf can‚Äôt fail.‚Äù 1IF IT CAN'T HAPPEN, USE ASSERTIONS TO ENSURE THAT IT WON'T If we believe something cannot happen, or something true, use assertions to ensure your belief is true! If the condition of assertion is not met, it will immediately crash the app. It‚Äôs very useful during development because it leads us exactly to the problems. Before to continue, let‚Äôs talk about the Swift Optimization levelsDepend on whether the build is in Release mode or Debug mode, the Swift compiler will turn on or off the assertions (Lines with assert statements are omitted), it‚Äôs good to know the Swift optimization levels before we continue.There are 3 types of optimization level for a build in Xcode None (Onone): The default for debug builds. Compile without any optimization. Fast (O): The default for release builds. Compile with optimizations. Unchecked (Ounchecked): Compile with optimizations and remove runtime safety checks, including checking array out of bounds, unwrapping nil, precondition and preconditionFailure. That‚Äôs why we should not use the Ounchecked mode in release build because it can lead to memory corruptions and the app might behave inappropriately. Updates: As you can see there is no longer the -Ounchecked mode in Xcode10, instead a new option introduced Optimize for Size. The main difference between the O mode and Osize mode is ‚ÄúWhen compiling with -O the compiler tries to transform the code so that it executes with maximum performance. However, this improvement in runtime performance can sometimes come with a tradeoff of increased code size. With the new -Osize optimization mode the user has the choice to compile for minimal code size rather than for maximum speed‚Äù (swift.org) Apply Assertion to SwiftTruly to say, before reading this chapter of the book, I thought ‚ÄúAssertion‚Äù only used when writing unit test. The fact that developers use Assertion in developing to make the developing process safer and easier for tracing a bug.Swift provides 5 types of assertion function that differ from each other in terms of how they affect the flow of codes: assert() &amp; assertionFailure(): Use them when we want to verify our code, but if it is actually an issue, it wouldn‚Äôt necessarily exit the app. The compiler will ignore assert() and assertionFailure() statements for a release version (In -O mode). For example, I use assert to ensure there are no unexpected requests in my business flow. By doing so, I guarantee that if there is a ‚Äústrange guy‚Äù appears in my flow, the flow will be broken and the app will be terminated. Also, the debugger will lead me directly to the problem so that I can identify logic problems and clear out bugs as early as possible. precondition() &amp; preconditionFailure(): Use these functions to detect a condition that must be fulfill before continuing to process, even in release version (-O mode). For example, let‚Äôs say that we need to load a config file when the app launch. If there is no config file, then we should stop the app immediately rather than continuing the execution.123guard let fileConfig = Bundle.main.path(forResource: \"config\", ofType: \"json\") else { preconditionFailure(\"Unable to load config file.\")} fatalError(): The same as precondition() and preconditionFailure() functions, except fatalError() works for all optimisation levels in all configurations, it means your app ALWAYS be terminated if the fatalError line is reached. In the following example, I use fatalError() to force every inherited class must override the parseData(files:) from its super class. Highlighted advice from the author &quot;All errors give you information. You could convince yourself that the error can't happen, and choose to ignore it. Instead, Pragmatic Programmers tell themselves that if there is an error, something very, very bad has happened.&quot; If an error happens, can we recover it? If we can not handle some unexpected problems, then crash early to protect our vital data (Especially in banking apps that require high security for database). &quot;Don't put assertion in the code of real error handling.‚Äú It is a misunderstanding if we put assertion everywhere around the code, particularly in the code of real error handling. Assertion is not supposed to be used this way. If we simply to terminate a running program, it will affect to the user experiences, resulting in users will no longer open your app. The simplest principle to check if we should exit the program when errors occur is When your code discovers that something that was supposed to be impossible just happened, your program is no longer viable. Anything it does from this point forward becomes suspect, so terminate it as soon as possible. A dead program normally does a lot less damage than a crippled one. &quot;The condition passed to an assertion should not have a side effect&quot;. It is embarrassing if we put a code to check errors actually causing to other errors. üòñ For example, the following code (In Java) is added assert to make sure the next element is not nil, but it actually creates a new error. Can you find it?12345while (iter.hasmoreElements () { Test.ASSERT(iter.nextElements() != null); object obj = iter.nextElement(); // ....} ConclusionIn this article, we walked through these five methods for an early exit in Swift. In general, the right way to pick which one to use depends on the context of the error: Whether the error can be recoverable or not? If the answer is no, then crashing is the best way we can do to protect our app from unpredictable behaviors. Sometimes, the app is in a situation where it would be too dangerous to continue.Hope you found this post useful then you can apply this idea to your next project.Thanks for reading! üöÄ","link":"/2019/01/19/Crash-early-in-Swift/"},{"title":"Chuy·ªán ·ªü ƒê·∫°i H·ªçc (Ph·∫ßn 1)","text":"T·ªëi h√¥m qua v√¥ t√¨nh l∆∞·ªõt Facebook th√¨ trang Confession c·ªßa tr∆∞·ªùng m√¨nh hi·ªán l√™n b√†i post c·ªßa m·ªôt b·∫°n k17, b·∫°n t√¢m s·ª± v·ªÅ chuy·ªán h·ªçc ·ªü ƒê·∫°i H·ªçc.B·∫°n t√¢m s·ª± r·∫±ng b·∫°n ƒëang stress v√† cƒÉng th·∫≥ng v√¨ l∆∞·ª£ng ki·∫øn th·ª©c ·ªü ƒê·∫°i H·ªçc qu√° nhi·ªÅu l√†m b·∫°n kh√¥ng theo k·ªãp, trong khi ƒë√≥ c√°c b·∫°n c√πng kho√° l·∫°i c√≥ v·∫ª nh∆∞ ti·∫øp thu nhanh h∆°n b·∫°n. ƒêi·ªÅu ƒë√≥ l√†m b·∫°n th√™m t·ª± ti v√† mu·ªën b·ªè cu·ªôc.Tr∆∞·ªõc gi·ªù m√¨nh kh√¥ng c√≥ th√≥i quen comment l√™n c√°c Fan page hay Confession, m√† v√¨ ƒë·ªçc ƒë∆∞·ª£c b√†i post c·ªßa b·∫°n m√¨nh th·∫•y sao gi·ªëng v·ªõi m√¨nh 5 nƒÉm v·ªÅ tr∆∞·ªõc qu√°, v√¨ v·∫≠y m√¨nh mu·ªën vi·∫øt m·ªôt b√†i chia s·∫ª ng·∫Øn ƒë·ªÉ chia s·∫ª v·ªõi c√°c b·∫°n v·ªÅ con ƒë∆∞·ªùng m√¨nh ƒë√£ ƒëi qua c√°ch ƒë√¢y 5 nƒÉm, c≈©ng l√† con ƒë∆∞·ªùng m√† c√°c b·∫°n s·∫Ω ƒëi, d√π √≠t hay nhi·ªÅu. 1. ‚ÄúH·ªçc C√¥ng Ngh·ªá Th√¥ng Tin m√† Visual Basic l√† c√°i g√¨ m√† c≈©ng kh√¥ng bi·∫øt th√¨ ngh·ªâ cha cho r·ªìi!‚Äùƒê√≥ l√† c√¢u tr·∫£ l·ªùi c·ªßa th·∫±ng b·∫°n h·ªçc Qu·ªëc Ph√≤ng v·ªõi m√¨nh khi m√¨nh h·ªèi quy·ªÉn s√°ch d√†y cui n√≥ c·∫ßm tr√™n tay l√† s√°ch g√¨. L√∫c ƒë√≥ bu·ªìn l·∫Øm ch·ª©, c·∫£m gi√°c nh∆∞ m√¨nh l√† sinh v·∫≠t ngo√†i h√†nh tinh kh√°c r·ªõt xu·ªëng ch·ªó n√†y v·∫≠y.Sau ƒë√≥ v√†o k√≠ t√∫c x√°, (L√∫c n√†y g·∫∑p th√≠m Tr∆∞∆°ng - Th·∫±ng n√†y gi·ªèi t·ª´ c·∫•p 3, thi Tin tr∆∞·ªùng qu·∫≠n huy·ªán t·ªânh g√¨ ƒë√≥ n√≥ thi h·∫øt r·ªìi), n√≥ h·ªèi m√¨nh ch·ª© ‚Äú√îng bi·∫øt con tr·ªè hem, √¥ng bi·∫øt ƒë·ªá quy hem, √¥ng bi·∫øt thu·∫≠t to√°n Dijktra, chu tr√¨nh Hamilton hem‚Äù (WTH !!!). Ch·∫£ hi·ªÉu n√≥ n√≥i g√¨, m√¨nh ch·ªâ bi·∫øt nhe rƒÉng c∆∞·ªùi. :))V√†o l·ªõp h·ªçc, (L√∫c n√†y g·∫∑p th√≠m T√∫), m√¨nh c√≤n ƒëang loay hoay debug c√°i Hello World th√¨ th√≠m T√∫ ƒë√£ bay l√™n b·∫£ng code m·ªôt c√°ch th·∫ßn th√°nh: i++, j++ (WTF !!!).‚Äú√ä m√†y, i++ l√† sao m√†y‚Äù - Uy said =]].ƒê√≥, background l·∫≠p tr√¨nh c·ªßa m√¨nh l√† v·∫≠y ƒë√≥ :). R·ªìi m√¨nh c≈©ng l√™ l·∫øt qua ƒë∆∞·ª£c 4 nƒÉm ƒê·∫°i H·ªçc ƒë·∫•y th√¥i, n√™n tin vui cho c√°c b·∫°n l√† d√π bi·∫øt hay kh√¥ng bi·∫øt n√™n t·∫£ng l·∫≠p tr√¨nh, v√†o ƒê·∫°i H·ªçc th√¨ m·ªçi ng∆∞·ªùi s·∫Ω c√πng m·ªôt ƒëi·ªÉm xu·∫•t ph√°t l·∫°i h·∫øt nh√©, ch·ªâ l√† m·∫•y b·∫°n bi·∫øt tr∆∞·ªõc s·∫Ω c√≥ nhi·ªÅu l·ª£i th·∫ø h∆°n th√¥i. M√† c≈©ng ph·∫£i th√¥i, t·∫°i nh·ªØng nƒÉm c·∫•p 3 ng∆∞·ªùi ta ƒë√£ b·ªõt th·ªùi gian ƒëi ch∆°i, xem phim, la c√† ƒë·ªÉ chuy√™n t√¢m nghi√™n c·ª©u r·ªìi c√≤n g√¨.M√¨nh c√≥ m·ªôt ng∆∞·ªùi b·∫°n t·ª´ng n√≥i l√† m√¨nh gi·ªëng nh∆∞ m·ª•c ti√™u c·ªßa n√≥ v·∫≠y ƒë√≥, n√≥ s·∫Ω c·ªë g·∫Øn ph·∫•n ƒë·∫•u cho ƒë·∫øn khi qua ƒë∆∞·ª£c m·∫∑t m√¨nh, ƒë·ªÉ xem th·ª≠ ai l√† ng∆∞·ªùi ƒë·∫°t ƒë∆∞·ª£c ∆∞·ªõc m∆° c·ªßa m√¨nh s·ªõm h∆°n. M√¨nh tr·∫£ l·ªùi l·∫°i l√† *‚ÄùM√¨nh kh√¥ng l·∫•y ng∆∞·ªùi kh√°c ra ƒë·ªÉ l√†m m·ª•c ti√™u cho m√¨nh, m√¨nh c√≥ nh·ªØng m·ª•c ti√™u ri√™ng. M·∫∑t kh√°c, m·ªói ng∆∞·ªùi sinh ra ƒë√£ c√≥ nh·ªØng xu·∫•t ph√°t ƒëi·ªÉm, nh·ªØng n·ªó l·ª±c kh√°c nhau r·ªìi, t√¥i kh√¥ng bi·∫øt con ƒë∆∞·ªùng b·∫°n ƒë√£ ƒëi nh∆∞ th·∫ø n√†o v√† b·∫°n c≈©ng v·∫≠y. V·∫≠y sao l·∫°i so s√°nh ƒë∆∞·ª£c?‚Äù* 2. Nh·ªØng ki·∫øn th·ª©c n·ªÅn ·ªü ƒê·∫°i H·ªçcSau ƒë√¢y l√† list nh·ªØng m√¥n h·ªçc ƒë·∫°i c∆∞∆°ng trong 3 k√¨ ƒë·∫ßu. To√°n ƒë·∫°i c∆∞∆°ng: To√°n r·ªùi r·∫°c: C√°c b·∫°n s·∫Ω h·ªçc v·ªÅ Vector, c√°c ph√©p to√°n tr√™n Vector, ƒë·∫°i s·ªë Bool, c√°c b·∫£ng ch√¢n tr·ªã, b·∫£ng logic, kh√°i ni·ªám c∆° b·∫£n v·ªÅ ƒë·ªì th·ªã ‚Ä¶ X√°c su·∫•t th·ªëng k√™: C√°c b·∫°n s·∫Ω ƒë∆∞·ª£c h·ªçc v·ªÅ c√°c ph√©p to√°n t√≠nh x√°c su·∫•t, c√°c ph√©p ƒë·∫øm, th·ªëng k√™ ‚Ä¶ ƒê·∫°i S·ªë B1, B2: H·ªçc v·ªÅ c√°ch ph√©p to√°n x·ª≠ l√Ω tr√™n ma tr·∫≠n, ƒë·ªãnh th·ª©c, kh√¥ng gian vector ‚Ä¶ Gi·∫£i t√≠ch B1, B2: H·ªçc v·ªÅ vi ph√¢n, t√≠ch ph√¢n, ƒë·∫°o h√†m ‚Ä¶ Nh·ªØng m√¥n n√†y c·ª±c k√¨ quan tr·ªçng cho nh·ªØng m√¥n khoa h·ªçc m√°y t√≠nh sau n√†y n√™n t·∫≠p trung h·ªçc cho ch·∫Øc nh√©. To√°n r·ªùi r·∫°c quan tr·ªçng n·∫øu sau n√†y b·∫°n chuy√™n v·ªÅ thu·∫≠t to√°n, gi·∫£i thu·∫≠t, l√Ω thuy·∫øt ƒë·ªì th·ªã, automata, tr√¨nh bi√™n d·ªãch, x·ª≠ l√Ω ng√¥n ng·ªØ t·ª± nhi√™n. X√°c su·∫•t th·ªëng k√™ c·∫ßn n·∫øu b·∫°n l√†m nhi·ªÅu v·ªÅ tr√≠ tu·ªá nh√¢n t·∫°o, \bData Science, Machine Learning. ƒê·∫°i s·ªë tuy·∫øn t√≠nh ma tr·∫≠n, vector etc. c√≥ ·ª©ng d·ª•ng trong Cryptography, ph√¢n t√≠ch ƒë·ªô ph·ª©c t·∫°p thu·∫≠t to√°n. Tin h·ªçc ƒë·∫°i c∆∞∆°ng: ƒêi·ªán T·ª≠ CƒÉn B·∫£n: M√¥n n√†y h·ªçc c√°i g√¨ m√¨nh qu√™n r·ªìi, v√† c≈©ng kh√¥ng bi·∫øt t·∫°i sao m√¨nh l·∫°i qua m√¥n. L√Ω Thuy·∫øt M·∫°ch S·ªë: M√¥n n√†y h·ªçc v·ªÅ c√°c c·ªïng logic AND, OR, XOR, NOT. C√°c h·ªá c∆° s·ªë ƒë·∫øm, c√°c ph√©p to√°n x·ª≠ l√Ω tr√™n bit bla bla. Nh·∫≠p M√¥n L·∫≠p Tr√¨nh: M√¥n n√†y nh·∫π nh√†ng th√¥i, h·ªçc v·ªÅ m·∫•y c√°i c·ª±c c∆° b·∫£n nh∆∞ vi·∫øt ‚ÄúH·∫ø l√¥ b√† con‚Äù, h·ªçc c√°c syntax c∆° b·∫£n: l·∫∑p, ƒëi·ªÅu khi·ªÉn, r·∫Ω nh√°nh ‚Ä¶ L√Ω Thuy·∫øt ƒê·ªì Th·ªã: M√¥n n√†y l√† m√¥n m√¨nh th√≠ch nh·∫•t trong 4 nƒÉm ƒê·∫°i H·ªçc v√¨ ƒë∆∞·ª£c h·ªçc v·ªõi C√¥ V√¢n d·ªÖ th∆∞∆°ng. C√°c b·∫°n s·∫Ω ƒë∆∞·ª£c h·ªçc v·ªÅ c√°c ph√©p duy·ªát ƒë·ªì th·ªã (BFS, DFS), c√°c thu·∫≠t to√°n t√¨m ƒë∆∞·ªùng ƒëi ng·∫Øn nh·∫•t (Dijkstra, Floyd + Bellman), c√°c kh√°i ni·ªám v·ªÅ ƒë·ªì th·ªã (Li√™n th√¥ng, ƒë·∫≥ng c·∫•u bla bla), chu tr√¨nh Euler v√† Hamilton ‚Ä¶ B·∫°n n√™n ƒë·ªçc th√™m quy·ªÉn: Introduction To Algorithm [THOMAS H. CORMEN, CHARLES E. LEISERSON, RONALD L. RIVEST, CLIFFORD STEIN] Nh·∫≠p M√¥n C√¥ng Ngh·ªá Th√¥ng Tin 1,2: Hai m√¥n n√†y ch·ªß y·∫øu ‚ÄúC∆∞·ª°i ng·ª±a xem hoa‚Äù cho vui th√¥i, s·∫Ω gi·ªõi thi·ªáu cho c√°c b·∫°n v·ªÅ ng√†nh C√¥ng Ngh·ªá Th√¥ng Tin, c√°c chuy√™n ng√†nh v√† c√°c h∆∞·ªõng nghi√™n c·ª©u. Hai m√¥n n√†y nh·∫π nh√†ng, ƒë·ª´ng t·∫°o √°p l·ª±c l√†m g√¨. C∆° S·ªü D·ªØ Li·ªáu: H·ªçc v·ªÅ c√°c kh√°i ni·ªám c∆° b·∫£n trong h·ªá th·ªëng th√¥n tin v√† c∆° s·ªü d·ªØ li·ªáu, c√°c h·ªá th·ªëng CSDL v√† m√¥ h√¨nh d·ªØ li·ªáu quan h·ªá, s·ª≠ d·ª•ng SQL ƒë·ªÉ truy v·∫•n c∆° s·ªü d·ªØ li·ªáu, thi·∫øt k·∫ø c∆° s·ªü d·ªØ li·ªáu, ph√¢n t√≠ch ch·∫•t l∆∞·ª£ng c·ªßa m·ªôt l∆∞·ª£c ƒë·ªì c∆° s·ªü d·ªØ li·ªáu. Ki·∫øn Tr√∫c M√°y T√≠nh v√† H·ª£p Ng·ªØ: H·ªçc v·ªÅ c√°c c√°ch thi·∫øt k·∫ø ki·∫øn tr√∫c c·ªßa m√°y t√≠nh, t·ªïng quan v·ªÅ m√°y t√≠nh, ki·∫øn tr√∫c MIPS, x86, x32, c√°ch thi·∫øt k·∫ø CPU c·ªßa m√°y t√≠nh, c√°c h·ªá c∆° s·ªë v√† c√°ch l∆∞u tr·ªØ tr√™n m√°y t√≠nh ‚Ä¶ B·∫°n n√™n t√¨m ƒë·ªçc th√™m quy·ªÉn Computer Architecture: A Quantitative Approach [John L.Hennessy and David A.Patterson] H·ªá ƒêi·ªÅu H√†nh: M√¥n n√†y quan tr·ªçng, c√°c b·∫°n c·∫ßn h·ªçc th·∫≠t t·ªët m√¥n n√†y. M√¥n n√†y c√°c b·∫°n s·∫Ω ƒë∆∞·ª£c h·ªçc v·ªÅ c√°ch h·ªá ƒëi·ªÅu h√†nh l√†m vi·ªác, h·ªçc v·ªÅ Kernel c·ªßa OS, h·ªá th·ªëng t·∫≠p tin FAT32 v√† FAT64, c√°ch m√† OS qu·∫£n l√Ω v√† ƒëi·ªÅu ph·ªëi c√°c ti·∫øn tr√¨nh, ƒë·ªìng b·ªô ho√° gi·ªØa c√°c ti·∫øn tr√¨nh, qu·∫£n l√Ω b·ªô nh·ªõ tr√™n OS ‚Ä¶ B·∫°n n√™n t√¨m ƒë·ªçc th√™m quy·ªÉn Operating System Concepts [Silberschatz, Galvin, Gagne]. M·∫°ng M√°y T√≠nh: M√¥n n√†y quan tr·ªçng, n√™n ƒë·∫ßu t∆∞ nhi·ªÅu th·ªùi gian t√¨m hi·ªÉu. M√¥n n√†y c√°c b·∫°n h·ªçc v·ªÅ m·∫°ng m√°y t√≠nh, c√°ch m√† c√°c h·ªá th·ªëng m√°y t√≠nh l√†m vi·ªác v·ªõi nhau, c√°ch m·ªôt g√≥i tin ƒë∆∞·ª£c truy·ªÅn ƒëi trong h·ªá th·ªëng m·∫°ng, c√°c kh√°i ni·ªám v·ªÅ m·∫°ng m√°y t√≠nh (IP, subnet mark, ‚Ä¶), m√¥ h√¨nh 7 t·∫ßng OSI, sau ƒë√≥ h·ªçc v√†o chi ti·∫øt t·ª´ng t·∫ßng trong m√¥ h√¨nh m·∫°ng. B·∫°n n√™n t√¨m ƒë·ªçc th√™m quy·ªÉn Computer Networking: A Top-Down Approach [7th Edition, Kurose &amp; Ross] L·∫≠p Tr√¨nh H∆∞·ªõng ƒê·ªëi T∆∞·ª£ng: M√¥n n√†y c√°c b·∫°n b·∫Øt bu·ªôc ph·∫£i n·∫Øm v·ªØng, h·ªçc t·ªët m√¥n n√†y th√¨ b·∫°n c√≥ th·ªÉ h·ªçc nhanh b·∫•t k√¨ ng√¥n ng·ªØ l·∫≠p tr√¨nh n√†o. V√† n√™n nh·ªõ, sau c√πng th√¨ ng√¥n ng·ªØ c≈©ng ch·ªâ l√† c√°i ƒë·ªÉ hi·ªán th·ª±c ho√° c√°i √Ω t∆∞·ªüng c·ªßa m√¨nh th√¥i. Kh√¥ng n√™n ƒë·∫∑t n·∫∑ng v·∫•n ƒë·ªÅ ng√¥n ng·ªØ l·∫≠p tr√¨nh l√™n h√†ng ƒë·∫ßu m√† b·ªè qua c∆° s·ªü ƒë·ªÉ x√¢y d·ª±ng ng√¥n ng·ªØ ƒë√≥. B·∫°n n√™n t√¨m ƒë·ªçc th√™m Head First Design Pattern [Head First],Design Patterns [Gang Of Four] K·ªπ Thu·∫≠t L·∫≠p Tr√¨nh: M√¥n n√†y s·∫Ω d·∫°y b·∫°n c√°c kh√°i ni·ªám trong l·∫≠p tr√¨nh (Con tr·ªè, v√πng nh·ªõ, ma tr·∫≠n, stack, heap ‚Ä¶) v√† c√°c chi√™u th·ª©c l·∫≠p tr√¨nh r·∫•t hay (Quy ho·∫°ch ƒë·ªông (Dynamic Programming), quay lui (Backtracking), m√† c√°i m√¨nh th√≠ch nh·∫•t l√† v√©t c·∫°n (Greedy)) Ahihi. C·∫•u Tr√∫c D·ªØ li·ªáu &amp; Gi·∫£i Thu·∫≠t: M√¥n n√†y s·∫Ω d·∫°y b·∫°n c√°c lo·∫°i c·∫•u tr√∫c d·ªØ li·ªáu trong l·∫≠p tr√¨nh (Tree, Stack, Heap, Queue ‚Ä¶). C√°ch s·ª≠ d·ª•ng t·ª´ng lo·∫°i d·ªØ li·ªáu trong t·ª´ng tr∆∞·ªùng h·ª£p c·ª• th·∫ø. ƒê·ªìng th·ªùi c√≤n d·∫°y b·∫°n c√°c gi·∫£i thu·∫≠t c∆° b·∫£n (Sort, Search ‚Ä¶), ƒë√°nh gi√° ƒë·ªô ph·ª©c t·∫°p gi·ªØa c√°c gi·∫£i thu·∫≠t. Khi n√†o d√πng c√°i n√†y, khi n√†o d√πng c√°i kia, c√°i n√†o t·ªët h∆°n, ph·∫£i ƒë√°nh ƒë·ªïi c√°i g√¨ bla bla. ƒê·ªÉ h·ªçc t·ªët m√¥n n√†y th√¨ ngo√†i gi√°o tr√¨nh tr√™n tr∆∞·ªùng, m√¨nh nghƒ© c√°c b·∫°n n√™n ƒë·ªçc th√™m quy·ªÉn Introduction To Algorithm [Steven S.Skiena] ho·∫∑c Introduction To Algorithm [THOMAS H. CORMEN, CHARLES E. LEISERSON, RONALD L. RIVEST, CLIFFORD STEIN] ƒë·ªÉ tƒÉng n·ªôi c√¥ng. Ngo√†i ra ƒë·ªÉ tr·ªü th√†nh m·ªôt l·∫≠p tr√¨nh vi√™n c√≥ t√¢m, code √≠t bug, ng∆∞·ªùi kh√°c ƒë·ªçc code c·ªßa b·∫°n kh√¥ng b·ªã ·ª©c ch·∫ø th√¨ n√™n ƒë·ªçc th√™m nh·ªØng quy·ªÉn sau: Clean Code [Robert C.Martin], Code Complete [Steve McConnell], Refactoring [Martin Fowler, Steve McConnell], Pragmatic Programmer [Andrew Hunt, David Thomas]. 3. Vi·ªác ch·ªçn chuy√™n ng√†nh:Sau 3 h·ªçc k√¨ ƒë·∫ßu c√°c b·∫°n s·∫Ω ƒë∆∞·ª£c ch·ªçn chuy√™n ng√†nh ph√π h·ª£p v·ªõi nguy·ªán v·ªçng c·ªßa m√¨nh.C√°c b·∫°n s·∫Ω ƒê∆Ø·ª¢C CH·ªåN chuy√™n ng√†nh ch·ª© kh√¥ng b·ªã √©p bu·ªôc hay s·ª£ h·∫øt slot g√¨ h·∫øt nh√©, v√¨ c√≥ m·ªôt s·ªë b·∫°n inbox h·ªèi m√¨nh ch·ªó n√†y n√™n nh√¢n ƒë√¢y m√¨nh n√≥i lu√¥n.Khoa m√¨nh hi·ªán c√≥ 6 chuy√™n ng√†nh: C√¥ng Ngh·ªá Ph·∫ßn M·ªÅm (Software Engineering): H·ªçc v·ªÅ quy tr√¨nh ph√°t tri·ªÉn ph·∫ßn m·ªÅm; H·ªçc v·ªÅ c√°ch ph√¢n t√≠ch y√™u c·∫ßu ph·∫ßn m·ªÅm, thi·∫øt k·∫ø ph·∫ßn m·ªÅm, hi·ªán th·ª±c ho√° ph·∫ßn m·ªÅm v√† ki·ªÉm th·ª≠ ph·∫ßn m·ªÅm. H·ªá Th·ªëng Th√¥ng Tin (Information System): H·ªçc c√°ch ph√°t tri·ªÉn, x√¢y d·ª±ng c√°c h·ªá th·ªëng th√¥ng tin ph·ª©c t·∫°p, th√¥ng minh, t·ªëi ∆∞u; Nghi√™n c·ª©u b·∫£o m·∫≠t th√¥ng tin, r√∫t tr√≠ch th√¥ng tin ƒëa ng√¥n ng·ªØ. M·∫°ng M√°y T√≠nh v√† Vi·ªÖn Th√¥ng (Computer Networks and Telecommunication): Ph√°t tri·ªÉn c√°c ·ª©ng d·ª•ng m·∫°ng, h·ªá ƒëi·ªÅu h√†nh cho c√°c thi·∫øt b·ªã m·∫°ng, ph√°t tri·ªÉn h·ªá th·ªëng. Khoa H·ªçc M√°y T√≠nh (Computer Science): Khai th√°c d·ªØ li·ªáu, ph√¢n t√≠ch v√† thi·∫øt k·∫ø thu·∫≠t to√°n ƒë·ªÉ t·ªëi ∆∞u b√†i to√°n, ph√°t tri·ªÉn c√°c h·ªá th·ªëng tr√≠ tu·ªá nh√¢n t·∫°o (AI)‚Ä¶ C√¥ng Ngh·ªá Tri Th·ª©c (Knowledge Engineering): Nghi√™n c·ª©u v·ªÅ x·ª≠ l√Ω ng√¥n ng·ªØ t·ª± nhi√™n (Gi·ªçng n√≥i √°) ho·∫∑c ƒëa ph∆∞∆°ng ti·ªán (File √¢m thanh); nghi√™n c·ª©u v·ªÅ m·∫≠t m√£ v√† an ninh th√¥ng tin. Th·ªã Gi√°c M√°y T√≠nh v√† Khoa H·ªçc Robot (Computer Vision and Robotics): T√≠ch h·ª£p k·ªπ thu·∫≠t trong ƒë·ªì ho·∫° m√°y t√≠nh v√† x·ª≠ l√Ω ·∫£nh s·ªë v√†o thi·∫øt b·ªã di ƒë·ªông v√† robot. H·ªó tr·ª£ ph√°t hi·ªán, nh·∫≠n d·∫°ng, truy v·∫•n, t√°i t·∫°o c√°c ƒë·ªëi t∆∞·ª£ng trong c√°c m√¥i tr∆∞·ªùng kh√°c nhau. ƒê·∫øn giai ƒëo·∫°n n√†y th√¨ c√°c b·∫°n s·∫Ω t·ª± ƒëƒÉng k√≠ m√¥n h·ªçc cho ph√π h·ª£p v·ªõi chuy√™n ng√†nh c·ªßa m√¨nh. V√≠ d·ª• b·∫°n ch·ªçn chuy√™n ng√†nh ‚ÄúC√¥ng Ngh·ªá Ph·∫ßn M·ªÅm‚Äù th√¨ b·∫°n ph·∫£i t√≠ch lu·ªπ ƒë·ªß N t√≠n ch·ªâ thu·ªôc c√°c m√¥n ph·∫ßn m·ªÅm v√† ph·∫£i ho√†n th√†nh N m√¥n h·ªçc b·∫Øt bu·ªôc trong c√¥ng ngh·ªá ph·∫ßn m·ªÅm.M·ªôt l·ªùi khuy√™n cho c√°c b·∫°n l√† kh√¥ng n√™n ch·ªâ ch·ªçn h·ªçc nh·ªØng m√¥n trong ph·∫°m vi chuy√™n ng√†nh c·ªßa m√¨nh, n√™n ch·ªçn h·ªçc th√™m nh·ªØng m√¥n h·ªçc ·ªü nh·ªØng chuy√™n ng√†nh kh√°c m√† n√≥ hay, n√≥ b·ªï √≠ch, n√≥ h·ªó tr·ª£ cho chuy√™n ng√†nh ch√≠nh c·ªßa m√¨nh. V√≠ d·ª• nh∆∞ b·∫°n ch·ªçn C√¥ng ngh·ªá Ph·∫ßn m·ªÅm th√¨ c√≥ th·ªÉ h·ªçc th√™m c√°c m√¥n kh√°c c·ªßa Khoa H·ªçc M√°y T√≠nh nh∆∞ ‚ÄúPh√¢n T√≠ch ƒê·ªô Ph·ª©c T·∫°p Thu·∫≠n To√°n‚Äù, ‚ÄúPh√¢n T√≠ch v√† Thi·∫øt K·∫ø Gi·∫£i Thu·∫≠t‚Äù hay ‚ÄúChuy√™n ƒê·ªÅ H·ªá ƒêi·ªÅu H√†nh Linux‚Äù hay ‚ÄúB·∫£o M·∫≠t C∆° S·ªü D·ªØ Li·ªáu‚Äù hay ‚ÄúKhai Th√°c D·ªØ Li√™u v√† ·ª®ng D·ª•ng‚Äù hay ‚ÄúM√°y H·ªçc‚Äù ‚Ä¶ Chung quy l·∫°i l√† ph·∫£i bi·∫øt l·ª±a m√¥n m√† h·ªçc.ƒê·ªÉ t√¨m hi·ªÉu th√™m v·ªÅ c√°c chuy√™n ng√†nh, c√°c b·∫°n tham kh·∫£o t·∫°i ƒë√¢y Chuy√™n ng√†nh CNTT 4. ƒêi·ªÉm s·ªë c√≥ th·ª±c s·ª± quan tr·ªçng?*‚ÄùXu·ª≥, h·ªçc l√† h·ªçc ki·∫øn th·ª©c th√¥i ch·ª© ƒëi·ªÉm th√¨ c√≥ quan tr·ªçng g√¨.‚Äù*M√¨nh n√≥i th·∫≥ng lu√¥n l√† c√¢u n√†y ch·ªâ l√† c√¢u ngu·ªµ bi·ªán c·ªßa m·∫•y b·∫°n l∆∞·ªùi l√†m b√†i th√¥i, n·∫øu c√°c b·∫°n l√†m b√†i ƒë·∫ßy ƒë·ªß th√¨ ƒëi·ªÉm c·ªßa c√°c b·∫°n c≈©ng s·∫Ω x·ª©ng ƒë√°ng v·ªõi nh·ªØng g√¨ b·∫°n b·ªè ra th√¥i.Quay l·∫°i v·∫•n ƒë·ªÅ, ƒëi·ªÉm s·ªë ·ªü ƒê·∫°i H·ªçc c√≥ th·∫≠t s·ª± quan tr·ªçng? Quan ƒëi·ªÉm c·ªßa m√¨nh l√† n√≥ kh√¥ng qu√° quan tr·ªçng, nh∆∞ng c≈©ng kh√¥ng ph·∫£i l√† th·ª© c√≥ th·ªÉ ph·ªõt l·ªù.ƒêi·ªÉm s·ªë, trong ƒê·∫°i H·ªçc, m·ªôt m·∫∑t l√† ƒë·ªÉ b·∫°n kh·ªèi b·ªã ƒë√≥ng ti·ªÅn h·ªçc ngu r·ªõt m√¥n, m·∫∑t kh√°c n√≥ l·∫°i c√≥ √Ω nghƒ©a quan tr·ªçng h∆°n ƒë·ªëi v·ªõi nh·ªØng b·∫°n c·∫ßn h·ªçc b·ªïng ƒë·ªÉ chi tr·∫£ h·ªçc ph√≠ hay sinh ho·∫°t h√†ng th√°ng. Xa x√¥i h∆°n l√† ƒë·ªÉ sau n√†y c√°c b·∫°n c√≥ th·ªÉ Apply c√°c h·ªçc b·ªïng du h·ªçc n∆∞·ªõc ngo√†i.ƒêi·ªÉm s·ªë, ngo√†i ƒê·∫°i H·ªçc, l√† c√°i m√† nh√† tuy·ªÉn d·ª•ng s·∫Ω nh√¨n v√†o ƒë·∫ßu ti√™n (ƒê·ªëi v·ªõi ng∆∞·ªùi m·ªõi ra tr∆∞·ªùng) ƒë·ªÉ xem x√©t xem b·∫°n c√≥ qua ƒë∆∞·ª£c v√≤ng g·ªüi xe kh√¥ng. Th·ª≠ ƒë·∫∑t m√¨nh v√†o v·ªã tr√≠ nh√† tuy·ªÉn d·ª•ng, b·∫°n m·ªõi ra tr∆∞·ªùng, h·ªç kh√¥ng bi·∫øt g√¨ v·ªÅ b·∫°n, h·ªç l·∫•y g√¨ ƒë·ªÉ ƒë√°nh gi√° nƒÉng l·ª±c v√† con ng∆∞·ªùi b·∫°n? M√¨nh kh√¥ng bi·∫øt th·∫≠t s·ª± c√°c nh√† tuy·ªÉn d·ª•ng s·∫Ω ƒë√°nh gi√° nh∆∞ th·∫ø n√†o, nh∆∞ng m√¨nh nghƒ© ƒëi·ªÉm GPA s·∫Ω ph·∫ßn n√†o n√≥i l√™n con ng∆∞·ªùi b·∫°n, r·∫±ng b·∫°n c√≥ ph·∫£i l√† m·ªôt ng∆∞·ªùi c√≥ tr√°ch nhi·ªám (V·ªõi vi·ªác h·ªçc) c·ªßa m√¨nh kh√¥ng? R·∫±ng b·∫°n c√≥ ƒë·ªß ƒëi·ªÅu ki·ªán ƒë·ªÉ t·ªõi v√≤ng test k·ªπ thu·∫≠t, v√≤ng ph·ªèng v·∫•n kh√¥ng? ƒêi·ªÉm s·ªë gi·ªëng nh∆∞ l√† t·∫•m v√© ƒë·ªÉ b·∫°n ƒëi v√†o m·ªôt h·ªôi tr∆∞·ªùng, l√∫c ƒë√≥ nƒÉng l·ª±c th·∫≠t s·ª± c·ªßa b·∫°n s·∫Ω ƒë∆∞·ª£c th·ªÉ hi·ªán. M√† ngay c·∫£ t·∫•m v√© m·ªùi b·∫°n c√≤n ch∆∞a c√≥ th√¨ l·∫•y c∆° h·ªôi ƒë√¢u ƒë·ªÉ th·ªÉ hi·ªán b·∫£n th√¢n?V·∫≠y ƒëi·ªÉm s·ªë c√≥ quan tr·ªçng kh√¥ng? 5. Ho·∫°t ƒë·ªông ngo·∫°i kho√°, c√≥ ƒÉn ƒë∆∞·ª£c kh√¥ng?N√≥i v·ªÅ ho·∫°t ƒë·ªông ngo·∫°i kho√°, m√¨nh n√≥i th·∫≥ng l√† m√¨nh kh√¥ng tham gia qu√° nhi·ªÅu ho·∫°t ƒë·ªông ƒêo√†n - H·ªôi. M√¨nh ch·ªâ l·ªçc ra m·ªôt v√†i ho·∫°t ƒë·ªông th·∫≠t s·ª± c√≥ √Ω nghƒ©a (Cho m√¨nh v√† cho ng∆∞·ªùi kh√°c) ƒë·ªÉ tham gia. V√≠ d·ª• nh∆∞ hi·∫øn m√°u nh√¢n ƒë·∫°o, vui h·ªôi trƒÉng r·∫±m, v·ªÅ v·ªõi ngo·∫°i th√†nh ‚Ä¶ ƒêi m·∫•y c√°i n√†y v·ª´a b·ªï √≠ch, v·ª´a c√≥ tr·∫£i nghi·ªám l·∫°i gi√∫p ƒë·ª° ƒë∆∞·ª£c ng∆∞·ªùi kh√°c.C√°c ho·∫°t ƒë·ªông ngo·∫°i kho√° n√†y s·∫Ω l√† ƒëi·ªÉm nh·∫•n quan tr·ªçng trong h·ªì s∆° xin h·ªçc b·ªïng h·ªçc t·∫≠p ho·∫∑c h·ªçc b·ªïng du h·ªçc.Ngo√†i c√°c ho·∫°t ƒë√¥ng trong tr∆∞·ªùng, c√°c b·∫°n c√≥ th·ªÉ t√¨m th√™m c√°c ho·∫°t ƒë·ªông kh√°c t·ª´ c√°c t·ªï ch·ª©c t·ª´ thi·ªán. M√¨nh ƒë√£ t·ª´ng tham gia ho·∫°t ƒë·ªông t·ª´ thi·ªán c·ªßa t·ªï ch·ª©c phi ch√≠nh ph·ªß Habitat k·∫øt h·ª£p v·ªõi ƒêHQG TP.H·ªì Ch√≠ Minh, t·∫≠p ƒëo√†n POSCO H√†n Qu·ªëc v√† sinh vi√™n H√†n Qu·ªëc ƒë·ªÉ x√¢y nh√† t√¨nh th∆∞∆°ng cho ng∆∞·ªùi ngh√®o ·ªü V≈©ng T√†u. C√°c ho·∫°t ƒë·ªông n√†y r·∫•t √Ω nghƒ©a v√† c√≤n gi√∫p b·∫°n c√≥ th√™m b·∫°n b√®, c√°c m·ªëi quan h·ªá sau n√†y.C√°c b·∫°n tham kh·∫£o th√™m t·∫°i ƒë√¢y: Habitat for Humanity Vietnam. 6. H·ªçc b·ªïng, ki·∫øm ·ªü ƒë√¢u?M·ªói k√¨ tr∆∞·ªùng m√¨nh ƒë·ªÅu c√≥ r·∫•t nhi·ªÅu h·ªçc b·ªïng h·ªó tr·ª£ c√°c b·∫°n: H·ªçc b·ªïng khuy·∫øn kh√≠ch h·ªçc t·∫≠p d√†nh cho nh·ªØng b·∫°n c√≥ ƒëi·ªÉm h·ªçc t·∫≠p cao (L·∫•y t·ª´ tr√™n l·∫•y xu·ªëng ƒë·∫øn khi h·∫øt ch·ªâ ti√™u). H·ªìi l√∫c nƒÉm nh·∫•t m√¨nh nh·∫≠n th√¨ gi√° tr·ªã c·ªßa n√≥ l√† 2tr5 th√¨ ph·∫£i, sau ƒë√≥ ƒë·∫øn nƒÉm t∆∞ th√¨ n√≥ tƒÉng l√™n ƒë∆∞·ª£c g·∫ßn 4tr 1 k√¨ (Ch·∫Øc do l·∫°m ph√°t :))). Kho·∫£ng ti·ªÅn n√†y c≈©ng ƒë·ªß ƒë·ªÉ c√°c b·∫°n chi tr·∫£ (Ph·∫ßn n√†o) h·ªçc ph√≠.Th·∫≠t ra ƒë·ªÉ l·∫•y ƒë∆∞·ª£c su·∫•t h·ªçc b·ªïng n√†y m√¨nh nghƒ© l√† kh√¥ng qu√° kh√≥. ƒêi·ªÉm trung b√¨nh c·ªßa c√°c b·∫°n ch·ªâ c·∫ßn tr√™n 8.0 l√† ƒë√£ c√≥ c∆° h·ªôi nh·∫≠n r·ªìi. V·ªÅ v·∫•n ƒë·ªÅ ƒëi·ªÉm r√®n luy·ªán. M√¨nh nghƒ© c≈©ng kh√¥ng c·∫ßn thi·∫øt ph·∫£i d√†nh qu√° nhi·ªÅu th·ªùi gian ƒë·ªÉ tham gia c√°c ho·∫°t ƒë·ªông ƒêo√†n - H·ªôi l√†m g√¨, ch·ªâ c·∫ßn tham gia m·ªôt v√†i ho·∫°t ƒë·ªông ch√≠nh (Xem l·∫°i m·ª•c ho·∫°t ƒë·ªông ngo·∫°i kho√°) v√† kh√¥ng vi ph·∫°m g√¨ ƒë·∫øn c√°c ‚Äògi·ªõi rƒÉng‚Äô c·ªßa tr∆∞·ªùng (V·∫Øng sinh ho·∫°t c√¥ng d√¢n, x√°c nh·∫≠n l∆∞u tr√∫ bla bla g√¨ ƒë√≥) l√† ƒë·ªß ƒëi·ªÅu ki·ªán r·ªìi. Ngo√†i ra khoa m√¨nh c≈©ng c√≥ li√™n k·∫øt v·ªõi c√°c doanh nghi·ªáp ƒë·ªÉ c√≥ c√°c su·∫•t h·ªçc b·ªïng kh√°c. C√°c c√¥ng ty l·ªõn nh∆∞ KMS, ELCA, CSC, Global Cybersoft, NTTData, GameLoft, VNG‚Ä¶ ƒë·ªÅu c√≥ li√™n k·∫øt v·ªõi khoa m√¨nh ƒë·ªÉ trao h·ªçc b·ªïng h·∫±ng k√¨ (H√†ng nƒÉm) cho sinh vi√™n khoa m√¨nh. Gi√° tr·ªã c√°c su·∫•t h·ªçc b·ªïng dao ƒë·ªông t·ª´ 3tr - 5tr tu·ª≥ c√¥ng ty.ƒê·ªÉ ƒë∆∞·ª£c c√°c su·∫•t h·ªçc b·ªïng n√†y th√¨ ƒëi·ªÉm trung b√¨nh c·ªßa c√°c b·∫°n kh√¥ng c·∫ßn qu√° cao (Ch·ªâ c·∫ßn t·ª´ 7.5+). Th∆∞·ªùng th√¨ c√°c su·∫•t h·ªçc b·ªïng n√†y nh·∫Øm t·ªõi c√°c b·∫°n sinh vi√™n kh√≥ khƒÉn trong khoa n√™n s·∫Ω c√≥ y√™u c·∫ßu (Optional) n·ªôp th√™m m·ªôt gi·∫•y x√°c nh·∫≠n gia ƒë√¨nh c√≥ ho√†n c·∫£nh kh√≥ khƒÉn ·ªü ƒë·ªãa ph∆∞∆°ng. Gi·∫•y n√†y th√¨ b·∫°n v·ªÅ UBND qu√™ c·ªßa b·∫°n xin t·ªù gi·∫•y x√°c nh·∫≠n nh√©.C√°c su·∫•t h·ªçc b·ªïng n√†y ngo√†i gi√° tr·ªã v·∫•t ch·∫•t (Ti·ªÅn ƒë√≥), m·ªôt s·ªë c√¥ng ty c√≤n offer cho b·∫°n c√°c c∆° h·ªôi th·ª±c t·∫≠p (KMS, theo m√¨nh bi·∫øt), ho·∫∑c s·∫Ω c√≥ th∆∞ m·ªùi b·∫°n l√†m vi·ªác ngay sau khi t·ªët nghi·ªáp. Qu√° s∆∞·ªõng ph·∫£i hem? Th√™m th√¥ng tin cho c√°c b·∫°n l√† khoa m√¨nh c≈©ng c√≥ Qu·ªπ h·ªçc b·ªïng t·ª´ c√°c c·ª±u sinh vi√™n trong khoa d√†nh cho c√°c b·∫°n c√≥ ho√†n c·∫£nh th·ª±c s·ª± kh√≥ khƒÉn (C√°i n√†y h√¨nh nh∆∞ kh√¥ng y√™u c·∫ßu ƒëi·ªÉm cao, 7.0+).C√°c b·∫°n s·∫Ω ƒë∆∞·ª£c ph·ªèng v·∫•n v·ªõi c√°c Th·∫ßy/C√¥ ch·ªß nhi·ªám Qu·ªπ h·ªçc b·ªïng, Th·∫ßy/C√¥ s·∫Ω quy·∫øt ƒë·ªãnh s·ªë ph·∫≠n c·ªßa b·∫°n :). Theo m√¨nh bi·∫øt th√¨ h·ªçc b·ªïng n√†y ƒë∆∞·ª£c c·∫•p h√†ng th√°ng trong su·ªët 4 nƒÉm h·ªçc v·ªõi y√™u c·∫ßu l√† b·∫°n ph·∫£i ho√†n th√†nh t·ªët ch∆∞∆°ng tr√¨nh h·ªçc hay sao ƒë√≥.ƒê·ªÉ th√™m th√¥ng tin th√¨ b·∫°n v√†o ƒë√¢y: Qu·ªπ h·ªçc b·ªïng c·ª±u sinh vi√™n khoa CNTT. Ph√≠a sau l√† nh·ªØng su·∫•t h·ªçc b·ªïng l·ªõn h∆°n, ƒë√≤i h·ªèi b·∫°n ph·∫£i c√≥ nhi·ªÅu th√†nh t√≠ch h∆°n (GPA ph·∫£i th·∫≠t cao: 8.5+, English t·ªët: Essay, m·ªôt s·ªë h·ªçc b·ªïng ƒë√≤i h·ªèi b·∫°n ph·∫£i test k·ªπ thu·∫≠t, c·ªëng hi·∫øn cho x√£ h·ªôi: ho·∫°t ƒë·ªông ngo·∫°i kho√°, bonus th√™m: C√¥ng tr√¨nh nghi√™n c·ª©u, b√†i b√°o khoa h·ªçc, gi·∫£i th∆∞·ªüng qu·ªëc t·∫ø bla bla).L√∫c n√†y nh·ªØng ho·∫°t ƒë·ªông ngo·∫°i kho√° c·ªßa b·∫°n m·ªõi th·ª±c s·ª± ph√°t huy t√°c d·ª•ng, nh·ªØng ho·∫°t ƒë·ªông ph·ª•c v·ª• x√£ h·ªôi, nh·∫Øm ƒë·∫øn c·ªông ƒë·ªìng s·∫Ω ƒë∆∞·ª£c ban ƒëi·ªÅu h√†nh ƒë√°nh gi√° cao, ph·∫ßn n√†o bi√©t ƒë∆∞·ª£c nh√¢n c√°ch con ng∆∞·ªùi b·∫°n. C√°c h·ªçc b·ªïng l·ªõn ng∆∞·ªùi ta nh√¨n nh·∫≠n con ng∆∞·ªùi ·ªü nhi·ªÅu kh√≠a c·∫°nh ch·ª© kh√¥ng ch·ªâ h·ªçc kh√¥ng, ki·ªÉu gi·ªëng nh∆∞ T√†i v√† ƒê·ª©c ph·∫£i ƒëi v·ªõi nhau v·∫≠y ƒë√≥.M√¨nh list d∆∞·ªõi ƒë√¢y ch·ªâ l√† nh·ªØng h·ªçc b·ªïng m√¨nh ƒë√£ ƒë·∫°t ƒë∆∞·ª£c th√¥i nh√©, tr∆∞·ªùng m√¨nh c√≤n r·∫•t nhi·ªÅu c√°c h·ªçc b·ªïng kh√°c t∆∞∆°ng ƒë∆∞∆°ng, b·∫°n c√≥ th·ªÉ t√¨m th√™m tr√™n trang web c·ªßa tr∆∞·ªùng: Odon Vallet Scholarship 2016 from Recontres du Vietnam ‚Äì Vallet Foundation for students with outstanding achievements. (Gi√° tr·ªã 15tr) Sunflower Mission Engineering and Technology Scholarship from eSilicon Corporation and Sunflower Mission foundation. (Gi√° tr·ªã 300$) Pony Chung scholarship is sponsored by Pony Chung foundation, Hyundai Development Company and Vietnam National University. (Gi√° tr·ªã 500$ + C∆° h·ªôi ƒë∆∞·ª£c h·ªçc b·ªïng sau ƒê·∫°i H·ªçc ·ªü H√†n Qu·ªëc) Lawrence S.Ting scholarship from Lawrence S.Ting Memorial Fund for students with outstanding achievements. (Gi√° tr·ªã 10tr)Ph·∫ßn Essay xin h·ªçc b·ªïng, ƒë·ªÉ h√¥m n√†o r·∫£nh m√¨nh vi·∫øt v·ªÅ kinh nghi·ªám v·ªõi Essay sau, gi·ªù l√†m bi·∫øng r·ªìi =]].3s qu·∫£ng c√°o b·∫±ng khen c·ªßa Sunflower (C√°i b·∫±ng khen n√†y ƒë·∫πp n√™n khoe :))): 7. H·ªçc nh∆∞ th·∫ø n√†o?Quan tr·ªçng nh·∫•t v·∫´n l√† ch√≠nh b·∫°n, s·∫Ω kh√¥ng c√≥ m·ªôt ph∆∞∆°ng ph√°p h·ªçc t·∫≠p n√†o ph√π h·ª£p v·ªõi b·∫°n h·∫øt. B·∫°n ph·∫£i t·ª± t√¨m ra n√≥.Nh∆∞ng l·ªùi khuy√™n c·ªßa m√¨nh d√†nh cho c√°c b·∫°n l√† n√™n c√≥ m·ªôt nh√≥m h·ªçc t·∫≠p, ƒë·ªëi v·ªõi m√¨nh th√¨ nh√≥m n√†y kh√¥ng c·∫ßn ph·∫£i l√† nh·ªØng super trong l·ªõp, ch·ªâ c·∫ßn c√°c b·∫°n ch·ªãu kh√≥ h·ªçc chung v·ªõi nhau (Nh·ªõ nh√©, h·ªçc nhi·ªÅu h∆°n ch∆°i), chia s·∫ª ki·∫øn th·ª©c v·ªõi nhau, l√¢u l√¢u cho copy code x√≠ =]], v√¨ l∆∞·ª£ng ki·∫øn th·ª©c ·ªü ƒê·∫°i H·ªçc r·∫•t nhi·ªÅu, ƒë·∫∑c bi·ªát l√† ng√†nh c·ªßa m√¨nh, n√™n b·∫°n ph·∫£i c√≥ ƒë·ªìng b·ªçn ƒë·ªÉ h·ªçc chung, v·ªõi r·ªß r√™ c√∫p h·ªçc ƒëi xem phim, ƒëi h√°t Karaoke ch·∫≥ng h·∫°n. H·ªìi ƒë√≥ m√¨nh ·ªü chung k√≠ t√∫c x√° v·ªõi th√≠m Tr∆∞∆°ng, n√≥ c≈©ng ch·ªãu h·ªçc n√™n m√¨nh ƒëu b√°m n√≥ ƒë·ªÉ n√≥ ch·ªâ b√†i cho; hai ƒë·ª©a c·∫Øm ƒë·∫ßu ch·∫°y deadline ng√†y ƒë√™m, nh·ªù v·∫≠y m√† c≈©ng kh√° l√™n ƒë∆∞·ª£c. (y)Trong Software Engineering c√≥ m·ªôt kh·∫£i ni·ªám g·ªçi l√† Trade-off, nghƒ©a l√† b·∫°n ph·∫£i bi·∫øt ƒë√°nh ƒë·ªïi gi·ªØa ƒë∆∞·ª£c v√† m·∫•t, gi·ªØa chi ph√≠ b·ªô nh·ªõ v√† th·ªùi gian, gi·ªØa m√¥n n√†y v√† m√¥n kia, trong nh·ªØng ho√†n c·∫£nh c·ª• th·ªÉ, b·∫°n l·ª±a ch·ªçn c√°i n√†o th√¨ ƒë√≥ l√† quy·∫øt ƒë·ªãnh c·ªßa b·∫°n :).*‚ÄùYou can not write perfect softwares. Because a perfect software does not exist. No one in the brief history of computing has ever written a piece of perfect software. It‚Äôs unlike that you‚Äôll be the first. And unless you accept this as a fact, you‚Äôll end up wasting time and energy chasing an impossible dream‚Äù* (Pragmatic Programmer).C√°c b·∫°n c≈©ng t·∫≠p t∆∞ duy ph·∫£n bi·ªán, t·ª©c l√† khi ng∆∞·ªùi ta ƒë∆∞a ra m·ªôt b√†i to√°n hay m·ªôt solution cho b√†i to√°n, c√°c b·∫°n ph·∫£i bi·∫øt ƒë·∫∑t l·∫°i c√¢u h·ªèi, ‚ÄúT·∫°i sao ph·∫£i l√†m c√°ch n√†y m√† kh√¥ng ph·∫£i l√†m c√°ch kia?‚Äù, ‚ÄúC√°ch n√†y c√≥ ∆∞u, nh∆∞·ª£c ƒëi·ªÉm g√¨ so v·ªõi c√°ch kia?‚Äù, ‚ÄúL√†m nh∆∞ th·∫ø n√†y sau n√†y c√≥ d·ªÖ m·ªü r·ªông hay d·ªÖ b·∫£o tr√¨ kh√¥ng?‚Äù, ‚ÄúC√≥ c√°ch n√†o th√¥ng minh h∆°n kh√¥ng?‚Äù ‚Ä¶ ƒë·∫°i lo·∫°i l√† nh·ªØng c√¢u h·ªèi nh∆∞ v·∫≠y.Vi·ªác ƒë·∫∑t c√¢u h·ªèi s·∫Ω gi√∫p b·∫°n hi·ªÉu r√µ h∆°n v·ªÅ v·∫•n ƒë·ªÅ, ng∆∞·ªùi n√≥i chuy·ªán v·ªõi b·∫°n c≈©ng bi·∫øt l√† b·∫°n ƒë√£ hi·ªÉu r√µ v·∫•n ƒë·ªÅ n√™n m·ªõi c√≥ th·ªÉ ƒë·∫∑t c√¢u h·ªèi ng∆∞·ª£c l·∫°i, ch·ª© c·ª© ng·ªìi d·∫° d·∫° r·ªìi l√†m theo m√† kh√¥ng bi·∫øt ƒë√∫ng sai th√¨ l√∫c ƒë√≥ b·∫°n ch∆∞a c√≥ c√°i g·ªçi l√† Critical thinking.M·ªôt v·∫•n ƒë·ªÅ n·ªØa l√† tr∆∞·ªõc khi ƒë·∫∑t c√¢u h·ªèi, c√°c b·∫°n n√™n t·ª± t√¨m hi·ªÉu th·∫≠t k·ªπ v·ªÅ v·∫•n ƒë·ªÅ n√†y, khi n√†o t√¨m kh√¥ng ra ho·∫∑c kh√¥ng bi·∫øt keyword ƒë·ªÉ t√¨m th√¨ m√¨nh m·ªõi n√™n ƒëi h·ªèi ng∆∞·ªùi kh√°c. M√¨nh v·ª´a ti·∫øt ki·ªám th·ªùi gian cho ng∆∞·ªùi kh√°c (Nhi·ªÅu khi h·ªèi ngu qu√° b·ªã ch·ª≠i th√¨ c≈©ng ƒë·ª´ng tr·∫ª tr√¢u m√† g√¢n c·ªï l√™n c√£i), v·ª´a gi√∫p m√¨nh t·∫≠p t√≠nh t·ª± nghi√™n c·ª©u. Sau n√†y ra ƒë·ªùi, s·∫øp giao cho c√°i task, kh√¥ng bi·∫øt ƒë∆∞·ªùng t√¨m hi·ªÉu th√¨ ƒëi h·ªèi ai? Quay l·∫°i h·ªèi th·∫±ng h·ªìi ƒë√≥ h·ªçc chung √†? =]]Sau ƒë√¢y l√† m·ªôt s·ªë k√™nh c√°c b·∫°n c√≥ th·ªÉ tham kh·∫£o: Medium, Stack overflow, Quora. Ngo√†i ra c√≤n c√≥ c√°c group h·ªçc t·∫≠p tr√™n facebook c·ªßa khoa, c√°c b·∫°n n√™n follow c√°c trang n√†y ƒë·ªÉ c·∫≠p nh·∫≠p th√¥ng tin.Ph∆∞∆°ng ph√°p ti·∫øp thu ki·∫øn th·ª©c trong 1 m√¥n h·ªçc: c·ªë g·∫Øng h·ªçc ki·∫øn th·ª©c c∆° b·∫£n (thu·∫≠t to√°n ch·∫°y nh∆∞ th·∫ø n√†o, giao th·ª©c ch·∫°y th·∫ø n√†o, ∆∞u nh∆∞·ª£c ƒëi·ªÉm c·ªßa t·ª´ng lo·∫°i c∆° s·ªü d·ªØ li·ªáu, ‚Ä¶) thay v√¨ t·∫≠p trung nhi·ªÅu v√†o syntax v√† th∆∞ vi·ªán.V√†, ph·∫£i d√†nh th·ªùi gian ƒë·ªçc th√™m s√°ch, h·ªçc tr√™n tr∆∞·ªùng ki·∫øn th·ª©c cho m·ªçi ng∆∞·ªùi l√† nh∆∞ nhau. V·∫≠y c√°i g√¨ ƒë·ªÉ ph√¢n bi·ªát b·∫°n v·ªõi nh·ªØng ng∆∞·ªùi c√≤n l·∫°i? L√† ki·∫øn th·ª©c b·∫°n t·ª± l∆∞·ª£m nh·∫∑t ri√™ng ·ªü ngo√†i l·ªõp h·ªçc. ƒê·ªçc th√™m s√°ch s·∫Ω gi√∫p b·∫°n c√≥ c√°i nh√¨n s√¢u h∆°n v·ªÅ v·∫•n ƒë·ªÅ ƒë√£ h·ªçc tr√™n l·ªõp. Nhi·ªÅu khi th·∫ßy tr√™n l·ªõp n√≥i c≈©ng ch∆∞a h·∫≥n l√† ƒë√∫ng h·∫øt. ƒê·ªçc s√°ch th√¨ ch∆∞a bao gi·ªù l√† v√¥ b·ªï c·∫£ :). S√°ch th√¨ m√¨nh c√≥ list ra m·ªôt v√†i cu·ªën n·ªïi ti√™ng ·ªü m·ª•c 2.Ki·∫øn th·ª©c n·ªÅn ·ªü ƒê·∫°i H·ªçc r·ªìi.N√™n nh·ªõ m√¨nh l√† m·ªôt Engineer ch·ª© kh√¥ng ph·∫£i l√† m·ªôt Coder. 8. ‚ÄúL∆∞∆°ng anh c√≥ ƒë·ªß s·ªëng hem?‚ÄùC√¢u n√†y l√† c√¢u h·ªèi cu·ªëi c√πng sau khi c√°c b·∫°n ƒë√£ moi h·∫øt c√°c kinh nghi·ªám h·ªçc t·∫≠p c·ªßa m√¨nh. M√¨nh ƒë·ªÅu tr·∫£ l·ªùi l√† ‚ÄúHem‚Äù =]]Nh∆∞ th·∫ø n√†o l√† ƒë·ªß? ƒê·ªß s·ªëng th√¥i h·∫£? V·∫≠y th√¨ ch·∫Øc ƒë·ªß s·ªëng r·ªìi v√¨ m√¨nh v·∫´n c√≤n s·ªëng m√† vi·∫øt c√°i b√†i n√†y n√†y.C√≥ m·ªôt c√¢u n√≥i m√¨nh th·∫•y r·∫•t ƒë√∫ng ƒë√≥ l√† Theo ƒëu·ªïi ƒëam m√™, con n·ª£ s·∫Ω theo ƒëu·ªïi b·∫°n ‚ÄúTheo ƒëu·ªïi ƒëam m√™, th√†nh c√¥ng s·∫Ω theo ƒëu·ªïi b·∫°n‚Äú. Khi b·∫°n l√†m vi·ªác h·∫øt m√¨nh v·ªõi nƒÉng l·ª±c c·ªßa m√¨nh th√¨ ng∆∞·ªùi kh√°c s·∫Ω nh·∫≠n th·∫•y n√≥, s·∫Ω ƒë√°nh gi√° ƒë√∫ng nh·ªØng g√¨ b·∫°n ƒë√£ b·ªè ra, v√† b·∫°n s·∫Ω nh·∫≠n l·∫°i ƒë∆∞·ª£c nh·ªØng g√¨ x·ª©ng ƒë√°ng th√¥i.L·∫°i th√™m m·ªôt c√¢u chuy·ªán t·ª´ m·ªôt cu·ªôc ph·ªèng v·∫•n, sau khi h·ªèi m√¨nh m·ª©c l∆∞∆°ng m√¨nh mong mu·ªën nh·∫≠n, ch·ªã nh√¢n s·ª± d·ªÖ th∆∞∆°ng m·ªõi chia s·∫ª v·ªõi m√¨nh r·∫±ng: 1234S·ª± nghi·ªáp m·ªói ng∆∞·ªùi s·∫Ω tr·∫£i qua 3 giai ƒëo·∫°n:M·ªüi t·ªët nghi·ªáp: L√∫c n√†y b·∫°n ho√†n to√†n tr·∫Øng tay, h√£y t·∫≠p trung l∆∞·ª£m nh·∫∑t ki·∫øn th·ª©c, n√¢ng cao tr√¨nh ƒë·ªô, theo ch√¢n ng∆∞·ªùi gi·ªèi ƒë·ªÉ h·ªçc c√°i tr√≠, c√°i t√†i c·ªßa ng∆∞·ªùi ·∫•y. T·∫°o th∆∞∆°ng hi·ªáu c√° nh√¢n ri√™ng c·ªßa m√¨nh, c√°i t√™n c·ªßa b·∫°n.Ki·∫øm ti·ªÅn: Khi ƒë√£ c√≥ trong tay ki·∫øn th·ª©c, b·∫°n b·∫Øt ƒë·∫ßu lao m√¨nh v√†o ki·∫øm ti·ªÅn.S·ªëng v·ªõi ƒëam m√™: L√∫c n√†y ti·ªÅn ƒë·ªëi v·ªõi b·∫°n kh√¥ng c√≤n quan tr·ªçng n·ªØa, c√°i quan tr·ªçng h∆°n c·∫£ l√† ƒë∆∞·ª£c l√†m c√°i b·∫°n th√≠ch, l√†m c√°i b·∫°n ƒëam m√™, l√†m c√°i b·∫°n sinh ra ƒë·ªÉ l√†m. Sau c√πng th√¨ ch·ªã tr·∫£ l·ªùi l√† ‚ÄúM·ª©c l∆∞∆°ng em ƒë∆∞a ra cao qu√° c√¥ng ty ch·ªã hem tr·∫£ n·ªïi‚Äù =]].M√¨nh k·ªÉ c√¢u chuy·ªán tr√™n v·ªõi ƒë√°m b·∫°n th√¢n, ch√∫ng n√≥ n√≥i ƒë·∫•y l√† thuy·∫øt √¢m m∆∞u ƒë·ªÉ t·∫©y n√£o sinh vi√™n ƒë√≥ =]].Ri√™ng m√¨nh th√¨ th·∫•y ch·ªã n√≥i c≈©ng ƒë√∫ng m√†, ‚ÄúFollow your passion and success will follow you.‚ÄùV√†o ng√†y t·ªët nghi·ªáp c√°c b·∫°n s·∫Ω ƒë∆∞·ª£c th·∫ßy tr∆∞·ªüng Khoa cam k·∫øt 100% s·∫Ω t√¨m ƒë∆∞·ª£c vi·ªác sau khi t·ªët nghi·ªáp nh√©, n√™n c√°c b·∫°n kh·ªèi lo th·∫•t nghi·ªáp hay l∆∞∆°ng b·ªïng nh√© (Vi·ªác ƒë√≥ c≈©ng c√≥ th·ªÉ l√† ƒë√°nh vƒÉn b·∫£n d·∫°o kh√¥ng ch·ª´ng :3) 9. K·∫øtN√≥i chung, qu√£ng ƒë∆∞·ªùng ƒê·∫°i H·ªçc m√† m√¨nh ƒë√£ ƒëi qua, v√† c√°c b·∫°n s·∫Ω ƒëi qua c√≥ l·∫Ω l√† qu√£ng th·ªùi gian ƒë·∫πp nh·∫•t c·ªßa ƒë·ªùi ng∆∞·ªùi.L√∫c tr∆∞·ªõc m√¨nh v·∫´n hay nghe c√°c anh kho√° tr√™n n√≥i ‚Äúƒêi l√†m bu·ªìn h∆°n ƒëi h·ªçc‚Äù hay ‚ÄúGi·ªù ∆∞·ªõc g√¨ ƒë∆∞·ª£c quay l·∫°i 1 th√°ng l√∫c h·ªçc Qu·ªëc Ph√≤ng, ch·∫Øc l√∫c ƒë√≥ qu·∫©y banh c√°i TT. Qu·ªëc Ph√≤ng‚Äù. L√∫c ƒë√≥ m√¨nh c≈©ng ‚ÄúD·∫°, em c≈©ng th·∫•y v·∫≠y‚Äù, m√† l√∫c ƒë√≥ ƒë√£ c√≥ tr·∫£i nghi·ªám g√¨ ƒë√¢u m√† D·∫° nh∆∞ ƒë√∫ng r·ªìi =]].B√¢y gi·ªù, ƒë√£ qua r·ªìi c√°i th·ªùi sinh vi√™n ƒë√≥, gi·ªù m·ªõi th·∫≠t s·ª± hi·ªÉu ƒë∆∞·ª£c t√¢m tr·∫°ng c·ªßa ng∆∞·ªùi n√≥i.N√≥i d√†i n√≥i dai, n√≥i t√≥m l·∫°i l√† 4 nƒÉm s·∫Ω tr√¥i qua r·∫•t mau, n√™n c√°c b·∫°n c·ª© s·ªëng ch·∫≠m l·∫°i th√¥i, t·ª´ t·ª´ m√† t·∫≠n h∆∞·ªüng deadline v·ªõi b·∫°n b√®. Sau c√πng nh√¨n l·∫°i th√¨ n√≥ c≈©ng ch·∫≥ng l√† g√¨ c·∫£. NOT A BIG DEAL !!! C√°i m√† c√°c b·∫°n c√≥ ƒë∆∞·ª£c l√† k·ªâ ni·ªám th·ªùi sinh vi√™n ƒë·∫ßy nhi·ªát huy·∫øt :).By the way, m·ªôt ph√∫t m·∫∑c ni·ªám cho s·ª± ƒë√≥ng g√≥p c·ªßa c√°c thanh ni√™n: ƒê·∫°p X√≠ch L√¥ (DevOps &amp; Security Engineer), C·∫£nh Nguy·ªÖn (Back-end Engineer) ƒë√£ g√≥p √Ω ch·ªânh s·ª≠a b√†i vi·∫øt.","link":"/2017/09/25/Chuyen-o-Dai-Hoc-Phan-1/"},{"title":"Create and Distribute Private Libraries with Cocoapods","text":"CocoaPods is a dependency manager for Swift and Objective-C projects. This tool not only allows us to easily integrate those dependencies but also allows us to create our own libraries. In this post I‚Äôm going to guide you how to create a private library and distribute it to your private team without publishing the library. Init repositoriesGo to Github or Bitbutket, then create two repositories. One for our source code that is shared between our team, the other one for Podspec, which defines all the information about that Pod. Image 1. Create Github repo to store our source code Image 2. Create Github repo to store our Podspec files Following the instructions on Github page, it guides you how to add your project to these repositories. 123456$ echo \"# MyAwesomeKit-Spec\" &gt;&gt; README.md$ git init$ git add README.md$ git commit -m \"first commit\"$ git remote add origin git@github.com:uynguyen/MyAwesomeKit-Spec.git$ git push -u origin master Create our own libraryOpen XCode and create a new Cocoa Touch Framework named MyAwesomeKit. After that, create a simple class called HaHaHaManager, this class defines our public methods for clients. To make it easier, I define a simple method, which takes 2 numbers as arguments then return their addition: 123456public class HaHaHaManager { public init() { } public func awesomeFunction(a: Int, b: Int) -&gt; Int { return a + b }} Note: Since we are creating a public Framework, we have to overide the default constructor of the HaHaHaManager class, make it become public. Otherwise, our clients who use this Framework can not create an instance of this class because the default scope of classes in Swift is internal. After then, push our code to the repository that we created at the first step. Make sure you add a tag as a version for this commit. 1234$ git add .$ git commit -m \"Our first commit\"$ git tag MyAwesomeKit_1.0.0$ git push -u origin master --tags Add your Private Repository to your CocoaPods InstallationUse the following command to create your new private repository to your CocoaPods 1$ pod repo add REPO_NAME SOURCE_URL 1$ pod repo add MyAwesomeKit https://github.com/uynguyen/MyAwesomeKit Make sure you have the correct access rights to the repository. You can config ssh to access the repo via ssh key. See also: Generating a new SSH key and adding it to the ssh-agentTo check if your installation is successful, use the following commands: 12$ cd ~/.cocoapods/repos/MyAwesomeKit$ pod spec lint . --allow-warnings This command is used to validate specifications. --allow-warnings flag indicates that we skip all warnings when validate the Pod file. (Missing some options such as lisence, author or description). Generate our Podspec fileType the command to generate our Podspec file. This file contains all information about our code, including git repository, the version of the library, dependencies, etc. 1$ pod spec create MyAwesomeKit You will see something like this 123456789101112131415Pod::Spec.new do |s| s.name = \"MyAwesomeKit\" s.version = \"1.0.0\" s.summary = \"An awesome KIT can do anything for you\" s.homepage = \"https://github.com/uynguyen/MyAwesomeKit\" s.author = { \"Uy Nguyen\" =&gt; \"uynguyen.itus@gmail.com\" } s.source = { :git =&gt; \"git@github.com:uynguyen/MyAwesomeKit.git\", :tag =&gt; \"MyAwesomeKit_#{s.version}\" } s.platform = :ios, '8.0' s.requires_arc = true s.dependency 'AFNetworking', '~&gt; 3.1.0' [1] s.source_files = \"MyAwesomeKit/**/*.{swift}\" [2] s.frameworks = 'UIKit', 'CoreText' [3] s.library = 'z', 'c++' s.module_name = 'MyAwesomeKit'end Here‚Äôs what‚Äôs going on: 1: Your other Podspecs depenencies. For more than one dependency, add new line to define it. 2: The source files that will be included. (Replace it by .m, .mm, .c or .cpp if you need) 3: The framewords that are linked with your library. For other options, please refer to Podspec Syntax Reference Push to Spec Repo 1$ pod repo push MyAwesomeKit MyAwesomeKit.podspec --allow-warnings The structure of your folder will be like 12345.‚îú‚îÄ‚îÄ MyAwesomeKit-Spec ‚îî‚îÄ‚îÄ MyAwesomeKit ‚îî‚îÄ‚îÄ 1.0.0 ‚îî‚îÄ‚îÄ MyAwesomeKit.podspec Whenever you update the library, you have to run the update command to update your Pod repos 1$ pod repo update Use our awesome KitIt‚Äôs time to use our powerful Kit. Open XCode and create new project named MyAwesomeApp. After that, type the below command to init the Pod file 1$ Pod init Open the Pod file, add the following code to install our library. 123456789101112131415161718# Uncomment the next line to define a global platform for your projectsource 'git@github.com:uynguyen/MyAwesomeKit-Spec.git'source 'https://github.com/CocoaPods/Specs.git'platform :ios, :deployment_target =&gt; '8.0'target 'MyAwesomeApp' do # Comment the next line if you're not using Swift and don't want to use dynamic frameworks use_frameworks! pod 'MyAwesomeKit', '1.0.0' # Pods for MyAwesomeApp target 'MyAwesomeAppTests' do inherit! :search_paths # Pods for testing end target 'MyAwesomeAppUITests' do inherit! :search_paths # Pods for testing endend Let see our results (Pray and hope to it works well) ConclusionWe have just published our first private Pod to our team. From now on, our team can use this library privately. Moreover, it‚Äôs easy to update and distribute the library when it gets upgrade. Thanks to CocoaPod!If you have any questions or comments about the post, feel free to kick an email to me. References[1] Private Pods","link":"/2017/09/25/Create-and-Distribute-Private-Libraries-with-Cocoapods/"},{"title":"Design patterns","text":"","link":"/2018/06/01/Design-patterns/"},{"title":"Documenting a Software Architecture","text":"It‚Äôs clear that documenting architectures is one of the most boring important tasks of Software Engineering. A two-sided activityThere are many good reasons why we have to document our software projects: Other members can understand and evaluate the design of this software. We can understand what we implemented when we return to it after a certain of time. We can do analysis on the design to evaluate the performance of this system, prevent errors occur before we start the implementation phase. Documenting architectures also have some downsides, like: The documents will gradually out of date with the code. Keeping the architecture documentscurrent is often an overlooked activity, especially under the pressures in a project. Documenting is time consuming and expensive. So when should we document software architectures?There are a lot of factors to consider if we need to document or not. Projects with little prospect of a long life probably don‚Äôt need a lot of documentation. The other factor to consider when documenting is the needs of project stakeholders, including the various roles like developers, testers, managers, etc. In a small team, the documentation can be minimal and can be replaced by interpersonal communication, it saves our time. In a large team, however, the documentation becomes more important for describing the system, especially companies that work in multiple countries and in many offices. Therefore, it is important to think carefully before documentation because it takes time to develop and maintain along with projects.In this post, I will introduce you to the most popular language to document software architectures: Unified Modeling Language. Unified Modeling Language (UML)UML is a modeling language of Software Engineering. It provides a standard way to visualize the design of a system or an application. UML includes both structural and behavioral diagrams for representing a software system: A structual diagram describes static architectures of its system. A behavioral diagram shows the interactions between entities inside a system. Note that I have never used Component diagrams, Package diagram, Deployment diagrams, Profile Diagram, Composite Structure diagrams, Communication diagrams, Interaction Overview diagrams and Timing diagrams so I‚Äôm going to skip these diagrams in this post. Structual diagramsClass diagramsA class diagram describes the structure of a system by showing relationships between its classes. It also shows attributes and methods of each class. The main purpose of class diagrams is to get the general overview of the system. Where vis = visibility Syntax Visibility type + Public If a variable or a method is static, it has to be underlined. # Protected - Private ~ Package The following lines introduce some major replationships in Class diagrams. Mark Meaning Implementation Class B implement the behaviors that are defined in Class A. Inheritance Class B has IS-A relationship with class A, or we can say Class B is a type of Class A. Dependency It exists between two elements if changes to the definition of one element may cause changes to the other. Association A binary association (with two ends) is normally represented as a line. It indicates that Class A contains one or more properties belonged to class B, or vice versa. Aggregation It is a special case of Association. We can say Class A is aggregated with Class B if Object X as an instance of class A is destroyed but Object Y as an instance of class B is still exist. Here, the lives of both Employee and Department are independent of each other. Employees may exist without a department. Composition It is a special case of Aggregation but it is stronger than Aggregation relationship. If Object X as an instance of class A is destroyed, the Object Y as an instance of class B will also be destroyed. We also say Composition is HAS-A relationship. Here, If we delete the verhicle object then all the engines are automatically deleted. The engines do not have their independent life cycle, it depends on the verhicle object‚Äôs life. A class diagram example. Instance diagrams (Object diagrams)Basically, an instance diagram is similar to the class diagram which it depends upon. However, an instance diagram is just a snapshot of the system at some point in time, and it shows what values those objects contain at this specified time. Instance diagrams are often used to make prototypes of a system, and to get more understand the system in a practical view.Symbols and notations of instance diagrams can be utilized in class diagrams. Example Transfer from a class diagramt to an instance diagram. Behavioral diagramsActivity diagramsAn activity diagram shows the flow from one activity to another activity (An activity is a function performed by the system). Note that messages are not included in activity diagrams.An activity diagram is often used to describe the high level of the system, mainly for business users or non-technical persons. It can also describe the steps in a use case diagram.Basic symbols and components: Basic Symbol Meaning Start point It represents the initial action state. Activity It represents an activity of the process. Condition Use this symbol when an activity requires a decision prior to moving on to the next activity Synchronization It indicates that multiple acitivies are performed synchronously. Time event This refers to an event that stops the flow for a time. Interrupting Edge An event that interrupts the flow. End Point It represents the final action state. Sequence diagramsA sequence diagram shows how objects and components interact with each other to complete a function.Basic symbols and components: Basic Symbol Meaning Actor It shows entities that interact with the system. Object It represents an object in UML. Activation box It represents the time needed to complete a task. Loop It indicates loop statements. Alternative It indicates condition statements. Parallel Each task in the frame represents a thread of execution done in parallel. Synchronous message The sender must wait for a response to a message before it continues. The diagram should show both the call and the reply. Asynchronous message The sender does not need to wait for a response to a message before it continues. Return message Messages are replied to calls. Delete object It indicates that the object will be detroyed. State Machine diagramsThe main purpose of state machine diagrams is to show the state changing of an object during its lifetime. Basic Symbol Meaning State A state represents a situation during the life of an object. Initial State The object‚Äôs initial state. Final State The object‚Äôs final state. The following example shows the transition state of an order. Use Case diagramsAn use-case diagram shows how the users or other external applications interact with the system. It also shows the scope of the system. Basic Symbol Meaning Actors They represent the users or external systems that interact with our system. Use cases They represent the different uses that a user might have. Associations There are two types of associations: Actor-use case and use case - use case. an Actor - use case association indicates which actors are associated with which use cases. An Use case - Use case association shows the relationship of two use cases: - Include: A use case ‚Äúinclude‚Äù another if it is a required action by the use case. - Extend: A use case ‚Äúextend‚Äù another if it is an optional use of the use case. - Generalization: The use case inherits the structure, behavior, and relationships of another. Have you ever heard about Business Process Model and Notation (or BPMN)?‚ÄúBusiness Process Model and Notation (BPMN) is a standard for business process modeling that provides a graphical notation for specifying business processes in a Business Process Diagram (BPD).‚Äù (Wiki).The main objectives of BPMN are: To provide a set of standard notation that is understandable by business stakeholders. Often used to defined business logic because it has more complete concepts of events and it supports asynchronous message exchanges, which are important in business processing. BPMN is similar to activity diagram from UML. An Example of BPMN. A shopping process described by using BPMN (Source from Google image) ## Differences between UML and BPMN, which one to use? We use BMPN to describe the system on a high level, not care too much about computational details. In contrast, UML is used to define the details of this system, how is it constructed? how is it organized? how does it interact with other components? how is data processed? etc. ConclusionIn this post, I showed you the general ideas of some popular UML diagrams, and showed you the main difference between the UML and the BPMN. Of course, there‚Äôre still a lot of purposes and notations of those diagrams that I can not list out here because of the scope of this post.If you are interested in UML, you can download the full document of UML here (The latest version of UML is 2.5.1).Thanks for reading. References[1] Essential Software Architecture (2011, Springer-Verlag Berlin Heidelberg)Ian Gorton (auth.), Chapter 8 Documenting a Software Architecture.","link":"/2018/04/11/Documenting-a-Software-Architecture/"},{"title":"Drag and Drop","text":"","link":"/2019/09/02/Drag-and-Drop/"},{"title":"Grand Central Dispatch in Swift","text":"Grand Central Dispatch, or GCD for short, is a low-level C APIs for managing concurrent tasks. It helps us improve our app performance by executing a block of code in reasonable threads, like perform computationally expensive tasks in the background. GCD provides several options for running tasks such as synchronously, asynchronously, after a certain delay, etc.In this post I will explain more details about GCD and how it works, also provide some interesting points when we work with GCD. Let‚Äôs start. IntroductionAt the heart of GCD are dispatch queues which are pools of threads managed by GCD. Apple creates GCD to make developers don‚Äôt need to care too much about these queues, they just simply dispatch a block of code to a given queue without caring about which thread is used. GCD ConceptsConcurrencyConcurrency is achieved when more than two tasks are executed at the same time. In fact, the word ‚ÄúConcurrency‚Äù does not exactly mean ‚Äúat the same time‚Äù or ‚Äúhappen in parallel‚Äù. Under the hook, CPU gives every task a certain time slice to do its works. For example, if there are 5 tasks to be executed in one second, with the same priority, the OS will divide 1,000 milliseconds by 5 (tasks) and will give each task 200 milliseconds of the CPU time. As a result, they will appear to have been executed concurrently. Serial queue and concurrent queueA serial queue will execute its tasks in a first-in-first-out (FIFO) fashion. It‚Äôs mean that they can only execute one block of code at a time. They do not run on the main thread, therefore, they do not block the UI.In contrast, a concurrent queue allows to execute multiple tasks in parallel. It means tasks can finish in any order and you won‚Äôt know the time it will take. Synchronously (sync) and asynchronously (async) methodsWhen you dispatch a task to a queue, you determine whether the block run synchronously or asynchronously. There are some main differences between the two techniques: A synchronous method returns control to the caller only after the task is completed whereas an asynchronous method returns control to the caller immediately. Since asynchronous methods return control immediately so they don‚Äôt block the current thread. Note that the world ‚Äúsynchronous‚Äù does not mean the program have to wait for the code to finish before continuing. It just means that the concurrent queue will wait until the task has finished before it executes the next block of code on the queue.The code below demonstrates how to use async and sync executions.1234567891011121314151617DispatchQueue.global().sync { [1] print(\"A\") DispatchQueue.global().async { for i in 0...5 { print(i) } }}DispatchQueue.global().sync { [2] print(\"B\") DispatchQueue.global().async { for i in 6...10 { print(i) } }} Generally, we can not predict the output when we run the code above because everytime we run the program, the numerous of different outputs will be printed. We can only say that ‚ÄúB‚Äù will always be printed after ‚ÄúA‚Äù as the caller need to wait for the block [1] returns control so that it can execute the next block [2].If we edit these inner blocks to sync, we guarantee that the output will always be A 0 1 2 3 4 5 B 6 7 8 9 10.Three main types of queuesThere are three main types of queues in GCD: Main queue: Tasks are dispatched to this queue will be performed on the main thread, where UI-related works are called. The Main queue is a serial queue. Important note, the sync method can not be called on main thread because it will block the thread completely and lead the application to deadlock. Therefore, all tasks submitted to the main queue must be submitted asynchronously. 1234567override func viewDidLoad() { super.viewDidLoad() let mainQueue = DispatchQueue.main mainQueue.sync { // -&gt; This code will lead to Deadlock print(\"Inner block called\") }} Global queues: They are concurrent queues and are shared by the system. We use global queues for any task that does not involve the UI. For example, downloading an image from the internet then display it to the user after it is downloaded, fetching database from a server, etc.When we work with global queues, we don‚Äôt specify the priority but we use a Quality of Service (QoS) to help the GCD determine the priority of the tasks. It is important to keep in mind that apps use various resources like CPU, memory, network interface, etc. Thus, we should choose the right QoS of the queue in order to remain responsive and efficient of the app. The OS will base on the given QoS to make smart decisions about when and where to execute them.There are four types of QoS: User-interactive: This indicates that the tasks need to be executed immediately in order to remain responsive on UI. We use it for UI updates or performing animations. User-initiated: Work that the user has initiated and requires immediate results (In a few seconds or less). We use it to perform an action when users click something in the UI. Utility: the tasks may take some time to complete and does not require an immediate result (Takes a few seconds to a few minutes) such as downloading data. Background: This represents tasks that the user is not directly aware of. Normally, we use it for fetching data or any tasks that don‚Äôt require user interaction. Custom queues: When you create a custom queue, you can specify which type of queue it is (Serial or concurrent). By default, they‚Äôre serial queues. DeadlockThe word Deadlock refers to a situation in which a set of different threads sharing the same resource are waiting for each other release the resource to finish its tasks.When working with the GCD, if we do not fully understand the GCD‚Äôs concepts, we may create a deadlock in our code. For example, the code below is making a deadlock. 123456789func deadLock() { let myQueue = DispatchQueue(label: \"myLabel\") myQueue.async { myQueue.sync { print(\"Inner block called\") } print(\"Outer block called\") } } First, we create a custom queue with a given label. Then we dispatch asynchronously a block of code calling another block of code synchronously. It is clear that the inner and the outer blocks are executing on the same queue. By default, a custom queue is serial so the inner block will not start before the outer block finishes. On the other hand, the outer block can not finish because the inner block is holding the control of the current thread (Synchronously). Hence, a deadlock occurs.There are two ways to fix the problem. The first one is changing the type of the queue to concurrent. By doing this way, we ensure that the inner block does not have to wait for the outer block has finished so that it can start. 1let myQueue = DispatchQueue(label: \"myLabel\", attributes: .concurrent) The second one is changing the inner block to async. This time, the outer block will not wait for the inner block has completed so that it can start. 123456myQueue.async { myQueue.async { print(\"Inner block called\") } print(\"outer block called\")} There is a recommend on Apple document about Deadlock at Dispatch queues and thread safety chapter&quot;Do not call the dispatch_sync function from a task that is executing on the same queue that you pass to your function call. Doing so will deadlock the queue. If you need to dispatch to the current queue, do so asynchronously using the dispatch_async function.&quot; LivelockThere is another lock concept besides deadlock called Livelock. Unlike deadlock, the livelock does not block the current thread. They‚Äôre just unable to make further progress. Or to more accurately, livelock is ‚Äúa situation in which two or more processes continuously change their states in response to changes in the other process(es) without doing any useful work‚Äù.There is a good human example of livelock on StackOverflowA husband and wife are trying to eat soup, but only have one spoon between them. Each spouse is too polite, and will pass the spoon if the other has not yet eaten.There are other types of lock when we work with concurrency like bound resources, mutual exclusion, starvation. Because of the scope of this post, I will not explain all of them here. Please refer to other sources for more details. Important notes On iPhones, discretionary and background operations, including networking, are paused when Low Power Mode is enabled. When using Xcode 9 with iOS 11, a warning will be emitted when a user-interface object is accessed from a non-main thread. The user interactive priority should be rare in your program. If everything is high priority, nothing is. ConclusionIn this post, I showed you some interesting points about GCD in Swift. In next post, we will discuss more about other advanced concepts of concurrent programming like DispatchGroup, Operation Queue, Group Tasks, etc. Then we will implement a tiny project to mix them together.If you have any comments, don‚Äôt be hesitate to contact me. References[1] Apple‚Äôs documentation: Concurrency Programming Guide[2] iOS 8 Swift Programming Cookbook by O‚ÄôReilly, Chap.7: Concurrency and Multitasking.","link":"/2018/01/04/Grand-Central-Dispatch-in-Swift/"},{"title":"Integrate Google Drive to iOS app","text":"At Fossil, I‚Äôve had the chance to experiment with Google Drive integration, as a cloud bases storage. The main advantage of using Google Drive is to share with other members easily, with a good web-based UI to modify the contents of folders, and it‚Äôs free. However, I struggled when trying to make Google Drive work due to lack of documents and articles related to Google Drive APIs, especially in Swift. Additionally, the code and examples on Google‚Äôs sites are out of date. Therefore, I decided to write this article with a hope of saving your time when you want to integrate Google Drive to your apps. Let‚Äôs get started. Create your app and Google API accessIn order to use Google APIs, firstly we have to go to Google Console Dashboard to create a project. So head to Google cloud console, click the drop-down menu to create a new project.Your Google Drive API is disabled by default when you create new projects. To enable Google Drive API manually, click on ‚ÄúAPIs &amp; Services‚Äù item on the left bar side, it will lead you to another page where you can enable Google services for your apps.Click ‚ÄúEnable APIs and services‚Äù button, then type to search for ‚ÄúGoogle drive‚Äù, next select Google Drive from results, finally click ‚ÄúEnable‚Äù to activate the app.That‚Äôs all you need to create an app using Google API. Add credential for your iOS appCredentials allow your iOS to access your enabled APIs. Click to ‚ÄúCredentials‚Äù button on the left sidebar to add your iOS app. Next, input your app information including your app name and bundle id, please note that you need to type exactly the bundle id, otherwise it will not work.After creating new credential successfully, you should be able to download the plist file that will contain the keys necessary for setting up your Xcode project. Keep this file in a safe place, we will use it in the next step. 1234567891011121314&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\"&gt;&lt;plist version=\"1.0\"&gt;&lt;dict&gt; &lt;key&gt;CLIENT_ID&lt;/key&gt; &lt;string&gt;YOUR_CLIENT_ID&lt;/string&gt; &lt;key&gt;REVERSED_CLIENT_ID&lt;/key&gt; &lt;string&gt;YOUR_REVERSED_CLIENT_ID&lt;/string&gt; &lt;key&gt;PLIST_VERSION&lt;/key&gt; &lt;string&gt;1&lt;/string&gt; &lt;key&gt;BUNDLE_ID&lt;/key&gt; &lt;string&gt;com.example&lt;/string&gt;&lt;/dict&gt;&lt;/plist&gt; Project configurationGoogle APIs Client Library is a library written by Google for accessing Google APIs. Go ahead and add the following library to your Pod file. 12pod 'GoogleAPIClientForREST/Drive', '~&gt; 1.2.1'pod 'GoogleSignIn', '~&gt; 4.1.1' You will find YOUR_REVERSED_CLIENT_ID and YOUR_CLIENT_ID in the client configuration plist file that you downloaded previously. Select your target project, go to ‚ÄúInfo‚Äù tab, add a new item at the ‚ÄúURL Types‚Äù section, then input YOUR_REVERSED_CLIENT_ID at the ‚ÄúURL Schemes‚Äù box.In case you don‚Äôt know what URL Schemes use for, every each item in the URL Schemes section allows you to define a custom URL scheme for your app. For example, your app might let users tapping a custom URL in an email to launch your app in a specified context. By default, Apple supports common schemes associated with system apps like mail, sms, facetime, etc. For more information, please refer to Defining a Custom URL Scheme for Your AppIf you don‚Äôt add YOUR_REVERSED_CLIENT_ID as a custom URL scheme, your app will get the following crash when trying to authorize with Google API. So make sure you don‚Äôt miss this important step.Next, open the AppDelegate.swift file, add your client id to Google Sign In instance. 1234func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -&gt; Bool { GIDSignIn.sharedInstance().clientID = \"YOUR_CLIENT_ID\" return true} Then, open your ViewController where you allow user to sign in with their Google account and implement the two delegate GIDSignInUIDelegate and GIDSignInDelegate from Google Sign in. 123456789101112131415extension ViewController: GIDSignInDelegate { func sign(_ signIn: GIDSignIn!, didSignInFor user: GIDGoogleUser!, withError error: Error!) { if let _ = error { } else { print(\"Authenticate successfully\") } } func sign(_ signIn: GIDSignIn!, didDisconnectWith user: GIDGoogleUser!, withError error: Error!) { print(\"Did disconnect to user\") }}extension ViewController: GIDSignInUIDelegate {} Finally, assign Google sign in delegate to your view controller. 123456private func setupGoogleSignIn() { GIDSignIn.sharedInstance().delegate = self GIDSignIn.sharedInstance().uiDelegate = self GIDSignIn.sharedInstance().scopes = [kGTLRAuthScopeDrive] GIDSignIn.sharedInstance()?.signInSilently()} You might notice the GIDSignIn.sharedInstance().scopes line of code. This line of code defines which permissions the user grants for your app to access their data when authenticating. In this case, we use the kGTLRAuthScopeDrive scope that allows our app to view and manage all the files in the user‚Äôs Google Drive, including team drive. The signInSilently method will attempt to sign in a previously authenticated user silently. If you do all the above steps properly, you should be able to authenticate your app with Google API. ![](/Post-Resources/GoogleDrive/GoogleSignIn.png \"Google Sign in\") ![](/Post-Resources/GoogleDrive/GrantPermission.png \"Grant permission\") Common APIsWork with ‚ÄúMy Drive‚ÄùSearching12345678public func search(_ name: String, onCompleted: @escaping (GTLRDrive_File?, Error?) -&gt; ()) { let query = GTLRDriveQuery_FilesList.query() query.pageSize = 1 query.q = \"name contains '\\(name)'\" self.service.executeQuery(query) { (ticket, results, error) in onCompleted((results as? GTLRDrive_FileList)?.files?.first, error) }} Listing12345678 public func listFiles(_ folderID: String, onCompleted: @escaping (GTLRDrive_FileList?, Error?) -&gt; ()) { let query = GTLRDriveQuery_FilesList.query() query.pageSize = 100 query.q = \"'\\(folderID)' in parents and mimeType != 'application/vnd.google-apps.folder'\" self.service.executeQuery(query) { (ticket, result, error) in onCompleted(result as? GTLRDrive_FileList, error) }} Uploading123456789101112131415private func upload(_ folderID: String, fileName: String, data: Data, MIMEType: String, onCompleted: ((String?, Error?) -&gt; ())?) { let file = GTLRDrive_File() file.name = fileName file.parents = [folderID] let params = GTLRUploadParameters(data: data, mimeType: MIMEType) params.shouldUploadWithSingleRequest = true let query = GTLRDriveQuery_FilesCreate.query(withObject: file, uploadParameters: params) query.fields = \"id\" self.service.executeQuery(query, completionHandler: { (ticket, file, error) in onCompleted?((file as? GTLRDrive_File)?.identifier, error) })} Downloading12345678910111213public func download(_ fileItem: GTLRDrive_File, onCompleted: @escaping (Data?, Error?) -&gt; ()) { guard let fileID = fileItem.identifier else { return onCompleted(nil, nil) } self.service.executeQuery(GTLRDriveQuery_FilesGet.queryForMedia(withFileId: fileID)) { (ticket, file, error) in guard let data = (file as? GTLRDataObject)?.data else { return onCompleted(nil, nil) } onCompleted(data, nil) }} Deleting123456789public func delete(_ fileItem: GTLRDrive_File, onCompleted: @escaping ((Error?) -&gt; ())) { guard let fileID = fileItem.identifier else { return onCompleted(nil) } self.service.executeQuery(GTLRDriveQuery_FilesDelete.query(withFileId: fileID)) { (ticket, nilFile, error) in onCompleted(error) }} Work with ‚ÄúTeam Drive‚ÄùThe only thing we need to do in order to work with ‚ÄúTeam Drive‚Äù is to set the corpora param of the query to teamDrive. By default, the user corpora is applied. That means the query only applied to the folders onwed by the user. By setting to teamDrive, we indicate that the query will affect to team drive of the user. We can combine multiple corpora in a single query if you need to do so. Final thoughtsGoogle Drive is an ideal storage to integrate with our applications. In this article, we covered how to config Google Drive API and how to execute common APIs. I hope you learned something today.You can find all the source code demo on my Github üôÇ References[1] Google Developer https://developers.google.com/drive/api/v3/about-sdk","link":"/2019/02/15/Integrate-Google-Drive-to-iOS-app/"},{"title":"Integrate Google Sign In on MacOS App in Swift","text":"As an iOS developer, you might have chances to write applications on Mac os. And sometimes, your applications require users to authenticate before they can use your app. Enabling Google Sign in helps you save a lot of time to implement authentication flow. Unfortunately, it is a lack of documentation on how to integrate Google Sign in on Macos app, particularly in Swift. I once had a chance to implement this feature to my app. Now I want to share with you how we can do it. Let‚Äôs get started. Setting upLet‚Äôs first create your mac os application, name whatever you like. Then, run pod init command to init the Pod workspace.Next, add the following line to your Pod file. 123456use_frameworks!pod 'GTMAppAuth' # GTMAppAuth is an alternative authorizer to GTMOAuth2, supports for authorizing requests with AppAuth.pod 'SwiftyJSON' # JSON parserpod 'PromiseKit' # Make async requestspod 'Kingfisher' # Cached imagepod 'SnapKit' # Autolayout Then run pod install to download all these dependencies. Get an OAuth client IDBefore getting started to the example, firstly go-ahead to Google Console and create a new project. Then press the ‚ÄúCreate credentials‚Äù &gt; ‚ÄúOAuth client ID‚Äù &gt; ‚ÄúOther‚Äù application type &gt; Follow the instructions to get your credentials.After you create the OAuth client ID, take note of the client ID and the client secret, which you will need to configure Google Sign-in in your app. You can optionally download the configuration file containing your project information for future reference. Config projectMake sure that you configure your app to allow incoming and outcoming network by going to Signing &amp; Capabilities &gt; App Sanbox &gt; Check both Incoming Connections &amp; Outcoming Connections. If you do not do that, you will get the following error because your app does not have permission to perform requests. 122019-12-11 22:22:49.472046+0700 GoogleSignInDemo[3955:65750] Metal API Validation Enabled2019-12-11 22:22:51.444494+0700 GoogleSignInDemo[3955:66166] dnssd_clientstub ConnectToServer: connect() failed path:/var/run/mDNSResponder Socket:11 Err:-1 Errno:1 Operation not permitted Next, open the Info.plist and add a new value for CFBundleURLTypes, which reverses DNS notation form of your client ID. Safari will use this DNS notation to open your app after authentication process is performed successfully. 1234567891011&lt;key&gt;CFBundleURLTypes&lt;/key&gt;&lt;array&gt; &lt;dict&gt; &lt;key&gt;CFBundleTypeRole&lt;/key&gt; &lt;string&gt;Editor&lt;/string&gt; &lt;key&gt;CFBundleURLSchemes&lt;/key&gt; &lt;array&gt; &lt;string&gt;com.googleusercontent.apps.REPLACE_BY_YOUR_CLIENT_ID&lt;/string&gt; &lt;/array&gt; &lt;/dict&gt;&lt;/array&gt; Making authorizationLet‚Äôs first create our service object, class GoogleSignInService, which handles all requests related to Google Sign in. It also contains all of your project‚Äôs credentials. 123456789class GoogleSignInService: NSObject, OIDExternalUserAgent { static let kYourClientNumer = \"REPLACE_BY_YOUR_CLIENT_ID\" static let kIssuer = \"https://accounts.google.com\" static let kClientID = \"\\(Self.kYourClientNumer).apps.googleusercontent.com\" static let kClientSecret = \"REPLACE_BY_YOUR_CLIENT_SECRET\" static let kRedirectURI = \"com.googleusercontent.apps.\\(Self.kYourClientNumer):/oauthredirect\" static let kExampleAuthorizerKey = \"REPLACE_BY_YOUR_AUTHORIZATION_KEY\" // The rest omitted} Discover Google service‚Äôs endpoint and define a request. 1234567891011OIDAuthorizationService.discoverConfiguration(forIssuer: URL(string: Self.kIssuer)!) { // The rest omitted let request = OIDAuthorizationRequest(configuration: config, clientId: Self.kClientID, clientSecret: Self.kClientSecret, scopes: [OIDScopeOpenID, OIDScopeProfile, OIDScopeEmail], redirectURL: URL(string: Self.kRedirectURI)!, responseType: OIDResponseTypeCode, additionalParameters: nil) // The rest omitted} Take a look at the scopes param, this param defines which user‚Äôs info your app can access to. Google Sign In offers 5 different scopes, including: NSString *const OIDScopeOpenID = @‚Äùopenid‚Äù; NSString *const OIDScopeProfile = @‚Äùprofile‚Äù; NSString *const OIDScopeEmail = @‚Äùemail‚Äù; NSString *const OIDScopeAddress = @‚Äùaddress‚Äù; NSString *const OIDScopePhone = @‚Äùphone‚Äù; You can select which ones fit your app‚Äôs requirements.Finally, start the authentication process. 1234567OIDAuthState.authState(byPresenting: request, externalUserAgent: self, callback: { (state, error) in guard error == nil else { seal.reject(error!) return } // You got the OIDAuthState object here}) After the authentication process performs successfully, you will get an OIDAuthState object which will be used as a param to init the GTMAppAuthFetcherAuthorization object.Normally, you should save this GTMAppAuthFetcherAuthorization object to a key chain and re-use it for the next REST API calls. 123456private func saveState() { // The rest omitted if auth.canAuthorize() { GTMAppAuthFetcherAuthorization.save(auth, toKeychainForName: Self.kExampleAuthorizerKey) }} Making requestsAfter saving the service object to the key chain, you now can retrieve it to make any requests. I will make a request to fetch the current user profile. 12345678910111213func loadProfile() -&gt; Promise&lt;GoogleSignInProfile&gt; { return Promise { (seal) in // The rest omitted if let url = URL(string: \"https://www.googleapis.com/oauth2/v3/userinfo\") { let service = GTMSessionFetcherService() service.authorizer = auth service.fetcher(with: url).beginFetch { (data, error) in // Process the data here // data = [\"locale\", \"family_name\", \"given_name\", \"picture\", \"sub\", \"name\", emai] } } }} Troubleshoot After logging in, if your Safari can not redirect back to your app. Just clean up your project (Shift + Cmd + K) then run again. Other web browsers (Chrome, Firefox, etc) can not open your app so that make sure you launch the sign-in web on Safari.1NSWorkspace.shared.open([url], withAppBundleIdentifier: \"com.apple.Safari\", options: .default, additionalEventParamDescriptor: nil, launchIdentifiers: nil) { Final thoughtsYou can find the completed demo hereNow you can use Google Sign in inside your macOS to reduce your efforts for authentication. To get the full source code, please download via the Github link.In case you have any problems do not hesitate to contact me.","link":"/2019/12/11/Integrate-Google-Sign-In-on-MacOS-App-in-Swift/"},{"title":"Memory leak","text":"As a Software Engineer, you definitely have heard about the Memory leak concept. Memory leak is a situation where blocks of memory are located by the program remain in the memory despise they are no longer referenced. Leaks waste space by filling up pages of memory with inaccessible data. As a result, the size of memory using in your apps keep increasing, affect the user experiences and the performance of your app. Even worse, your app will be crashed randomly because a process will be terminated by the system if it consumes too much memory.In this topic, we will discuss how the memory is managed in iOS and how to use the memory efficiently. Read on. Automatic Reference CountingARCMost of the modern programming languages (such as Java, C#, Go, etc.) have a built-in process which automatically finds unused objects and deletes them to free up memory. The primary purpose of this technology is to reduce memory leak and let programmers focus on their business logic without caring too much about memory management.As a high-level programming language, Swift also has Automatic Reference Counting (ARC) to manage memory using in our apps. How ARC worksWhenever we create a new instance of a class, ARC will allocate a space of memory to store information about that instance. This memory holds information about the type of the instance, any stored properties associated with that instance. Especially, this memory holds the information of how many properties, constants, and variables are currently referring to that instance. ARC will never deallocate that instance as long as at least one active reference to that instance still exists.Once the number of objects referring to that instance comes to zero, ARC will deallocate that instance and free the memory held by that instance.By applying this technique, Apple ensures that class instances do not keep holding space in memory when they are no longer needed, generally avoids the problem of memory leaks. Memory leakIn most cases, ARC does its job well. We don‚Äôt usually worry about memory management. However, leaks still happen in iOS by accident. This is when two objects hold strong references to one another so that each object keeps the other one from being deallocated. Let‚Äôs take an example, there are two classed named Person and Car. 1234567891011121314151617181920212223242526272829class Person { let name: String var car: Car? lazy var greeting: () -&gt; String = { return \"Hello, my name is \\(self.name). I have \\(self.car?.name ?? \"no cars\")\" } init(name: String) { self.name = name } deinit { print(\"Person \\(self.name) is being destroyed.\") }}class Car { let name: String var owner: Person? init(name: String) { self.name = name } deinit { print(\"car \\(self.name) is being destroyed.\") }} Every Person instance has a name property of type String and an optional Car property that initially nil because a person may not always have a car.Likewise, every Car instance has a name property of type String and an optional Person property that initially nil because a car may not always have an owner.Next, let‚Äôs define two variables called Foo and BMW of Person and Car classes, respectively. Now, we link the two instances together so that the person has a car, and the car has an owner. 123456# Main blockvar foo: Person? = Person(name: \"Foo\")var car: Car? = Car(name: \"BMW\")foo!.car = carseat!.owner = fooprint(foo!.greeting()) The next code snippet will release these two instances by setting them to nil. 12foo = nilseat = nil As you might know, once setting a variable to nil, it means there are no references to this class instance, ARC will deallocate the space of this object to free up memory. As an expectation, we should see the deinit methods of Student and Car are called. However, those two methods are never called, there are no any messages, indicates objects are released, printed to the console. This means that the foo and the car are never deinitialized.The reason why these two objects are not released because these two objects hold strong references to one another so that each object keeps the other one from being deallocated, resulting in they are never deinitialized. This situation is called strong reference cycle in programming. Break strong reference cyclesThere are two ways to break strong reference cycles in Swift. Depending on which situation we are facing, we will choose a sensible approach to solve the problem. Both methods let an instance reference to one another without keeping a strong hold on it. Weak referenceWeak references should be used when the object it refers to might become nil in the future. As such, the captured objects are optional types.In the example above, it‚Äôs appropriate for a car to be able to have no owner at some point in its lifetime, and so a weak reference is an appropriate way to break the reference cycle in this case.Let‚Äôs make some changes to make the magic happen 123456789101112class Car { let name: String weak var owner: Person? init(name: String) { self.name = name } deinit { print(\"Car \\(self.name) is being destroyed.\") }} Let‚Äôs run the code, there are still no messages printed to the console, it means the two objects are not released. What the heck!Let‚Äôs trace back to our code to check what‚Äôs wrong with it.Do you see that? There is another problem with the code: The closure. Unowned referenceIn the above example, the Person class not only creates a strong reference cycle with the Car class but also between itself and the greeting closure. Here is how the cycle looks:To resolve this problem, we will use ‚ÄúUnowned reference‚Äù. Unowned references should be used when the closure and the object it refers to will always have the same lifetime as one another. This means the two objects will be deallocated at the same time. As a result, an unowned reference can never become nil.Let‚Äôs make some changes to make the magic happen (Again). 12345678910111213141516class Person { let name: String var car: Car? lazy var greeting: () -&gt; String = { [unowned self] in return \"Hello, my name is \\(self.name). I have \\(self.car?.name ?? \"no cars\")\" } init(name: String) { self.name = name } deinit { print(\"Person \\(self.name) is being destroyed.\") }} Let‚Äôs run the code, you should see the following messages printed to the console. 123Hello, my name is Foo. I have BMWPerson Foo is being destroyed.Car BMW is being destroyed. The two objects foo and car have been released and the leak has been resolved.Here is how the cycle looks so far: Tools to detect strong reference cyclesEncountering memory leaks is usually a nightmare for an iOS developer because it is too difficult to figure out the root cause. Luckily, we have multiple tools are supported by Apple to track down memory leaks. Allocations and Leaks InstrumentFrom the toolbar of XCode, choose Product &gt; Profile &gt; Allocations to start a new instrument profile for tracking memory allocations. Allocations instrument tracks all of the objects that app allocates during its lifetime.Now, press the red button on the top left in the panel to start recording.There is so many information related to memory mapping showed in the tool. To identify memory leak, we just need to focus on two main columns: #Persident and #Transident. Persident column: keeps a count of the number of objects of each type that currently exist in memory. Transident column: shows the number of objects that have existed but have since been deallocated. As you can see, the #Persident column keep increasing whenever you press to the ‚ÄúCreate a leak‚Äù button to execute the main block. When you see something like this happend to your app, it‚Äôs time to revise your classes to find out where the leak is. Debug Memory GraphDebug Memory Graph is a tool first introduced in Xcode 8. It is able to grab leaks such as retain cycles.From the debug navigator, click debug mode &gt; View Memory Graph Hierarchy to visualize the memory mappingYou should see somethings like this.From the visualization, we can see there are two strong reference cycles come from the Person-Car relationship and from inside the Person itself. ConclusionEvery iOS developer should have a deep understanding of how ARC works to avoid memory leaks. Undeniably, a good management of memory contributes to the app performance and the user experience. Hopefully, all of the concepts we walk through in this article will help you build apps that have the best performance. Feel free to leave your comments here. References[1] The Swift Programming Language (Swift 4.0.3), App Inc., Automatic Reference Counting chapter.","link":"/2018/09/12/Memory-leak/"},{"title":"Play Central And Peripheral Roles With CoreBluetooth","text":"IntroductionAs I mentioned in the previous post, CoreBluetooth allows us to create applications that can communicate with BLE devices such as heart rate monitors, body sensors, trackers, or hybrid devices.There are two roles to play in the CoreBluetooth concepts: Central and peripheral. Central: Obtain data from peripherals. Peripheral: Publish data to be accessed by a central. We can make a Bluetooth device plays as a peripheral from either firmware-side or software-side. In this post, I will show you how to create a peripheral by using our own identifiers. Also using another device, as a central, to connect and explore our services. Let‚Äôs get it started. Set up a PeripheralTo create a service, you need to have a unique identifier called UUID. A standard service has a 16-bit UUID and a custom service has a 128-bit UUID. Go ahead and type the following command to generate a unique uuid from your terminal. 1$ uuidgen As you can see, the command returns an uuid in hexa format (128 bit): A56E51F3-AFFE-4E14-87A2-54927B22354C. We will use this string to set up our own service. 123456789101112131415161718192021class ViewController: UIViewController, CBPeripheralManagerDelegate { let kServiceUUID = \"A56E51F3-AFFE-4E14-87A2-54927B22354C\" // Other properties ... override func viewDidAppear(_ animated: Bool) { super.viewDidAppear(animated) peripheralManager = CBPeripheralManager(delegate: self, queue: nil) [1] } func peripheralManagerDidUpdateState(_ peripheral: CBPeripheralManager) { print(\"peripheralManagerDidUpdateState \\(peripheral.state.rawValue)\") if peripheral.state == .poweredOn { let serviceUUID = CBUUID(string: kServiceUUID) [2] self.service = CBMutableService(type: serviceUUID, primary: true) [3] } // Other code }} Here is what these methods do: [1] You create an instance of PeripheralManager class, which will play as a peripheral in our example. Note that there is a queue param in the constructor. The events of the peripheral role will be dispatched on the provided queue. If we pass nil, the main queue will be used. [2] To set up a service, we need to create an instance of CBUUID class. The constructor gets a unique uuid as a param, which differentiates our service among others. [3] We create an instance of CBMutableService class. The constructor receives two params: The first one is our unique uuid, which was defined at [2]; the second param indicates that whether our service is primary or not. If not, our service will not be found when the app is in the background. Note that you can add services as many as you want. To be simple, I only create one service in this post.OK, let‚Äôs move to the next step. We will define characteristics for our service by using the below code. 12345let characteristic = CBMutableCharacteristic.init( type: CBUUID(string: kCharacteristicUUID), [1] properties: [.read, .write, .notify], [2] value: nil, [3] permissions: [CBAttributePermissions.readable, CBAttributePermissions.writeable]) [4] Here is what‚Äôs going on: [1] Like a service, a characteristic also needs a unique uuid to be differentiated among others. [2] We set up properties for the char. There is a variety of characteristic permissions, but I often use some of them: Read: Used for characteristics that don‚Äôt change very often, e.g version number. Write: Modify the value of the characteristic. Indicate and notify: The peripheral continuously notify the updated value of the characteristic to the central. The central does not have to constantly ask for it. IndicateEncryptionRequired: Only trusted devices can enable indications of the characteristic value.For other properties, please refer to Apple document [3] The value of the characteristic. Important note: If you provide a value for a characteristic, the characteristic must be read-only. Otherwise, you will get a run-time exception look like.2018-03-03 12:48:32.938615+0700 Peripheral[4238:3046876] *** Terminating app due to uncaught exception 'NSInternalInconsistencyException', reason: 'Characteristics with cached values must be read-only'Therefore, you must specify the value to be nil if you expect the value to change during the lifetime of the published service (write). [4] All characteristic should include the ‚Äúreadable‚Äù permission so that centrals could read its value. If we want a central can send commands to peripherals, we need to set the ‚Äúwriteable‚Äù permission to the characteristic. Now we have one service and one characteristic. Let‚Äôs publish it. 1234self.service?.characteristics = []self.service?.characteristics?.append(characteristic)self.peripheralManager.add(self.service!) After adding a service to the peripheral manager, the delegate method peripheralManager(_ peripheral: CBPeripheralManager, didAdd service: CBService, error: Error?) will be called. 1234567func peripheralManager(_ peripheral: CBPeripheralManager, didAdd service: CBService, error: Error?) { if let error = error { print(\"Add service failed: \\(error.localizedDescription)\") return } print(\"Add service succeeded\")} We‚Äôre almost done, just one more step: Start advertising the peripheral so that it can be found by other centrals. 12peripheralManager.startAdvertising([CBAdvertisementDataLocalNameKey: \"TiTan\", CBAdvertisementDataServiceUUIDsKey : [self.service!.uuid]]) After advertising, the delegate method peripheralManagerDidStartAdvertising will be triggered to indicate whether the peripheral did advertise successfully or not. 1234567func peripheralManagerDidStartAdvertising(_ peripheral: CBPeripheralManager, error: Error?) { if let error = error { print(\"Start advertising failed: \\(error.localizedDescription)\") return } print(\"Start advertising succeeded\")} At this point, we‚Äôve already defined and published our service(s). From now on, the peripheral can be discovered by centrals via CoreBluetooth. Set up a CentralFirst, we need to create an instance of the CBCentralManager class. 12345678class ViewController: UIViewController, CBCentralManagerDelegate, UITableViewDelegate, UITableViewDataSource, CBPeripheralDelegate { override func viewDidLoad() { super.viewDidLoad() // Do any additional setup after loading the view, typically from a nib. centralManager = CBCentralManager(delegate: self, queue: nil) ... }} Like a peripheral manager, there is a queue param in the constructor. The events of the central role will be dispatched on the provided queue. If we pass nil, the main queue will be used.We need to wait for the central manager to be ready, then we will start scanning nearby devices. 1234567func centralManagerDidUpdateState(_ central: CBCentralManager) { print(\"peripheralManagerDidUpdateState \\(central.state.rawValue)\") if central.state == .poweredOn { self.centralManager.scanForPeripherals(withServices: nil, options: nil) }} If it find a peripheral, the delegate method func centralManager(_ central: CBCentralManager, didDiscover peripheral: CBPeripheral, advertisementData: [String : Any], rssi RSSI: NSNumber) will be called. 123456789101112func centralManager(_ central: CBCentralManager, didDiscover peripheral: CBPeripheral, advertisementData: [String : Any], rssi RSSI: NSNumber) { if let name = peripheral.name { if (!checkIfExisted(name)) { let tupleDeviceInfo = (device: peripheral, rssi: RSSI) self.scannedDevices.append(tupleDeviceInfo) } DispatchQueue.main.async { self.tbvScannedDevices.reloadData() } }} Inside the method, we will check if the peripheral is valid, after that we will add it to the current list, then reload the table view. Note that the RSSI value represents the strength of the transmitting signal. We can estimate the current distance between the central and the peripheral based on the value. The greater the value, the closer the device is.Build and run the project, you will see the list of discovered devices like this. Now, let‚Äôs connect to our peripheral (The ‚ÄúTitan‚Äù device) by clicking on the corresponding row.Once a connection is made successfully, the delegate method func centralManager(_ central: CBCentralManager, didConnect peripheral: CBPeripheral) will be called. Otherwise, the method centralManager(_ central: CBCentralManager, didFailToConnect peripheral: CBPeripheral, error: Error?) will be triggered. 123456func centralManager(_ central: CBCentralManager, didConnect peripheral: CBPeripheral) { self.centralManager.stopScan() peripheral.delegate = self self.peripheral = peripheral self.peripheral?.discoverServices(nil) [1]} 123centralManager(_ central: CBCentralManager, didFailToConnect peripheral: CBPeripheral, error: Error?) { // Fail to connect peripheral} Notice that after connecting to the peripheral, we need to discover the services of the peripheral to use it ([1]).The delegate method func peripheral(_ peripheral: CBPeripheral, didDiscoverServices error: Error?) will be called after discovering services. 1234567891011func peripheral(_ peripheral: CBPeripheral, didDiscoverServices error: Error?) { if let err = error { print(\"didDiscoverServices fail \\(err.localizedDescription)\") return } // [1] Start discovering all chars for service in (peripheral.services)! { peripheral.discoverCharacteristics(nil, for: service) }} We did not finish yet =.= After discovering services, we also need to discover all characteristics of the services at [1].Like others, the method func peripheral(_ peripheral: CBPeripheral, didDiscoverCharacteristicsFor service: CBService, error: Error?) will be called after discovering characteristics for a service. 123456789101112func peripheral(_ peripheral: CBPeripheral, didDiscoverCharacteristicsFor service: CBService, error: Error?) { if let error = error { print(\"didDiscoverCharacteristicsFor Error \\(error.localizedDescription)\") return } for char in service.characteristics! { if char.properties.contains(.notify) { peripheral.setNotifyValue(true, for: char) [1] } ... }} As you can see, we need to set notify to the characteristic that contains the notify property to receive updates from it. [1]Finally, we‚Äôve done for setting up a connection between the peripheral and the central. Now let‚Äôs explore the data. Read and write data from peripheralYou have to specify which characteristic you want to read. 1self.peripheral?.readValue(for: discovererChars[kCharacteristicUUID]!) From the peripheral side, you will receive a read request inside the method 12345func peripheralManager(_ peripheral: CBPeripheralManager, didReceiveRead request: CBATTRequest) { print(\"Read request\") request.value = myValue.data(using: .utf8) peripheral.respond(to: request, withResult: .success)} After the peripheral response to read requests, the delegate method func peripheral(_ peripheral: CBPeripheral, didUpdateValueFor characteristic: CBCharacteristic, error: Error?) will be called from the central side. 1234 func peripheral(_ peripheral: CBPeripheral, didUpdateValueFor characteristic: CBCharacteristic, error: Error?) { let value = String.init(data: characteristic.value!, encoding: .utf8)! ...} If the value is successfully retrieved, you can access it through the characteristic‚Äôs value property, like above.Sometimes we want to write the value of a characteristic, which is writeable. We can write the value to it by calling the peripheral‚Äôs writeValue method like this. 1self.peripheral?.writeValue(data, for: discovererChars[kCharacteristicUUID]!, type: .withResponse) There is an argument called type, you specify what type of write you want to perform. In the example above, the write type is .withResponse, which instructs the peripheral to let your app know whether or not the write succeeds.From the peripheral side, you will receive a write request inside the method 1234func peripheralManager(_ peripheral: CBPeripheralManager, didReceiveWrite requests: [CBATTRequest]) { print(\"Write request\") peripheral.respond(to: requests[0], withResult: .success)} After the write request receives the response, the method peripheral(_ peripheral: CBPeripheral, didWriteValueFor characteristic: CBCharacteristic, error: Error?) will be called. 12345func peripheral(_ peripheral: CBPeripheral, didWriteValueFor characteristic: CBCharacteristic, error: Error?) { if let err = error { print(\"Did write value with error \\(err.localizedDescription)\") }} Encypted characteristic valuesSometimes we want to secure sensitive data. We can config the appropriate characteristic properties and permissions. Something like this 12345let encryptedChar = CBMutableCharacteristic.init( type: CBUUID(string: kCharacteristicUUID), properties: [.read, .notify, .notifyEncryptionRequired], value: nil, permissions: [.readable]) By doing this way, we ensure that only trusted devices have permissions to access these data.In my example, once a connection is made, CoreBluetooth tries to pair the peripheral (iPad) with the central (iPhone) to create a secure connection. Both devices will receive an alert indicating that the other device would like to pair. After paring, the central can access to the encrypted characteristic values of the peripheral. Some important notes The client-server model of BLE is called a publish and subscribe model. The peripheral only consumes power when it‚Äôs advertising its services, or receiving or responding to a central‚Äôs request. You can pass a list of service UUIDs inside the scanForPeripherals method. When you specify a list of service UUIDs, the central manager returns only peripherals that advertise those services, allowing you to scan only for devices that you may be interested in. You need to grant permissions to let your app uses Bluetooth LE accessory, and acts as a Bluetooth LE accessory for peripheral sides. (Go to project -&gt; Capabilities for setting). You also need to add one more information property to your info.plist, let‚Äôs add an entry with key Privacy - Bluetooth Peripheral Usage Description and value App communicates using CoreBluetooth (Or whatever you want to describe). A quick look to my appLet‚Äôs try some light exercise from my example. Summarize the programming flow for BLETo summarize the general programming workflow of CoreBluetooth on iOS, please take a look at the picture below. Final thoughtsIn this post, I guided you how to use the CoreBluetooth to create a peripheral as well as how to create a central to connect and obtain data from a peripheral. In the future, we can see that all devices around us are connected together via Bluetooth, towards the IoT world.You can download the completed project of the central here or the peripheral here.If you have any questions or comments, feel free to leave it on my post. Any comments are welcome. References[1] Core Bluetooth Programming Guide from Apple","link":"/2018/02/21/Play-Central-And-Peripheral-Roles-With-CoreBluetooth/"},{"title":"Play with Android Things","text":"","link":"/2019/02/07/Play-with-Android-Things/"},{"title":"React Native In My Real World","text":"React Native was introduced in January of 2015 at React.js Con: The first public preview. In March of 2015, React Native is open and available on Github. After releasing, React Native quickly becomes popular and is constantly updated by thousands of developers in the world. Currently, React Native is one of the most stars repositories on Github. ThreadsPerformanceNative modules123$ react-native run-ios --simulator 'iPad Pro (9.7 inch)'$ react-native run-ios --device 'qa'$ react-native run-ios --configuration Release --device 'qa' 123456789#import &lt;React/RCTBridgeModule.h&gt;@interface RCT_EXTERN_MODULE(SDKWrapper, NSObject)RCT_EXTERN_METHOD(supportedEvents)RCT_EXTERN_METHOD(startScanning)RCT_EXTERN_METHOD(stopScanning)RCT_EXTERN_METHOD(playAnimation)RCT_EXTERN_METHOD(connectToDevice:(NSString *)serialNumber:(RCTPromiseResolveBlock)resolve:(RCTPromiseRejectBlock)reject) //PromiseRCT_EXTERN_METHOD(disConnectToDevice:(RCTPromiseResolveBlock)resolve:(RCTPromiseRejectBlock)reject) //Promise@end 123456789101112public class SDKWrapper extends ReactContextBaseJavaModule { public SDKWrapper(ReactApplicationContext reactContext) { super(reactContext); } @Override public String getName() { return \"SDKWrapper\"; } @ReactMethod public void startScanning() {. . .}} 123456import {NativeModules} from 'react-native'; const {SDKWrapper} = NativeModules; ....SDKWrapper.doSomething();SDKWrapper.saySomething();.... Pros and consPros Native performance Learn once, run everywhere Flex box Hot reloading Platform detection in code Cons Not stable, hard to keep up Lack of documentation Single dedicated device thread Calling callback Conclusion","link":"/2017/12/01/React-Native-In-My-Real-World/"},{"title":"Review Book: Clean Code","text":"This is a book I have been gifted a long time ago from an old colleague, also he is one of my close friends. This is one of the software books that I like the most but have no chance to buy when I was a student. IntroductionAbout the author, Robert C. Martin, he is considered one of the oldest engineers in the software industry. He has many years of experience working in the software field from various positions, from a developer, manager, to CEO. He is best known for writing software guides that describe software principles, software patterns, and practices of software. He has published many books like Clean Coder, Clean Code, Clean Architecture, etc. Clean Code is one of the software books that many software engineers in the world encourage reading.The author said that *‚ÄùOver time the mess becomes so big and so deep and so tall, they can not clean it up‚Äù*. We need to read, think a lot before writing code. We should avoid writing the code in a hurry. Hurry to write the lousy code will lead to spending more time later for maintaining. Clean Code focuses on the technical aspects: instructing the programmer how to organize the code and write clean code. You won‚Äôt be learning any new frameworks, but it will provide you with a fundamental set of coding style rules. It‚Äôs worth reading the book. The book contentsThe contents of the book are divided into three parts: The first chapters will explain the principles, patterns, and practices of writing clean code. The second part consists of many case studies, each case study is an exercise in transforming the code that has some problems into code that has fewer problems. The last part is the play-off. Why clean code?Bjarne Stroustrup (Inventor of C++): Elegant, Efficiency.Grady Booch (Author of Object Oriented Analysis): Readability.David Thomas (Founder of OTI): Easy for other people to enhance it.Warn Cunningham (Inventor of Wiki): Make the language look simple.Me: To be able to remember what you write in a month ago. Clean code evaluation criteriaGeneral Don‚Äôt repeat yourself: Duplication may be the root of all evil in software. Many principles and practices have been created for the purpose of controlling or eliminating it. Sometimes we can use Template method pattern to remove higher-level duplication. Naming variables, methods, arguments, classes, files The name of a variable, function or class should answer the question why it exists, what it does and how it is used. Use searchable names. Classes and objects should have noun or noun phrase names. Methods should be a verb or verb phrase. Inconsistency: Be careful with the conventions you choose, and once chosen, continue to follow them. Comments Comments should say things that the code can not say for itself: Explain the idea in code, if it can not, then write comments. Comments should be reserved for technical notes about the code and design. Use correct grammar and punctuation. Don‚Äôt comment-out code, delete it. Functions Functions should be small: Fewer than 100 lines. It makes the function easier to read and understand. Functions should do only one thing. Functions should have a small number of arguments (Fewer than 4 arguments). Don‚Äôt pass boolean values as arguments. Functions that are never called should be deleted. Separate error processing from normal processing. Encapsulate conditionals. Error handling Error handling is important, but if it obscures logic, it‚Äôs wrong. Don‚Äôt return Null: Consider throwing an exception or returning a SPECIAL CASE object instead. If you code this way, you will minimize the chance of NullPointerException and your code will be cleaner. Don‚Äôt pass Null as arguments. Boundaries Wrapping third-party APIs: Minimize your dependency upon it. When there are new releases of the third-party package, we should run the test to see whether there are behavioral differences. Avoid letting too much of our code know about the third-party particulars: Let‚Äôs use an Adapter to deal with it. Classes A class should be small: We measure it by responsibilities. (We know it as SRP principle) A code should be placed where a reader would naturally expect it to be. (Where should be the PI constant go? Should it be in the Match class? Or maybe in the Circle class?). Be aware when creating static methods. A static method does not operate on a single instance. All the data that method uses come from its arguments, and not from any instances of this class. Also, make sure that there is no chance that you want it to behave polymorphically. Concurrency There are some basic definitions we should know when we talk about concurrency and threads: Bound resources, mutual exclusion, starvation, deadlock, and livelock. Concurrency does not always improve performance. It sometimes incurs some overhead and bugs come from it are not usually repeatable. Limit the access of the data that is shared between more than two threads. Use copies of data if there is a chance. Keep the synchronized sections as small as possible because Locks create delays and add overhead. They are expensive. Multithreaded code behaves differently in different environments: Run tests in every potential deployment environment. What I like The knowledge in this book is useful. It totally could be applied to reality. After reading the book, my coding style has changed a lot. The book is easy to understand and follow. You will read a lot of code, you will have challenges to think about what‚Äôs right about that code and what‚Äôs wrong with it. After each chapter, the author summarizes the main ideas. It helps me remember the main points longer. What I dislike The author uses Java code as examples in the book. Sometimes to understand the author‚Äôs ideas we have to find out more about Java concepts. (Spring framework, JUnit framework, type of exceptions, etc.) The author‚Äôs ideas are duplicated in some chapters. GenerallyOf course, in the scope of the article, I can not fully describe the ideas of ‚Äã‚Äãthe author. This is a good book that I recommend, especially for junior developers who recently graduated. Since at the school, teachers may not teach us how a code is called clean, your coding styles are not evaluated. In fact, Your code can run properly but is not clean.If you can afford to buy this book so that you can refer to when you need, it will be very useful.‚ÄúYou are reading this book for two reasons. First, you are a programmer. Second, you want to be a better programmer.‚Äù","link":"/2017/10/20/Review-Book-Clean-Code/"},{"title":"Review book: Building Applications With iBeacon","text":"In the previous post, I basically give you a quick look at iBeacon - A Bluetooth protocol built on top of BLE by Apple, and made a simple demo of how iBeacon can wake up an application after being terminated by the user. However, I did not mention other foundation concepts in Beacon, it also did not give you a deep look at the advantages and disadvantages of this powerful technology.Today, I would like to introduce you to a good book giving a solid knowledge in Beacon field, especially iBeacon: Building Applications With iBeacon published by O‚ÄôReilly.After reading this book, I ensure that you will get a good knowledge in iBeacon field and your mind will be more open to the next coming up ideas.Let‚Äôs drive-in! Main contentThe book mainly focuses on developers who are looking for an efficient way to integrate beacon protocol to their applications. To use the book efficiently, I recommend you should have some BLE background knowledge as iBeacon is built on top of BLE.In the beginning, the book describes a brief history of proximity technologies in particular. It also explains why and when to use in some specified circumstances.The two key main why using iBeacon are, first and foremost, GPS technologies struggle to do better than a few meters, and GPS is often limited indoors. iBeacons can enable a determination within centimeters. The second one is iBeacons offer high precision micro-location, along with the ability to act on what a mobile device is near. No other technology yet offers that combination.To convince the reader, the book compares GPS versus Beacon, in other word location versus proximity; giving some limitations of current GPS technology, the writer makes some area in which Beacon is far superior to GPS.Next, the book explains how Beacon protocol works under the hook; introduces you to the foundational terms, and how they interact with each other.Finally, in some chapters, the book guides you on how to set up your own beacons on Mac OS, mobile devices, or tiny computers such as Ras. Pi or Arduino. Key concepts The relationship between iBeacons, generic beacons, BLE beacons, and BLE devices is described as below iBeacons are a subset of the BLE beacon specification, All iBeacons are BLE beacons, and all BLE beacons are BLE devices. However, there are beacons that are not Bluetooth-based, and there are BLE devices that do not beacon. An iBeacon needs to be configured with its identifying numerical tuple (UUID, major number, and minor number).Beacon identifier = UUID + Major + Minor. In Core Location, a region is a space in which a specified combination of UUID, major number, and minor number are received. Core Location supports three types of filtering a region: UUID only: any installed iBeacon that matches the uuid. UUID plus major number: Like the UUID-only option, it is likely to match several iBeacons, most likely installed at one particular location. UUID plus major and minor numbers: This option will match only one specific iBeacon. The following code illustrates how to define those three regions in Swift, respectively.123let region1 = CLBeaconRegion(uuid: \"uuid1\", identifier: \"Your region's name 1\")let region2 = CLBeaconRegion(proximityUUID: \"uuid2\", major: 1, identifier: \"Your region's name 2\")let region3 = CLBeaconRegion(proximityUUID: \"uuid3\", major: 1, minor: 0, identifier: \"Your region's name 3\") iOS and iBeacon: Apple provides two main actions when working with iBeaconMonitoringMonitoring provides a capability of subscription on the appearance of a region, which is combined with one or more beacons.An event in and out will be fired when a device enters or exits a region, respectively. Performed in both the foreground and the background on iOS, is used to determine when a device has entered or left an iBeacon‚Äôs coverage area. One of the most benefits of using beacon is regions are tracked by the operating system, not the application. Even when applications are not running (terminated by the OS or force stop by the user), the OS can relaunch the app to handle the events. After bringing back to the background, the app has a few seconds to execute its tasks (Around 10s). The location manager defines a method for didEnterRegion, which is called when a device crosses the boundary to enter a region The location manager defines a method for didExitRegion, which is called when a device crosses the boundary to leave a region. Monitoring limitation iOS can only monitor for up to 20 regions in one single app as describes in Apple documentation Regions are a shared system resource, and the total number of regions available system-wide is limited. For this reason, Core Location limits to 20 the number of regions that may be simultaneously monitored by a single app‚Äù Apple doc. The system also takes some time to trigger the exit event, in practice it is around 30 ~ 40s. RangingUses its transmissions to estimate the distance from a mobile device to a beacon. A common use of ranging operations is to determine which iBeacon is closest to this area.The location manager will trigger the didRangeBeacons method after ranging successfully, a list of iBeacons that have ranging data will be passed to the delegated method, along with the region in which they were detected. It also provides the received signal strength indicator (RSSI) to estimate a range in meters (It is a property of the CLBeacon object). Ranging limitation: One main downside of ranging operations requires much more activity in the Bluetooth hardware and consume significant power, because the Bluetooth interface is much more active when ranging What I like I never thought iBeacon topic would be written as a whole book but the author did it very well: The book describes iBeacon in a deep explanation. Make clear of foundational terms that are commonly used in beacon technology. Analyses the pros and cons of iBeacon with examples. Introduce other applications of beacon that I never thought about before, which opens my mind a lot: Indoor Location and Proximity: Map replacement, transit assistance, indoor direction finding, where is my car?, museum guides, retail store enhancement. Proximity-Triggered Actions: Mobile advertisements, ticket validation, treasure hunt, patient information integration. Queue management: Queue measurement, restaurant table pager, transaction completion in retail. Easy to understand: the content is well-organized, it‚Äôs easy to follow the content flow. What I dislikeThere is nothing to complain about the book, from content to form. GenerallyMany technologies exist to help phones interact with the world around them. This book introduces you to iBeacons, a Bluetooth technology that allows a device to discover nearby subjects with relatively high accuracy. There is no doubt that the applications of beacon are increasingly widely applied in many fields, especially in marketing and advertising.From my point of view, you should read the book so that you can unlock your mind about iBeacon. Maybe your next startup is built on top of Beacon, who knows?In the next tutorial, I will take you into practice with iBeacon on iOS, also will introduce you to some techniques to deal with iBeacon in deep analysis.If you have any questions or comments on this post, feel free to contact me!","link":"/2020/06/14/Review-book-Building-Applications-With-iBeacon/"},{"title":"Review book: Swift Apprentice - Raywenderlich","text":"While I was searching for a book to boost my iOS development skill, I found this Swift Apprentice book on Raywenderlich‚Äôs book store. Take a quick look at the content of the book, I decided to add the book to my library.Generally, If your iOS skill is mid-level or senior, you‚Äôre so confident with your master programming skill, this book is not for you. But if you‚Äôre looking for a book to strengthen your knowledge, or you just want to make sure everything you understand about Swift language is right - as my purpose, then take this book with you.You‚Äôll learn about very basic things like function, method, constants, control statement, etc. You‚Äôll also have a chance to get in-depth knowledge about Stack/Heap allocation, protocol-oriented programming, and generic programming, which make your daily job more convenient, and you will find yourself like a master in Swift language.Let‚Äôs drive-in! About the authorFor those who don‚Äôt know who Raywenderlich is, it is a community site focused on creating programming tutorials and books (Mainly focus on mobile development on Android and iOS). Their content covers all levels from beginning to advanced topics.I often access Raywenderlich site to get example code and to make my knowledge up to date. Their tutorials are extremely great, technically accurate and are updated to the newest technologies.Swift Apprentice is one of their collection of iOS programming. Keynotes Lazy property: If you have a property that might take some time to calculate, you don‚Äôt want to slow things down until you actually need the property, let‚Äôs use the lazy stored property. It is useful for such things as downloading a user‚Äôs profile picture or making a serious calculation. The heap vs. the stack:The Stack is used to store anything on the immediate thread of execution; it‚Äôs managed and optimized by the CPU. When a function creates a variable, the stack stores that variable and then destroys it when the function exits. Since the stack is so strictly organized, it‚Äôs very efficient, and thus quite fast.The heap, on the other side, is used to store instances of reference types. The heap is generally a large pool of memory from which the system can request and dynamically allocate blocks of memory. Lifetime is flexible and dynamic. It doesn‚Äôt automatically destroy its data (the stack does so). Additional work is required to free the memory on the Heap, which makes creating and removing data on the heap a slower process, compared to on the stack.When an instance of a class is created, your code requests a block of memory on the heap to store the instance itself.When an instance of a struct is created (that is not part of an instance of a class), the instance itself is stored on the stack, and the heap is never involved. When to use a class versus a struct: Values vs. objects: Use structures as values and classes as objects with identity. To make it simple, just keep in mind that there are no two objects are considered equal simply because they hold the same state. In contrast, instances of value types, which are values, are considered equal if they are the same value. e.g, no two students are considered equal, even if they have the same name; Two points (x, y) are equal if x1 and y1 the same to x2 and y2, respectively, so we implement Point as a struct.Speed: If these instances will only exist in memory for a short time ‚Äî go towards using a struct. If your instance will have a longer lifecycle in memory, let‚Äôs think of a class.Another approach is to use only what you need. If your data will never change or you need a simple data store, then use structures. If you need to update your data and you need it to contain logic to update its own state, then use classes. Often, it‚Äôs best to begin with a struct. If you need the added capabilities of a class sometime later, then you just convert the struct to a class. Two-Phase initialization:‚Ä¢ Phase one: Initialize all of the stored properties in the class instance, from the bottom to the top of the class hierarchy. If you use properties and methods before phase one is complete, the compiler will throw errors.‚Ä¢ Phase two: We can now use properties and methods of the object. Protocols in the Standard Library: Equatable, Comparable, Hashable, CustomStringConvertible. Generic function parameters: 123func swapped&lt;T, U&gt;(_ x: T, _ y: U) -&gt; (U, T) { (y, x)} Wildcard pattern: 1234if case (_, 0, 0) = coordinate { // x can be any value. y and z must be exactly 0. print(\"On the x-axis\") // Printed! } Value-binding pattern:123if case let (x, y, 0) = coordinate { print(\"On the x-y plane at (\\(x), \\(y))\") // Printed: 1, 0 } ‚ÄúIs‚Äù type-casting pattern‚Äù:12345switch element { case is String: print(\"Found a string\") default: break} Rethrows: By using rethrows instead of throws, functions indicate that they will only rethrow errors thrown by the functions called inside itself but never errors of its own. Protocol-oriented benefits:By using protocols instead of implementations, we focus on what the object can do instead of how the object does, which makes the application more extendable and testable.Multiple inheritances: One of the real benefits of protocols is that they allow a form of multiple inheritance. Swift is a protocol-oriented language. What I like Well organized. Real examples: There are examples for each topic to make sure readers deeply understand what they just mentioned. Easy to understand: As the content are well-organized, it‚Äôs easy to follow the content flow. Stop and think: There are short exercises and challenges throughout the book to give you some programming practice and test your knowledge along the way. Keypoints: They summarize key points at the end of each chapter. What I dislikeI tried to look over the books several times to find a spot that I dislike but there is nothing to complain about, from content to form. GenerallySwift is fun and is filled with programming paradigms. After reading this book, I hope you now feel more comfortable enough with the language to move on to building bigger things. With the language fundamentals we‚Äôve gained, we‚Äôre ready to explore advanced frameworks such as Animation, UIKit, etc. to build iOS apps, macOS apps and more.I hope you find this book interesting.Happy weekend!","link":"/2020/02/26/Review-book-Swift-Apprentice-Raywenderlich/"},{"title":"Shipping your iOS app to Store","text":"Submitting your app to the Apple Store isn‚Äôt as simple as pressing a ‚Äúmagic‚Äù button then it does everything, but it‚Äôs not as complicated as you think either. It‚Äôs maybe your first time launching your first app, and you don‚Äôt have a chance to get familiar with the submitting process before. This step-by-step tutorial will show you the main flow to submit apps from zero to a hero. Kindly note that you need to have a Paid Developer Account to get it done.Jump in! Certificates, app Ids and provisioning profilesIn other to submit your app to App Store, you need to understand what certificates, app IDs and provisioning profiles are. Basically, A distribution certificate identifies your team/organization within a distribution provisioning profile and allows you to submit your app to the Apple App Store. The following image describes the relationship between them. Create a Distribution Certificate On your Mac, Open Key Chain Access app. Go to Certificate Assistant &gt; Request a Certificate From a Certificate Authority. Fill in your email to the email box. The Keychain Access will create a private key, which is stored in the keychain, and a .certSigningRequest file which will be uploaded to Apple. Apple will issue a certificate for you based on the .certSigningRequest. The Certificate contains the public key. After that, you can download the file and open it. The public key will be pushed to the Keychain and paired with the private key to make the ‚ÄúCode Signing Identify‚Äù. Just so you know what is CSR A CSR or Certificate Signing request is a block of encoded text that is given to a Certificate Authority when applying for an SSL Certificate. It is usually generated on the server where the certificate will be installed and contains information that will be included in the certificate such as the organization name, common name (domain name), locality, and country. It also contains the public key that will be included in the certificate. A private key is usually created at the same time that you create the CSR, making a key pair. After having the .certSigningRequest file, go to the Apple developer page, sign in to your Apple Account &gt; Certificates, Identifiers &amp; Profiles &gt; Press the ‚Äú+‚Äù button to create a new certification &gt; Remember to select the ‚ÄúiOS Distribution (App Store and Ad Hoc)‚Äù option. Next, select to upload your .certSigningRequest file you just created at the step 3. Finally, you now can download the Certificate file to your Mac, open it and the key will be pushed to the keychain automatically. That‚Äôs all for creating a Distribution Certificate, let‚Äôs move on to the next step, create your app id. Create App Id Press the ‚Äú+‚Äù button on the page ‚ÄúAll Identifiers‚Äù Fill in your app information, including your bundle Id. Please note that this bundle id must match your bundle id in XCode. You can also use wildcard pattern to define bundle Id for more than one app Ids. Create Provisioning Profile Press the ‚Äú+‚Äù button on the page ‚ÄúProfiles‚Äù, then select ‚ÄúApp Store‚Äù option. Select your app Id that you just created in the previous step, Create App Id. Select your Certificate that you just created in the previous step, Create a Distribution Certificate Now you have a profile that links your Certificate and your app Ids. Download this file and open it. The Provisioning Profiles will be pushed to XCode automatically. UploadingIt‚Äôs time to upload your app to Store.Let‚Äôs back to your project, from the Top Tool Bar &gt; Product &gt; Archive, XCode will rebuild your project. After that, the XCode Organizer will launch and show all archives you‚Äôve created in the past.Select the current build, then click on ‚ÄúDistribute App‚Äù in the right-hand panel. The next window allows you to select your credentials including the Distribution Certificate and the Provisioning Profiles you created in the first section. Finally, press the upload button, XCode will do the rest for you. An email will be sent to notify you right after Apple completes the processing process, it usually takes some minutes.Your app has been successfully uploaded to your iTunes Profile, let‚Äôs go to the final step. SubmitingNavigate to App Store Connect, select ‚ÄúMy Apps‚Äù. you will see your app appear on the page. You need to prepare the following information to fill in on these pages: App Name, Privacy Policy URL, Age Rating, Category. Screenshot in different sizes: This might take your time the most, your screenshots need to meet Apple requirements at Screenshot specifications. Kindly note that users will see these screenshots related to their current devices, so make sure your photos are fancy and extractive as most as you can. Fastlane also supports take screenshots automatically, you can find the document if you‚Äôre interesting. Fastlane tools can automate this process making it fast, and consistent while giving you beautiful results! Version description, keywords, support URL. If your app requires sign in, fill in account information with username and password. App notes: Some important notes you want to send the previewer to make sure it works properly. (e.g we strongly recommend using the service with a Wifi connection for best quality) Attachment: It‚Äôs best to have a short demo of your app. Contact information: If there are any issues, Apple will contact you via this information. You‚Äôre done. Now precess the ‚ÄúSubmit‚Äù button to start the reviewing process. Reviewing processYour reviewing process takes some time to complete, it may be a couple of days to couple weeks depends on your app category, features, and ‚Ä¶ the reviewer.If your app violates Apple rules such as using unapproved private APIs, lack of permission description, crashing or poor performance, it will get rejected. In the end, we have to accept that Apple has the final word on allowing anything into the App Store. Just because you think your app is great does not mean that Apple will allow it into App Store. I myself experienced this strickly-randomly-emotionally process when submitting my application. The first submission went smoothly without any troubles. The second one, which is updated some UI, got rejected because Apple thinks my app contains a feature that is not allowed in the App Store. With many emails and phone calls, I finally had to remove this feature from my app. (?!) Final wordsIn this post, I guided you on how to submit your app to Store in a very detailed step. Hope this post saves your time in delivering your amazing apps to users. Can‚Äôt wait.In next post, I will show your steps to upload your app to Google Play.Happy coding.","link":"/2018/12/13/Shipping-your-iOS-app-to-Store/"},{"title":"Swift Summit conference in San Francisco 2017","text":"Swift Summit Conference 2017 was held at the Palace Of Fine Arts, San Francisco, which is one of ten palaces at the heart of the Panama-Pacific Exhibition. At the conference, Swift developers from around the world shared new knowledge, tools and ideas on iOS platform and Swift language. Image 1. I was there, at the Swift Summit conference 2017 The conference hosted more than 20 technical sessions and developer labs. Especially, there was an exhibitor hall with top tech companies like Facebook, IBM, Lyft, Capital One, etc. There, I met other developers, talked about new technologies and received swags from sponsors. Image 2. My bag (And another one of my friend's) was full of swags from the conference :)). Ten days to enjoy the US, two days to enjoy the conferenceAs it had been the first time I go to San Francisco, I was not comfortable with the weather there. I remember that in the first morning day I went to the Palace of Fine Arts, the weather was 13c degree at that time. I was freezing to death!When I first entered the main hall, I felt better because of the warm light. The organizers prepared a lot of food and fruits on a table in the center of the hall. My friends and I went around to visit tech companies, tried using their new technologies, and received their swags.The size of the conference was not as I expected. It was quite small, about one hundred people, I guess. But the organizers and the speakers prepared contents very well. Below are some key sessions that I attribute the best during two conference days. Asynchronous programmingAsynchronous methods, (Async for short), are the methods that not immediately returning results like most method, the async methods take some time to produce results.Before attending this session, I often use callback to deal with asynchronous methods like scanning bluetooth devices or retrieving some resources from the internet. In fact, callback is a bad programming technique. Callback will make our code hard to read, hard to debug and take much more time to maintain later. In the end, our code will turn into something that we call the callback hell.In this session, the speaker introduced a framework that helps us to simplify asynchronous programming, PromiseKit. It is easy to learn, easy to use and result in clearer, more readable code.For more details about this session, please refer to another one of my posts: Asynchronous Programming in Swift BuglifeBugLife is an open framework help our users to submit a bug report from their phone, and it immediately shows up in our issue dashboard. The best benefits that I found when I use BugLife are it is free and is easy to integrate to our apps without breaking a sweat.For more details about how to use this framework, please refer to another one of my posts: BugLife in real life MixpanelMixpanel is a library help us to track user behaviors and other events that occur on our apps. Many technology companies use Mixpanel to analyze their data to get to know their users deeper. From the results, they can make decisions to improve their app to please users. Image 3. Developers were attending a developer Lab. Swift on the Server: State of the UnionThis session described the current state of Swift on the server, and make some predictions about what the next year will hold. Unfortunately, I fell asleep in this session so I dont catch many ideas from the speaker.For more details about how to use this framework, please refer to another one of my posts: Swift on the server side iOS Architectures in ContextWhy we have to care about choosing an architecture?Nowadays, we have so many software architectures to choose, if we do not choose a fit architecture for our apps, one day we will find ourselves in being unable to find and fix any issues inside our apps. During this session, the speaker discussed on some iOS architectures like MVC, MVP, MVVM, VIPER, etc. With many years of experience working on software architectures, he evaluated on both upside and downside one by one.For me, this session was quite difficult to grab all ideas of the speaker since I don‚Äôt have many experiences in designing software architectures. After that, I had to spend more time to read other documents and technical blogs to get understand what he said. Image 4. The scene around the conference After all ‚Ä¶Late on the second day, we had a Halloween party in the hall of the palace. This is my first time attending a technology conference in a technology-led country, the US. After two days attending the conference, I have updated some new technologies and also applied some technologies to projects at my company. Truly to say, there are some sessions that are a little boring and only introductory. Also the jet lag made me feel tired so I did not fully concentrate on some sessions. That‚Äôs a regret.In the end, this is still the best trip ever! Image 5. An unforgetable trip","link":"/2017/11/29/Swift-Summit-conference-in-San-Francisco-2017/"},{"title":"Two weeks at Fossil Group in the US","text":"Last week, I had a chance to visit the US again.","link":"/2019/05/19/Two-weeks-at-Fossil-Group-in-the-US/"},{"title":"What is refactoring?","text":"","link":"/2018/02/27/What-is-refactoring/"},{"title":"What&#39;s new in iPad OS 14?","text":"To see #5 top updates in iPadOS 14.","link":"/2020/06/26/What-s-new-in-iPad-OS-14/"},{"title":"Working In Thread Safe on iOS","text":"As you might know, the word ‚ÄúThread safe‚Äù is referred to a computer science concept in the context of multi-thread programs. A code is called ‚ÄúThread safe‚Äù if any shared data is accessed by only one thread at any given time. Notice these shared data are called critical sections in an operating system.The point is Swift collection types like Array and Dictionary are not thread-safe when declared mutable (With var keyword).In this post, we will discuss some techniques to make our code thread safe in iOS. Case studyLet‚Äôs say we have an array which contains crucial data. In reality, it can be an amount of money in a credit card, transaction states, etc. They are really important so if we don‚Äôt protect these values accurately, we will face significant errors at runtime.To simulate a race condition, I‚Äôm going to use DispatchQueue.concurrentPerform to create 10 concurrent threads running at the same time. 12345678910111213class ViewController: UIViewController { var array = [Int]() override func viewDidAppear(_ animated: Bool) { super.viewDidAppear(animated) // Do any additional setup after loading the view, typically from a nib. DispatchQueue.concurrentPerform(iterations: 10) { index in self.array.append(index) } } // The rest of code} The result of the above code is unpredictable. You will fall into 2 cases: Most of the times you run this code, you will get a run-time crash like thisThe fundamental problem is because Swift collections like Array and Dictionary are not thread-safe but we let multiple threads modify the array at the same time. Stackoverflow If you luckily don‚Äôt get this crash, the elements of the array will look random like this:Element count 5Element count 9Element count 10The point is we do not always get 10 elements as expected. How it happened?It‚Äôs not safe to let one thread modify the value while another is reading it. SolutionsThe way to avoid race conditions is to synchronize data, or the critical sections. Synchronizing data usually means to ‚Äúlock‚Äù it so that only one thread can access that part of the code at a time.Since Swift does not support built-in concurrency solutions, we‚Äôre going to use Grand Central Dispatch to implement thread safe instead. Using serial queueBy leveraging serial queues, we can prevent race conditions on a resource. As I introduced how a serial queue works in a previous post, Grand-Central-Dispatch-in-Swift, a serial queue allows just only one process run at a time so the array is safe from concurrent processes. 123456789101112131415161718class SafetyArray&lt;T&gt; { var array = [T]() let serialQueue = DispatchQueue(label: \"com.uynguyen.queue\") var last: T? { var result: T? self.serialQueue.sync { result = self.array.last } return result } func append(_ newElement: T) { self.serialQueue.async() { self.array.append(newElement) } } } Although we protect the array from being accessed by multiple threads, using serial queue is not the best solution. Reading the last value is not optimized because multiple read requests have to wait for each other as it is in a serial queue. Reads should be able to happen concurrently, as long as we do not make a write at the same time. Using concurrent queue with the barrier flagThe main idea of this solution is using a concurrent queue instead of a serial queue.Swift supports us to dispatch a block of code to a concurrent queue with a flag called barrier. The barrier flag ensures that the concurrent queue does not execute any other tasks while executing the barrier process. Once the barrier process done, then the queue allows running other tasks simultaneously by default implementation. 123456789101112131415161718class SafeArray&lt;T&gt; { var array = [T]() let concurrentQueue = DispatchQueue(label: \"com.uynguyen.queue\", attributes: .concurrent) var last: T? { var result: T? self.concurrentQueue.sync { result = self.array.last } return result } func append(_ newElement: T) { self.concurrentQueue.async(flags: .barrier) { self.array.append(newElement) } } } We continue to use the sync method for reading the last element, but all readers will run in parallel this time since we are using a concurrent queue. The trade offWorking with multiple threads is a hard part of coding. Although we have to protect critical sections from multiple accesses, we should keep in mind that *‚ÄùKeep the synchronized sections as small as possible because Locks create delays and add overhead. They are expensive‚Äù*. Clean code.Some tips to deal with concurrency: Concurrency does not always improve performance. It sometimes incurs some overhead and bugs come from it are not usually repeatable. Limit the access of the data that is shared between more than two threads. Use copies of data if there is a chance. Multithreaded code behaves differently in different environments: Run tests in every potential deployment environment. Final thoughtsThread safe is one of the most important concepts in computer science, especially in a system which allows accessing data simultaneously. Understand how to make code thread safe, we can avoid serious errors occurring at runtime.Happy coding.","link":"/2018/06/05/Working-In-Thread-Safe-on-iOS/"},{"title":"Hello World","text":"Welcome to Uy Nguyen‚Äôs blog!I love writing, so I build this site to write any stupid crap things in my life, my job or whatever related to Software Engineering. In this way, I remember these topics longer. I also want to share what I learned to anyone who needs it.Feel free to kick an email if you need to reach me. ‚ÄúBe a Software Engineer, not a Coder.‚Äù - Uy Nguyen","link":"/2017/08/01/hello-world/"},{"title":"iOS: Introducing Stack Views Programmatically","text":"As your iOS development skill is growing, I believe you use UIScrollView, UICollectionView, UITableView, and other native views regularly and proficiently in your applications. Yet, some iOS developers still don‚Äôt know what exactly UIStackView is, what it uses for or in which situation should we use UIStackView.In this tutorial, I will introduce you to UIStackView - A view helps us to simplify our iOS layouts. Let‚Äôs imagine you‚Äôre going to build an application that allows the user to add or remove views in run time. Remember how we will accomplish this task? We first have to remove all constraints in the relative area and update them all over again. Or remember the case where you implement the sign-in / sign-up view, you add many text fields and manually set constraints between those views. In such situations, UIStackView appears to be more useful than other views. To demonstrate how to apply UIStackView to your projects, we‚Äôre going to build a simple application that allows the user to control smart devices in their home; Users can add or remove which room they want it to show in their list of control. The main key here is all actions of the user are executed in runtime dynamically. Additionally, instead of using Storyboard in this project, I‚Äôm going to use code dynamically along with the help of the AutoLayout framework (SnapKit - it is just a matter of preference). Let‚Äôs put aside other complex implementation, the application contains only two views: A login view and a home page. Also, there will be no logic code at all. Key propertiesTo understand how a Stack View work, we first need to have a look at its properties. No matter what kind of the Stack View is (Horizontal or Vertical), there are four main properties: Axis, Spacing, Alignment, and Distribution. The following image summarizes the relative among those attributes. Axis: determines the stack‚Äôs orientation, including Horizontal and Vertical. Spacing: determines the minimum space between the stack‚Äôs views. Alignment: determines the layout of the stack‚Äôs views perpendicular to its axis.Both horizontal and vertical stack views have the Fill and Center options. Fill: Stack‚Äôs arranged views will be resized so that they fit the stack view perpendicularly to its axis. The leading and trailing edges of vertically stacked items or the top and bottom edges of horizontally, respectively. Center: As the name suggests, center the stack‚Äôs views horizontally (Vertical stack) or vertically (Horizontal stack). Fill Center There are some alignment options applied only for horizontal stack views: Top: As the name suggests, center the stack‚Äôs views horizontally (Vertical stack) or vertically (Horizontal stack). Bottom: As the name suggests, center the stack‚Äôs views horizontally (Vertical stack) or vertically (Horizontal stack). First baseline: A layout where the stack view aligns its arranged views based on their first baseline. Last baseline: A layout where the stack view aligns its arranged views based on their last baseline. Top Bottom First baseline Last baseline Similarly, there are some alignment options worked for vertical stack views only: Leading: The stack view aligns the leading edge (Left) of its arranged views along its leading edge. Similar to top alignment for horizontal stacks. Trailing: The stack view aligns the trailing edge (Right) of its arranged views along its leading edge. Similar to bottom alignment for horizontal stacks. Leading Trailing Distribution: determines the layout of the stack‚Äôs views along its axis. The subviews are all resized based on this setting. Fill: This is set as the default distribution when a Stack View is created. When we put views inside a UIStackView with Fill set as the distribution, it will keep trying to stretch the size one of the views to fill the space.So the question is, what criteria will it base on to choose the view to resize? Content Hugging Priority (CHP) will be. To determine which view will be stretched, the stack view will rely on CHP for evaluation, the lower its priority, the more likely it is to be chosen. If all the views have the same CHP, the first one will be picked. Fill Equally: Each control in a UIStackView will be of equal size. Fill Proportionally: All the controls need to have an intrinsic content size, Stack view will ensure the controls maintain the same proportion. Equal Spacing: This distribution type will maintain equal spacing between the subviews. Equal Centering: This distribution type will maintain an equal space between the center of the subviews. Fill Fill Equally Fill Proportionally Equal Spacing Equal Centering Note: UIStackView is a non-rendering view, which means you can not set the background-color property, or override the draw method, etc. Take to practiceNow, with that knowledge in mind, we‚Äôre going to apply it to an existed project that currently does not use UIStackView to arrange its view at all. By applying UIStackView into practice, we will really get an understanding of how a UIStackView works and what problems it can resolve. Auto arrange viewsThe first thing UIStackView brings to us is the freedom from setting constraints for all views.The login view is quite simple, it contains two text fields, a login button and some text labels. Without using UIStackView, we have to manually set constraints for all those text fields. 12345678910111213141516171819view.addSubview(lblLogin)lblLogin.snp.makeConstraints { (make) in make.centerX.equalToSuperview() make.centerY.equalToSuperview().offset(-250) make.left.equalToSuperview().offset(20) make.right.equalToSuperview().offset(-20) make.height.equalTo(30)}view.addSubview(lblUsername)lblUsername.snp.makeConstraints { (make) in make.centerX.left.right.equalTo(lblLogin) make.top.equalTo(lblLogin.snp.bottom).offset(30) make.height.equalTo(30)}view.addSubView(btnLogin)//...// The rest omitted But it‚Äôs still not a nightmare. Imagine now you want to add some other views, such as a label and a switch view to allow the user to remember the login session. We now have to alter all other views to insert those new views to the right place on the screen! The task will be easier and simpler if we use StackView. Now let see how we can do it.First, let‚Äôs add a new property to the Log in view controller. 12345678910111213lazy var stackView: UIStackView = { let stack = UIStackView() stack.axis = .vertical stack.spacing = 20.0 stack.alignment = .fill stack.distribution = .fillEqually [self.lblUsername, self.txtUserName, self.lblPassword, self.txtPassword, self.btnLogin].forEach { stack.addArrangedSubview($0) } [1] return stack}() Notice at [1], this is how we add arraged views to a stack view. Then, we just need to set contraints for the stackView. 12345678910override func viewDidLoad() { super.viewDidLoad() // ... view.addSubview(stackView) stackView.snp.makeConstraints { (make) in make.centerX.left.right.equalTo(lblLogin) make.top.equalTo(lblLogin.snp.bottom).offset(30) make.height.equalTo(280) }} In the future, if we want to add new views, we just need to put it to the arranged views array. As below. 123456789lazy var keepLoginStackView: UIStackView = { let stackView = UIStackView() stackView.axis = .horizontal stackView.alignment = .trailing stackView.distribution = .fill [self.lblRememberMe, self.swKeepLogin].forEach { stackView.addArrangedSubview($0) } return stackView}() 12345// ...self.txtPassword,self.keepLoginStackView,self.btnLogin].forEach { stack.addArrangedSubview($0) }// ... Can you see the differences? The codebase now is cleaner and more maintainable than the old one, isn‚Äôt it? Dynamic viewsNow switch to the case where we will implement the Home page of the application.When the user presses the right button of the screen, a new view, which represents for a room to be controlled in this case, will be placed on the main page. The user can also remove any rooms in the list by pressing the ‚ÄúRemove‚Äù button. Inside each room, there is a ‚ÄúHide‚Äù / ‚ÄúShow‚Äù button that allows hiding and showing the room image. Remember in the past where you have to implement a similar feature in your app without using UIStackView, what will you do? Somewhat painful! We first need to remove all constraints in the relative area and update them all over again. Here is what we‚Äôre going to do with UIStackView, the main page contains a vertical stack view embedded inside a scroll view. Whenever the Add button is pressed, a new TaskView view will be added to this stack view. 1234567func addMoreView() { let view = TaskView(delegate: self, data: room[Int.random(in: 0..&lt;room.count)]) let constraint1 = view.heightAnchor.constraint(lessThanOrEqualToConstant: 400.0) constraint1.isActive = true self.taskStackView.addArrangedSubview(view) self.view.layoutIfNeeded()} We also need to set height constraints for this new view. Because the height of the view might be changed when the show/hide button is pressed, we need to define this constraint as lessThanOrEqualToConstant:value so that the stack view can adjust this height constraint. 12345678910func onRemove(_ view: TaskView) { if let first = self.taskStackView.arrangedSubviews.first(where: { $0 === view }) { UIView.animate(withDuration: 0.3, animations: { first.isHidden = true first.removeFromSuperview() }) { (_) in self.view.layoutIfNeeded() } }} When the remove button on a task view is clicked, this view will be removed from the stack view. We can access all arranged views of a stack view by accessing arrangedSubviews property. We first loop for all arranged views and find the appropriate view which have the same address with the sender, then remove it from the super view. Additionally, I make a small animation, UIView.animate(withDuration:animations:), so that the transition looks more smooth and fancier than the last one.By using the same approach, you can do the same thing when the user clicks on Show / Hide button to show/hide the image view. Let‚Äôs take a try by yourself. Final thoughIn this tutorial, I introduced you to UIStackView - a subclass of UIView helping to manages the position and size of its arranged views. We also worked through a demonstration that takes UIStackView into practice. Now you get the idea of how the UIStackView works and what the UIStackView uses for, next times try to use UIStackView in your app to leverage its power. I will do, won‚Äôt you?You can download the completed demo at Github,Happy coding!","link":"/2020/07/18/iOS-Introducing-Stack-Views/"},{"title":"Advanced iOS Concurrency: Operations [1]","text":"There are two techniques to deal with Concurrency in iOS: GCD - Grand Central Dispatch and Operations. Most of the time, GCD provides most of the concurrency capabilities you need. Yet, sometimes you‚Äôll want some extra advanced customizations. It‚Äôs time to use Operations. This tutorial will introduce Operations in Swift, also explain when and why we use Operation instead of GCD.Let‚Äôs switch the gears! There is a big gap between knowing the path and walking through the path. Introduce OperationsOperation is a class allowing you to submit a block of code that should be run on a different thread, it is built on top of GCD. Basically, both GCD and operation roles are similar. However, operations have other benefits that give us more control over the task. OOP design: as the operation is a Swift class, you can subclass it and override its methods if need. It will be easy to use and re-use in the future. State management: An Operation has its own state machine that is changed during its lifecycle. The operation itself handles the changes of its states. We can not modify these states of an object. Dependency among operations: If you want to start a task after other tasks have finished executing, then the operation should be your choice. An operation will not start executing until all of the operations that it depends on have successfully finished their jobs. Cancel the submitted task: By using operations, we have the capability of canceling a running operation. It‚Äôs very useful in a case where we want to stop operations that are irrelevant at a certain time. For example, to cancel downloading data when the user scrolls the table making some cells disappear. Dependency and the capability of canceling making operations much more controllable over GCD. Take to practiceLet‚Äôs assume that we‚Äôre building an application that will fetch some posts of mine. After downloading the cover images, they will be applied a simple filter, then displayed in a table view.Go ahead and create a project. The project simply contains only one main screen with a table view that displays posts with a title and a cover image. To simplify the source of data, I created a JSON file that contains 100 rows describing a post with key as title and value as the url linked to the cover image. 123456789[ // input.json {\"Building your personal page with Hexo\": \"https://uynguyen.github.io/Post-Resources/Hexo/Cover.png\"}, {\"Beta Test and TestFlight\": \"https://uynguyen.github.io/Post-Resources/TestFlight/Cover.png\"}, {\"iOS: Mix and Match\": \"https://uynguyen.github.io/Post-Resources/MixMatch/mix-match-banner.png\"}, {\"Best practice: Core Data Concurrency\": \"https://uynguyen.github.io/Post-Resources/CoreDataConcurrency/banner.png\"}, {\"Two weeks at Fossil Group in the US\": \"https://uynguyen.github.io/Post-Resources/Fossil_Group/Fossil_Group.jpg\"}, ...] Inside the MainViewController, let‚Äôs read the input file 12345678910111213141516171819202122class ViewController: UIViewController { @IBOutlet weak var tbPosts: UITableView! var urls = [(title: String, url: String)]() override func viewDidLoad() { super.viewDidLoad() self.setup() // ... } func setup() { let inputUrl = Bundle.main.url(forResource: \"input\", withExtension: \"json\")! do { let data = try Data(contentsOf: inputUrl) if let jsonDict = try JSONSerialization.jsonObject(with: data) as? [[String: String]] { self.urls = jsonDict.map { ($0.first!.key, $0.first!.value) } } } catch { } } By using a simple function of CoreImage, the grayScale(input:) method will transform a UIImage to a black-white image with the Tonal filter 12345678910111213141516171819func grayScale(input: UIImage) -&gt; UIImage? { let context = CIContext(options: nil) var inputImage = CIImage(image: input) let filters = inputImage!.autoAdjustmentFilters() for filter: CIFilter in filters { filter.setValue(inputImage, forKey: kCIInputImageKey) inputImage = filter.outputImage } let cgImage = context.createCGImage(inputImage!, from: inputImage!.extent) let currentFilter = CIFilter(name: \"CIPhotoEffectTonal\") currentFilter!.setValue(CIImage(image: UIImage(cgImage: cgImage!)), forKey: kCIInputImageKey) let output = currentFilter!.outputImage let cgimg = context.createCGImage(output!, from: output!.extent) return UIImage(cgImage: cgimg!)} It‚Äôs time to set up the table view, we use URLSession to download the image from the input url, then display to the cell after downloading successfully. 1234567891011121314151617181920extension ViewController: UITableViewDataSource { // The rest omitted func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell { let cell = tableView.dequeueReusableCell(withIdentifier: \"CellId\", for: indexPath) as! PostTableViewCell let input = urls[indexPath.row] URLSession.shared.dataTask(with: URL(string: input.url)!, completionHandler: { (data, res, error) in guard error == nil, let data = data, let image = UIImage(data: data) else { return } DispatchQueue.main.async { cell.lblPostTitle.text = input.title cell.imgPostImage.image = self.grayScale(input: image) } }).resume() return cell }} Build and run the project, you should see the images appear on the list. Let‚Äôs try to scroll the table. Can you feel laggy?You might notice where the issue comes from. To set up a cell, we first download the image from the internet, then apply a Tonal filter to the image. These two actions are performing in the main thread, putting too much pressure on the thread that should only use for user interaction. Using GCDWe can dispatch the code of downloading and filtering image to another separated queue 12345678910111213DispatchQueue.global(qos: .background).async { URLSession.shared.dataTask(with: URL(string: input.url)!, completionHandler: { (data, res, error) in guard error == nil, let data = data, let image = UIImage(data: data) else { return } let filteredImage = self.grayScale(input: image) DispatchQueue.main.async { cell.lblPostTitle.text = input.title cell.imgPostImage.image = filteredImage } }).resume()} By executing the code on a background queue, we offload work to the main queue and make the UI much more responsive.Rebuild the project, you will see the differences.Even we resolve the issue of user interaction, the performance of the app is still not optimized.What can be done to make this better?As the user scrolls the table, cells come and gone. There‚Äôs no sense in continuing to download and process an image of an invisible cell. It‚Äôs better to cancel the block of code to improve the performance and reduce the battery consumption of the app. But how we can cancel a task that is running in GCD?Here is the Operation come to. Switch gear to OperationLet‚Äôs break the task to set up a table view cell into two tasks: one is to download the image and another is to apply the filter. 12345678910111213141516171819class DownloadImageOperation: Operation { let url: URL var outputImage: UIImage? init(url: URL) { self.url = url } override func main() { guard !isCancelled else { return } URLSession.shared.dataTask(with: self.url, completionHandler: { (data, res, error) in guard error == nil, let data = data else { return } self.outputImage = UIImage(data: data) }).resume() }} 123456789101112131415161718192021222324252627282930313233343536class ImageFilterOperation: Operation { let context = CIContext(options: nil) var processedImage: UIImage? func grayScale(input: UIImage) -&gt; UIImage? { var inputImage = CIImage(image: input) let filters = inputImage!.autoAdjustmentFilters() for filter: CIFilter in filters { filter.setValue(inputImage, forKey: kCIInputImageKey) inputImage = filter.outputImage } let cgImage = context.createCGImage(inputImage!, from: inputImage!.extent) let currentFilter = CIFilter(name: \"CIPhotoEffectTonal\") currentFilter!.setValue(CIImage(image: UIImage(cgImage: cgImage!)), forKey: kCIInputImageKey) let output = currentFilter!.outputImage let cgimg = context.createCGImage(output!, from: output!.extent) return UIImage(cgImage: cgimg!) } override func main() { guard !isCancelled else { return } let dependencyImage = self.dependencies .compactMap { $0 as? DownloadImageOperation } .first if let image = dependencyImage?.outputImage { guard !isCancelled else { return } self.processedImage = self.grayScale(input: image) } }} To use Operation, we simply subclass the Operation class and override the main method where our task is placed. By default, operations run in the background, so there are no worries about blocking the main thread.Back to the task to set up the table view cell, you might notice that there is a dependency between these two tasks, we only do the filter process after downloading the image. In other words, the ImageFilterOperation operation depends on the DownloadImageOperation operation. Operation Dependencies is one of the ‚Äúkiller functions‚Äù of Operation along with the capability of canceling a running operation. By linking the two operations, we ensure that the dependent operation does not begin before the prerequisite operation has completed. Additionally, the linking makes a clean way to pass data from the first one to the second one. 1234e.glet dependencyImage = self.dependencies .compactMap { $0 as? DownloadImageOperation } .first It‚Äôs time to do the improvement.Let‚Äôs first define an OperationQueue to the ViewController. The OperationQueue class is what we use to manage Operations. 123456789101112131415161718192021222324class ViewController: UIViewController { private let queue = OperationQueue() // The rest omiited // ... func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell { let cell = tableView.dequeueReusableCell(withIdentifier: \"CellId\", for: indexPath) as! PostTableViewCell let input = urls[indexPath.row] let downloadOpt = DownloadImageOperation(url: URL(string: input.url)!) let grayScaleOpt = ImageFilterOperation() grayScaleOpt.addDependency(downloadOpt) grayScaleOpt.completionBlock = { DispatchQueue.main.async { cell.lblPostTitle.text = input.title cell.imgPostImage.contentMode = .scaleToFill cell.imgPostImage.image = grayScaleOpt.processedImage } } self.queue.addOperation(downloadOpt) self.queue.addOperation(grayScaleOpt) return cell }} Here, we init two new instances of the DownloadImageOperation and the ImageFilterOperation classes. Then, we set grayScaleOpt operation depend to downloadOpt that will make sure the grayScaleOpt only be executed after the downloadOpt has completed. Finally, we add these two operations to the OperationQueue. Once an operation is added to the queue, the operation will be scheduled. If the queue finds an available thread on which to run the operation, the job will be executed until it has completed or been canceled. When the operation completes, the completionBlock is called. ‚ÄúOperations have important effects on your application‚Äôs performance. For instance, if you want to download a lot of content from the Internet, you might want to do so only when it is absolutely necessary. Also, you might decide to ensure that only a specific number of operations can run at the same time. If you do decide to limit the number of concurrent operations in a queue, you can change the maxConcurrentOperationCount property of your operation queue. This is an integer property that allows you to specify how many operations, at most, can run in a queue at a given time.‚Äù (iOS 8 Swift Programming Cookbook) Learning the above theories is enough, now re-build the project to see the result. Ops! Nothing appears, the image is not downloaded! Something went wrong ???In the next tutorial, we will find out what happened to our code and why the Operation did not work properly as expected.Thank you for reading.","link":"/2020/05/16/iOS-Concurrency-Operations/"},{"title":"iOS: Mix and Match","text":"As Swift has been becoming a flagship language for iOS development, most of the new iOS projects nowadays are built in Swift. However, there are many useful libraries are developed in other low-level programming languages such as Objective-C and / or C++ to boost performance. On the other hand, not all engineering positions are open to new projects, most of them are hired to maintain and develop new features based on the current code base that are built-in Objective-C.Having the knowledge to mix the two languages within a single project is good for your iOS development skills as you will face it someday in your career path. In this post, I‚Äôm going to show you not only how to use Objective-C and Swift in one single project but also how to use a set of programming languages in a single one, including C++/ Objective-C/ Swift and React Native. Hope you will find this post interesting.Let‚Äôs drive-in. C++ &lt;- Objective-C++For those who have not heard about Objective-C++,Objective-C++ is Objective-C is actually a source code that mixes Objective-C classes and C++ classes in one single file.You just need to change your .m file to .mm to get the magic worked.First, I will create a C++ library that will be used by Objective-C++ classes. 1234class CPlusPlusMath { public: int multiplyTwoNumbers(int a, int b);}; The implementation 123int CPlusPlusMath::multiplyTwoNumbers(int a, int b) { return a * b;} Then, you need to create a bridging header file to your project because our new project is in Swift language. The bridging header is where you define all the Objective-C classes that are exposed to Swift. When we add a new Objective-C class to the Swift code-based project, XCode automatically offers to add this file to the project.Next, you rename the .m file to .mm to change it from Objective-C code to Objective-C++.From now on, you can call to our C++ lib (or other ones) inside this Objective-C++ file 12345678#import \"CPlusPlusMath.hpp\"@implementation ObjMath- (long)multiplyTwoNumbers:(int) num1 num2:(int) num2 { CPlusPlusMath *a = new CPlusPlusMath(); return a-&gt;multiplyTwoNumbers(num1, num2);} Objective-C++ &lt;-&gt; SwiftThe interesting thing is we can call Objective-C(++) code from Swift code and vise versa.To use Objective-C classes from Swift, we need to declare their headers to the bridging header file. Let‚Äôs go ahead and include our mathematical library to this file. 12345//// Use this file to import your target's public headers that you would like to expose to Swift.//#include \"ObjMath.h\" That‚Äôs all you need to do to build the first line from Objective-C to Swift. 1234func multiply(num1: Int, num2: Int) -&gt; Int { let objMath = ObjMath() return objMath.multiplyTwoNumbers(Int32(num1), num2: Int32(num2))} Next, we need to build the other line from Swift to Objective-C.We use objc keyword before any classes and methods we want to expose to Objective-C classes. A small note is that these exposed classes need to be inherited from the NSObject class. Otherwiser, we will get the complile error Only classes that inherit from NSObject can be declared @objc. 123456789@objcclass SwifthMath: NSObject { @objc func add(num1: Int, num2: Int) -&gt; Int { return num1 + num2 } // The rest omited} Swift &lt;-&gt; React NativeLimitation Swift objects can have a subclass of an objective-c class, like NSObject. But a swift class cannot be a base class for an objective-c class. TroubleshootConclusionsMany developers are still using Objective-C for many reasons, and they definitely use C++ libraries in their projects, especially in Game development where C++ reaches full its performance.I hope that this post will give you a quick look at how to Mix and Match multiple languages in a single project.You can find the demonstration project at GithubThanks for reading.","link":"/2020/01/30/iOS-Mix-and-Match/"},{"title":"Best practice: Advanced BLE scanning process on iOS","text":"iOS developers are building applications that play both roles Peripheral and Central to exchange data with other copies apps. The data can be exchange a small of information via BLE packets or the signal strength indicator (RSSI) value from one to the others. However, keeping the app last forever in the foreground is impossible. Sooner or later, the app will enter to background mode by the user and finally will be suspended by the system depending on RAM available, power consumption and other factors. Thus, understanding the procedure of advertising and scanning on iOS devices helps you to build good applications that fit your expectations.At the end of this tutorial, we will build a simple application that acts as both a scanner and an advertiser. When two applications find each other, they will write a log record for analysis. Depending on the results, we will find out how effective our application is using Core Bluetooth.Let‚Äôs switch the gear! Foundational knowledgeAccording to the Getting Started With Bluetooth Low Energy book, the two main purposes of advertising packets are: To broadcast data for applications. To discover slaves and to connect them. The maximum size of payload each advertising packet is 31 bytes, along with the header information. Every elapsed interval, which ranges from 20ms to 10.24s, advertising packets are broadcasted blindly to notify its presence to other devices or applications. There are two types of scanning approaches: Passive Scanning: Scanners simply receives advertising packets without any further actions. Active Scanning: After receiving an advertising packet, the scanner performs a Scanning Request packet to the advertiser. After receiving the Scanning Request, the advertiser responds with a Scanning Response packet which allows the advertises to send extra data (Extra 31 bytes) to the scanner. To classify advertising packet types, we rely on three properties: connectability, scannability, and directability Adv packet type Connectability: Determines if a scanner can make a connection or not Scannability: Determines if a scanner can issue a scan request or not Directability: Determines if this packet is targeted at any particular scanners or not. ADV_IND Yes Yes No ADV_DIRECT_IND Yes No Yes ADV_NONCONN_IND No No No ADV_SCAN_IND No Yes No There are a lot more advanced topics that described in more detail in the Getting Started With Bluetooth Low Energy book, such as how data is organized in BLE devices and how to communicate with existing hardware, etc. If you want to know more, please refer to the book.Because of the scope of this post, understanding of the advertising process is good enough for us to move to the next section. Scanning and advertising on iOSSetting up the advertiser - PeripheralWe‚Äôre going to reuse my previous repo allowing an ios phone advertises as a peripheral using Core Bluetooth.First, I will generate 5 UUIDs as the services of the advertiser (Peripheral). 1234let kServiceUUID1 = \"1FA2FD8A-17E0-4D3B-AF45-305DA6130E39\"...let kServiceUUID4 = \"4FA2FD8A-17E0-4D3B-AF45-305DA6130E39\"let kServiceUUID5 = \"5FA2FD8A-17E0-4D3B-AF45-305DA6130E39\" Next, I will create a list of CBMutableService and then add them to the CBPeripheralManager object. 12345678910111213141516services.forEach { (each) in let cbService = CBMutableService(type: each.uuid.cbUUID, primary: true) var charArr = [CBMutableCharacteristic]() each.characteristics.forEach { (char) in charArr.append(CBMutableCharacteristic.init( type: char.uuid.cbUUID, properties: [.read, .write, .notify], value: nil, permissions: CBAttributePermissions(char.permissions.map { $0.cbAttributePermission } ))) } cbService.characteristics = charArr self.peripheralManager.add(cbService)} Finally, we start advertising the peripheral when its state gets ready. 12self.peripheralManager.startAdvertising([CBAdvertisementDataLocalNameKey: \"uynguyen\", CBAdvertisementDataServiceUUIDsKey: self.cbServices.map { $0.uuid }]) As the above code gets executed, we will see the following log are printed. 123456789101112Add service 1FA2FD8A-17E0-4D3B-AF45-305DA6130E39 Succeeded---&gt; Chars [&lt;CBMutableCharacteristic: 0x2802d4070 UUID = 463FED20-DA93-45E7-B00F-B5CD99775150, Value = (null), Properties = 0x1A, Permissions = 0x3, Descriptors = (null), SubscribedCentrals = ()&gt;, &lt;CBMutableCharacteristic: 0x2802d4380 UUID = 463FED21-DA93-45E7-B00F-B5CD99775150, Value = (null), Properties = 0x112, Permissions = 0x1, Descriptors = (null), SubscribedCentrals = ()&gt;, &lt;CBMutableCharacteristic: 0x2802d4620 UUID = 463FED22-DA93-45E7-B00F-B5CD99775150, Value = {length = 6, bytes = 0x486168616861}, Properties = 0x2, Permissions = 0x1, Descriptors = (null), SubscribedCentrals = ()&gt;]...Add service 5FA2FD8A-17E0-4D3B-AF45-305DA6130E39 Succeeded---&gt; Chars []===&gt; Start advertising Succeeded Setting the scanner - CentralThe next step is to set up our Central Manage - the scanner. As you might know from my previous tutorial, the code to scan nearby devices is quite simple. 1234private func startScanning() { self.centralManager?.scanForPeripherals(withServices: nil, options: [CBCentralManagerScanOptionAllowDuplicatesKey: true])} The nil value we pass to withServices param indicates that we will scan all nearby devices without specifying service uuids. The CBCentralManagerScanOptionAllowDuplicatesKey option specifies the scan should run without duplicate filtering. Once the central discover a peripheral, we will print its info including the local name and the CBAdvertisementDataServiceUUIDsKey value in the advertising packet. 12345public func centralManager(_ central: CBCentralManager, didDiscover peripheral: CBPeripheral, advertisementData: [String : Any], rssi RSSI: NSNumber) { print(\"Did found per \\(peripheral.name)\") print(\"CBAdvertisementDataServiceUUIDsKey adv value \" + advertisementData[CBAdvertisementDataServiceUUIDsKey])// ...} Let‚Äôs build and run the project, 12345Did found peripheral name: Optional(\"Uy Nguyen iPad\")CBAdvertisementDataServiceUUIDsKey adv value:Optional(&lt;__NSArrayM 0x282a79350&gt;( 1FA2FD8A-17E0-4D3B-AF45-305DA6130E39)) Looking at the log, can you spot what‚Äôs going wrong? There is a problem with the advertising packet: the CBAdvertisementDataServiceUUIDsKey value contains only 1 service, where are the other services from 2 to 5? Let‚Äôs print out full advertising packet to see what it contains. 1234[\"kCBAdvDataServiceUUIDs\": &lt;__NSArrayM 0x283460630&gt;(1FA2FD8A-17E0-4D3B-AF45-305DA6130E39), \"kCBAdvDataLocalName\": uynguyen, \"kCBAdvDataTimestamp\": 620013184.4512661, \"kCBAdvDataRxPrimaryPHY\": 0, \"kCBAdvDataIsConnectable\": 1, \"kCBAdvDataRxSecondaryPHY\": 0] Still no luck, we can not find the other services from &quot;2FA2FD8A-17E0-4D3B-AF45-305DA6130E39&quot; to &quot;5FA2FD8A-17E0-4D3B-AF45-305DA6130E39&quot;. Finding problemsIt turns out the advertising packet the Central receive depends on how we call scanForPeripherals method.If we change param withServices to an array of our service from &quot;1FA2FD8A-17E0-4D3B-AF45-305DA6130E39&quot; to &quot;5FA2FD8A-17E0-4D3B-AF45-305DA6130E39&quot; explicitly, we will see the differences. 12345678private func startScanning() { self.centralManager?.scanForPeripherals(withServices: [CBUUID(string: \"1FA2FD8A-17E0-4D3B-AF45-305DA6130E39\"), CBUUID(string: \"2FA2FD8A-17E0-4D3B-AF45-305DA6130E39\"), CBUUID(string: \"3FA2FD8A-17E0-4D3B-AF45-305DA6130E39\"), CBUUID(string: \"4FA2FD8A-17E0-4D3B-AF45-305DA6130E39\"), CBUUID(string: \"5FA2FD8A-17E0-4D3B-AF45-305DA6130E39\")], options: [CBCentralManagerScanOptionAllowDuplicatesKey: true])} Here is the log that comes to. 12345678910[\"kCBAdvDataIsConnectable\": 1, \"kCBAdvDataServiceUUIDs\": &lt;__NSArrayM 0x280708750&gt;(1FA2FD8A-17E0-4D3B-AF45-305DA6130E39), \"kCBAdvDataLocalName\": uynguyen, \"kCBAdvDataRxSecondaryPHY\": 0, \"kCBAdvDataHashedServiceUUIDs\": &lt;__NSArrayM 0x280708720&gt;(2FA2FD8A-17E0-4D3B-AF45-305DA6130E39,3FA2FD8A-17E0-4D3B-AF45-305DA6130E39,4FA2FD8A-17E0-4D3B-AF45-305DA6130E39,5FA2FD8A-17E0-4D3B-AF45-305DA6130E39), \"kCBAdvDataRxPrimaryPHY\": 0, \"kCBAdvDataTimestamp\": 620013608.239601] Now, we can see the new value contained inside the advertising packet, the kCBAdvDataHashedServiceUUIDs. But what is it?Let‚Äôs back to the Peripheral side, if you look closer to the definition of the advertising method of Peripheral object, you might know what it actually is. In short, when you make an iPhone advertise as a peripheral, if there is no space for any services UUIDs contained in the value of CBAdvertisementDataServiceUUIDsKey, these services will be moved to another space called overflow area. Another term, T_T What does exactly the overflow area mean?Basically, the overflow area is placed in the scan response packet. These service uuids are hashed by Apple alg and are discovered only by an iOS device explicitly scanning for them. In our case, because we pass our service uuids from 1F to 5F when start scanning, we will get this kCBAdvDataHashedServiceUUIDs value in the advertising packets. To verify this statement, I use a tool introduced by Apple for BLE debugging - (A New Way to Debug iOS Bluetooth Applications), to grab the advertising packet from our Peripheral for analyzing.And here is the result Advertising packet type: ADV_IND, which means the scanner can make a connection to it; and a scanner can issue a scan request; and its packets do not target at any particular scanners. The yellow box is the advertising data: (Data: 02 01 1A 11 06 39 0E 13 A6 5D 30 45 AF 3B 4D E0 17 8A FD A2 1F 09 09 75 79 6E 67 75 79 65 6E), length = 31 bytes; it contains CBAdvertisementDataLocalName (75 79 6E 67 75 79 65 6E &gt; ‚Äúuynguyen‚Äù) and our first service uuid 1F A2 FD 8A 17 E0 4D 3B AF 45 30 5D A6 13 0E 39 (39 0E 13 A6 5D 30 45 AF 3B 4D E0 17 8A FD A2 1F). The scan response packet (SCAN_RSP) contains the other info that the advertising packet is not enough length to carry on. In our case, it contains the other services from 2F to 5F. Understanding this packet is quite complex to put in this tutorial so I will skip explaining it for now. I have another tutorial working on this packet later. In conclusion, what we have found here is: Advertising, while the app is in background, performs differently than when it is in the foreground. CBAdvertisementDataLocalNameKey is ignored. All service UUIDs contained in the value of the CBAdvertisementDataServiceUUIDsKey advertisement key are placed in a special ‚Äúoverflow‚Äù area; they can be discovered only by an iOS device that is explicitly scanning for them. TestingThe table below summarizes what we have investigated. 1* YES means the Central is able to find the Peripheral. Case 1 - Both Peripheral and Central‚Äôs screens turn on \\ Peripheral Background Peripheral Foreground Central Background Yes Yes Central Foreground Yes Yes Case 2 - Peripheral‚Äôs screen turn off (locked), Central‚Äôs screen turn on \\ Peripheral Background Peripheral Foreground Central Background Yes Yes Central Foreground Yes Yes Case 3 - Central‚Äôs screen turn off (locked), Peripheral‚Äôs screen turn on \\ Peripheral Background Peripheral Foreground Central Background No No Central Foreground No No Case 4 - Both Peripheral and Central‚Äôs screens turn off (locked) \\ Peripheral Background Peripheral Foreground Central Background No No Central Foreground No No From the above experiments, regardless of the state of the device playing Peripheral role, the screen of the device playing Central mode must turn on so that it can scan nearby peripherals. In other words, if we‚Äôre building an application that allows an iOS device to discover other nearby iOS devices, we have to run both Central and Peripheral modes on each device AND the most important, if two devices want to find each other, either the screen must be turned on.There is a technique (It‚Äôs likely a trick) to get over this issue, is that scheduling periodically to push notifications to your iOS devices, which immediately turn the screen on so that the Central can discover nearby Peripherals.While the app is in background, it performs differently than when it is in the foreground. One of them is the frequency of advertising packets to be sent may decrease. As a result, a Scanner in background finds nearby peripherals is slower compared to when it is in foreground. ConclusionCongratulation! We walked through a tutorial to get a deeper view of how CoreBluetooth on iOS works in both Central and Peripheral modes. Hope you find this post interested!If you have any comments, feel free to send me an email to uynguyen.itus@gmail.com or leave your questions on the comment box. Made with love.","link":"/2020/08/23/Best-practice-Advanced-BLE-scanning-process-on-iOS/"},{"title":"Best practice: iOS background processing - Background App Refresh Task","text":"Unlike Android, iOS has restrictions for the use of background processing in an attempt of improving battery life and user experience. When your apps enter to background mode, it‚Äôs time developers get out of control of their app. How and when your app gets a chance to execute your task totally depends on the system. At the heart of iOS, Apple uses its own internally-complex algorithm to determines which apps are allowed to run in the background, based on various factors such as the pattern of user activity, current battery state, etc.In this tutorial, we will learn how to request periodic execution time on iOS. After understanding how it works, we will apply this technique to a BLE-based app in some specific cases in the next tutorial.Let‚Äôs rock! Foundational knowledgeBefore taking deep dive into practice, it‚Äôs good to understand how iOS manages application states. It‚Äôs been the first time Apple officially announces a video that describes top factors contributing to the app launch times at WWDC (WWDC 2020 - Background execution demystified). To summarize, Apple designs iOS in a way allowing applications to keep its content up to date on one hand. On the other hand, iOS must adapt to its major goals: Battery life: allowing background execution while maintaining all-day battery life. Performance: ensure background execution does not have any negative effect on active usage. Privacy: Users should be aware of background tasks based on their particular usage patterns. Respecting user intent: if a user takes a certain action, make sure the system responds to correctly. With these goals in mind, here are the top 7 factors that play a role in system scheduling of background execution. Critical low battery: When the phone is about to run out of battery (&lt; 20%), background execution will be pause by the system to avoid battery usage. Low power mode: When users change to phone to low power mode, the user explicitly indicates that the system should preserve battery for critical tasks only. Background App refresh setting: The user can toggle the setting to allow or not a specified app can run background tasks. App usage: There is a limit of resources on the phone so that the system must priorities which apps it should allocate resources for. Typically, apps that the user uses the most. Apple also mentioned to ‚ÄúOn-device predictive engine‚Äù that learns which apps the user often uses and when. The on-device predictive engine will rely on this information to priorities background execution. App switcher: Only apps are visible in App Switcher have opportunities to run background tasks. System budget: Ensure background activities do not drain battery and data plans, there is a limit of battery and data of background execution throughout the day. Rate limit: The system performs sone rate-limiting per launch. and some other factors: Airplane mode, device temperature, display, device lock state, etc. CapabilitiesMake sure your app has added these following capabilities Prior to iOS 13It‚Äôs quite simple to set up a background fetch prior to iOS 13.Inside the application(_:didFinishLaunchingWithOptions) method, we should add the following command. 1UIApplication.shared.setMinimumBackgroundFetchInterval(UIApplication.backgroundFetchIntervalMinimum) The setMinimumBackgroundFetchInterval specifies the minimum amount of time that must elapse between background fetch executions. However, the exact timing of the event is up to the system. Generally, UIApplicationBackgroundFetchIntervalMinimum is a good default value to use. Once your app has a chance to perform background tasks, the event application(_:,performFetchWithCompletionHandler) will be triggered. 1234func application(_ application: UIApplication, performFetchWithCompletionHandler completionHandler: @escaping (UIBackgroundFetchResult) -&gt; Void) { Logger.shared.debug(\"\\(Date().toString()) perfom bg fetch\") completionHandler(.newData)} Don‚Äôt forget to call completionHandler callback. If you do not call this callback, the system does not aware your task has been completed, which leads to limiting your app from waking up on the next events To simulate background fetch, from the tab bar &gt; Debug &gt; Simulate background fetch. Note that it works only when running on real devices. iOS 13+, Advance Background processing - WWDC 2019 and Background execution demystified - WWDC 2020At WWDC 2019, Apple introduced a new framework for scheduling background work: BackgroundTasks. This new framework does better support for tasks that are needed to be done in the background. There are two kinds of tasks supported by BackgroundTasks framework: BGAppRefreshTaskRequest, and BGProcessingTaskRequest. With the presence of the new framework, Apple marked deprecated on the old one from iOS 13, and no longer support on MacOS.Firstly, we have to register the identifiers of background tasks executed in our app. Open info.plist file, and add the following information. 12345&lt;key&gt;BGTaskSchedulerPermittedIdentifiers&lt;/key&gt;&lt;array&gt; &lt;string&gt;YOUR_REFRESH_TASK_ID&lt;/string&gt; &lt;string&gt;YOUR_PROCESSING_TASK_ID&lt;/string&gt;&lt;/array&gt; Forget the above step leading to a crash at runtime. 12020-10-11 08:24:40.648838+0700 TestBgTask[275:5188] *** Terminating app due to uncaught exception 'NSInternalInconsistencyException', reason: 'No launch handler registered for task with identifier com.example.bgRefresh' BGAppRefreshTaskRequest is used when you need to execute a task in the background in a short time.Refresh tasks like fetching social media feed, new emails, latest stock prices, etc are appropriate to schedule by BGAppRefreshTaskRequest. 30s is the time the system allows your task to execute per launch. Several minutes of run times to finish your work when you register a BGProcessingTaskRequest. Tasks such as Core ML training on the device should be registered by a BGProcessingTaskRequest. To register background tasks, inside the application(_:didFinishLaunchingWithOptions) method, we should add the following command. 1234567891011121314151617181920212223242526272829303132333435363738394041424344 func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -&gt; Bool { if #available(iOS 13, *) { BGTaskScheduler.shared.register(forTaskWithIdentifier: appRefreshTaskId, using: nil) { task in Logger.shared.info(\"[BGTASK] Perform bg fetch \\(appRefreshTaskId)\") task.setTaskCompleted(success: true) self.scheduleAppRefresh() } BGTaskScheduler.shared.register(forTaskWithIdentifier: appProcessingTaskId, using: nil) { task in Logger.shared.info(\"[BGTASK] Perform bg processing \\(appProcessingTaskId)\") task.setTaskCompleted(success: true) self.scheduleBackgroundProcessing() } } } @available(iOS 13.0, *) func scheduleAppRefresh() { let request = BGAppRefreshTaskRequest(identifier: \"YOUR_REFRESH_TASK_ID\") request.earliestBeginDate = Date(timeIntervalSinceNow: 5 * 60) // Refresh after 5 minutes. do { try BGTaskScheduler.shared.submit(request) } catch { print(\"Could not schedule app refresh task \\(error.localizedDescription)\") } } @available(iOS 13.0, *) func scheduleBackgroundProcessing() { let request = BGProcessingTaskRequest(identifier: appProcessingTaskId) request.requiresNetworkConnectivity = true // Need to true if your task need to network process. Defaults to false. request.requiresExternalPower = true // Need to true if your task requires a device connected to power source. Defaults to false. request.earliestBeginDate = Date(timeIntervalSinceNow: 5 * 60) // Process after 5 minutes. do { try BGTaskScheduler.shared.submit(request) } catch { print(\"Could not schedule image fetch: (error)\") } }} One more thing that needs to be done. When the app enters to the background, we will start scheduling background tasks. 1234567func applicationDidEnterBackground(_ application: UIApplication) { Logger.shared.info(\"App did enter background\") if #available(iOS 13, *) { self.scheduleAppRefresh() self.scheduleBackgroundProcessing() }} As always, It‚Äôs important to call task.setTaskCompleted(success: true) as quick as possible.You might notice that after calling task.setTaskCompleted(success: true), we need to call self.scheduleAppRefresh() and self.scheduleBackgroundProcessing() again to re-schedule these tasks to the system. Simulate background task and background processingFortunately, Apple supports a way to trigger background execution.After submitting your task to the system, pause the application by any break point. Then, enter the following command to the Xcode console. 1e -l objc -- (void)[[BGTaskScheduler sharedScheduler] _simulateLaunchForTaskWithIdentifier:@\"YOUR_REFRESH_TASK_ID || YOUR_PROCESSING_TASK_ID\"] The output should be 12345672020-10-11 08:53:58.628667+0700 TestBgTask[381:17115] üíö-2020-10-11 08:53:58.628 +0700 Start schedule app refresh(lldb) e -l objc -- (void)[[BGTaskScheduler sharedScheduler] _simulateLaunchForTaskWithIdentifier:@\"com.example.bgRefresh\"]2020-10-11 08:54:01.927263+0700 TestBgTask[381:16973] Simulating launch for task with identifier com.example.bgRefresh2020-10-11 08:54:03.669153+0700 TestBgTask[381:17095] Starting simulated task: &lt;decode: missing data&gt;2020-10-11 08:54:07.560697+0700 TestBgTask[381:17095] Marking simulated task complete: &lt;BGAppRefreshTask: com.example.bgRefresh&gt;2020-10-11 08:54:07.560750+0700 TestBgTask[381:17012] üíô-2020-10-11 08:54:06.045 +0700 [BGTASK] Perform bg fetch com.example.bgRefresh2020-10-11 08:54:07.563846+0700 TestBgTask[381:17012] üíö-2020-10-11 08:54:07.562 +0700 Start schedule app refresh Expectation vs RealityYou might expect that background execution would be evenly distributes through out the day. However, here is what we observe in reality. Because of the 7 factors I introduced at the beginning of this tutorial, the ‚ÄúOn-device predictive engine‚Äù learns the user usage pattern and understands that the user typically opens the app in the morning, lunchtime, and in the evening. That‚Äôs why the system will allow your background tasks to launch just before the user foregrounds the app. Other factors that affect the result are if the user toggled ‚ÄúLow power mode‚Äù, or if the phone fell into the critical low battery state. Best advices Background tasks will not be run until the first device unlocks after the reboot. We can check if the user is in low power mode:12ProcessInfo.processInfo.isLowPowerModeEnabledNSProcessInfoPowerStateDidChange We also can check the ‚Äúbackground refresh setting‚Äù status.12UIApplication.shared.backgroundRefreshStatusUIApplication.backgroundStatusDidChangeNotification Minimize data usage: Using thumbnails instead of full images, and only download what‚Äôs really necessary. Minimize power consumption: avoid unnecessary hardware usage such as GPS, accelerometer, etc. Also, make sure you complete the task as soon as possible. Use BackgroundURLSession to offload the work from the app to the system. SummaryIn this post, we take a deep dive into what factors contributed to your background executions, and understand are key differences between BGAppRefreshTaskRequest and BGProcessingTaskRequest. We also take a demo project to see how it actually works in reality.Next time, you can choose what kind of request is most appropriate to your tasks, and how you can respond gracefully to your user‚Äôs intent.Hopefully, the information that this post brings in helps you build better applications: freshness and optimization.There is another technique to wake your app up, silent notification. We will talk about it in the next tutorial.Happy weekend! References Background execution demystified WWDC 2020 Advances in App Background Execution WWDC 2019","link":"/2020/09/26/Best-practice-iOS-background-processing-Background-App-Refresh-Task/"},{"title":"Review book: RxSwift Reactive Programming with Swift","text":"","link":"/2020/09/26/Review-book-RxSwift-Reactive-Programming-with-Swift/"},{"title":"WWDC 2020 - Key Note Series: Top reasons why app get killed in background","text":"Ever wonder why your app gets killed from the system when it enters to the background? This post is going to summarize are introduced by Apple in WWDC 2020.","link":"/2020/09/30/WWDC-2020-Key-Note-Series-Top-reasons-why-app-get-killed-in-background/"}],"tags":[{"name":"Swift","slug":"Swift","link":"/tags/Swift/"},{"name":"iOS","slug":"iOS","link":"/tags/iOS/"},{"name":"Concurrency","slug":"Concurrency","link":"/tags/Concurrency/"},{"name":"Operations","slug":"Operations","link":"/tags/Operations/"},{"name":"Core Data","slug":"Core-Data","link":"/tags/Core-Data/"},{"name":"BLE","slug":"BLE","link":"/tags/BLE/"},{"name":"iBeacon","slug":"iBeacon","link":"/tags/iBeacon/"},{"name":"Objective-C","slug":"Objective-C","link":"/tags/Objective-C/"},{"name":"CoreBluetooh","slug":"CoreBluetooh","link":"/tags/CoreBluetooh/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"Vendor","slug":"Vendor","link":"/tags/Vendor/"},{"name":"Study","slug":"Study","link":"/tags/Study/"},{"name":"Design Patterns","slug":"Design-Patterns","link":"/tags/Design-Patterns/"},{"name":"UML","slug":"UML","link":"/tags/UML/"},{"name":"Software Architecture","slug":"Software-Architecture","link":"/tags/Software-Architecture/"},{"name":"DispatchQueue","slug":"DispatchQueue","link":"/tags/DispatchQueue/"},{"name":"macOS","slug":"macOS","link":"/tags/macOS/"},{"name":"Cocoa","slug":"Cocoa","link":"/tags/Cocoa/"},{"name":"Memory management","slug":"Memory-management","link":"/tags/Memory-management/"},{"name":"ReactNative","slug":"ReactNative","link":"/tags/ReactNative/"},{"name":"CrossPlatform","slug":"CrossPlatform","link":"/tags/CrossPlatform/"},{"name":"books","slug":"books","link":"/tags/books/"},{"name":"study","slug":"study","link":"/tags/study/"},{"name":"Books","slug":"Books","link":"/tags/Books/"},{"name":"Conference","slug":"Conference","link":"/tags/Conference/"},{"name":"UI","slug":"UI","link":"/tags/UI/"},{"name":"UIStackView","slug":"UIStackView","link":"/tags/UIStackView/"}],"categories":[]}