{"pages":[{"title":"About","text":"I’m Uy Nguyen.I’m a Software Engineer, creating awesome and effective softwares to serve people around the world.Let’s start scrolling and learn more about me. Education:University of Science - Vietnam National UniversityBachelor in Software Engineering, GPA 8.86 / 10.0Thesis: Web-based IDE for collaborating programming.This system allows users to create projects, build, run and debug applications online with an IDE that supports three majors programming languages: C/C++, C#, and Java. If there are any problems while development, users can post questions linked to their projects, other members will help them to solve the problems by answering the questions directly. By using this system, users will not have to spend time installing IDEs on their computers and reducing debugging time thanks to the help of the community. ProjectsClue: Construction ManagementClue App allows users to control equipment and construction projects in a single platform; generate real-time insights and performance reports to maximize the productivity of the operation.Link to App Store (React Native)Link to Google Play (React Native) Software Development Kit – Fossil GroupThe Fossil App is the companion app for Fossil’s line of smartwatches. Receive alerts from your favorite contacts and apps, compare multiple time zones and track everything from steps to sleep through the app. Turn your smartwatch into a remote control with customizable buttons that can control your music, check your commute time and more.As a Device Integration Engineer, I develop an SDK built in Bluetooth Low Energy technology in iOS. The SDK lets the application communicate with smartwatches or trackers.Link to App Store (iOS Native, Swift / Objective-C, CoreBluetooth) Dark Hat (Side project)An iOS BLE tool written in Swift supports test and control BLE devices.Link to App Store (iOS Native, Swift) Ayobody (Side project)Fitness social app connects users to Personal Nutrition Coach.Provide Personal Meal Plan: Craft a personal nutrition plan, get recommendations and track progress of users.Link to App Store (React Native)Link to Google Play (React Native) HTVC Calendar (Side project)HTV Calendar was built in React Native. It provides information of TV shows and events in Vietnam every day. It also allows users to add/edit/remove personal notes including notification feature.Link to App Store (React Native)Link to Google Play (React Native) News Market (Side project)News Market is the place to sell news between news hunters and media channels or newspapers.Website (ReactJs): http://chotintuc.htvc.com.vn Link to App Store (iOS Native, Swift)Link to Google Play (Android Native, Kotlin) Working Experiences: Senior Software Engineer at CLUEClue app allows users to manage construction projects and equipment by providing real-time insights in one platform.Detailed achievements: Develop Clue application in React Native. Build a native Bluetooth module to track equipment using BLE. Work directly with CTO and Product Owner to research new features. Support to develop web app in React and back-end side in Python. Device Integration Engineer at Fossil Vietnam - MisfitDesign and implement software components to talk with Misfit/Fossil smartwatches, trackers and other wearable products.Detailed achievements: Develop advanced services and SDK (Software Development Kit) on iOS platform to work with Bluetooth Low Energy in Swift and Objective-C. Build iOS apps to demonstrate SDK’s functions. Analyzing and solving problems of the SDK by using Fabric, Firebase. Build an automation testing system: Support create test cases and run them automatically, then report the result in NodeJs and ReactJs. Continuously investigate new technologies and new frameworks to improve the library Former internship, Full stack developer, taembe.comWork with NodeJs and ReactJs.Detailed achievements: Work on implementing features and improving the back-end side in NodeJs. Work on Implementing and maintaining the front-end code in ReactJs. Work with database in CouchDB, PouchDB and MySQL. Former internship at Renesas Design VietnamWork on embedded system and embedded architecture.Detailed achievements: Develop and verify eight modules of RX chip series: I2C Bus Interface, CRC Calculator,D/A Converter, Data Operation Circuit, Data Transfer Controller, 8 Bit Timer, Compare Match Timer, Clock Frequency Accuracy Measurement Circuit. Technical Stacks: Solid computer science fundamentals with good knowledge of algorithms, data structure and design patterns. Proficiency in mobile development: React Native, iOS (Swift) and Android (Kotlin) Deep understanding of memory management and multi-threading, including GCD, blocks and dispatch queues. Familiar with iOS SDKs (UIKit, Cocoa Touch, Core Data, Core Location, Core Bluetooth). Deep understanding of RESTful API designs. Experience building web apps in NodeJs, ReactJs, and Python. Familiarity with continuous integration (Jenkins), application monitoring (Firebase, Sentry). Experience developing applications on EC2. Familiar with Alatsian, Jira and Agile software development.","link":"/about/index.html"},{"title":"Todo Sobre Alamofire","text":"Si alguna vez has tenido la oportunidad de trabajar con redes en iOS, definitivamente has escuchado sobre Alamofire, una biblioteca de redes escrita en Swift para iOS y MacOS. Simplifica todos los trabajos de red comunes en tu aplicación.Si aún no has conocido Alamofire, no te preocupes, este tutorial te presentará todas las tareas que Alamofire puede manejar por ti. Si ya estás familiarizado con él, no importa, toma esta publicación como un resumen y una centralización de tu manual de Alamofire.¡Vamos a sumergirnos! Próximamente! Construye tu propio servidorDiseña la capa de redDependencias SwiftyJSON, una biblioteca que ayuda a trabajar con datos JSON. [SnapKit][https://github.com/SnapKit/SnapKit], Autolayout basado en Swift. Tema avanzadoReflexión final","link":"/es/posts/All-About-Alamofire/index.html"},{"title":"ANCS: Apple Notification Center Service","text":"PrefacioANCS, que significa Apple Notification Center Service, fue diseñado por Apple. Permite que los accesorios Bluetooth que se conectan a dispositivos iOS a través de BLE tengan una forma sencilla de acceder a las notificaciones que ocurren en los dispositivos iOS. Detalles técnicos","link":"/es/posts/ANCS-Apple-Notification-Center-Service/index.html"},{"title":"Programación Asíncrona en Swift","text":"Promise Kit, uno de los mejores frameworks para manejar programación asíncrona en Swift En esta publicación, usaré las siguientes librerías de terceros para completar el proyecto: Alamofire: Un framework de redes HTTP en Swift. SwiftyJSON: Para procesar datos JSON. SwiftGifOrigin: Una extensión de UIImage para mostrar archivos Gif. Bolts-Swift: Fue diseñado por Parse y Facebook, lo uso para crear métodos asíncronos. PromiseKit: Un framework que nos ayuda a simplificar la programación asíncrona. APIs de Giphy para buscar y descargar imágenes gif. Comenzando Los métodos asíncronos, (Async para abreviar), son métodos que no retornan resultados inmediatamente como la mayoría de los métodos, los métodos async toman algo de tiempo para producir resultados.A menudo uso callbacks para manejar métodos asíncronos como escanear dispositivos Bluetooth o recuperar algunos recursos de internet. De hecho, callback es una técnica de programación mala. Callback hará que nuestro código sea difícil de leer, difícil de depurar y tome mucho más tiempo para mantener después. Al final, nuestro código se convertirá en algo que llamamos el infierno de callbacks.En esta publicación, crearé un proyecto usando una técnica a la vez para explicar por qué dije que callback es malo.Primero, ve y crea un proyecto, nómbralo como quieras, luego instala estos frameworks de Pod en tu proyecto. También necesitas editar la clave NSAllowsArbitraryLoads a YES en el diccionario NSAppTransportSecurity en el archivo info.plist para especificar qué dominios están exceptuados de las reglas que defines para App Transport Security. En nuestro caso, este es el dominio de giphy. Permitir solicitudes HTTP solo para el dominio de giphy 1234567891011&lt;key&gt;NSAppTransportSecurity&lt;/key&gt; &lt;dict&gt; &lt;key&gt;NSExceptionDomains&lt;/key&gt; &lt;dict&gt; &lt;key&gt;api.giphy.com&lt;/key&gt; &lt;dict&gt; &lt;key&gt;NSExceptionAllowsInsecureHTTPLoads&lt;/key&gt; &lt;true/&gt; &lt;/dict&gt; &lt;/dict&gt;&lt;/dict&gt; O permitir solicitudes HTTP para todos los dominios, no es una buena idea. 12345&lt;key&gt;NSAppTransportSecurity&lt;/key&gt;&lt;dict&gt; &lt;key&gt;NSAllowsArbitraryLoads&lt;/key&gt; &lt;true/&gt;&lt;/dict&gt; Creemos una clase llamada ImageLoader. Esta clase contiene dos métodos que nos ayudan a buscar y descargar imágenes gif del servidor de Giphy. 123456789101112//// ImageLoader.swift//class ImageLoader { func fetchImage(keyword: String) { // Buscando imágenes que coincidan con la palabra clave en el servidor de Giphy } func downloadImage(url: URL) { // Descargar la imagen en la url }} La primera versión: Usando callbackPrimero, necesitamos definir dos callbacks, que se pasarán a los métodos fetchImage y downloadImage. 12public typealias FetchImageBlock = (URL?, Error?) -&gt; Voidpublic typealias DownloadImageBlock = (URL?, Error?) -&gt; Void Luego, implementamos estos dos métodos: fetchImage toma una palabra clave y un callback como parámetros, envía una solicitud al servidor de Giphy para consultar todas las imágenes que coinciden con la palabra clave, obtiene la primera y finalmente retorna la url de descarga a través del callback. downloadImage toma una url y un callback como parámetros, luego usa el framework Alamofire para descargar la imagen. Finalmente, retorna la url de destino, donde se guarda la imagen, a través del callback. 123456789101112131415161718192021func fetchImage(keyword: String, callback: @escaping FetchImageBlock) { let endPoint = \"http://api.giphy.com/v1/gifs/search?q=\\(keyword)&amp;limit=1&amp;api_key=q4N1oD5jw3xvH2hIOkFAyHXWTTrh0D30\" let headers: HTTPHeaders = [ \"Content-Type\": \"application/json\" ] Alamofire.request(endPoint, headers: headers).responseData { (response) in if let error = response.error { return callback(nil, error) } let jsonData = JSON.init(data: response.data!) let dataArray = jsonData[\"data\"].array if let dataArray = dataArray, dataArray.count &gt; 0 { let imagesList = dataArray[0][\"images\"] let downsized_large = imagesList[\"downsized_large\"][\"url\"].stringValue return callback(URL.init(string: downsized_large), nil) } else { return callback(nil, nil) } }} 123456789101112131415func downloadImage(url: URL, callback: @escaping DownloadImageBlock) { let destination: DownloadRequest.DownloadFileDestination = { _, _ in let documentsURL = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)[0] let fileURL = documentsURL.appendingPathComponent(url.lastPathComponent) return (fileURL, [.removePreviousFile, .createIntermediateDirectories]) } Alamofire.download(url, to: destination).downloadProgress(closure: { (progress) in print(\"\\(progress)\") }).responseData(completionHandler: { (response) in if let error = response.error { return callback(nil, error) } callback(response.destinationURL, nil) })} Dentro del controlador de vista principal, definamos un método llamado searchImageWithKeyword. Este método toma una palabra clave como parámetro, luego pasa el parámetro al método fetchImage de una instancia de la clase ImageLoader. También necesitamos pasar un callback para manejar los resultados.Dentro del callback de fetchImage, verifiquemos si hay algún error. Si lo hay, entonces dejamos de llamar al siguiente método, downloadImage. De lo contrario, llamamos al downloadImage del objeto imageLoader. Luego pasamos la url y un callback como parámetros.Dentro del callback de downloadImage, verifiquemos si hay algún error. Si lo hay, entonces dejamos de llamar al siguiente. De lo contrario, actualizamos la vista de imagen en la vista principal llamando al método updateImageAtURL. 12345678910111213141516171819202122232425262728func searchImageWithKeyword(keyword: String) { let imageLoader = ImageLoader() imageLoader.fetchImage(keyword: keyword, callback: {downloadLink, error in if let error = error { print(\"Error \\(error)\") } else { if let downloadLink = downloadLink { imageLoader.downloadImage(url: downloadLink, callback: {downloadedURL, error in if let error = error { print(\"Error \\(error)\") } else { if let downloadedURL = downloadedURL { self.updateImageAtURL(url: downloadedURL) } else { print(\"Error: downloadedURL is nil\") } } }) } else { print(\"Error: downloadLink is nil\") } } })} 123456789101112131415func updateImageAtURL(url: URL) { guard Thread.isMainThread else { DispatchQueue.main.async { self.updateImageAtURL(url: url) } return } do { let data = try Data.init(contentsOf: url) self.imgImage.image = UIImage.gif(data: data) } catch { print(\"Error \\(error)\") }} Como puedes ver, el searchImageWithKeyword es bastante complejo con muchas declaraciones if y else dentro del método. Tenemos que verificar errores en muchas líneas de código. ¿Imaginas cuán complejo sería si tuviéramos más de tres métodos dentro de sí mismo? Un infierno de callbacks en otro lenguaje, Javascript Compila y ejecuta el proyecto. Ingresa una palabra clave que quieras buscar en el servidor de Giphy, presiona el botón de búsqueda y verás el primer resultado. El proyecto de programación async Una mejor solución: Usando BoltsBolts es un framework que fue diseñado por Parse y Facebook, lo uso para crear métodos asíncronos, sin usar callback. El framework Bolts nos permite escribir código como una serie de acciones basadas en eventos. 123456789101112131415161718192021222324func fetchImage(keyword: String) -&gt; Task&lt;URL&gt;! { let mainTask = TaskCompletionSource&lt;URL&gt;() let endPoint = \"http://api.giphy.com/v1/gifs/search?q=\\(keyword)&amp;limit=1&amp;api_key=q4N1oD5jw3xvH2hIOkFAyHXWTTrh0D30\" let headers: HTTPHeaders = [ \"Content-Type\": \"application/json\" ] Alamofire.request(endPoint, headers: headers).responseData { (response) in if let error = response.error { return mainTask.set(error: error) } let jsonData = JSON.init(data: response.data!) let dataArray = jsonData[\"data\"].array if let dataArray = dataArray, dataArray.count &gt; 0 { let imagesList = dataArray[0][\"images\"] let fixed_height_still = imagesList[\"downsized_large\"][\"url\"].stringValue return mainTask.set(result: URL.init(string: fixed_height_still)!) } else { return mainTask.set(error: NSError.init(domain: \"myDomain\", code: 0, userInfo: nil)) } } return mainTask.task} 1234567891011121314151617181920212223func downloadImage(url: URL) -&gt; Task&lt;URL&gt;! { let mainTask = TaskCompletionSource&lt;URL&gt;() let destination: DownloadRequest.DownloadFileDestination = { _, _ in let documentsURL = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)[0] let fileURL = documentsURL.appendingPathComponent(url.lastPathComponent) return (fileURL, [.removePreviousFile, .createIntermediateDirectories]) } Alamofire.download(url, to: destination).downloadProgress(closure: { (progress) in print(\"\\(progress)\") }).responseData(completionHandler: { (response) in if let error = response.error { return mainTask.set(error: error) } if let destinationURL = response.destinationURL { return mainTask.set(result: destinationURL) } else { return mainTask.set(error: NSError.init(domain: \"myDomain\", code: 0, userInfo: nil)) } }) return mainTask.task} Veamos cuán simple sería el searchImageWithKeyword usando Bolts. 12345678910func searchImageWithKeyword(keyword: String) { let imageLoader = ImageLoader() imageLoader.fetchImage(keyword: keyword).continueOnSuccessWith { (linkDownload) -&gt; Void in imageLoader.downloadImage(url: linkDownload).continueOnSuccessWith(continuation: { (downloadedURL) -&gt; Void in self.updateImageAtURL(url: downloadedURL) }) }.continueOnErrorWith { (error) in print(\"Error \\(error)\") }} Compila y ejecuta el proyecto, nada cambió. Pero el código es más legible que el primero, ¿no? Reunimos todos los errores en un solo lugar, también separamos el manejo de errores y el código de éxito. Una solución mucho mejor: Usando PromiseKitUna cosa que no me gusta del framework Bolts es la falta de documentación y proyectos de ejemplo. Cuando usé por primera vez el framework Bolts, fue muy difícil acostumbrarme a las APIs del objeto Task.En la conferencia Swift Summit 2017, hubo un ponente que presentó un Framework para manejar métodos async, PromiseKit. Después de la conferencia, reemplacé el código que usaba el framework Bolts por PromiseKit en los proyectos de mi empresa. Me di cuenta de que mi código ahora es más legible. Creo que la escritura de PromiseKit será más familiar para los desarrolladores que la escritura de Bolts, especialmente para aquellos que han trabajado con Javascript como yo.Un método async creado usando PromiseKit retorna una nueva Promise genérica, que es la clase principal proporcionada por PromiseKit. Su constructor toma un bloque de ejecución simple con dos parámetros: fulfill: Una función a llamar cuando el valor deseado está listo para cumplir la promesa. reject: Una función a llamar si hay un error. Apliquemos PromiseKit a nuestro proyecto 12345678910111213141516171819202122func fetchImage(keyword: String) -&gt; Promise&lt;URL&gt; { return Promise { fullfil, reject in let endPoint = \"http://api.giphy.com/v1/gifs/search?q=\\(keyword)&amp;limit=1&amp;api_key=q4N1oD5jw3xvH2hIOkFAyHXWTTrh0D30\" let headers: HTTPHeaders = [ \"Content-Type\": \"application/json\" ] Alamofire.request(endPoint, headers: headers).responseData { (response) in if let error = response.error { return reject(error) } let jsonData = JSON.init(data: response.data!) let dataArray = jsonData[\"data\"].array if let dataArray = dataArray, dataArray.count &gt; 0 { let imagesList = dataArray[0][\"images\"] let fixed_height_still = imagesList[\"downsized_large\"][\"url\"].stringValue return fullfil(URL.init(string: fixed_height_still)!) } return reject(NSError.init(domain: \"myDomain\", code: 0, userInfo: nil)) } }} 12345678910111213141516171819202122func downloadImage(url: URL) -&gt; Promise&lt;URL&gt; { return Promise { fullfil, reject in let destination: DownloadRequest.DownloadFileDestination = { _, _ in let documentsURL = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)[0] let fileURL = documentsURL.appendingPathComponent(url.lastPathComponent) return (fileURL, [.removePreviousFile, .createIntermediateDirectories]) } Alamofire.download(url, to: destination).downloadProgress(closure: { (progress) in print(\"\\(progress)\") }).responseData(completionHandler: { (response) in if let error = response.error { return reject(error) } if let destinationURL = response.destinationURL { return fullfil(destinationURL) } reject(NSError.init(domain: \"myDomain\", code: 0, userInfo: nil)) }) }} Y el resultado final, ¡qué código tan hermoso! :)) 123456789101112func searchImageWithKeyword(keyword: String) { let imageLoader = ImageLoader() firstly { imageLoader.fetchImage(keyword: keyword) }.then { downloadLink -&gt; Promise&lt;URL&gt; in return imageLoader.downloadImage(url: downloadLink) }.then {downloadedURL -&gt; Void in self.updateImageAtURL(url: downloadedURL) }.catch { error in print(\"Error \\(error)\") }} Una característica que encuentro muy interesante en ambos frameworks, Bolts y PromiseKit, es que permiten que nuestro código se ejecute en un hilo dado (hilo principal o hilo de fondo). Esta es una gran característica ya que la mayor parte del trabajo realizado en el controlador de vista ha sido para actualizar la UI. A veces, las tareas de larga duración se manejan mejor en un hilo de fondo, para no bloquear la UI. Para más detalles sobre esta característica de Thread, por favor consulta sus documentos: #Threading ConclusiónYa que estoy trabajando en CoreBluetooth, a menudo tengo que trabajar con métodos async. Demasiados callbacks hacen que mi proyecto sea más difícil de entender y difícil de depurar si ocurren errores. Promise hace que mi código se convierta en una chica más hermosa ;).Puedes descargar el proyecto de ejemplo completamente terminado aquí.Siéntete libre de dejar tus comentarios en mi publicación.","link":"/es/posts/Asynchronous-Programming-in-Swift/index.html"},{"title":"Android Bluetooth: Una Trampa","text":"Desarrollar aplicaciones Android habilitadas para BLE está lleno de desafíos, especialmente cuando se trata de gestionar operaciones concurrentes. Una de las trampas más comunes que enfrentan los desarrolladores es el comportamiento inesperado que ocurre cuando intentan ejecutar operaciones BLE en rápida sucesión. En esta publicación de blog, profundizaremos en por qué esto sucede y cómo puedes superarlo implementando un mecanismo de cola personalizado para operaciones BLE. Si has trabajado con BLE en Android, podrías haber encontrado un problema frustrante: cuando intentas ejecutar múltiples operaciones BLE una tras otra, como leer y escribir characteristics o descriptors, solo la primera operación tiene éxito, mientras que las otras parecen desaparecer. Esto es más que un inconveniente menor; es un problema serio porque la lógica de tu aplicación a menudo depende de la finalización exitosa de estas operaciones. Sin ellas, tu UI no puede actualizarse con los datos frescos de tu dispositivo conectado, llevando a una mala experiencia de usuario. Entonces, ¿qué está pasando bajo el capó? El problema central está en cómo el stack BLE de Android maneja las operaciones. Las operaciones BLE son asíncronas, lo que significa que no se completan instantáneamente. Cuando ejecutas el stack BLE con múltiples solicitudes en rápida sucesión, el sistema lucha por mantenerse al día, llevando a operaciones descartadas y comportamiento impredecible. El Enfoque Convencional: Soluciones Basadas en CallbacksUna forma de mitigar este problema es usando callbacks para secuenciar tus operaciones BLE.Por ejemplo, podrías esperar a que el callback onCharacteristicWrite() se dispare antes de comenzar la siguiente operación. Esto funciona para casos de uso simples donde tus interacciones BLE están limitadas a una sola pantalla o Activity.Sin embargo, este enfoque rápidamente se vuelve inmanejable a medida que crece la complejidad de tu aplicación. A medida que agregas más operaciones BLE—como leer y escribir descriptors, manejar conexiones y desconexiones, actualizar el MTU y realizar descubrimiento de services. Encontrarás que se necesita una solución más escalable. La Solución Escalable: Implementando un Mecanismo de ColaPara manejar operaciones BLE de manera más confiable, un mecanismo de cola personalizado es esencial. Al encolar operaciones BLE, aseguras que cada operación se ejecute secuencialmente, solo después de que la operación anterior haya tenido éxito o fallado. Este enfoque no solo previene que las operaciones sean descartadas sino que también simplifica la gestión de tareas BLE a través de tu aplicación. Aquí hay un esquema básico de cómo podrías implementar tal mecanismo: Crear una Cola: Comienza creando una cola (como un LinkedList o Queue) para contener tus operaciones BLE. Cada operación puede representarse como un objeto de tarea o comando que contiene los detalles de la operación que quieres realizar. Manejador de Operaciones: Implementa una clase de manejador o gestor responsable de procesar las operaciones en la cola. Esta clase debe escuchar la finalización de cada operación BLE, ya sea que tenga éxito o falle, antes de desencolar y ejecutar la siguiente operación. Integración de Callbacks: Modifica tus callbacks BLE existentes (como onCharacteristicWrite(), onCharacteristicRead(), etc.) para disparar el desencolado y ejecución de la siguiente operación en la cola. Manejo de Errores: Implementa manejo de errores para asegurar que las operaciones fallidas no bloqueen la cola. También podrías querer implementar lógica de reintento para errores transitorios. Actualizaciones de UI: Ya que tu UI puede depender del resultado de las operaciones BLE, asegura que tu gestor de cola dispare actualizaciones de UI apropiadas una vez que las operaciones se completen. 1234567891011121314151617181920212223242526272829303132333435363738394041424344class BLEManager { ConcurrentLinkedQueue&lt;BLEBaseCommand&gt; commandQueue = new ConcurrentLinkedQueue&lt;&gt;(); // Nota que estamos usando una ConcurrentLinkedQueue para prevenir problemas de concurrencia. private void terminateCommands() { commandQueue.clear(); currentCommand = null; } private void enqueueCommand(BLEBaseCommand command) { commandQueue.offer(command); if (currentCommand == null) { executeNextCommand(); } } private void signalCommandEnd() { currentCommand = null; if (!commandQueue.isEmpty()) { // ¿Hay comando restante? executeNextCommand(); } } private void executeNextCommand() { BLEBaseCommand next = commandQueue.poll(); if (next == null) { // Todo hecho return; } currentCommand = next; try { if (!currentCommand.execute()) { runOnUiThread(currentCommand.fallback); // Maneja tu error desde la función `fallback` dependiendo del comando signalCommandEnd(); } } catch (Exception ex) { signalCommandEnd(); } } private void runOnUiThread(Runnable runnable) { new Handler(Looper.getMainLooper()).post(runnable); }} En algún lugar de tu clase BluetoothGattCallback. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253@Override public void onConnectionStateChange(BluetoothGatt gatt, int status, int newState) { // Tu lógica manager.signalCommandEnd();}@Overridepublic void onServiceChanged(@NonNull BluetoothGatt gatt) { // Tu lógica manager.signalCommandEnd();}@Overridepublic void onServicesDiscovered(BluetoothGatt gatt, int status) { // Tu lógica manager.signalCommandEnd();}@Overridepublic void onCharacteristicRead(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic, int status) { // Tu lógica manager.signalCommandEnd();}@Overridepublic void onCharacteristicWrite(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic, int status) { // Tu lógica manager.signalCommandEnd();}@Overridepublic void onDescriptorRead(BluetoothGatt gatt, BluetoothGattDescriptor descriptor, int status) { // Tu lógica manager.signalCommandEnd();}@Overridepublic void onDescriptorWrite(BluetoothGatt gatt, BluetoothGattDescriptor descriptor, int status) { // Tu lógica manager.signalCommandEnd();}@Overridepublic void onReadRemoteRssi(BluetoothGatt gatt, int rssi, int status) { // Tu lógica manager.signalCommandEnd();}@Overridepublic void onMtuChanged(BluetoothGatt gatt, int mtu, int status) { // Tu lógica manager.signalCommandEnd();} A continuación está el diagrama de clases básico Por Qué Esto ImportaImplementar un mecanismo de cola para operaciones BLE no se trata solo de evitar operaciones descartadas; se trata de crear una arquitectura más confiable y escalable para tu aplicación. A medida que expandes la funcionalidad BLE de tu aplicación, estarás agradecido por la estabilidad y previsibilidad que proporciona un sistema de cola. Vale la pena mencionar que paradigmas más modernos como RxJava o el framework de Kotlin pueden ofrecer soluciones aún más elegantes a este problema. Estas herramientas pueden ayudarte a gestionar operaciones asíncronas con mayor flexibilidad y menos código repetitivo. Sin embargo, para muchos desarrolladores, un mecanismo de cola personalizado proporciona una base sólida que puede ser fácilmente entendida e implementada sin introducir dependencias adicionales. Podríamos discutir esto en otro hilo. ConclusiónBLE en Android puede ser desafiante, pero con las estrategias correctas, puedes construir aplicaciones robustas que se comuniquen confiablemente con dispositivos BLE. Al implementar un mecanismo de cola personalizado, puedes superar muchos de los problemas relacionados con la concurrencia. Ya sea que estés comenzando con BLE o buscando mejorar tus aplicaciones existentes, adoptar un enfoque de cola hará tu proceso de desarrollo más fluido y tus aplicaciones más confiables.¡Feliz Codificación!","link":"/es/posts/Android-Bluetooth-A-Pitfall/index.html"},{"title":"Concurrencia Avanzada en iOS: Operaciones Asíncronas [2]","text":"En la publicación anterior, Concurrencia Avanzada en iOS: Operations, revisamos los conceptos de Operation en iOS e hicimos una aplicación de demostración que obtiene algunas de mis publicaciones. Después de descargar las imágenes de portada, se les aplicará un filtro simple y luego se mostrarán en una tabla. Sin embargo, la aplicación aún no está completa. Hay algo que salió mal con nuestra aplicación que hace que no muestre las imágenes descargadas correctamente. En este tutorial, continuaremos donde lo dejamos.¡Prepárate! Ciclo de vida de OperationPara descubrir por qué nuestra aplicación no funcionó correctamente, revisemos el código fuente actual 123456789101112class DownloadImageOperation: Operation { override func main() { guard !isCancelled else { return } URLSession.shared.dataTask(with: self.url, completionHandler: { (data, res, error) in guard error == nil, let data = data else { return } self.outputImage = UIImage(data: data) }).resume() }} La siguiente imagen describe los cambios en los estados de las operaciones. Cuando se llama al método main, ejecutará nuestra tarea asíncrona y luego saldrá inmediatamente haciendo que el estado de la operación cambie a isFinish. En ese momento, nuestra tarea asíncrona en realidad aún no ha completado.Actualmente, estamos llamando para descargar una imagen dentro del método main de la Operation. La causa raíz está relacionada con el Ciclo de Vida de Operation en sí. Por lo tanto, para soportar operaciones asíncronas en nuestra aplicación, necesitamos gestionar manualmente los estados de las operaciones. Key-Value ObservingAntes de implementar nuestra clase Async Operation personalizada, necesitamos aprender un nuevo concepto primero: KVO. Asumo que no has escuchado sobre este concepto, así que primero le daremos un vistazo rápido.Key-Value Observing, también conocido como KVO, es una de las técnicas para observar los cambios de estado de un objeto en Objective-C y Swift. Cada vez que el valor de las propiedades observadas cambia, el bloque de código de observación se ejecutará. En el corazón de KVO, el concepto principal se basa en el Patrón Observer.Las clases Swift que heredan de la clase NSObject tienen métodos para permitir que otros objetos observen sus propiedades. Key-value observing proporciona un mecanismo que permite que los objetos sean notificados de cambios en propiedades específicas de otros objetos. Es particularmente útil para la comunicación entre las capas de modelo y controlador en una aplicación. Creemos un Playground para probarlo. 1234567891011121314151617181920212223242526272829class CreditCard: NSObject { @objc dynamic private(set) var number: Int = 1000 func increaseNumber(by value: Int) { self.number += value }}class Person: NSObject { let cretdit: CreditCard var kvoToken: NSKeyValueObservation? init(cretdit: CreditCard) { self.cretdit = cretdit kvoToken = self.cretdit.observe(\\.number, options: .new) { (credit, change) in guard let newNumber = change.newValue else { return } print(\"New number is \\(newNumber)\") } } deinit { kvoToken?.invalidate() }}let credit = CreditCard()let person = Person(cretdit: credit)credit.increaseNumber(by: 500) Aquí, defino dos clases: CreditCard y Person. Un objeto Person tiene un objeto CreditCard como propiedad. Lo que quiero es que cada vez que la propiedad number de la tarjeta de crédito cambie, la persona sea notificada. Aquí es donde entra KVO.Ejecuta el código anterior en el playground, deberías ver el log New number is \\(newNumber) impreso en tu consola. ¿Por qué necesitamos saber sobre KVO? La respuesta es porque la clase Operation usa notificaciones KVO. Cada vez que el estado de Operation cambia, se enviará una notificación KVO.Sin las notificaciones KVO, el OperationQueue no podrá observar el estado de nuestras operaciones por lo que no puede actualizarse correctamente. Por lo tanto, cuando gestionamos el estado de la operación por nosotros mismos, debemos asegurarnos de que esas notificaciones KVO se envíen correctamente. Async OperationCreemos la clase AsyncOperation heredada de la clase Operation. 12345678910class AsyncOperation: Operation { enum State: String { case ready, executing, finished var keyPath: String { return \"is\\(rawValue.capitalized)\" } } // El resto del código} A continuación, declaramos una propiedad para rastrear el estado del objeto. 12345678910var state = State.ready { willSet { willChangeValue(forKey: newValue.keyPath) willChangeValue(forKey: state.keyPath) } didSet { didChangeValue(forKey: oldValue.keyPath) didChangeValue(forKey: state.keyPath) }} La clase base Operation necesita conocer los cambios tanto del estado antiguo como del nuevo estado.Tomemos un caso específico como ejemplo, el estado actualmente es ready, luego establecemos el estado a executing. Hay 4 notificaciones KVO que deben enviarse: Primero, notificar el willChangeValue para isReady. Luego, notificar el willChangeValue para executing. Después de eso, notificar el willChange para isReady. Finalmente, notificar el willChange para executing. Después de eso, sobrescribimos las propiedades de estados. 123456789101112131415override var isReady: Bool { return super.isReady &amp;&amp; state == .ready}override var isExecuting: Bool { return state == .executing}override var isFinished: Bool { return state == .finished}override var isAsynchronous: Bool { return true} Eso es todo para gestionar el estado de la clase Async Operation. Cuando se agrega una operación a una cola de operaciones, el método start es lo que se llama primero, luego llamará al método main de la operación ejecutando el bloque principal de código que has asignado a la operación. 1234override func start() { main() state = .executing} ¿Recuerdas cuando mencioné que Operation tiene características extraordinarias que lo hacen superar a GDC? La primera son las dependencias y la otra es la capacidad de cancelar una operación en ejecución. Es muy útil en un caso donde queremos detener operaciones que son irrelevantes en un momento determinado. Por ejemplo, cancelar la descarga de datos cuando el usuario hace scroll en la tabla haciendo que algunas celdas desaparezcan.Agreguemos esta característica a nuestra clase Async Operation.Primero, necesitamos modificar el método start para verificar la propiedad isCancelled antes de llamar realmente al método main. 123456789override func start() { if isCancelled { state = .finished return } main() state = .executing} Y luego sobrescribir el método cancel para actualizar el estado a finished 123override func cancel() { state = .finished} En este punto, hemos terminado de implementar nuestra clase Async Operation. Es hora de mezclar todo junto en nuestra aplicación. Juntando todoDebido a que la clase DownloadImageOperation se ejecuta de forma asíncrona, no podemos establecer la clase Operation como su clase base, ahora establecemos AsyncOperation en su lugar. Ten en cuenta que para soportar la cancelación en la clase DownloadImageOperation, mantendremos el valor de retorno de crear una tarea de datos como una propiedad de esta clase para que podamos cancelar este URLSessionDataTask más tarde.La clase DownloadImageOperation se verá así. 123456789101112131415161718192021222324252627282930class DownloadImageOperation: AsyncOperation { let url: URL var outputImage: UIImage? private var task: URLSessionDataTask? init(url: URL) { self.url = url } override func main() { self.task = URLSession.shared.dataTask(with: self.url, completionHandler: { [weak self] (data, res, error) in guard let `self` = self else { return } defer { self.state = .finished } guard !self.isCancelled else { return } guard error == nil, let data = data else { return } self.outputImage = UIImage(data: data) }) task?.resume() } override func cancel() { super.cancel() task?.cancel() }} Volvamos a nuestro ViewController principal. Para cancelar las operaciones en ejecución, primero agregamos un nuevo diccionario como propiedad de ViewController que rastrea todas las operaciones en ejecución para cada celda de la tabla en un index path correspondiente. 1private var operations: [IndexPath: [Operation]] = [:] Dentro del delegado func tableView(_ tableView:cellForRowAt indexPath:), después de agregar dos operaciones a la cola de operaciones, también las agregaremos al diccionario operations para rastrearlas. Además, si hay una operación para este index path, la cancelamos antes de mantener la nueva. 123456if let existingOperations = operations[indexPath] { for operation in existingOperations { operation.cancel() }}operations[indexPath] = [grayScaleOpt, downloadOpt] Cuando el usuario hace scroll en la tabla, algunas celdas desaparecen y se llama al delegado func tableView(_ tableView:didEndDisplaying cell:indexPath:). En ese momento, también cancelaremos las operaciones en ejecución para esa celda asegurándonos de que solo las operaciones de las celdas visibles se estén ejecutando. 1234567func tableView(_ tableView: UITableView, didEndDisplaying cell: UITableViewCell, forRowAt indexPath: IndexPath) { if let operations = operations[indexPath] { for operation in operations { operation.cancel() } }} Ahora, deberías ver que la aplicación funciona correctamente. Además, al iniciar y cancelar las operaciones de manera inteligente, estamos ahorrando tráfico de red así como reduciendo el consumo de batería. Esas cosas pueden hacer que nuestra aplicación funcione más rápido. ConclusiónHay algunos beneficios de Operation sobre GCD que mantienen nuestro código fuente mantenible y reutilizable.Por último mencionar, por favor ten cuidado al usar Operation o GCD porque la concurrencia a veces introduce errores que no siempre son transparentes de encontrar y corregir. En el libro Clean Code, Robert C. Martin establece algunos puntos importantes cuando se trabaja con múltiples hilos Hay algunas definiciones básicas que debemos conocer cuando hablamos de concurrencia e hilos: Recursos limitados, exclusión mutua, inanición, deadlock y livelock. La concurrencia no siempre mejora el rendimiento. A veces incurre en algún overhead y los errores que provienen de ella no suelen ser repetibles. Limita el acceso a los datos que se comparten entre más de dos hilos. Usa copias de datos si hay una posibilidad. Mantén las secciones sincronizadas lo más pequeñas posible porque los Locks crean retrasos y agregan overhead. Son costosos. El código multihilo se comporta de manera diferente en diferentes entornos: Ejecuta pruebas en cada entorno de despliegue potencial. Puedes encontrar el proyecto final a través del enlaceGracias por leer. Referencias Capítulo 6: Operations, Concurrency By Tutorials - Multithreading in Swift with GCD and Operations, Raywenderlich, Capítulo 7: Concurrency and Multitasking, iOS 8 Swift Programming Cookbook, O’Reilly.","link":"/es/posts/Advanced-iOS-Concurrency-Async-Operations-2/index.html"},{"title":"Mejores prácticas: Proceso avanzado de escaneo BLE en iOS","text":"Los desarrolladores de iOS están creando aplicaciones que desempeñan ambos roles, Peripheral y Central, para intercambiar datos con otras copias de aplicaciones. Los datos pueden intercambiarse como pequeña información a través de paquetes BLE o el valor del indicador de intensidad de señal (RSSI) de uno a otro. Sin embargo, mantener la aplicación para siempre en primer plano es imposible. Tarde o temprano, la aplicación entrará en modo background por el usuario y finalmente será suspendida por el sistema dependiendo de la RAM disponible, el consumo de energía y otros factores. Por lo tanto, comprender el procedimiento de advertising y scanning en dispositivos iOS te ayuda a construir buenas aplicaciones que cumplan tus expectativas.Al final de este tutorial, construiremos una aplicación simple que actúa tanto como scanner como advertiser. Cuando dos aplicaciones se encuentren entre sí, escribirán un registro de log para análisis. Dependiendo de los resultados, descubriremos qué tan efectiva es nuestra aplicación usando Core Bluetooth.¡Vamos a ponernos en marcha! Conocimiento fundamentalSegún el libro Getting Started With Bluetooth Low Energy, los dos propósitos principales de los paquetes de advertising son: Transmitir datos para aplicaciones. Descubrir slaves y conectarlos. El tamaño máximo del payload de cada paquete de advertising es de 31 bytes, junto con la información del header. Cada intervalo transcurrido, que varía de 20ms a 10.24s, los paquetes de advertising se transmiten ciegamente para notificar su presencia a otros dispositivos o aplicaciones. Hay dos tipos de enfoques de scanning: Passive Scanning: Los scanners simplemente reciben paquetes de advertising sin ninguna acción adicional. Active Scanning: Después de recibir un paquete de advertising, el scanner realiza un paquete de Scanning Request al advertiser. Después de recibir el Scanning Request, el advertiser responde con un paquete de Scanning Response que permite a los advertisers enviar datos extra (31 bytes adicionales) al scanner. Para clasificar los tipos de paquetes de advertising, nos basamos en tres propiedades: connectability, scannability y directability Tipo de paquete Adv Connectability: Determina si un scanner puede hacer una conexión o no Scannability: Determina si un scanner puede emitir un scan request o no Directability: Determina si este paquete está dirigido a algún scanner en particular o no. ADV_IND Sí Sí No ADV_DIRECT_IND Sí No Sí ADV_NONCONN_IND No No No ADV_SCAN_IND No Sí No Hay muchos más temas avanzados que se describen con más detalle en el libro Getting Started With Bluetooth Low Energy, como cómo se organizan los datos en dispositivos BLE y cómo comunicarse con hardware existente, etc. Si quieres saber más, consulta el libro.Debido al alcance de esta publicación, entender el proceso de advertising es suficiente para que pasemos a la siguiente sección. Scanning y advertising en iOSConfigurando el advertiser - PeripheralVamos a reutilizar mi repositorio anterior que permite que un teléfono iOS haga advertising como peripheral usando Core Bluetooth.Primero, generaré 5 UUIDs como los services del advertiser (Peripheral). 1234let kServiceUUID1 = \"1FA2FD8A-17E0-4D3B-AF45-305DA6130E39\"...let kServiceUUID4 = \"4FA2FD8A-17E0-4D3B-AF45-305DA6130E39\"let kServiceUUID5 = \"5FA2FD8A-17E0-4D3B-AF45-305DA6130E39\" A continuación, crearé una lista de CBMutableService y luego los agregaré al objeto CBPeripheralManager. 12345678910111213141516services.forEach { (each) in let cbService = CBMutableService(type: each.uuid.cbUUID, primary: true) var charArr = [CBMutableCharacteristic]() each.characteristics.forEach { (char) in charArr.append(CBMutableCharacteristic.init( type: char.uuid.cbUUID, properties: [.read, .write, .notify], value: nil, permissions: CBAttributePermissions(char.permissions.map { $0.cbAttributePermission } ))) } cbService.characteristics = charArr self.peripheralManager.add(cbService)} Finalmente, comenzamos el advertising del peripheral cuando su estado está listo. 12self.peripheralManager.startAdvertising([CBAdvertisementDataLocalNameKey: \"uynguyen\", CBAdvertisementDataServiceUUIDsKey: self.cbServices.map { $0.uuid }]) Cuando se ejecuta el código anterior, veremos que se imprimen los siguientes logs. 123456789101112Add service 1FA2FD8A-17E0-4D3B-AF45-305DA6130E39 Succeeded---&gt; Chars [&lt;CBMutableCharacteristic: 0x2802d4070 UUID = 463FED20-DA93-45E7-B00F-B5CD99775150, Value = (null), Properties = 0x1A, Permissions = 0x3, Descriptors = (null), SubscribedCentrals = ()&gt;, &lt;CBMutableCharacteristic: 0x2802d4380 UUID = 463FED21-DA93-45E7-B00F-B5CD99775150, Value = (null), Properties = 0x112, Permissions = 0x1, Descriptors = (null), SubscribedCentrals = ()&gt;, &lt;CBMutableCharacteristic: 0x2802d4620 UUID = 463FED22-DA93-45E7-B00F-B5CD99775150, Value = {length = 6, bytes = 0x486168616861}, Properties = 0x2, Permissions = 0x1, Descriptors = (null), SubscribedCentrals = ()&gt;]...Add service 5FA2FD8A-17E0-4D3B-AF45-305DA6130E39 Succeeded---&gt; Chars []===&gt; Start advertising Succeeded Configurando el scanner - CentralEl siguiente paso es configurar nuestro Central Manager - el scanner. Como podrías saber de mi tutorial anterior, el código para escanear dispositivos cercanos es bastante simple. 1234private func startScanning() { self.centralManager?.scanForPeripherals(withServices: nil, options: [CBCentralManagerScanOptionAllowDuplicatesKey: true])} El valor nil que pasamos al parámetro withServices indica que escanearemos todos los dispositivos cercanos sin especificar service uuids. La opción CBCentralManagerScanOptionAllowDuplicatesKey especifica que el escaneo debe ejecutarse sin filtrado de duplicados. Una vez que el central descubre un peripheral, imprimiremos su información incluyendo el local name y el valor de CBAdvertisementDataServiceUUIDsKey en el paquete de advertising. 12345public func centralManager(_ central: CBCentralManager, didDiscover peripheral: CBPeripheral, advertisementData: [String : Any], rssi RSSI: NSNumber) { print(\"Did found per \\(peripheral.name)\") print(\"CBAdvertisementDataServiceUUIDsKey adv value \" + advertisementData[CBAdvertisementDataServiceUUIDsKey])// ...} Vamos a compilar y ejecutar el proyecto, 12345Did found peripheral name: Optional(\"Uy Nguyen iPad\")CBAdvertisementDataServiceUUIDsKey adv value:Optional(&lt;__NSArrayM 0x282a79350&gt;( 1FA2FD8A-17E0-4D3B-AF45-305DA6130E39)) Mirando el log, ¿puedes detectar qué está mal? Hay un problema con el paquete de advertising: el valor de CBAdvertisementDataServiceUUIDsKey contiene solo 1 service, ¿dónde están los otros services del 2 al 5? Imprimamos el paquete de advertising completo para ver qué contiene. 1234[\"kCBAdvDataServiceUUIDs\": &lt;__NSArrayM 0x283460630&gt;(1FA2FD8A-17E0-4D3B-AF45-305DA6130E39), \"kCBAdvDataLocalName\": uynguyen, \"kCBAdvDataTimestamp\": 620013184.4512661, \"kCBAdvDataRxPrimaryPHY\": 0, \"kCBAdvDataIsConnectable\": 1, \"kCBAdvDataRxSecondaryPHY\": 0] Sin suerte, no podemos encontrar los otros services desde &quot;2FA2FD8A-17E0-4D3B-AF45-305DA6130E39&quot; hasta &quot;5FA2FD8A-17E0-4D3B-AF45-305DA6130E39&quot;. Encontrando problemasResulta que el paquete de advertising que el Central recibe depende de cómo llamamos al método scanForPeripherals.Si cambiamos el parámetro withServices a un array de nuestros services desde &quot;1FA2FD8A-17E0-4D3B-AF45-305DA6130E39&quot; hasta &quot;5FA2FD8A-17E0-4D3B-AF45-305DA6130E39&quot; explícitamente, veremos las diferencias. 12345678private func startScanning() { self.centralManager?.scanForPeripherals(withServices: [CBUUID(string: \"1FA2FD8A-17E0-4D3B-AF45-305DA6130E39\"), CBUUID(string: \"2FA2FD8A-17E0-4D3B-AF45-305DA6130E39\"), CBUUID(string: \"3FA2FD8A-17E0-4D3B-AF45-305DA6130E39\"), CBUUID(string: \"4FA2FD8A-17E0-4D3B-AF45-305DA6130E39\"), CBUUID(string: \"5FA2FD8A-17E0-4D3B-AF45-305DA6130E39\")], options: [CBCentralManagerScanOptionAllowDuplicatesKey: true])} Aquí está el log que resulta. 12345678910[\"kCBAdvDataIsConnectable\": 1, \"kCBAdvDataServiceUUIDs\": &lt;__NSArrayM 0x280708750&gt;(1FA2FD8A-17E0-4D3B-AF45-305DA6130E39), \"kCBAdvDataLocalName\": uynguyen, \"kCBAdvDataRxSecondaryPHY\": 0, \"kCBAdvDataHashedServiceUUIDs\": &lt;__NSArrayM 0x280708720&gt;(2FA2FD8A-17E0-4D3B-AF45-305DA6130E39,3FA2FD8A-17E0-4D3B-AF45-305DA6130E39,4FA2FD8A-17E0-4D3B-AF45-305DA6130E39,5FA2FD8A-17E0-4D3B-AF45-305DA6130E39), \"kCBAdvDataRxPrimaryPHY\": 0, \"kCBAdvDataTimestamp\": 620013608.239601] Ahora, podemos ver el nuevo valor contenido dentro del paquete de advertising, el kCBAdvDataHashedServiceUUIDs. Pero ¿qué es?Volvamos al lado del Peripheral, si miras más de cerca la definición del método de advertising del objeto Peripheral, podrías saber qué es realmente. En resumen, cuando haces que un iPhone haga advertising como peripheral, si no hay espacio para ningún service UUID contenido en el valor de CBAdvertisementDataServiceUUIDsKey, estos services se moverán a otro espacio llamado overflow area. Otro término, T_T ¿Qué significa exactamente el overflow area?Básicamente, el overflow area se coloca en el paquete de scan response. Estos service uuids son hasheados por el algoritmo de Apple y son descubiertos solo por un dispositivo iOS que escanea explícitamente por ellos. En nuestro caso, porque pasamos nuestros service uuids del 1F al 5F cuando comenzamos a escanear, obtendremos este valor kCBAdvDataHashedServiceUUIDs en los paquetes de advertising. Para verificar esta declaración, uso una herramienta introducida por Apple para depuración BLE - (A New Way to Debug iOS Bluetooth Applications), para capturar el paquete de advertising de nuestro Peripheral para análisis.Y aquí está el resultado Tipo de paquete de Advertising: ADV_IND, lo que significa que el scanner puede hacer una conexión con él; y un scanner puede emitir un scan request; y sus paquetes no están dirigidos a ningún scanner en particular. El cuadro amarillo son los datos de advertising: (Data: 02 01 1A 11 06 39 0E 13 A6 5D 30 45 AF 3B 4D E0 17 8A FD A2 1F 09 09 75 79 6E 67 75 79 65 6E), longitud = 31 bytes; contiene CBAdvertisementDataLocalName (75 79 6E 67 75 79 65 6E &gt; “uynguyen”) y nuestro primer service uuid 1F A2 FD 8A 17 E0 4D 3B AF 45 30 5D A6 13 0E 39 (39 0E 13 A6 5D 30 45 AF 3B 4D E0 17 8A FD A2 1F). El paquete de scan response (SCAN_RSP) contiene la otra información que el paquete de advertising no tiene suficiente longitud para transportar. En nuestro caso, contiene los otros services del 2F al 5F. Entender este paquete es bastante complejo para ponerlo en este tutorial, así que omitiré explicarlo por ahora. Tengo otro tutorial trabajando en este paquete más adelante. En conclusión, lo que hemos encontrado aquí es: El Advertising, mientras la aplicación está en background, funciona de manera diferente que cuando está en foreground. CBAdvertisementDataLocalNameKey es ignorado. Todos los service UUIDs contenidos en el valor de la clave de advertisement CBAdvertisementDataServiceUUIDsKey se colocan en un área especial de “overflow”; solo pueden ser descubiertos por un dispositivo iOS que escanee explícitamente por ellos. PruebasLa tabla a continuación resume lo que hemos investigado. 1* SÍ significa que el Central puede encontrar al Peripheral. Caso 1 - Las pantallas de ambos Peripheral y Central están encendidas \\ Peripheral Background Peripheral Foreground Central Background Sí Sí Central Foreground Sí Sí Caso 2 - Pantalla del Peripheral apagada (bloqueada), pantalla del Central encendida \\ Peripheral Background Peripheral Foreground Central Background Sí Sí Central Foreground Sí Sí Caso 3 - Pantalla del Central apagada (bloqueada), pantalla del Peripheral encendida \\ Peripheral Background Peripheral Foreground Central Background No No Central Foreground No No Caso 4 - Las pantallas de ambos Peripheral y Central están apagadas (bloqueadas) \\ Peripheral Background Peripheral Foreground Central Background No No Central Foreground No No De los experimentos anteriores, independientemente del estado del dispositivo que juega el rol de Peripheral, la pantalla del dispositivo que juega el modo Central debe estar encendida para que pueda escanear peripherals cercanos. En otras palabras, si estamos construyendo una aplicación que permite que un dispositivo iOS descubra otros dispositivos iOS cercanos, tenemos que ejecutar ambos modos Central y Peripheral en cada dispositivo Y lo más importante, si dos dispositivos quieren encontrarse, cualquiera de las pantallas debe estar encendida.Hay una técnica (Es más bien un truco) para superar este problema, que es programar periódicamente el envío de notificaciones push a tus dispositivos iOS, lo cual inmediatamente enciende la pantalla para que el Central pueda descubrir Peripherals cercanos.Mientras la aplicación está en background, funciona de manera diferente que cuando está en foreground. Una de ellas es que la frecuencia de los paquetes de advertising que se envían puede disminuir. Como resultado, un Scanner en background encuentra peripherals cercanos más lento comparado con cuando está en foreground. Conclusión¡Felicitaciones! Recorrimos un tutorial para obtener una visión más profunda de cómo funciona CoreBluetooth en iOS tanto en modos Central como Peripheral. ¡Espero que encuentres interesante esta publicación!Si tienes algún comentario, siéntete libre de enviarme un correo electrónico a uynguyen.itus@gmail.com o deja tus preguntas en el cuadro de comentarios. Hecho con amor.","link":"/es/posts/Best-practice-Advanced-BLE-scanning-process-on-iOS/index.html"},{"title":"Mejores prácticas: Cómo manejar Bluetooth Low Energy en segundo plano","text":"PrefacioCuando trabajas con CoreBluetooth, ¿alguna vez te has preguntado cómo la aplicación BLE en iOS puede sobrevivir cuando es terminada por el sistema? ¿Cómo podemos traerla de vuelta al segundo plano? ¿Hay algo como un servicio en Android que pueda durar para siempre? Puedes encontrar la respuesta a todas estas preguntas en esta publicación. ¡Sigue leyendo! Ciclo de vida de la aplicación en iOSAntes de obtener una comprensión profunda de cómo podemos mantener nuestra aplicación en segundo plano, es bueno comenzar con el ciclo de vida de la aplicación en iOS.Como ya sabrás, hay cinco estados principales de cada aplicación iOS.Not running La aplicación no ha sido lanzada o estaba ejecutándose pero fue terminada por el sistema o el usuario.Inactive Es el estado inicial antes de que la aplicación realmente haga la transición a un estado diferente.Active La aplicación se está ejecutando en primer plano y recibiendo eventos del usuario.Background La aplicación está en segundo plano y es invisible para el usuario. Sin embargo, una aplicación que solicita tiempo de ejecución adicional puede permanecer en este estado por un período de tiempo. Además, la aplicación hará la transición al estado inactivo antes de entrar en el modo de segundo plano.Suspended La aplicación está en segundo plano pero no se le permite ejecutar ningún código. La aplicación es movida a este estado automáticamente por el sistema y no recibirá ningún evento antes de que el sistema lo haga. Cuando las aplicaciones en primer plano necesitan más memoria, el sistema puede terminar las aplicaciones suspendidas para hacer más espacio para las aplicaciones en primer plano. Ten en cuenta que no podemos predecir cuándo la aplicación suspendida será terminada por el sistema. Después de ser terminada, la aplicación regresa al estado not running. Problemas de BLE con el ciclo de vida de la aplicaciónComo se mencionó, cuando la aplicación entra en segundo plano, la aplicación podría ser terminada por el sistema si necesita liberar recursos para otras aplicaciones. A diferencia del SO Android, después de ser eliminada por el sistema, podemos reiniciar un servicio para mantener tu aplicación viva. En iOS, una vez que la aplicación es terminada por el sistema, no hay forma de traerla de vuelta al segundo plano. Como resultado, cualquier evento Bluetooth que se despache desde el dispositivo nunca llegará a la aplicación. Significa que tu aplicación podría perder las indicaciones que son activadas por los usuarios, como reproducir una pista de música en su teléfono al presionar botones físicos desde un dispositivo BLE. Apple da un ejemplo llamado “Smart door” (Puerta inteligente). La idea principal de este ejemplo es tener una interacción automática entre la aplicación y la cerradura de la puerta. Imagina que estamos desarrollando una aplicación que puede bloquear y desbloquear automáticamente la puerta cuando el usuario entra y sale de su casa, respectivamente. Sin embargo, el principal problema de esta implementación es mantener la conexión entre los dos, el teléfono y la cerradura de la puerta. Mientras usan su teléfono, los usuarios hacen una variedad de acciones en el teléfono: abrir / cerrar aplicaciones, alternar la configuración de Bluetooth, entrar en modo avión, reiniciar el teléfono, etc. Estas interacciones pueden llevar a que nuestra aplicación sea eliminada por el sistema, para siempre. En este caso, la aplicación no podrá reconectarse a la cerradura cuando el usuario regrese a casa, y el usuario podría no poder abrir la puerta. Para lidiar con este problema, Apple proporciona un método llamado State Preservation and Restoration (Preservación y Restauración de Estado) (procesamiento en segundo plano de CoreBluetooth). State Preservation and Restoration está integrado en CoreBluetooth y permite que nuestra aplicación pueda ser relanzada en segundo plano cuando es terminada por el sistema.En resumen, iOS toma una instantánea de todos los objetos relacionados con Bluetooth que estaban en marcha en nuestra aplicación. Posteriormente, si hay algún evento Bluetooth relacionado con los objetos Bluetooth con los que nuestra aplicación estaba interactuando llega al teléfono, nuestra aplicación será despertada de la tumba. ¡Eso es increíble! Implementar State Preservation and RestorationPara demostrar la técnica de State Preservation and Restoration en iOS, voy a reutilizar el código fuente de la publicación anterior Desempeñar Roles de Central y Periférico con CoreBluetooth pero agregaremos más código a los proyectos para hacerlo mágico.Primero, configuro mi iPad para actuar como un Periférico con un uuid “1FA2FD8A-17E0-4D3B-AF45-305DA6130E39”, que se genera a través del comando uuidgen en Mac. Luego, hago que comience a hacer advertising con el nombre local “iPad”. Si hay una conexión establecida por un central manager, los logs de entrada/salida se imprimirán para saber si la conexión se realizó exitosamente. Cuando se toca el botón “Send Notify”, la aplicación notificará una cadena de datos “Say something cool!” a través del “463FED21-DA93-45E7-B00F-B5CD99775150” que está definido como una característica notificable encriptada de la aplicación al central manager conectado. Lo siguiente que necesitamos hacer es volver a la aplicación Central Manager y crear un Restore Identifier para los objetos CBCentralManager que serán tomados por el sistema operativo cuando la aplicación sea terminada, elegí la cadena “YourUniqueIdentifierKey”. A continuación, implementaremos el willRestoreState proporcionado por Apple. 123456789101112131415161718public func centralManager(_ central: CBCentralManager, willRestoreState dict: [String : Any]) { LocalNotification.shared.showNotification(id: \"willrestorestate\", title: \"Manager will restore state\", body: \"\", timeInterval: 1.0) let systemSoundID: SystemSoundID = 1321 AudioServicesPlaySystemSound (systemSoundID) if let peripherals = dict[CBCentralManagerRestoredStatePeripheralsKey] as? [CBPeripheral] { peripherals.forEach { (awakedPeripheral) in print(\"\\(Date.now). - Awaked peripheral \\(String(describing: awakedPeripheral.name))\") guard let localName = awakedPeripheral.name, localName == \"iPad\" else { return } self.connectedDevice = Device.init(peripheral: awakedPeripheral) } }} Aquí, cuando se llama a centralManager(_:, willRestoreState), reproduciré una pista de sonido y mostraré una ventana emergente con el nombre del periférico despertado para informar que la aplicación realmente fue despertada por el sistema. Dentro del método, también podemos obtener un diccionario lleno de información de estado. Cuando lo recuperamos con la clave CBCentralManagerRestoredStatePeripheralsKey, esto contiene cosas como un array de CBPeripheral, que contiene todos los periféricos que estaban conectados o pendientes de conexión en el momento en que la aplicación fue terminada por el sistema. Aquí, itero a través del array de periféricos, verifico si está mi periférico de interés, luego inicializo un Device y lo establezco de nuevo en la variable connectedDevice para poder recibir valores actualizados del periférico. También agrego el código que mostrará una notificación local en el delegado appDidFinishLaunching y en el método peripheral(:didUpdateValueFor:chacracteristic) para pruebas. 123456func peripheral(_ peripheral: CBPeripheral, didUpdateValueFor characteristic: CBCharacteristic, error: Error?) { if let data = characteristic.value { let str = String.init(data: data, encoding: .utf8) ?? \"\" LocalNotification.shared.showNotification(id: \"DidUpdateValue\", title: \"Peripheral did update value from grave!\", body: \"\\(str)\", timeInterval: 1.0) }} 12345678func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) -&gt; Bool { let _ = BluetoothManager.sharedInstance let _ = LocalNotification.shared LocalNotification.shared.showNotification(id: \"didfinishlaunch\", title: \"App did finish launching\", body: \"Options: \\(launchOptions?[UIApplicationLaunchOptionsKey.bluetoothCentrals] ?? \"nil\")\", timeInterval: 1.0) return true} ¡Es hora de ejecutar nuestro experimento! Voy a usar dos métodos para simular la terminación de la aplicación en segundo plano por el sistema.El primero es usando XCode. Ejecuta la aplicación desde Xcode. Detén la aplicación presionando el botón “Stop” desde Xcode. Reinicia la aplicación desde Xcode. El segundo es haciendo los siguientes pasos: Presiona el botón home para hacer que la aplicación entre en segundo plano. Mantén presionado el botón de encendido hasta que veas “deslizar para apagar”. Suelta el botón de encendido y mantén presionado el botón home por aproximadamente 5s (hasta que veas que tu pantalla de inicio reapareció). En la siguiente demostración, verás que uso ambos para probar. ¡Veamos algo genial suceder! Aquí está el log impreso desde Xcode. 123456789102018-08-18 19:46:35.6560 App did finish lauching with option nil2018-08-18 19:46:35.6620 Manager will restore state2018-08-18 19:46:35.6650. - Awaked peripheral Optional(\"iPad\")2018-08-18 19:46:35.6660 Manager did update state 52018-08-18 19:46:35.6950 App did become active2018-08-18 19:46:35.7080 Found iPad2018-08-18 19:46:35.7100 Did connect.2018-08-18 19:46:51.5170 App will resign active2018-08-18 19:46:52.1100 App did enter backgroundMessage from debugger: Terminated due to signal 9 Primero, me conecté al dispositivo iPad, luego simulé la terminación por Xcode (Relanzar la aplicación desde Xcode), después de eso ves que el delegado centralManager(_:, willRestoreState) fue activado por la ventana emergente. Más tarde, simulé la terminación usando el segundo método, cuando la pantalla de inicio reapareció, una cosa es segura: la aplicación fue terminada. A continuación, presioné el botón “Send notify” desde el iPad (Que estaba actuando como Periférico) para enviar un evento BLE a la aplicación. Sorprendentemente, centralManager(_:, willRestoreState) fue llamado inmediatamente como podemos ver que apareció una notificación local, luego otra mostró los datos BLE recibidos del periférico (La cadena “Say something cool!”). ¡Realmente funcionó! ¡La aplicación ahora puede durar para siempre! Pero espera un minuto, no es tan simple. Este enfoque todavía tiene algunas limitaciones que discutiremos más adelante en esta publicación. Como habrás notado, hay una diferencia entre las dos formas que usé para simular la terminación en segundo plano, cuando la aplicación fue relanzada desde la primera forma, el valor de option del delegado application(application:didFinishLaunchingWithOptions:) siempre es nil, mientras que podíamos extraer el [UIApplicationLaunchOptionsKey.bluetoothCentrals usando la segunda forma (El valor de launchOptions?[UIApplicationLaunchOptionsKey.bluetoothCentrals] devolverá la cadena “YourUniqueIdentifierKey”). No sé la razón por la que sucedió. Pero una cosa es segura: el segundo enfoque es mejor que el primero ya que coincide con el documento de Apple. *”Cuando tu aplicación es relanzada por el sistema, puedes recuperar todos los identificadores de restauración para los objetos central manager que el sistema estaba preservando para tu aplicación”.* Entonces, en application(application:didFinishLaunchingWithOptions:), podemos obtener una lista de UUID que representan todos los objetos CBCentralManager que estaban activos cuando la aplicación fue terminada y que Core Bluetooth e iOS tomaron mientras estabas terminado. Usa UIApplicationLaunchOptionsBluetoothCentralsKey para obtener cualquier central que hayamos instanciado antes de ser eliminados. Recorre el array de centralManagerUUID y encuentra el que coincida con el Restoration Identifier que nos interesa. LimitacionesCuando el usuario fuerza el cierre de la aplicación desde la vista de tareas múltiplesSi el usuario fuerza el cierre de la aplicación desde la vista de tareas múltiples, no hay oportunidad para que la aplicación se despierte del evento de restauración. Pero afortunadamente, hay otra tecnología que podemos aprovechar para poner la aplicación de nuevo en segundo plano llamada “iBeacon”. En la próxima publicación, te guiaré sobre cómo implementar esta interesante tecnología en nuestra aplicación. Cuando el usuario reinicia el teléfonoSi el usuario reinicia el teléfono, la aplicación será eliminada para siempre. Aprovechando CoreLocation, podemos resolver el problema. En la próxima parte, te mostraré cómo hacerlo. Reflexiones finalesEn esta publicación, recorrimos el ciclo de vida de la aplicación iOS, también te mostré cómo mantener la aplicación viva incluso cuando fue terminada por el sistema. Los contenidos de esta publicación son realmente interesantes y se forman a partir de mis experimentos de trabajo reales.Espero que encuentres útil esta publicación.","link":"/es/posts/Best-practice-How-to-deal-with-Bluetooth-Low-Energy-in-background/index.html"},{"title":"Mejores practicas: Concurrencia en Core Data","text":"Algunas aplicaciones pueden sobrevivir sin ningun almacenamiento de datos. La mayoria de las otras aplicaciones utiles, sin embargo, guardan algun estado como configuraciones de usuario, perfil de usuario, objetivos, etc. En iOS, Apple proporciona Core Data como un framework para persistir tus datos valiosos. Una cosa a tener en cuenta es que aunque CoreData puede almacenar datos en una base de datos relacional, en realidad no es un motor de base de datos.En este tutorial, compartire contigo una mala experiencia que enfrente cuando trabaje con Core Data. Esperemos que despues de leer lo que comparto, evites enfrentar el mismo problema en tus proyectos.Comencemos. Tres componentes principales del stack de Core DataPrimero que nada, listare los tres componentes principales del stack de Core Data, puede que estes o no familiarizado con estos terminos pero es mejor obtener un entendimiento profundo del stack de Core Data antes de profundizar mas.La API de Core Data, tambien llamada el stack, consiste en tres componentes principales: NSManagedObjectModel: El modelo de datos describe una entidad (objeto). NSManagedObjectContext: Los objetos cuando se obtienen del almacenamiento persistente se colocan en el contexto de objeto administrado. Realiza validaciones y mantiene un seguimiento de los cambios realizados a los atributos del objeto para que las operaciones de deshacer y rehacer puedan aplicarse, si es necesario. En un contexto dado, un objeto administrado proporciona una representacion de un registro en un almacen persistente. Dependiendo de la situacion, puede haber multiples contextos, cada uno conteniendo un objeto administrado separado representando ese registro. Todos los objetos administrados estan registrados con un contexto de objeto administrado. NSPersistentStoreCoordinator: NSManagedObjectContext no trabaja directamente con NSPersistentStore para almacenar y recuperar datos, sino que NSPersistentStoreCoordinator lo hara. Los roles principales de NSPersistentStoreCoordinator son gestionar el estado del contexto de objeto administrado y serializar llamadas a NSPersistentStore para evitar redundancia. Puedes encontrar los roles principales de cada componente en la siguiente imagen Tenemos suficiente conocimiento de Core Data y sus diferentes componentes. Ahora, avancemos a la seccion principal. Core Data soporta concurrenciaCore Data soporta multi-threading en una aplicacion, lo que significa que mas de un hilo puede ejecutarse en paralelo para aumentar el rendimiento. Incluso algunas tareas pueden realizarse en segundo plano usando un hilo separado.Como podrias saber, cuando trabajas con CoreData, hay dos formas de definir un contexto de objeto administrado: NSMainQueueConcurrencyType y NSPrivateQueueConcurrencyType. Depende de nosotros decidir que tipo de MOC debemos crear en nuestras aplicaciones. Principalmente trabajaremos en el principal, pero para evitar hacer procesamiento de datos en la cola principal, ya que podria afectar la experiencia del usuario al hacer tareas pesadas en el hilo principal, a veces necesitamos crear un contexto de cola privada y realizar esas tareas pesadas en este contexto privado.La concurrencia absolutamente hace la aplicacion mas efectiva ya que las tareas ahora pueden hacerse en paralelo, pero hay algunas reglas estrictas definidas por Apple que debemos seguir, de lo contrario enfrentaremos algunos comportamientos inesperados, incluyendo crashes y perdida de datos. Regla 1: Los contextos de objetos administrados estan vinculados al hilo con el que estan asociados en la declaracion. La primera regla establece que no uses el contexto de cola principal en un hilo en segundo plano. La mayoria del tiempo, no hay falla en absoluto si violamos la regla. Sin embargo, cuando llega a produccion, pronto enfrentaras crashes en tu dashboard, resultando en malas experiencias de usuario y mas importante aun, llevando a perdida de datos. Regla 2: Los objetos administrados recuperados de un contexto estan vinculados a la misma cola con la que el contexto esta asociado. Eso significa no pasar ninguno de los objetos recuperados del contexto principal al privado y viceversa. Violar esta regla llevara al mismo resultado que la regla 1. Crash, crash, crash!Ha sido la primera vez que uso CoreData para almacenar datos valiosos de usuarios en nuestra aplicacion. Por un lado, no tome la concurrencia de Core Data en serio en ese momento. Por otro lado, no sabia que hay algunas reglas estrictas cuando se trabaja con concurrencia en Core Data. Como resultado, cuando la aplicacion llego a produccion, el numero de crashes habia sido reportado al dashboard de monitoreo. En ese momento, no tenia idea de como venian. No podia reproducir estos problemas para encontrar la causa raiz. Adicionalmente, el crash reportado por Firebase no tenia suficiente informacion para una investigacion. Intente revisar el flujo de mi aplicacion, buscando en StackOverflow y luego leyendo profundamente el documento de Apple de Core Data. Finalmente, la causa raiz viene de acceder a Core Data desde multiples hilos. Como estoy trabajando con Core Bluetooth, el punto clave es que Core Bluetooth despacha eventos de Bluetooth en el hilo principal por defecto. Sin embargo, configure la cola de Bluetooth a una cola en segundo plano para evitar bloquear la cola de UI. Aqui vienen los crashes ya que Core Data no permite acceder a NSManagedObject entre diferentes colas estrictamente. Para simular este problema, cree un bucle sin parar para ejecutar acciones de insercion y eliminacion en una cola en segundo plano continuamente. El siguiente codigo ilustra como realice la prueba. 1234567891011121314override func viewDidLoad() { super.viewDidLoad() // Do any additional setup after loading the view. self.doSomething()}func doSomething() { self.managedContext?.insert(person: self.person) self.managedContext?.delete(person: self.person) DispatchQueue.global(qos: .background).asyncAfter(deadline: .now() + 0.1, execute: { self.doSomething() })} Tarde o temprano, el crash llegara a nosotros. 1232019-10-13 12:31:55.497690+0700 CoreData-Concurrency[90636:1151728] [error] error: Serious application error. Exception was caught during Core Data change processing. This is usually a bug within an observer of NSManagedObjectContextObjectsDidChangeNotification. -[__NSCFSet addObject:]: attempt to insert nil with userInfo (null)CoreData: error: Serious application error. Exception was caught during Core Data change processing. This is usually a bug within an observer of NSManagedObjectContextObjectsDidChangeNotification. -[__NSCFSet addObject:]: attempt to insert nil with userInfo (null)2019-10-13 12:31:55.569306+0700 CoreData-Concurrency[90636:1151728] *** Terminating app due to uncaught exception 'NSInvalidArgumentException', reason: '-[__NSCFSet addObject:]: attempt to insert nil' Aqui hay algunas respuestas de la comunidad que puedes encontrar en Stackoverflow:https://stackoverflow.com/questions/36402366/core-data-crash-attempt-to-insert-nil-with-userinfo-nullhttps://stackoverflow.com/questions/55517083/ios-core-data-serious-application-error-attempt-to-insert-nil-in-less-than Evitar crashesPara evitar el crash, hay dos tecnicas que podemos aplicar, ambas aseguran que no violemos las reglas de confinamiento de concurrencia. #1La primera es asegurar que el managedObjectContext se ejecute en la cola con la que esta asociado en la inicializacion, que es la cola principal en este caso. 1234567func doSomething() { self.managedContext?.insert(person: self.person) self.managedContext?.delete(person: self.person) DispatchQueue.main.asyncAfter(deadline: .now() + 0.1, execute: { // Dispatch to main queue self.doSomething() })} En caso de que por alguna razon, no podamos ejecutar las acciones en la cola principal (por ejemplo, importar datos enormes al disco) podemos crear multiples contextos para resolver este problema. Ve a #2. #2Usando la tecnica de Core Data multiple context.Un contexto de objeto administrado (MOC) hijo no mantiene una referencia al coordinador de almacen persistente (PSC). En cambio, mantiene una referencia a otro (MOC) como su padre. Cada vez que un hijo realiza saveContext, los cambios seran enviados a su padre, y seguiran enviandose a otros padres (si los hay). Solo cuando el MOC padre raiz realiza saveContext, los cambios se guardan en el PSC. Creemos un MOC privado dentro de nuestra clase PersonManagedObject. 1private let privateMOC = NSManagedObjectContext(concurrencyType: .privateQueueConcurrencyType) Luego establece su padre como el MOC principal. 12345init?() { ... privateMOC.parent = self.managedObjectContext} De ahora en adelante, todas las acciones se realizaran en este privateMOC. El metodo performAndWait bloquea al llamador de retornar hasta que el bloque se ejecute.El metodo perform(_:) retorna inmediatamente y el contexto ejecuta los metodos del bloque en su propio hilo. Con el metodo performAndWait(_:), el contexto todavia ejecuta los metodos del bloque en su propio hilo, pero el metodo no retorna hasta que el bloque se ejecute. 12345678func insert(person: Person) { ... // Some code are obmitted self.privateMOC.performAndWait { self.privateMOC.insert(object) synchronize() }} No olvides llamar al metodo saveContext del contexto padre para guardar los cambios en el PSC. 1234567891011121314private func synchronize() { do { try self.privateMOC.save() // We call save on the private context, which moves all of the changes into the main queue context without blocking the main queue. self.managedObjectContext.performAndWait { do { try self.managedObjectContext.save() } catch { print(\"Could not synchonize data. \\(error), \\(error.localizedDescription)\") } } } catch { print(\"Could not synchonize data. \\(error), \\(error.localizedDescription)\") }} Despues de modificar el codigo usando #1 o #2, ejecute el programa de nuevo por un largo tiempo pero no hubo mas crashes! ConclusionCore Data es un framework muy util y ciertamente es indispensable en la mayoria de las aplicaciones moviles hoy en dia. Para evitar las mismas malas situaciones por las que acabo de pasar, asegurate de profundizar en sus componentes antes de comenzar tu codigo, especialmente la concurrencia de Core Data.Puedes encontrar mi proyecto completado en Github - Core Data ConcurrencyGracias por leer. Referencias[1] B.M. Harwani - Core Data iOS Essentials-Packt Publishing (2011)[2] Core Data, Multithreading, and the Main Thread[3] [Multiple context CoreData] https://www.cocoanetics.com/2012/07/multi-context-coredata/","link":"/es/posts/Best-practice-Core-Data-Concurrency/index.html"},{"title":"Mejores prácticas: procesamiento en segundo plano en iOS - Background App Refresh Task","text":"A diferencia de Android, iOS tiene restricciones para el uso del procesamiento en segundo plano en un intento de mejorar la duración de la batería y la experiencia del usuario. Cuando tus aplicaciones entran en modo de segundo plano, es el momento en que los desarrolladores pierden el control de su aplicación. Cómo y cuándo tu aplicación tiene la oportunidad de ejecutar tu tarea depende totalmente del sistema. En el corazón de iOS, Apple usa su propio algoritmo internamente complejo para determinar qué aplicaciones pueden ejecutarse en segundo plano, basándose en varios factores como el patrón de actividad del usuario, el estado actual de la batería, etc.En este tutorial, aprenderemos cómo solicitar tiempo de ejecución periódica en iOS. Después de entender cómo funciona, aplicaremos esta técnica a una aplicación basada en BLE en algunos casos específicos en el próximo tutorial.¡Comencemos! Conocimiento fundamentalAntes de sumergirnos profundamente en la práctica, es bueno entender cómo iOS gestiona los estados de la aplicación. Es la primera vez que Apple anuncia oficialmente un video que describe los principales factores que contribuyen a los tiempos de lanzamiento de la aplicación en WWDC (WWDC 2020 - Background execution demystified). Para resumir, Apple diseña iOS de una manera que permite a las aplicaciones mantener su contenido actualizado por un lado. Por otro lado, iOS debe adaptarse a sus objetivos principales: Duración de la batería: permitir la ejecución en segundo plano mientras se mantiene la batería durante todo el día. Rendimiento: asegurar que la ejecución en segundo plano no tenga ningún efecto negativo en el uso activo. Privacidad: Los usuarios deben estar al tanto de las tareas en segundo plano basándose en sus patrones de uso particulares. Respetar la intención del usuario: si un usuario realiza cierta acción, asegurarse de que el sistema responda correctamente. Con estos objetivos en mente, aquí están los 7 principales factores que juegan un papel en la programación del sistema de la ejecución en segundo plano. Batería críticamente baja: Cuando el teléfono está a punto de quedarse sin batería (&lt; 20%), la ejecución en segundo plano será pausada por el sistema para evitar el uso de batería. Modo de bajo consumo: Cuando los usuarios cambian el teléfono a modo de bajo consumo, el usuario indica explícitamente que el sistema debe preservar la batería solo para tareas críticas. Configuración de Background App Refresh: El usuario puede alternar la configuración para permitir o no que una aplicación específica ejecute tareas en segundo plano. Uso de la aplicación: Hay un límite de recursos en el teléfono, por lo que el sistema debe priorizar a qué aplicaciones debe asignar recursos. Típicamente, las aplicaciones que el usuario usa más. Apple también mencionó el “motor predictivo en el dispositivo” que aprende qué aplicaciones usa frecuentemente el usuario y cuándo. El motor predictivo en el dispositivo se basará en esta información para priorizar la ejecución en segundo plano. App switcher: Solo las aplicaciones visibles en el App Switcher tienen oportunidades de ejecutar tareas en segundo plano. Presupuesto del sistema: Para asegurar que las actividades en segundo plano no agoten la batería y los planes de datos, hay un límite de batería y datos de ejecución en segundo plano a lo largo del día. Límite de tasa: El sistema realiza algún límite de tasa por lanzamiento. y algunos otros factores: Modo avión, temperatura del dispositivo, pantalla, estado de bloqueo del dispositivo, etc. CapacidadesAsegúrate de que tu aplicación haya agregado las siguientes capacidades Antes de iOS 13Es bastante simple configurar un background fetch antes de iOS 13.Dentro del método application(_:didFinishLaunchingWithOptions), debemos agregar el siguiente comando. 1UIApplication.shared.setMinimumBackgroundFetchInterval(UIApplication.backgroundFetchIntervalMinimum) El setMinimumBackgroundFetchInterval especifica la cantidad mínima de tiempo que debe transcurrir entre las ejecuciones de background fetch. Sin embargo, el momento exacto del evento depende del sistema. Generalmente, UIApplicationBackgroundFetchIntervalMinimum es un buen valor predeterminado para usar. Una vez que tu aplicación tiene la oportunidad de realizar tareas en segundo plano, se activará el evento application(_:,performFetchWithCompletionHandler). 1234func application(_ application: UIApplication, performFetchWithCompletionHandler completionHandler: @escaping (UIBackgroundFetchResult) -&gt; Void) { Logger.shared.debug(\"\\(Date().toString()) perfom bg fetch\") completionHandler(.newData)} No olvides llamar al callback completionHandler. Si no llamas a este callback, el sistema no sabe que tu tarea ha sido completada, lo que lleva a limitar que tu aplicación se despierte en los próximos eventos Para simular background fetch, desde la barra de pestañas &gt; Debug &gt; Simulate background fetch. Ten en cuenta que solo funciona cuando se ejecuta en dispositivos reales. iOS 13+, Procesamiento en segundo plano avanzado - WWDC 2019 y Background execution demystified - WWDC 2020En WWDC 2019, Apple introdujo un nuevo framework para programar trabajo en segundo plano: BackgroundTasks. Este nuevo framework ofrece mejor soporte para tareas que necesitan hacerse en segundo plano. Hay dos tipos de tareas soportadas por el framework BackgroundTasks: BGAppRefreshTaskRequest y BGProcessingTaskRequest. Con la presencia del nuevo framework, Apple marcó como obsoleto el antiguo desde iOS 13, y ya no lo soporta en MacOS.Primero, debemos registrar los identificadores de las tareas en segundo plano ejecutadas en nuestra aplicación. Abre el archivo info.plist, y agrega la siguiente información. 12345&lt;key&gt;BGTaskSchedulerPermittedIdentifiers&lt;/key&gt;&lt;array&gt; &lt;string&gt;YOUR_REFRESH_TASK_ID&lt;/string&gt; &lt;string&gt;YOUR_PROCESSING_TASK_ID&lt;/string&gt;&lt;/array&gt; Olvidar el paso anterior lleva a un crash en tiempo de ejecución. 12020-10-11 08:24:40.648838+0700 TestBgTask[275:5188] *** Terminating app due to uncaught exception 'NSInternalInconsistencyException', reason: 'No launch handler registered for task with identifier com.example.bgRefresh' BGAppRefreshTaskRequest se usa cuando necesitas ejecutar una tarea en segundo plano en poco tiempo.Tareas de actualización como obtener el feed de redes sociales, nuevos correos electrónicos, últimos precios de acciones, etc. son apropiadas para programar con BGAppRefreshTaskRequest. 30s es el tiempo que el sistema permite que tu tarea se ejecute por lanzamiento. Varios minutos de tiempo de ejecución para terminar tu trabajo cuando registras un BGProcessingTaskRequest. Tareas como entrenamiento de Core ML en el dispositivo deben registrarse con un BGProcessingTaskRequest. Para registrar tareas en segundo plano, dentro del método application(_:didFinishLaunchingWithOptions), debemos agregar el siguiente comando. 1234567891011121314151617181920212223242526272829303132333435363738394041424344 func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -&gt; Bool { if #available(iOS 13, *) { BGTaskScheduler.shared.register(forTaskWithIdentifier: appRefreshTaskId, using: nil) { task in Logger.shared.info(\"[BGTASK] Perform bg fetch \\(appRefreshTaskId)\") task.setTaskCompleted(success: true) self.scheduleAppRefresh() } BGTaskScheduler.shared.register(forTaskWithIdentifier: appProcessingTaskId, using: nil) { task in Logger.shared.info(\"[BGTASK] Perform bg processing \\(appProcessingTaskId)\") task.setTaskCompleted(success: true) self.scheduleBackgroundProcessing() } } } @available(iOS 13.0, *) func scheduleAppRefresh() { let request = BGAppRefreshTaskRequest(identifier: \"YOUR_REFRESH_TASK_ID\") request.earliestBeginDate = Date(timeIntervalSinceNow: 5 * 60) // Refresh after 5 minutes. do { try BGTaskScheduler.shared.submit(request) } catch { print(\"Could not schedule app refresh task \\(error.localizedDescription)\") } } @available(iOS 13.0, *) func scheduleBackgroundProcessing() { let request = BGProcessingTaskRequest(identifier: appProcessingTaskId) request.requiresNetworkConnectivity = true // Need to true if your task need to network process. Defaults to false. request.requiresExternalPower = true // Need to true if your task requires a device connected to power source. Defaults to false. request.earliestBeginDate = Date(timeIntervalSinceNow: 5 * 60) // Process after 5 minutes. do { try BGTaskScheduler.shared.submit(request) } catch { print(\"Could not schedule image fetch: (error)\") } }} Una cosa más que necesita hacerse. Cuando la aplicación entra en segundo plano, comenzaremos a programar las tareas en segundo plano. 1234567func applicationDidEnterBackground(_ application: UIApplication) { Logger.shared.info(\"App did enter background\") if #available(iOS 13, *) { self.scheduleAppRefresh() self.scheduleBackgroundProcessing() }} Como siempre, es importante llamar a task.setTaskCompleted(success: true) lo más rápido posible.Podrías notar que después de llamar a task.setTaskCompleted(success: true), necesitamos llamar a self.scheduleAppRefresh() y self.scheduleBackgroundProcessing() nuevamente para reprogramar estas tareas en el sistema. Simular background task y background processingAfortunadamente, Apple soporta una forma de activar la ejecución en segundo plano.Después de enviar tu tarea al sistema, pausa la aplicación con cualquier breakpoint. Luego, ingresa el siguiente comando en la consola de Xcode. 1e -l objc -- (void)[[BGTaskScheduler sharedScheduler] _simulateLaunchForTaskWithIdentifier:@\"YOUR_REFRESH_TASK_ID || YOUR_PROCESSING_TASK_ID\"] La salida debería ser 12345672020-10-11 08:53:58.628667+0700 TestBgTask[381:17115] 💚-2020-10-11 08:53:58.628 +0700 Start schedule app refresh(lldb) e -l objc -- (void)[[BGTaskScheduler sharedScheduler] _simulateLaunchForTaskWithIdentifier:@\"com.example.bgRefresh\"]2020-10-11 08:54:01.927263+0700 TestBgTask[381:16973] Simulating launch for task with identifier com.example.bgRefresh2020-10-11 08:54:03.669153+0700 TestBgTask[381:17095] Starting simulated task: &lt;decode: missing data&gt;2020-10-11 08:54:07.560697+0700 TestBgTask[381:17095] Marking simulated task complete: &lt;BGAppRefreshTask: com.example.bgRefresh&gt;2020-10-11 08:54:07.560750+0700 TestBgTask[381:17012] 💙-2020-10-11 08:54:06.045 +0700 [BGTASK] Perform bg fetch com.example.bgRefresh2020-10-11 08:54:07.563846+0700 TestBgTask[381:17012] 💚-2020-10-11 08:54:07.562 +0700 Start schedule app refresh Expectativa vs RealidadPodrías esperar que la ejecución en segundo plano se distribuyera uniformemente a lo largo del día. Sin embargo, esto es lo que observamos en la realidad. Debido a los 7 factores que introduje al principio de este tutorial, el “motor predictivo en el dispositivo” aprende el patrón de uso del usuario y entiende que el usuario típicamente abre la aplicación en la mañana, a la hora del almuerzo y en la noche. Por eso el sistema permitirá que tus tareas en segundo plano se lancen justo antes de que el usuario ponga la aplicación en primer plano. Otros factores que afectan el resultado son si el usuario activó el “Modo de bajo consumo”, o si el teléfono cayó en estado de batería críticamente baja. Mejores consejos Las tareas en segundo plano no se ejecutarán hasta el primer desbloqueo del dispositivo después del reinicio. Podemos verificar si el usuario está en modo de bajo consumo:12ProcessInfo.processInfo.isLowPowerModeEnabledNSProcessInfoPowerStateDidChange También podemos verificar el estado de la “configuración de background refresh”.12UIApplication.shared.backgroundRefreshStatusUIApplication.backgroundStatusDidChangeNotification Minimizar el uso de datos: Usar miniaturas en lugar de imágenes completas, y solo descargar lo que realmente es necesario. Minimizar el consumo de energía: evitar el uso innecesario de hardware como GPS, acelerómetro, etc. También, asegúrate de completar la tarea lo antes posible. Usar BackgroundURLSession para descargar el trabajo de la aplicación al sistema. ResumenEn esta publicación, profundizamos en qué factores contribuyen a tus ejecuciones en segundo plano, y entendemos las diferencias clave entre BGAppRefreshTaskRequest y BGProcessingTaskRequest. También tomamos un proyecto demo para ver cómo funciona realmente en la práctica.La próxima vez, puedes elegir qué tipo de solicitud es más apropiada para tus tareas, y cómo puedes responder graciosamente a la intención de tu usuario.Esperamos que la información que trae esta publicación te ayude a construir mejores aplicaciones: frescura y optimización.Hay otra técnica para despertar tu aplicación, la notificación silenciosa. Hablaremos de ello en el próximo tutorial.¡Feliz fin de semana! Referencias Background execution demystified WWDC 2020 Advances in App Background Execution WWDC 2019","link":"/es/posts/Best-practice-iOS-background-processing-Background-App-Refresh-Task/index.html"},{"title":"Mejores prácticas: iBeacon","text":"Bienvenido a la siguiente parte de la serie de “Cómo manejar BLE en segundo plano“.En la parte anterior, te guié sobre cómo mantener tu aplicación viva el mayor tiempo posible cuando tu aplicación entra en modo de segundo plano usando la técnica State Preservation and Restoration soportada por Apple. Sin embargo, hay algunos casos de uso que esta técnica no puede manejar, como se describe a continuación (referencia al documento de Apple: Conditions Under Which Bluetooth State Restoration Will Relaunch An App)Como puedes ver, hay un caso común cuando los usuarios fuerzan el cierre de la aplicación desde la vista de tareas múltiples (Ya sea accidentalmente o intencionalmente), la técnica de Restoration no puede despertar tu aplicación. Imaginemos que tu aplicación tiene una función que permite a los usuarios presionar un botón en sus dispositivos conectados por BLE para encontrar dónde está su teléfono, pero si tu aplicación no se está ejecutando o no puede despertarse para manejar la señal BLE enviada desde tus dispositivos, esta función sería inútil.En esta publicación, te mostraré una técnica usando iBeacon para lidiar con este caso, que le da a tu aplicación otra oportunidad de despertarse aunque haya sido terminada por los usuarios. ¡Vamos a sumergirnos! Bienvenido al mundo de iBeaconiBeacon es un protocolo introducido por primera vez por Apple en la WWDC 2013. “iBeacon se basa en la detección de proximidad Bluetooth low energy transmitiendo un identificador universalmente único captado por una aplicación compatible o sistema operativo. El identificador y varios bytes enviados con él se pueden usar para determinar la ubicación física del dispositivo, rastrear clientes o activar una acción basada en la ubicación en el dispositivo, como un check-in en redes sociales o una notificación push” (Wiki).La aplicación de iBeacon es muy diversa como servicios basados en ubicación, comercio móvil o publicidad, por nombrar algunos.“The Automatic Museum Guide” (La Guía Automática del Museo) es un proyecto que me impresionó mucho, construido sobre la tecnología iBeacon. La aplicación permite a los visitantes explorar exhibiciones mostrando los contenidos apropiados rastreando su ubicación y su distancia con el beacon. ¡Esa es una idea brillante! Cómo funcionaApple ha estandarizado el contenido de los datos de advertisement de iBeacon. Consiste en un UUID de 16 bytes, la versión major y minor. Estos tres factores son únicos para cada beacon. Un último campo en el paquete es TX power usado para determinar qué tan cerca estás del beacon.Un beacon transmite este paquete en su rango, desde 20m hasta 300m, a intervalos regulares de tiempo. Estos paquetes son detectados automáticamente por teléfonos cercanos, luego la aplicación realizará una acción predefinida como mostrar una notificación o mostrar un código de promoción. Aunque iBeacon está basado en la tecnología Bluetooth low energy, una de las principales diferencias entre los dos es que iBeacon es una tecnología de transmisión unidireccional, con lo que quiero decir que solo el teléfono puede recibir datos de dispositivos iBeacon. Integración con iOS: comenzar a hacer advertising como un iBeaconPrimero, necesitamos un beacon para poder hacer el siguiente paso. Voy a usar mi iPad para actuar como un beacon usando un objeto CLBeaconRegion en CoreBluetooth en iOS.La UI principal simplemente contiene dos botones principales que iniciarán y detendrán el advertisement del iBeacon, respectivamente. 123456let region = CLBeaconRegion(proximityUUID: self.uuid!, major: self.major, minor: self.minor, identifier: self.identifier)let peripheralData = region.peripheralData(withMeasuredPower: nil)peripheral.startAdvertising(((peripheralData as NSDictionary) as! [String : Any])) Luego, implementamos el delegado peripheralManagerDidStartAdvertising(CBPeripheralManager, Error?) para verificar si el beacon hace advertising exitosamente. 1234567func peripheralManagerDidStartAdvertising(_ peripheral: CBPeripheralManager, error: Error?) { if error == nil { print(\"Successfully started advertising our beacon data.\") } else { print(\"Failed to advertise our beacon. Error = \\(String(describing: error))\") }} Para detener el advertising 1peripheralManager?.stopAdvertising() Aprovechar la tecnología iBeacon para hacer que nuestra aplicación dure para siemprePrimero, dentro del método didFinishLaunchingWithOptions de la clase AppDelegate, mostraré una notificación para ser notificado cada vez que nuestra aplicación sea relanzada. 1234func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -&gt; Bool { NotificationHandler.shared.showNotification(title: \"App did launch\", body: \"\") return true} Después de que aparece la vista principal, le digo al location manager que comience a monitorear la región dada y que comience a medir la distancia de los iBeacons dentro de esa región 1234func startMonitoring() { locationManager.startMonitoring(for: beaconRegion) locationManager.startRangingBeacons(in: beaconRegion)} Por defecto, el monitoreo te notifica cuando se entra o sale de la región independientemente de si tu aplicación está ejecutándose. El ranging, por otro lado, monitorea la proximidad de la región solo mientras tu aplicación está ejecutándose. Eso es todo para la configuración. En la siguiente demostración, verás que abro la aplicación y luego la termino desde la vista de tareas múltiples. Después de eso, presiono el botón “Start advertising” en mi iPad (El beacon). Verás que la aplicación fue relanzada inmediatamente aunque había sido eliminada (La notificación “App did launch” apareció). Eso es increíble. Nota: No esperes recibir un evento de inmediato, porque solo los cruces de límites generan un evento. En particular, si la ubicación del usuario ya está dentro de la región en el momento del registro, el location manager no genera automáticamente un evento. En su lugar, tu aplicación debe esperar a que el usuario cruce el límite de la región antes de que se genere un evento y se envíe al delegado. ConclusionesUna de las cosas más interesantes de iBeacon es que las aplicaciones iBeacon pueden ser despertadas incluso si han sido terminadas por el usuario. Significa que las aplicaciones iBeacon pueden durar para siempre. Para descargar los proyectos completos, por favor haz clic en los siguientes enlaces de Github: Actuar como un iBeacon: https://github.com/uynguyen/iBeaconDevice Aplicación Central manager: https://github.com/uynguyen/CentralManager-iBeacon No dudes en enviarme un correo electrónico si tienes alguna pregunta. Referencias[1] Region Monitoring and iBeacon","link":"/es/posts/Best-practice-iBeacon/index.html"},{"title":"Mejores prácticas: iOS vs Android Bluetooth","text":"La tecnología Bluetooth se ha convertido en una parte integral de las aplicaciones móviles modernas, permitiendo una comunicación inalámbrica fluida entre dispositivos. Ya sea para conectarse a unos auriculares inalámbricos, transferir archivos o interactuar con dispositivos del hogar inteligente, Bluetooth juega un papel crucial en mejorar la experiencia del usuario. Para los desarrolladores móviles, entender cómo implementar la funcionalidad Bluetooth es esencial. En esta publicación, profundizaremos en una comparación detallada de los frameworks de desarrollo Bluetooth para iOS y Android. Exploraremos las diferencias clave y similitudes entre estas dos plataformas, cubriendo todo desde la configuración inicial hasta la transferencia de datos y el manejo de errores. Al final de esta comparación, tendrás una comprensión clara de cómo aprovechar la tecnología Bluetooth en tus aplicaciones móviles, independientemente de si estás desarrollando para iOS o Android. Para tener una mejor visualización, hice una imagen a continuación para resumir el flujo para establecer una conexión en Android e iOS A primera vista, los dos flujos parecen bastante similares. Sin embargo, el flujo de Android incluye pasos adicionales. Aunque el proceso de conexión es más complejo en Android comparado con iOS, proporciona mayor control sobre los datos devueltos. Desglosemos el flujo en tres pasos principales para discusión: Scanning, Getting Ready, Interacting y Closing. Cada uno de estos pasos involucra acciones específicas y consideraciones que contribuyen a la funcionalidad general y eficiencia del proceso de conexión. ScanningEn la fase de scanning, los procesos son bastante similares entre Android e iOS, desde iniciar un escaneo hasta crear una conexión. La principal diferencia es que hay más información sobre el peripheral en el resultado del escaneo en Android que en iOS. El valor más interesante es la dirección MAC del dispositivo. iOS no expone este valor y en su lugar proporciona un UUID aleatorio.Los UUIDs en iOS se generan por aplicación y por emparejamiento de dispositivo, y su vida útil está ligada a la sesión o hasta que el dispositivo sea olvidado, así que no confíes en él para identificar o reconectarte a tus dispositivos. iOS no expone la dirección MAC por varias razones, principalmente relacionadas con privacidad y seguridad. Al ocultar la dirección MAC, Apple asegura que las aplicaciones y terceros no puedan usar mal esta información para rastrear o perfilar usuarios y también ayuda a prevenir actividades ilegales por parte de atacantes. Una posible solución para superar esta limitación es incluir tu propio identificador único en el paquete de advertising, que estará disponible en todas las plataformas. Otra nota importante es que el sistema operativo Android previene iniciar-detener escaneos más de aproximadamente 5 veces en 30 segundos (por favor nota que este valor varía de dispositivo a dispositivo). Llamar al método startScan muy frecuentemente en un corto tiempo llevará a que no se descubran dispositivos. El último valor común es el valor de intensidad de señal, RSSI (Received Signal Strength Indicator), que indica qué tan lejos está el dispositivo del teléfono. El rango es de -30 a -99; cuanto más cercano esté el valor a -30, más cerca está el dispositivo. Getting ReadyUna vez que tu dispositivo ha sido descubierto, el siguiente paso es prepararlo para que puedas realizar acciones de lectura y escritura. Hay dos enfoques diferentes para hacer que un dispositivo esté “listo”. El primer enfoque es action on-demand, que involucra no hacer nada hasta que sea necesario. Esto significa que no necesitas descubrir services/characteristics o establecer notificaciones hasta que tu aplicación realice comandos de lectura o escritura. La ventaja es una fase de conexión más corta, ya que tu aplicación no necesita descubrir todos los services y characteristics, establecer notificaciones o manejar errores si alguno falla. La desventaja es que la primera operación de lectura o escritura tomará más tiempo. El segundo enfoque involucra descubrir todos los perfiles Bluetooth por adelantado y hacer que el dispositivo esté listo para cualquier comando. Las desventajas y ventajas son opuestas al primer enfoque. No hay nada correcto o incorrecto con cada enfoque; es solo una cuestión de preferencia. Así que elige el que mejor te convenga. Para mí, prefiero ir con el segundo enfoque, como se describe en la imagen. La fase de configuración en iOS es bastante simple. Tu aplicación solo necesita descubrir todos los services. Para cada service, luego llamas a descubrir todas sus characteristics. Finalmente, establece notificaciones si las characteristics soportan cambios de valor. Podrías querer mantener una referencia a cada item de characteristic (CBPeripheral) para que puedas realizar operaciones de lectura y escritura. Por otro lado, el flujo de “preparar” es bastante complicado para Android. Si eres un desarrollador de iOS, podrías no interactuar mucho con el GATT Descriptor en tu aplicación. Primero, necesitas familiarizarte con los conceptos de GATT Descriptor y MTU (Maximum Transmission Unit). GATT Descriptor proporciona información extra sobre la characteristic con la que están asociados. Por ejemplo, cuando lees un valor de temperatura de un termómetro BLE, la characteristic podría tener un descriptor indicando la unidad de medida en Celsius o Fahrenheit. El GATT Descriptor más común es el Client Characteristic Configuration Descriptor (CCCD), que usarás para habilitar/deshabilitar notificaciones/indicaciones para una characteristic.La principal diferencia entre los tipos notification e indication es la confiabilidad. Las notificaciones son enviadas por el peripheral sin requerir un acknowledgment del dispositivo central. En contraste, las indicaciones requieren un acknowledgment del dispositivo central. Es simple establecer una notificación en iOS llamando a CBCharacteristic.setNotify() y el sistema hará el resto por ti. Identificará automáticamente el tipo de notificación y establecerá el valor correcto. En Android, debes llamarlo tú mismo. El siguiente código de ejemplo demuestra cómo puedes establecer una notificación para tu characteristic en Android: 12345678910111213141516171819202122232425262728final UUID CCCD_UUID = UUID.fromString(\"00002902-0000-1000-8000-00805f9b34fb\");if (!gattServer.setCharacteristicNotification(characteristic, true)) { return false;}final boolean canNotify = (characteristic.getProperties() &amp; BluetoothGattCharacteristic.PROPERTY_NOTIFY) &gt; 0;final boolean canIndicate = (characteristic.getProperties() &amp; BluetoothGattCharacteristic.PROPERTY_INDICATE) &gt; 0;if (!canNotify &amp;&amp; !canIndicate) { // No soporta notification/indication, no hacemos nada return true;}final BluetoothGattDescriptor cccDescriptor = characteristic.getDescriptor(CCCD_UUID);if (cccDescriptor == null) { // ¿No se puede encontrar el descriptor en la characteristic? return false;}if (cccDescriptor.setValue(canNotify ? BluetoothGattDescriptor.ENABLE_NOTIFICATION_VALUE : BluetoothGattDescriptor.ENABLE_INDICATION_VALUE)) { gattServer.writeDescriptor(cccDescriptor); return true;}return false; El paso final es opcional: solicitar cambiar el valor de MTU.MTU (Maximum Transmission Unit) se refiere a la mayor cantidad de datos que pueden enviarse en un solo paquete Bluetooth. Por defecto, el valor de MTU en BLE es 23 bytes, en otras palabras, para un solo comando de lectura y escritura, el máximo de bytes que tu aplicación/dispositivo puede entregar es 23 bytes (con un header de 3 bytes), pero puede negociarse entre los dispositivos central y peripheral hasta 517 bytes. En iOS, no solicitas directamente un tamaño de MTU; en su lugar, el MTU se negocia automáticamente entre los dispositivos central y peripheral durante el proceso de conexión. En Android, usa BluetoothGatt.requestMtu() para solicitar un tamaño de MTU específico y maneja la respuesta en BluetoothGattCallback.onMtuChanged(). Es un error común olvidar aumentar el MTU mientras tu dispositivo está enviando más de 20 bytes por solicitud, lo que lleva a datos faltantes en el paquete. Un comentario importante respecto a establecer conexiones es que hay un número máximo de dispositivos que pueden conectarse simultáneamente. No hay documentos oficiales para este número, pero muchos desarrolladores han encontrado que en iOS es alrededor de 7 - 10 dispositivos, mientras que en Android es alrededor de 10 - 20 dependiendo del modelo de teléfono y versión de Android. 123456789101112private final BluetoothGattCallback gattCallback = new BluetoothGattCallback() { @Override public void onMtuChanged(BluetoothGatt gatt, int mtu, int status) { if (status == BluetoothGatt.GATT_SUCCESS) { // Cambio de tamaño de MTU exitoso Log.d(\"MTU\", \"MTU changed to \" + mtu); } else { // Cambio de tamaño de MTU fallido Log.d(\"MTU\", \"MTU change failed with status \" + status); } }}; InteractingAl completar todos los pasos anteriores exitosamente, tu dispositivo está ahora listo para usar. Puedes leer valores de una characteristic, transferir datos a una específica, o leer el valor RSSI para determinar la distancia. Asegúrate de manejar los cambios de valor correctamente verificando de qué characteristic viene el valor. Vale la pena mencionar que en iOS, si tu aplicación transfiere una gran cantidad de datos al dispositivo (por ejemplo, transfiriendo un archivo), deberías esperar a que el siguiente evento peripheralIsReady se dispare antes de enviar el siguiente paquete. Enviar continuamente múltiples paquetes sin esperar este evento podría poner presión en los buffers de cola, llevando a paquetes perdidos. 123func peripheralIsReady(toSendWriteWithoutResponse peripheral: CBPeripheral) { // Listo para enviar el siguiente paquete} ClosingUna vez más, el paso de desconexión en iOS es muy simple. Solo necesitas llamar al método cancelPeripheralConnection. En Android, necesitas hacer más de una operación: disconnect el dispositivo y close el Bluetooth GATT. Recuerda que llamar disconnect solo cancela la conexión con el peripheral, no libera todos los recursos (por ejemplo, slots disponibles en el stack Bluetooth) hasta que llames close. Usas disconnect cuando quieres terminar temporalmente la conexión pero podrías reconectarte al dispositivo más tarde sin necesidad de restablecer completamente la configuración GATT. Usas close cuando has terminado completamente con la conexión Bluetooth y quieres asegurar que todos los recursos se limpien. ConclusiónEn esta publicación, exploramos los puntos importantes de implementar funcionalidad Bluetooth en aplicaciones móviles para iOS y Android. A través de nuestra comparación detallada, surgieron varios puntos clave que destacan tanto las similitudes como las diferencias entre estas dos plataformas. iOS Core Bluetooth ofrece un framework robusto y directo que se integra perfectamente con el ecosistema iOS. Proporciona una API limpia y consistente. Android Bluetooth, por otro lado, ofrece flexibilidad, capacidades extensas y soporta una amplia gama de funcionalidades Bluetooth. Aunque la configuración e implementación podría ser ligeramente más compleja comparada con iOS, la API Bluetooth de Android proporciona herramientas poderosas para manejar interacciones Bluetooth efectivamente. ReferenciasThe Ultimate Guide to Android Bluetooth Low EnergyThe Ultimate Guide to Apple’s Core Bluetooth","link":"/es/posts/Best-practice-iOS-vs-Android-Bluetooth/index.html"},{"title":"Integración de Bluetooth con App Clips: Una Guía Práctica","text":"Hoy en día, los usuarios demandan acceso rápido y fácil a los servicios que necesitan, sin descargar la versión completa de una aplicación. App Clips - una característica introducida por Apple en iOS 14 - ofrece una solución a esta demanda al permitir a los usuarios acceder a una pequeña parte de una aplicación. Al integrar tu aplicación habilitada para Bluetooth con App Clip, puedes llevar la experiencia del usuario al siguiente nivel. Esto abre nuevas posibilidades, como permitir a los usuarios conectarse a dispositivos cercanos, realizar una función específica y más. En este tutorial, te guiaré a través de la integración de Bluetooth en tu App Clip. Ya seas un desarrollador experimentado o un principiante, encontrarás todo lo que necesitas para comenzar. ¡Así que, vamos a sumergirnos! App Clips“Un App Clip es una pequeña parte de tu aplicación que es descubrible en el momento que se necesita y permite a las personas completar una tarea rápida de tu aplicación — incluso antes de instalar tu aplicación completa.”. Los App Clips están diseñados para ser ligeros y rápidos, proporcionando acceso rápido a las características y servicios principales de tu aplicación.Hay muchos beneficios de usar App Clips. Primero, ofrece una parte ligera de tu aplicación para que los usuarios prueben una característica de la aplicación sin comprometerse a una descarga completa. Segundo, los App Clips pueden ser lanzados a través de varios canales como etiquetas NFC, códigos QR, enlaces desde Safari o Messages.Aquí hay algunos casos de uso y aplicaciones de ejemplo que usan App Clips: Tickets: App Clip puede usarse para comprar y acceder rápidamente a tickets para eventos como conciertos, películas o eventos deportivos. Solicitud de viajes: App Clip puede usarse para hacer fácilmente una solicitud de servicio de viaje. Ej. Lyft. Retail: Los App Clips pueden usarse para acceder rápidamente a información del producto, hacer una compra o canjear un cupón en una tienda minorista Pedidos de comida: los usuarios pueden acceder rápidamente al menú del restaurante y hacer un pedido. Ej: Panera Bread. Estacionamiento: Los usuarios pueden simplemente escanear un código QR o tocar una etiqueta NFC para lanzar el App Clip y pagar por su lugar de estacionamiento. Por favor ten en cuenta que se requiere una cuenta de pago de Apple para desarrollar un App Clip. ConfiguraciónAbrir un hostingAntes de lanzar el App Clip, el sistema asegura que el App Clip incluya su firma de código en tu sitio web. Si tienes tu propio sitio web puedes agregar las siguientes líneas a tu Apple App Site Association (AASA) en tu servidor e ir al siguiente paso. 1234567{ &quot;appclips&quot;: { &quot;apps&quot;: [ &quot;[YOUR_TEAM_ID].[YOUR_APP_CLIP_BUNDLE_ID]&quot; ] }} Firebase Hosting puede ser una gran opción para aquellos que no tienen su propio servidor. Con Firebase Hosting, puedes configurar fácilmente tu sitio sin ningún costo ya que proporciona un nivel gratuito para hosting. Instala la herramienta de línea de comandos de Firebase mediante el siguiente comando sudo npm install -g firebase-tools Luego, inicia sesión en tu cuenta de Firebase firebase login Después de iniciar sesión exitosamente, navega al directorio que contiene el archivo que quieres subir, y luego ejecuta firebase init para seleccionar la opción hosting. Agrega las siguientes líneas al archivo firebase.json. 1234567891011121314...&quot;headers&quot;: [ { &quot;source&quot;: &quot;/.well-known/apple-app-site-association&quot;, &quot;headers&quot;: [ { &quot;key&quot;: &quot;Content-Type&quot;, &quot;value&quot;: &quot;application/json&quot; } ] }],&quot;appAssociation&quot;: &quot;NONE&quot;,... A continuación, crea el archivo public/.well-known/apple-app-site-association. 1234567{ &quot;appclips&quot;: { &quot;apps&quot;: [ &quot;[YOUR_TEAM_ID].[YOUR_APP_CLIP_BUNDLE_ID]&quot; ] }} Finalmente, sube los archivos a firebase firebase deploy Una vez que el despliegue sea exitoso, se te proporcionará la URL de tu sitio web. Esta URL se usará para configurar el lanzamiento de tu App Clip. Agregar target de App ClipPrimero, abre tu proyecto de Xcode y navega al menú File. Desde ahí, selecciona New y luego Target. Esto abrirá un cuadro de diálogo que te permite elegir el tipo de target que quieres crear. A continuación, selecciona la opción para App Clip y haz clic en Next. Esto te llevará a una pantalla donde puedes configurar varios ajustes para tu App Clip, como su nombre, identificador y target de despliegue. Una vez que hayas configurado estos ajustes, haz clic en Finish para crear el nuevo target de App Clip. Esto agregará los archivos y recursos necesarios a tu proyecto y te permitirá comenzar a desarrollar tu App Clip. Para configurar tu App Clip para que se lance correctamente, necesitarás seguir unos simples pasos.Primero, selecciona tu target de App Clip desde Xcode, luego navega a Signing &amp; Capabilities y selecciona Associated Domains. Desde ahí, puedes agregar tu URL de hosting a la lista de dominios con los que tu App Clip está asociado. Por ejemplo, digamos que tu URL de hosting es awesomeapp-54431.web.app. En este caso, agregarías appclips:awesomeapp-54431.web.app a la lista de dominios. Una vez que hayas completado estos pasos, todo debería estar configurado correctamente y puedes comenzar a implementar las funciones de tu App Clip. Esto puede involucrar escribir código para interactuar con varias APIs, diseñar interfaces de usuario y más. Los detalles exactos dependerán de los requisitos específicos de tu App Clip y las características que quieras incluir. ImplementaciónDesarrollaré una aplicación muy simple que permite escanear dispositivos Bluetooth cercanos y mostrarlos en una lista al lanzar el App Clip para demostrar cómo utilizar Bluetooth en App Clip. Puedes modificar la aplicación para que se ajuste a tus necesidades, como identificar automáticamente un dispositivo pre-seleccionado por dirección y conectarse automáticamente al dispositivo para ejecutar una tarea específica. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950struct ContentView: View { // El resto está omitido ... var body: some View { NavigationView { VStack { Image(\"logo\").resizable() .scaledToFit() .frame(width: 120).padding(.top, 10) TitleLargeText(\"Awesome App\").padding(.bottom, 5).padding(.top, 10).padding(.bottom, 10) Spacer() LabelLargeText(\"Nearby Devices\").frame(maxWidth: .infinity, alignment: .leading).padding(.horizontal, 20) List(devices.map { $0.name ?? \"Unknown name\" }, id: \\.self) { deviceName in LabelMediumText(deviceName) } VStack { HStack { LabelMediumText(\"Powered By\") Link(destination: URL(string: \"https://uynguyen.github.io\")!, label: { LabelMediumText(\"Uy Nguyen\", underline: true) }) }.padding(.top, 5) } } .frame(maxWidth: .infinity, maxHeight: .infinity, alignment: .top) .background(Color.black).onContinueUserActivity(NSUserActivityTypeBrowsingWeb, perform: handleUserActivity) .navigationBarTitle(\"\") .navigationBarHidden(true) } } func handleUserActivity(_ userActivity: NSUserActivity) { // Puedes extraer parámetros de la url, validar si la url es válida, etc. guard let incomingURL = userActivity.webpageURL, let components = URLComponents(url: incomingURL, resolvingAgainstBaseURL: true), let queryItems = components.queryItems else { return } // Todo está bien, comencemos a escanear BluetoothManager.shared.config { device, rssi in if !(devices.contains(where: { $0.identifier.uuidString == device.identifier.uuidString })) { devices.append(device) } } } ...} PruebasCódigo QR y NFCApple soporta probar tu App Clip sin tener que publicarlo mediante el registro de una Local Experience.Para registrar una experiencia local, ve a la configuración del teléfono Settings y selecciona Developer. Desde ahí, puedes acceder al menú Local Experiences y hacer clic en Register Local Experience.Una vez que hayas ingresado tu prefijo de URL y Bundle ID, podrás comenzar a completar la información para tu App Clip Card. Esta es la sección que se mostrará a los usuarios cuando hagan clic en la URL o escaneen el código QR asociado con tu App Clip.En la sección de App Clip Card, podrás proporcionar a los usuarios información importante sobre tu App Clip, incluyendo su nombre, banner y descripción. Esta información debe ser clara y concisa para que los usuarios puedan entender rápidamente qué hace tu App Clip y cómo puede serles útil.Además de esto, también necesitarás seleccionar el tipo de botón que quieres usar para tu App Clip. Hay tres tipos diferentes de botones disponibles: Open, View y Play.El botón Open se usa para lanzar el App Clip y llevar a los usuarios directamente a su interfaz principal.El botón View se usa para mostrar contenido específico dentro del App Clip, como una página o característica particular.Finalmente, el botón Play se usa para lanzar un reproductor multimedia dentro del App Clip, permitiendo a los usuarios escuchar música o ver videos.Siguiendo estos simples pasos y proporcionando a los usuarios un App Clip Card claro y atractivo, puedes ayudar a asegurar que tu App Clip sea exitoso y bien recibido por tu audiencia objetivo. En el video a continuación, puedes ver una demostración de cómo escanear el código QR asociado con mi sitio web, lanza automáticamente el App Clip e inicia el proceso de escaneo Bluetooth para dispositivos cercanos. Este es un ejemplo simple de cómo los App Clips pueden ofrecer una experiencia de usuario conveniente que elimina la necesidad de que los usuarios naveguen a través de múltiples pantallas o descarguen la aplicación completa. Notas: Si encuentras que ya no necesitas un App Clip que hayas instalado previamente en tu dispositivo iOS, puedes eliminarlo fácilmente siguiendo unos simples pasos. Simplemente ve a Settings y selecciona la opción App Clips. Desde ahí, puedes seleccionar el App Clip que quieres eliminar y hacer clic en la opción para borrarlo. Si estás experimentando problemas con tu App Clip y no se lanza a pesar de estar configurado correctamente, lo primero que deberías intentar es invalidar el caché y re-registrar tus experiencias locales. Esto puede hacerse yendo a Settings y seleccionando la opción Developer. Desde ahí, puedes acceder al menú Local Experiences y hacer clic en la opción Invalidate Cache. Una vez que hayas hecho esto, puedes re-registrar tus experiencias locales e intentar lanzar tu App Clip de nuevo. Safari y iMessageAdemás de lanzar App Clips mediante códigos QR, Apple también ofrece soporte para lanzar tu App Clip cuando un usuario comparte un enlace a tu sitio web a través de la aplicación Messages, o ve la URL en Safari directamente. El destinatario puede tocar el enlace para lanzar instantáneamente tu App Clip y acceder a la funcionalidad de tu App Clip rápida y fácilmente. Es importante notar que el Smart App Banner de Safari y compartir vía Messages solo están disponibles cuando el App Clip está publicado en el App Store. Banner de App Clip en Safari: requiere que el dispositivo del usuario tenga iOS 15+. Banner de App Clip en iMessage: requiere que el dispositivo del usuario tenga iOS 14+, y que contenga al remitente como contacto en la aplicación Contacts. Para habilitar mostrar la tarjeta de App Clip en Safari e iMessage, configura las siguientes líneas en tu sitio web. 1234&lt;meta name=&quot;apple-itunes-app&quot; content=&quot;app-id=YOUR_APP_ID, app-clip-bundle-id=YOUR_APP_CLIP_ID, app-clip-display=card&quot; /&gt;&lt;meta property=&quot;og:image&quot; content=&quot;BANNER_URL&quot; /&gt;&lt;meta property=&quot;og:title&quot; content=&quot;Awesome App&quot; /&gt;&lt;meta property=&quot;og:description&quot; content=&quot;Awesome App description&quot; /&gt; Mejores prácticas Mantenlo simple: El propósito de un App Clip es proporcionar una versión simplificada de la funcionalidad de tu aplicación. Enfócate en proporcionar solo las características clave que los usuarios más probablemente necesiten en el contexto donde están usando el App Clip. Optimiza para velocidad: Los App Clips deben ser ligeros y de carga rápida (Apple requiere que el tamaño del App Clip sea menor de 15MB, esto es para asegurar que los App Clips puedan ser descargados y lanzados rápidamente, incluso en conexiones de red más lentas.) para asegurar que los usuarios puedan acceder rápidamente a la funcionalidad que necesitan. Minimiza la cantidad de contenido y assets que se cargan para asegurar que el App Clip cargue rápidamente y no consuma demasiados datos. Es importante mantener el número de parámetros al mínimo y asegurarse de que sean fáciles de entender. Cuanto más complejos sean los parámetros, más difícil será para los usuarios saber cómo usarlos. Limita la longitud de los parámetros: Es mejor limitar la longitud de los parámetros a no más de 50 caracteres. Esto ayudará a asegurar que los usuarios puedan leer y entender fácilmente los parámetros. Valida los parámetros: Asegúrate de que tu App Clip valide todos los parámetros que se le pasan. Esto ayudará a asegurar que tu App Clip funcione correctamente y que los usuarios no puedan explotar ninguna vulnerabilidad. Además de escanear códigos QR, mostrar en Safari y compartir vía iMessage, Apple ofrece varios otros métodos para lanzar App Clips, como tocar un enlace en la aplicación Maps, sugerencias basadas en ubicación de Siri Suggestions y etiquetas NFC. Para asegurar que los usuarios puedan descubrir fácilmente tu App Clip, es importante aprovechar el método de lanzamiento apropiado y optimizar para descubribilidad. Al hacerlo, puedes aumentar las posibilidades de que los usuarios encuentren e interactúen con tu App Clip. Siguiente pasoEn el próximo tutorial, te proporcionaré instrucciones detalladas sobre cómo publicar tu App Clip y configurarlo para que se ejecute en Safari, Maps e iMessage. Sin embargo, ten en cuenta que los App Clips solo pueden ser lanzados cuando están publicados en el App Store. Por lo tanto, no puedo demostrar el proceso hasta que mi App Clip pase el proceso de revisión de Apple. :P ConclusiónEn conclusión, los App Clips ofrecen una gran oportunidad para mejorar la experiencia del usuario y simplificar el proceso de interacción con la aplicación. Con App Clips, los usuarios pueden acceder rápidamente a una función específica sin necesidad de descargar la aplicación completa. Esto puede ser particularmente útil para usuarios que quieren probar tu aplicación o tienen planes de datos o almacenamiento limitados. Ya seas propietario de un restaurante, gerente de tienda minorista o cualquier otro tipo de negocio, puedes aprovechar App Clip para crear una mejor experiencia general para tus usuarios.Entonces, ¿qué estás esperando? Dale una oportunidad a los App Clips y ve la diferencia que pueden hacer para tu aplicación y tu negocio. Referencias https://developer.apple.com/app-clips/","link":"/es/posts/Bluetooth-Integration-with-App-Clips-A-How-To-Guide/index.html"},{"title":"Big Endian vs Little Endian","text":"En ciencias de la computacion, un bit es la pieza de informacion mas pequena. Representa un digito del sistema numeral binario. Una cadena de 8 bits se llama un byte. Hay dos formas de almacenar una cadena de datos en computadoras: Big Endian y Little Endian. Si tus tareas trabajan con datos en piezas de bytes, debes saber como tratar con bytes en estos dos formatos. En este articulo, explicare como se almacenan los datos en las computadoras, cuales son las principales diferencias entre estos dos, y luego proporcionare algo de codigo util para trabajar con bytes en Swift y Objective-C. Conceptos basicosPara entender Big Endian y Little Endian, necesitas saber que son el Byte Menos Significativo (LSB) y el Byte Mas Significativo (MSB). El LSB es el bit mas a la derecha en una cadena, se llama asi porque tiene el menor efecto en el valor del numero binario. En contraste, el byte mas a la izquierda es el MSB que lleva el mayor valor numerico.Despues de entender estos dos, es facil distinguir entre Big Endian y Little Endian: En Big Endian, el MSB de los datos se coloca en el byte con la direccion mas baja. En Little Endian, el LSB de los datos se coloca en el byte con la direccion mas baja. Eso es todo! Las ventajas de Big Endian y Little Endian en una arquitectura de computadoraSegun Wiki, Big Endian es “el formato mas comun en redes de datos”, muchos protocolos de red como TCP, UDP, IPv4 e IPv6 estan usando el orden Big Endian para transmitir datos. Little Endian se usa principalmente en microprocesadores. Pero el punto es por que hacen eso?Bueno, cuando trabajaba con el orden de bytes en iOS, tambien me hice la pregunta a mi mismo y a mis colegas, “por que hacen eso?”, “Por que eligen Big Endian en lugar de Little Endian?”. Despues de investigar en internet, y obtener respuestas de un ingeniero senior de firmware en mi oficina, gradualmente entendi las ventajas de ambas formas de orden.Las ventajas de Little Endian son: Es facil leer el valor en una variedad de tamanos de tipo. Por ejemplo, la variable A = 0x13 en valor de 64 bits en memoria en la direccion B sera 1300 0000 0000 0000. A siempre se leera como 19 independientemente de usar lecturas de 8, 16, 32, 64 bits. Por el contrario, en Big Endian tenemos que saber en que tamano hemos escrito el valor para leerlo correctamente. Es facil convertir el valor a un tipo mas pequeno como de int16_t a int8_t ya que int8_t es el byte al principio de int16_t. Es facil hacer calculos matematicos “debido a la relacion 1:1 entre el desplazamiento de direccion y el numero de byte (desplazamiento 0 es byte 0), las rutinas matematicas de precision multiple son correspondientemente faciles de escribir.” Algunas ventajas principales de Big Endian son Siempre podemos probar si el numero es positivo o negativo mirando el byte en el desplazamiento cero, por lo que es facil hacer una comparacion. Los numeros tambien se almacenan en el orden en que se imprimen, por lo que las rutinas de binario a decimal son particularmente eficientes. Orden de bytes en iOSTanto Swift como Objective-C soportan metodos que nos ayudan a leer y escribir datos en las dos formas Little Endian y Big Endian. Las siguientes secciones demuestran como usamos estos metodos para interactuar con datos en memoria. Orden de bytes en Objective-C1234567891011121314NSString *strData = @\"001E653A\";NSData *data = [NSData dataWithHexString:strData];uint8_t *bytes = (uint8_t *)data.bytes;/* Functions for loading little endian to host endianess. */uint16_t firstInLittle = OSReadLittleInt16(bytes, 0); // 0x1E00 = 7680uint16_t secondInLittle = OSReadLittleInt16(bytes, 2); // 0x3A65 = 14949uint16_t firstInBig = OSReadBigInt16(bytes, 0); // 0x001E = 30uint16_t secondInBig = OSReadBigInt16(bytes, 2); // 0x653A = 25914/* Functions for storing host endianess to little endian. */uint8_t byte16[2];OSWriteLittleInt16(byte16, 0, firstInLittle); // byte16 = [0x00, 0x1E] Orden de bytes en Swift123456789101112let strData = \"3A651E00\"if let data = strData.hexadecimal() { let bytesArr = [UInt8](data) /* Functions for loading native endian values. */ let little = _OSReadInt16(bytesArr, 0) // 0x653A = 25914 let big = first.bigEndian // 0x3A65 = 14949 /* Functions for storing native endian values. */ let bytes = [UInt8](repeating: 0, count: 2) _OSWriteInt16(UnsafeMutableRawPointer(mutating:bytes), 0, second) // bytes = [0x65, 0x3A]} Pensamientos finalesEn este articulo, te mostre las diferencias entre los formatos de endianness y proporcione algo de codigo util para trabajar con bytes en iOS. Si tienes alguna sugerencia, solo hazmelo saber.Feliz fin de semana.","link":"/es/posts/Big-Endian-vs-Little-Endian/index.html"},{"title":"Beta Test y TestFlight","text":"Como desarrollador iOS, probablemente hayas escuchado sobre TestFlight - un producto de Apple que te permite distribuir tus aplicaciones a usuarios beta. Entonces, ¿qué podemos hacer con él? ¿Es útil?En este tutorial, recorreremos los pasos para subir un build a TestFlight e invitar usuarios a probar tu aplicación.También necesitas referirte a la publicación anterior Enviando tu aplicación a la Store para completar este tutorial.¡Divirtámonos! ¿Qué es TestFlight?TestFlight es un producto de Apple que permite a los desarrolladores distribuir sus aplicaciones a usuarios beta antes de pasar a producción. Con la última actualización de la aplicación TestFlight en iOS 13, los testers pueden dar retroalimentación directamente desde la aplicación con capturas de pantalla, crashes y otra información útil proporcionada. Usar TestFlight es una excelente manera de ayudar a probar tus aplicaciones y mejorar el rendimiento antes de que salgan en vivo.TestFlight proporciona dos tipos de testers: Tester Interno: Permite hasta 25 miembros de tu equipo que hayan sido asignados a un rol específico para probar tu aplicación. Cada miembro puede probar en hasta 30 dispositivos. Una vez que un build beta se envía a App Store Connect y está disponible para pruebas, los testers internos serán notificados para que puedan actualizar la aplicación. Tester Externo: Puedes invitar hasta 10,000 testers usando solo su dirección de correo electrónico o compartiendo un enlace público. La principal diferencia entre los dos es que para permitir que un Tester Externo pruebe tu aplicación, debes enviar tu aplicación a Apple para revisión. El proceso de revisión es el mismo que un envío oficial pero generalmente es más rápido que las revisiones normales de aplicaciones. Por contrato, probar tu aplicación con testers internos no requiere revisión por parte de Apple. Seleccionar build para pruebasDespués de completar el paso final en Enviando tu aplicación a la Store, tu aplicación se ha enviado exitosamente a App Store Connect. Ahora, navega a tu página de desarrolladores de Apple e inicia sesión con tu Apple Id, luego selecciona “My Apps” para ver todas las aplicaciones disponibles &gt; Selecciona una aplicación específica &gt; Desde la barra de herramientas superior &gt; Selecciona TestFlight &gt; Verás todos los builds que están disponibles para pruebas.La siguiente imagen te da una vista rápida del panel de TestFlight Desde la ventana principal, puedes ver todas las versiones disponibles de tu aplicación; cuándo expiran; cuántas invitaciones se enviaron; cuántas instalaciones tuvieron éxito. etc.Para agregar nuevos usuarios, haz clic en “App Store Connect Users” en la barra lateral izquierda &gt; Presiona el botón “+” &gt; Luego completa la información de tu tester incluyendo su App Id. Después de eso, puedes agregar tu tester a tu build. Aplicación TestFlightLos testers necesitan instalar la aplicación TestFlight en su dispositivo. Esta aplicación es gratuita y está disponible en la App Store. Después de agregar tus testers al build, los testers usarán su correo electrónico de invitación o un enlace público para inscribirse en las pruebas.Abre la aplicación TestFlight, el tester necesita iniciar sesión con su App Id. Después de eso, verán todas las aplicaciones disponibles que pueden instalar, que es igual que en la App Store. Una pequeña nota es que verás un pequeño punto naranja cerca del nombre de la aplicación para indicar que este build se instaló desde TestFlight. Fácil, ¿no? Desde ahora en adelante, cuando un build de esta aplicación esté disponible, tu tester recibirá una notificación y un correo electrónico de TestFlight. Luego pueden actualizar esta aplicación a través de TestFlight y disfrutar de la última versión. Después de las pruebasCuando hayas terminado las pruebas, puedes detener la aplicación de las pruebas, y luego ir a publicar una aplicación para el proceso de enviar tu aplicación a la App Store. Tu build beta dejará de estar disponible en TestFlight después de 90 días por defecto.En esta publicación, tuvimos una vista rápida de TestFlight y cómo distribuir tu prueba beta a tus testers. En la práctica, las pruebas beta son un término común en el proceso de desarrollo de software. Tener conocimiento de cómo distribuir tu aplicación será útil en algunas situaciones.¡¡¡Feliz programación!!!","link":"/es/posts/Beta-Test-and-TestFlight/index.html"},{"title":"Seguridad Bluetooth: Emparejamiento y Vinculación","text":"En los tiempos modernos, Bluetooth juega un papel crucial en la conexión de dispositivos de manera fluida. Desde rastreadores de fitness hasta dispositivos domésticos inteligentes, Bluetooth Low Energy (BLE) permite que los dispositivos se comuniquen de manera eficiente mientras reducen el consumo de energía. Sin embargo, con el aumento de la comunicación inalámbrica, garantizar la seguridad se ha convertido en una preocupación clave. Dos conceptos fundamentales de la seguridad Bluetooth son el Emparejamiento y la Vinculación, que a menudo se malinterpretan en el contexto de BLE. Garantizar que los dispositivos se emparejen y vinculen de manera segura es crítico para proteger datos sensibles. La implementación incorrecta de estos procesos puede llevar a varios tipos de ataques. Por ejemplo, los atacantes pueden interceptar comunicaciones y robar información valiosa. En este blog, exploraremos qué son el emparejamiento y la vinculación, por qué son importantes para la seguridad y cómo funcionan en la práctica, particularmente para aplicaciones móviles. Nivel bajo: Security Manager (SM)En el núcleo de la seguridad BLE está el Security Manager (SM), un componente crucial que gestiona varias funciones de seguridad. El SM maneja el intercambio de claves de seguridad y asegura que todos los datos transmitidos entre dispositivos estén cifrados y protegidos contra acceso no autorizado. Las responsabilidades clave del SM incluyen la gestión del emparejamiento, vinculación, cifrado y autenticación, y la gestión de claves. El SM proporciona diferentes métodos de autenticación para diferentes niveles de seguridad: Just Works: Sin autenticación involucrada. Usado para aplicaciones de baja seguridad. Passkey Entry: Se ingresa una clave (PIN) en uno o ambos dispositivos para autenticar. Numeric Comparison: Ambos dispositivos muestran un número, y el usuario debe confirmar que coinciden. Out-of-Band (OOB): Se utiliza otra tecnología inalámbrica, como NFC, para intercambiar información, proporcionando seguridad mejorada. Establecer la secuencia de emparejamiento y vinculaciónEl Emparejamiento es el proceso de establecer un enlace de comunicación seguro entre dos dispositivos Bluetooth. Este paso es esencial para asegurar que los dispositivos puedan compartir datos de manera segura. Durante el proceso de emparejamiento, los dispositivos intercambian información, se autentican mutuamente y crean claves de cifrado para proteger los datos que se transmiten. La Vinculación es el siguiente paso después del emparejamiento. Una vez que dos dispositivos se emparejan exitosamente, pueden almacenar las claves de cifrado e información de seguridad relacionada para uso futuro. Esto asegura que los dispositivos no necesiten emparejarse nuevamente la próxima vez que se conecten. Al almacenar estas claves, los dispositivos pueden reconectarse más rápida y seguramente en el futuro. A alto nivel, los pasos en el proceso de emparejamiento y vinculación incluyen: EMPAREJAMIENTO Iniciación: Un dispositivo envía una solicitud de emparejamiento al otro. Intercambio de Parámetros de Seguridad: Los dispositivos comparten sus capacidades, incluyendo los métodos de autenticación disponibles. Autenticación: Dependiendo de los métodos disponibles (Just Works, Passkey Entry, Numeric Comparison u Out-of-Band), los dispositivos se autentican. Generación de Claves: Se generan claves de cifrado y se usan para asegurar la comunicación. Establecimiento del Cifrado: Los dispositivos comienzan la comunicación cifrada después de que las claves se intercambian exitosamente. VINCULACIÓN Almacenamiento de Información de Seguridad: Después del emparejamiento, ambos dispositivos guardan las claves de cifrado para conexiones futuras. Reconexión: Durante interacciones futuras, los dispositivos pueden usar las claves guardadas para restablecer un enlace seguro y cifrado sin repetir el proceso de emparejamiento. A continuación se muestra un resumen del flujo en el ejemplo de un dispositivo móvil (central) y un periférico (por ejemplo, relojes inteligentes, monitores, etc.). Lado de la aplicación móviliOS no proporciona una API de vinculación explícita. Sin embargo, el proceso de vinculación ocurre de manera transparente cuando te conectas a un dispositivo BLE que lo requiere, y el sistema operativo solicitará al usuario la autenticación necesaria. La solicitud de emparejamiento generalmente se activa al acceder a características seguras. En contraste, tienes más control sobre el proceso de emparejamiento y vinculación en Android. 1234567891011121314151617181920212223242526272829BluetoothDevice device = bluetoothAdapter.getRemoteDevice(deviceAddress);// Checking bond stateint bondState = device.getBondState();if (bondState == BluetoothDevice.BOND_BONDED) { // Already bonded} else { // Create bond device.createBond();}...// Moniroting updatesBroadcastReceiver receiver = new BroadcastReceiver() { @Override public void onReceive(Context context, Intent intent) { final String action = intent.getAction(); if (BluetoothDevice.ACTION_BOND_STATE_CHANGED.equals(action)) { int bondState = intent.getIntExtra(BluetoothDevice.EXTRA_BOND_STATE, BluetoothDevice.ERROR); if (bondState == BluetoothDevice.BOND_BONDED) { // Device is bonded } else if (bondState == BluetoothDevice.BOND_BONDING) { // Bonding in progress } else if (bondState == BluetoothDevice.BOND_NONE) { // Bonding failed } } }}; En Android, no hay una API pública para eliminar programáticamente un dispositivo vinculado. Sin embargo, hay un método de API privada disponible que se puede acceder usando reflexión para eliminar una vinculación. Ten en cuenta que, debido a que esta es una API privada, no está soportada por Google, y usarla en código de producción puede resultar en comportamiento impredecible en ciertos dispositivos o que tu aplicación sea rechazada durante el proceso de revisión de Google. 123456789public static boolean removeBond(BluetoothDevice device) { try { Method removeBondMethod = BluetoothDevice.class.getMethod(\"removeBond\"); return (boolean) removeBondMethod.invoke(device); } catch (Exception e) { e.printStackTrace(); } return false;} Mejores prácticasMientras trabajaba con dispositivos que necesitan datos cifrados, encontré algunos problemas. A continuación están los puntos clave que he aprendido, que podrían ayudarte a ahorrar tiempo: Para soportar auto-conexión desde el sistema iOS, el dispositivo debe contener el perfil HID o estar suscrito al perfil ANCS del teléfono. En Android, el sistema operativo no se reconecta automáticamente al dispositivo cuando está vinculado; es trabajo de tus servicios. El sistema iOS muestra automáticamente el popup de emparejamiento inmediatamente después de llamar exitosamente a connect con el dispositivo si contiene el perfil HID. Eliminar todas las características cifradas del perfil HID de tu dispositivo evita que el sistema muestre automáticamente el popup de emparejamiento. Al leer una característica cifrada personalizada del perfil GATT, aparecerá el popup de solicitud de emparejamiento. El sistema operativo aún se conectará automáticamente al dispositivo después de emparejarlo con nuestra característica cifrada, incluso si el dispositivo HID no está cifrado. Usa Métodos de Autenticación Fuertes: Prefiere Numeric Comparison o Passkey Entry sobre Just Works. Actualiza los Protocolos de Cifrado: Asegúrate de que tus dispositivos usen protocolos de cifrado modernos y fuertes. ConclusiónEl emparejamiento y vinculación Bluetooth son procesos fundamentales que permiten la comunicación segura entre dispositivos. Al entender estos mecanismos, los desarrolladores pueden mejorar significativamente la seguridad de sus conexiones Bluetooth. A medida que crece el número de dispositivos conectados, garantizar una fuerte seguridad Bluetooth seguirá siendo una prioridad para salvaguardar datos personales sensibles. Referencias Kevin Townsend, Carles Cufí, Akiba, Robert Davidson - Getting Started with Bluetooth Low Energy_ Tools and Techniques for Low-Power Networking-O’Reilly Media (2014) How iOS and Android Handle Connections with BLE Human Interface Devices, Punch Through BLE Pairing and Bonding","link":"/es/posts/Bluetooth-security-Pairing-and-Bonding/index.html"},{"title":"Bluetooth Low Energy en iOS","text":"El framework Core Bluetooth (CB) permite que las aplicaciones de iOS y MacOS se comuniquen con dispositivos BLE. Tus aplicaciones pueden descubrir, explorar y controlar dispositivos BLE, como monitores de frecuencia cardíaca, rastreadores o relojes híbridos. Imagen 1. Dispositivos BLE (Fuente de Google) En MacOS 10.9 e iOS 6, los dispositivos Mac e iOS también pueden desempeñar los roles de periféricos BLE para servir datos a otros dispositivos, incluyendo otros dispositivos Mac e iOS. En este tutorial, presentaré los conceptos clave del framework Core Bluetooth y cómo usar el framework para descubrir, conectar y recuperar datos de dispositivos compatibles. No dudes en dejar tus comentarios en mi publicación. ## De un vistazo BLE fue introducido a principios de 2010 y está basado en la especificación Bluetooth 4.0. BLE utiliza la misma frecuencia de radio de 2.4 GHz que el Bluetooth clásico. En teoría y en condiciones ideales (sin obstáculos), el alcance de BLE supera los 100m, pero en realidad, la distancia máxima es de 10m. Imagen 2. BLE en la realidad (Fuente de Google) Esta tecnología es amigable con la energía porque utiliza menos energía que otras tecnologías inalámbricas. Gracias a su bajo consumo de energía, BLE se utiliza para integrarse en dispositivos eléctricos que requieren bajo consumo de energía como monitores de frecuencia cardíaca, rastreadores, relojes, zapatos para hacerlos más inteligentes.Entonces, ¿cuáles son las desventajas de la tecnología BLE? Es la tasa de transferencia de datos. Para disminuir el consumo de energía, los chips BLE solo transmiten datos en algunos momentos llamados intervalos (mientras que el Bluetooth Clásico puede transferir datos en cualquier momento que deseen), y la cantidad de datos transferidos en un intervalo también está limitada a unas pocas docenas de bytes. Más información sobre el rendimiento máximo en iOS y MacOS (Proporcionado por PunchThrough) iPhone 6, 6+, 6S, 6S+:12Normal Connection Interval of 30mSecs: 2,667 bytes/secConnection Interval for HID Over GATT is Present 11.25mSecs: 7,111 bytes/sec MacBook Pro - OS X (Varía según los modelos):1Maximum Connection Interval range of (11.25 - 15mSecs): 7,111 bytes/sec - 5334 bytes/sec Para obtener más detalles técnicos sobre la tecnología Bluetooth, consulta el Bluetooth Special Interest Group (SIG). Conceptos Básicos1. Los participantesHay dos roles principales involucrados en toda comunicación BLE: El Central y El Periférico: Periférico: son dispositivos que tienen datos que otros dispositivos necesitan. Central: típicamente usan la información proporcionada por un periférico para realizar alguna tarea. Por ejemplo, leer información de frecuencia cardíaca o temperatura de monitores (un periférico).Imagen 3. El Central y el Periférico (Fuente de [documentación de Apple](https://developer.apple.com/library/content/documentation/NetworkingInternetWeb/Conceptual/CoreBluetooth_concepts/AboutCoreBluetooth/Introduction.html)) 2. Los parámetros de conexiónLos parámetros de conexión para una conexión BLE son un conjunto de parámetros que determinan cuándo y cómo el Central y un Periférico realizan la transferencia de datos. El Central establecerá activamente los parámetros de conexión utilizados, pero el Periférico puede enviar otro parámetro que el Central puede aceptar o rechazar. Ambos lados continuarán solicitando parámetros de conexión hasta que encuentren un número razonable que ambos acepten.Hay 3 parámetros diferentes: Intervalo de conexión: Este valor determina con qué frecuencia el Central y el Periférico se transfieren datos entre sí. Latencia del esclavo (Latencia, abreviado): Si establecemos un valor de latencia distinto de cero, el Periférico puede omitir solicitudes del Central cuando el Central solicita datos hasta el número de veces de latencia del esclavo. Sin embargo, si el Periférico quiere transmitir datos al Central, puede enviar datos en cualquier momento. Esto permite que un periférico permanezca dormido por más tiempo para disminuir el consumo de energía. Tiempo de espera de supervisión de conexión: Este valor determina el tiempo de espera desde el último intercambio de paquetes hasta que la transferencia se considera perdida. El Central no comenzará a intentar reconectarse antes de que haya pasado el tiempo de espera. Por ejemplo, si estableces {intervalo, latencia, tiempo_espera} = {15, 0, 720} como parámetros de conexión para el periférico: Cada 15 (ms), el periférico se despertará y escuchará solicitudes del central, también transmitirá datos si es necesario. Latencia igual a 0, significa que el Periférico tiene que responder al Central en cualquier momento que el Central solicite en un intervalo (15 ms). Después de 720 (ms) desde que se envió el último paquete, si el Central aún no recibe el paquete, el Central determinará que el paquete se perdió y solicitará al Periférico que reenvíe el último paquete. 3. Pila de Protocolos Bluetooth Low EnergyCoreBluetooth oculta muchos de los detalles de bajo nivel de la especificación a los desarrolladores, haciendo mucho más fácil desarrollar aplicaciones que interactúen con dispositivos BLE. Advertising y General Advertising Profile (GAP)Los dispositivos BLE permiten que otros dispositivos sepan que existen mediante advertising usando el GAP. Los paquetes de advertising contienen información básica como el nombre del dispositivo, número de serie o valor RSSI, y también una lista de los servicios que proporciona. El tamaño limitado de los paquetes de advertising es de 128 bit.RSSI significa Received Signal Strength Indicator (Indicador de Intensidad de Señal Recibida). El valor RSSI representa la intensidad de la señal de transmisión. Podemos estimar la distancia actual entre el central y el periférico basándonos en el valor. Cuanto mayor sea el valor, más cerca está el dispositivo. Imagen 4. Advertising y descubrimiento en BLE General Attribute Profile (GATT)GATT es la capa que define servicios y características que se utilizan para transmitir datos entre el Central y el Periférico, también habilita operaciones de lectura, escritura y notificación en ellos.En la mayoría de los casos, el Periférico también se llama servidor GATT ya que proporciona los servicios y las características, mientras que el Central es el cliente GATT. ServiciosLos servicios se identifican por números únicos conocidos como UUIDs. Los servicios estándar como Device Information Service (0x180A), que expone información del fabricante e información básica sobre el dispositivo (versión de Firmware, número de serie, número de modelo), tienen un UUID de 16 bits y los servicios personalizados tienen un UUID de 128 bits. (Ej: 0x3dda0000957f7d4a34a674696673696d, etc.) CaracterísticasUna característica contiene una declaración de característica, propiedades de característica (ReadWrite, ReadOnly, Notify, WriteWithoutResponse, etc.), y un valor. Las características nos permiten acceder al valor y a la información que contienen. Un servicio puede tener más de una característica.La siguiente imagen muestra la relación entre Profile, Services, Characteristics. Imagen 5. Relación entre Profile, Services, Characteristics 4. Conceptos de Bluetooth y CoreBluetooth en iOSEn el framework CoreBluetooth Un Central está representado por la clase CBCentralManager y se usa para descubrir, establecer una conexión y controlar el periférico. Un periférico está representado por la clase CBPeripheral, los servicios relacionados con un periférico específico están representados por la clase CBService y las características del servicio de un periférico están representadas por la clase CBPeripheral. La siguiente imagen muestra la estructura de un Service y sus Characteristics en iOS: Imagen 6. Relación entre objetos CBPeripheral, CBService y CBCharacteristic en iOS ResumenBLE es una tecnología revolucionaria del Bluetooth Clásico. En realidad, BLE se utiliza para integrarse en dispositivos pequeños como cerraduras, rastreadores, relojes, zapatos y algunos tipos de joyería (anillos) para hacerlos más inteligentes, hacia el entorno IoT.En la siguiente sección, te guiaré sobre cómo usar CoreBluetooth para crear tus propios servicios en un dispositivo iOS, también usar CoreBluetooth en otro dispositivo para descubrir, conectar y controlar tus servicios BLE. Si te gustó esta publicación y te gustaría ver más en el futuro, házmelo saber. Referencias[1] Bluetooth Special Interest Group[2] Documento de Apple: Core Bluetooth Concepts[3] Maximizing BLE Throughput on iOS and Android","link":"/es/posts/Bluetooth-Low-Energy-On-iOS/index.html"},{"title":"Seguridad en Comunicaciones Bluetooth: Implementando Flujos de Autenticación y Cifrado","text":"Bluetooth se ha convertido en el hilo invisible que conecta nuestros dispositivos, desde relojes inteligentes y rastreadores de salud hasta cerraduras inteligentes y sistemas IoT industriales. Pero con la comodidad viene el riesgo: la comunicación Bluetooth es inalámbrica y fácilmente interceptable, lo que la hace vulnerable a la interceptación, acceso no autorizado y ataques de repetición.Para defendernos contra estas amenazas, la autenticación y el cifrado son esenciales. En esta publicación, presentaré un flujo de seguridad Bluetooth robusto, explicando cómo funcionan juntos la autenticación, el intercambio de claves y la transferencia cifrada. También lo compararemos con TLS/HTTPS ya que ambos comparten un enfoque similar de seguridad por capas. Repaso: Cómo Funciona HTTPSAntes de profundizar en la autenticación Bluetooth, es útil entender cómo HTTPS (Protocolo de Transferencia de Hipertexto Seguro) protege la comunicación en la web, ya que ambos comparten principios de seguridad similares.Cuando visitas un sitio web seguro (https://), tu navegador y el servidor realizan un proceso llamado handshake TLS para establecer confianza y cifrado. Este handshake ocurre en algunos pasos clave: Saludo del Cliente – El navegador envía un mensaje al servidor presentándose, listando los métodos de cifrado soportados y un número aleatorio (usado posteriormente en la generación de claves). Saludo del Servidor – El servidor responde con su propio número aleatorio, selecciona un método de cifrado y envía su certificado SSL/TLS — que incluye su clave pública y es verificado por una Autoridad de Certificación (CA). Autenticación – El navegador verifica que el certificado sea válido y confiable (no expirado, revocado ni emitido para otro dominio). Este paso asegura que el sitio web es legítimo. Intercambio de Claves – Usando la clave pública del certificado (o a través de ECDHE — Curva Elíptica Diffie-Hellman Efímera), ambas partes generan de forma segura una clave de sesión compartida que solo ellos pueden calcular. Comunicación Cifrada – Una vez establecida la clave de sesión, todos los datos intercambiados entre el navegador y el servidor se cifran usando cifrado simétrico (típicamente AES o ChaCha20). Integridad y Autenticación – Cada mensaje incluye una suma de verificación criptográfica (MAC o etiqueta AEAD) para prevenir manipulación o ataques de repetición. Desde ese punto en adelante, tu conexión está tanto cifrada (nadie puede leer tus datos) como autenticada (sabes que estás hablando con el servidor real). En resumen, HTTPS asegura la comunicación usando: Certificados para establecer identidad. Intercambio de claves para derivar claves de sesión únicas. Cifrado simétrico para rendimiento y confidencialidad. Verificaciones de integridad para detectar cualquier modificación. Un Flujo de Autenticación Bluetooth SeguroAhora traduzcamos estos conceptos a un flujo de seguridad Bluetooth práctico. A diferencia de HTTPS, Bluetooth no tiene una infraestructura de autoridad de certificación incorporada. En cambio, típicamente dependemos de Claves Precompartidas (PSK) o mecanismos de emparejamiento fuera de banda para establecer la confianza inicial. Aquí hay un flujo robusto de autenticación y cifrado para comunicación BLE: Fase 1: Autenticación Desafío-RespuestaAntes de que se intercambien datos sensibles, tanto la aplicación móvil (Central) como el dispositivo BLE (Periférico) deben demostrar que comparten un secreto común — el PSK. 1234567891011121314151617181920┌──────────────┐ ┌──────────────┐│ Central │ │ Periférico ││ (Móvil) │ │ (Dispositivo)│└──────┬───────┘ └──────┬───────┘ │ │ │ 1. Generar Desafío Aleatorio (Nc) │ │ 2. Enviar Desafío ─────────────────────▶ │ │ │ 3. Dispositivo genera Nd │ │ 4. Respuesta = HMAC(PSK, Nc||Nd)│ │ │ │ ◀───────────── 5. Enviar (Nd, Respuesta)│ │ │ │ 6. Verificar Respuesta │ │ 7. Generar propia Respuesta para Disp. │ │ ─────────────────────────────────────▶ │ │ │ │ 8. Dispositivo verifica │ ▼ ▼ [Autenticación Mutua Completada] Cómo funciona: Central genera un nonce (Nc) — un número aleatorio usado solo una vez — y lo envía al Periférico. Periférico genera su propio nonce (Nd) y calcula una respuesta usando HMAC-SHA256:1Respuesta = HMAC-SHA256(PSK, Nc || Nd) Periférico envía de vuelta (Nd, Respuesta) al Central. Central verifica calculando el mismo HMAC con el PSK compartido. Si coincide, el dispositivo está autenticado. Autenticación mutua — El Central luego envía su propia respuesta de vuelta para que el Periférico pueda verificar también la identidad del Central. Este mecanismo de desafío-respuesta asegura: Sin ataques de repetición — Cada sesión usa nonces frescos. Sin transmisión de PSK — El secreto nunca viaja por el aire. Autenticación mutua — Ambas partes prueban su identidad. Fase 2: Intercambio de Claves con ECDHUna vez autenticados, necesitamos establecer una clave de sesión para el cifrado. Usamos Curva Elíptica Diffie-Hellman (ECDH) para derivar un secreto compartido sin transmitirlo directamente. 1234567891011121314151617181920// Generar par de claves efímeras en cada ladolet privateKey = P256.KeyAgreement.PrivateKey()let publicKey = privateKey.publicKey// Intercambiar claves públicas sobre BLE// Central envía su clave pública al Periférico// Periférico envía su clave pública al Central// Ambos lados calculan el secreto compartidolet sharedSecret = try privateKey.sharedSecretFromKeyAgreement( with: peerPublicKey)// Derivar la clave de sesión usando HKDFlet sessionKey = sharedSecret.hkdfDerivedSymmetricKey( using: SHA256.self, salt: salt, sharedInfo: \"BLE-Session-Key\".data(using: .utf8)!, outputByteCount: 32) ¿Por qué ECDH? Secreto hacia adelante — Incluso si el PSK se compromete después, las sesiones pasadas permanecen seguras porque cada sesión usa claves efímeras. Sin transmisión de secreto compartido — Solo se intercambian claves públicas; el secreto compartido se calcula independientemente. Eficiente — ECC proporciona seguridad fuerte con tamaños de clave más pequeños, ideal para dispositivos BLE con recursos limitados. Fase 3: Transferencia de Datos CifradaCon la clave de sesión establecida, toda la comunicación subsecuente se cifra usando AES-GCM (Modo Galois/Contador): 1234567891011121314151617181920212223// Cifrar datos antes de enviarfunc encrypt(data: Data, using key: SymmetricKey) throws -&gt; Data { let nonce = AES.GCM.Nonce() let sealedBox = try AES.GCM.seal(data, using: key, nonce: nonce) // Combinar nonce + texto cifrado + etiqueta para transmisión return nonce + sealedBox.ciphertext + sealedBox.tag}// Descifrar datos recibidosfunc decrypt(data: Data, using key: SymmetricKey) throws -&gt; Data { let nonce = try AES.GCM.Nonce(data: data.prefix(12)) let ciphertext = data.dropFirst(12).dropLast(16) let tag = data.suffix(16) let sealedBox = try AES.GCM.SealedBox( nonce: nonce, ciphertext: ciphertext, tag: tag ) return try AES.GCM.open(sealedBox, using: key)} AES-GCM proporciona: Confidencialidad — Los datos están cifrados e ilegibles sin la clave. Integridad — La etiqueta de autenticación detecta cualquier manipulación. Autenticación — Solo las partes con la clave de sesión pueden descifrar. Contador de Secuencia: Previniendo Ataques de RepeticiónIncluso con cifrado, un atacante podría capturar y repetir paquetes cifrados. Para prevenir esto, incluimos un contador de secuencia: 12345678910111213141516struct SecureMessage { let sequenceNumber: UInt32 let encryptedPayload: Data}class SequenceValidator { private var expectedSequence: UInt32 = 0 func validate(_ message: SecureMessage) -&gt; Bool { guard message.sequenceNumber == expectedSequence else { return false // Ataque de repetición o fuera de orden detectado } expectedSequence += 1 return true }} El número de secuencia se incluye en los datos autenticados (AAD) de AES-GCM, por lo que cualquier modificación es detectada. Comparación: HTTPS vs Flujo de Seguridad BLE Aspecto HTTPS/TLS Flujo de Seguridad BLE Ancla de Confianza Autoridad de Certificación (CA) Clave Precompartida (PSK) Autenticación Verificación de certificado Desafío-respuesta con HMAC Intercambio de Claves ECDHE o RSA ECDH Cifrado AES-GCM, ChaCha20-Poly1305 AES-GCM Secreto Hacia Adelante Sí (con ECDHE) Sí (claves ECDH efímeras) Protección contra Repetición Números de secuencia en registro TLS Contador de secuencia en carga útil Ambos enfoques comparten los mismos principios fundamentales: Autenticar primero — Verificar identidad antes de confiar. Derivar claves de sesión — Nunca reutilizar claves entre sesiones. Cifrar todo — Proteger la confidencialidad de los datos. Verificar integridad — Detectar manipulación. Consideraciones de ImplementaciónEn el Lado Móvil (iOS/Swift)El framework CryptoKit de Apple proporciona todas las primitivas necesarias: 1234567891011121314151617181920212223242526272829import CryptoKitclass BLESecurityManager { private let psk: SymmetricKey private var sessionKey: SymmetricKey? private var sequenceNumber: UInt32 = 0 init(psk: Data) { self.psk = SymmetricKey(data: psk) } // Autenticación desafío-respuesta func generateChallenge() -&gt; Data { var bytes = [UInt8](repeating: 0, count: 16) _ = SecRandomCopyBytes(kSecRandomDefault, bytes.count, &amp;bytes) return Data(bytes) } func computeResponse(challenge: Data, nonce: Data) -&gt; Data { let message = challenge + nonce let hmac = HMAC&lt;SHA256&gt;.authenticationCode(for: message, using: psk) return Data(hmac) } func verifyResponse(_ response: Data, challenge: Data, nonce: Data) -&gt; Bool { let expected = computeResponse(challenge: challenge, nonce: nonce) return response == expected }} En el Lado del Dispositivo (Embebido)Para dispositivos con recursos limitados, bibliotecas como mbed TLS o wolfSSL proporcionan implementaciones ligeras: 12345678910111213141516171819202122232425// Pseudocódigo para dispositivo embebido#include \"mbedtls/gcm.h\"#include \"mbedtls/ecdh.h\"int verify_challenge_response( const uint8_t *psk, size_t psk_len, const uint8_t *challenge, size_t challenge_len, const uint8_t *nonce, size_t nonce_len, const uint8_t *response, size_t response_len) { uint8_t computed[32]; uint8_t message[challenge_len + nonce_len]; memcpy(message, challenge, challenge_len); memcpy(message + challenge_len, nonce, nonce_len); mbedtls_md_hmac( mbedtls_md_info_from_type(MBEDTLS_MD_SHA256), psk, psk_len, message, sizeof(message), computed ); return memcmp(computed, response, 32) == 0 ? 0 : -1;} Mejores Prácticas de Seguridad Rotar PSKs periódicamente — No dependas de un solo PSK para siempre. Implementa un mecanismo seguro para actualizarlo. Usar generación segura de números aleatorios — La aleatoriedad débil socava todo el modelo de seguridad. Implementar mecanismos de tiempo de espera — Abortar la autenticación si tarda demasiado (potencial ataque DoS). Validar todas las entradas — Verificar longitudes, formatos y límites antes de procesar. Manejar errores de forma segura — No filtrar información a través de mensajes de error o diferencias de tiempo. Considerar Conexiones Seguras BLE 4.2+ — La especificación BLE incluye Conexiones Seguras LE con ECDH. Úsalo como una capa adicional cuando esté disponible. Aplicaciones PrácticasEste flujo de seguridad es ideal para escenarios donde la confidencialidad de datos y la autenticación de dispositivos son críticas: Wearables — Relojes inteligentes y rastreadores de fitness que transmiten datos de salud que caen bajo regulaciones de privacidad (HIPAA, GDPR). Dispositivos de Hogar Inteligente — Cerraduras, abridores de puertas de garaje y cámaras de seguridad donde el acceso no autorizado podría tener consecuencias físicas. Dispositivos Médicos — Bombas de insulina, marcapasos y monitores continuos de glucosa donde la manipulación podría ser potencialmente mortal. IoT Industrial — Sensores y controladores en entornos de manufactura donde la integridad de datos afecta las operaciones y la seguridad. Terminales de Pago — Sistemas de punto de venta móviles que deben proteger transacciones financieras. Automotriz — Llaves remotas, herramientas de diagnóstico y sistemas de infoentretenimiento en vehículos que se conectan a teléfonos. ConclusiónLa seguridad en la comunicación Bluetooth no se trata solo de emparejar una vez y confiar para siempre — se trata de autenticación continua, claves frescas y transferencias cifradas. Al superponer: Autenticación desafío-respuesta basada en PSK — Demuestra que ambas partes comparten un secreto. Intercambio de claves ECDH — Establece claves de sesión con secreto hacia adelante. Cifrado AES-GCM — Protege confidencialidad e integridad. Contadores de secuencia — Previene ataques de repetición. Creamos un flujo de seguridad que es resistente a la interceptación, suplantación de identidad y ataques de repetición. Así como HTTPS transformó la seguridad web al hacer la comunicación cifrada el estándar, implementar flujos de seguridad Bluetooth robustos trae confianza y resiliencia similar a los dispositivos en los que confiamos diariamente. La comodidad inalámbrica de Bluetooth no tiene que venir a costa de la seguridad — con la arquitectura correcta, podemos tener ambas. Los ejemplos de código en esta publicación usan CryptoKit de Apple para iOS. Implementaciones similares son posibles en Android usando la Arquitectura de Criptografía Java (JCA) o BouncyCastle, y en dispositivos embebidos usando mbed TLS o wolfSSL.","link":"/es/posts/Bluetooth-security-Implement-authentication/index.html"},{"title":"Construyendo tu página personal con Hexo","text":"Cuando construí este sitio personal, mi primer objetivo es disfrutar mi hobby de escribir. Escribo lo que aprendo durante mi trabajo diario, y lo comparto. Espero que lo que comparto ayude a alguien cuando lo necesite. A cambio, tendré una comprensión profunda de lo que escribo, y a veces, recibiré “una taza de café” (Buy me Coffee) de un amigo que nunca he conocido. El poder se gana compartiendo conocimiento, no acaparándolo Algunos amigos vienen a mí preguntando cómo construir una página como la mía. Estoy feliz de compartir contigo cómo la construí.Después de este tutorial, podrás construir tu propio sitio en 5 minutos.¡Espero ver tu página lanzada pronto! Configurar herramientasNodeJs para macNavega a la página de NodeJS, descarga e instala el paquete de NodeJs para macOS.Para aquellos que no saben qué es NodeJs, NodeJs es un entorno de ejecución de JavaScript de código abierto y multiplataforma (OS X, Window, Linux) para escribir código del lado del servidor en Javascript.Al usar el modelo de I/O no bloqueante, NodeJS es una gran opción para aplicaciones en tiempo real, chat, streaming de datos, etc.Con una gran comunidad, el ecosistema de paquetes de NodeJs es cada vez más variado y eficiente, haciendo que NodeJS se convierta en una de las mejores tendencias de desarrollo en los últimos años. Puedes encontrar más información de NodeJs en internet si te parece interesante. HexoHexo es un framework de blog potenciado por NodeJs. Las características de simplicidad y rapidez de Hexo lo hacen dominar entre otros frameworks de blog como Hugo, Wordpress, Grav, etc.Elegí Hexo para construir mi blog porque estoy familiarizado con los comandos de NodeJS. Además, Hexo proporciona muchos temas que puedes integrar fácilmente a tu blog con personalización completa.Después de instalar NodeJs exitosamente, abre tu terminal y escribe las siguientes líneas 12345npm install hexo-cli -g [1]hexo init blog [2]cd blog [3]npm install [4]hexo server [5] Aquí está el paso a paso: Instalar la línea de comandos de hexo como un comando global. Crear la carpeta de tu blog. Moverte a la carpeta. Instalar las dependencias de node. Ejecutar tu servidor. Hexo se ejecutará en localhost:4000 por defecto. Ahora abre http://localhost:4000 en tu navegador para ver el resultado. Personalizar tu sitio webEn la raíz de tu carpeta, hay un archivo _config.yml que contiene las configuraciones de tu página. Puedes modificar cosas como el título de la página, el autor de la página, el formato de los artículos, etc. Para más información, por favor consulta los documentos de Hexo. Empezar a escribirPara crear un nuevo artículo, escribe 1hexo new \"My first blog\" Aquí, creas un post llamado “My first blog”. Recarga tu navegador, verás el resultado. Ten en cuenta que Hexo usa sintaxis Markdown para la edición, así que asegúrate de estar familiarizado con la sintaxis Markdown. TemasLa comunidad de Hexo proporciona muchos temas que puedes elegir según tu preferencia y personalizar este tema como tuyo. Te ahorra mucho tiempo gracias a la gran comunidad.Navega a Hexo themes y encuentra el que te guste, sigue sus instrucciones para descargarlo a la carpeta de tu blog.Luego, modifica el archivo _config.yml, busca y reemplaza la configuración themes con el nombre de tu nuevo tema. 1theme: whatever DespliegueAl usar la línea de comandos hexo generate, Hexo generará automáticamente todos tus archivos estáticos que puedes subir a tu servidor y distribuirlos a tus usuarios.En caso de que no tengas un servidor propio, ¡no te preocupes! Hay muchos servidores de hosting gratuitos por ahí. Puede que hayas oído hablar de Github page. Básicamente, Github page proporciona hosting gratuito y dominio para tu página, como la mía “uynguyen.github.io”. Si quieres usar Github page como tu host, por favor sigue las instrucciones para crear tu repositorio de github page.Después de tener tu propio repositorio, instala npm install hexo-deployer-git que te permite desplegar tu sitio.Luego, edita el archivo _config.yml, desde la sección “deploy” &gt; agrega la información de tu objetivo de despliegue 12345deploy: type: git repo: &lt;repository url&gt; branch: [branch] message: [message] A partir de ahora, una vez que termines de escribir, puedes publicar tus posts mediante el comando 1hexo clean &amp;&amp; hexo deploy También puedes usar Heroku para el despliegue en lugar de usar github. Para más información, por favor consulta Hexo deployment ConclusiónSi quieres una página personal simple para compartir tus ideas y contenidos, Hexo y Github page se convierten en una gran herramienta para ti. Con su simplicidad y su comunidad, es fácil de configurar, permitiéndote enfocarte en lo que importa: Tu compartir.Espero que encuentres útil este post.","link":"/es/posts/Building-your-personal-page-with-Hexo/index.html"},{"title":"Core Bluetooth en WatchOS","text":"¿Alguna vez pensaste en agregar una Watch App a tu producto? ¿Te preguntas cómo hacer que CoreBluetooth funcione en tu Watch App? ¡Estás en el lugar correcto! Este tutorial es tu guía definitiva. En esta publicación, te llevaremos paso a paso a través del proceso de integrar datos de dispositivos Bluetooth en tus aplicaciones de Apple Watch. Descubre cómo aprovechar el potencial de los dispositivos Bluetooth para mejorar la experiencia del usuario de tu Apple Watch. También proporcionaremos información sobre cómo superar los desafíos comunes al trabajar con Core Bluetooth en watchOS. Ya seas un profesional experimentado o un principiante, este tutorial simplifica el proceso para ti. Entornos: XCode 15.0.1, iOS 17.0.3, WatchOS 10.1.1, Swift 5. Configurar proyectoComienza yendo a la configuración de tu proyecto, luego selecciona File &gt; New Target &gt; Watch OS &gt; App, y completa los campos requeridos. Una vez hecho, Xcode integrará perfectamente un nuevo proyecto de watch app en tu workspace existente. Configuración de BluetoothEsencialmente, todos los métodos y eventos de Bluetooth en WatchOS se parecen mucho a los de iOS. Si ya tienes una clase BluetoothManager que maneja varias funciones de Bluetooth, como iniciar el escaneo o conectarse a un peripheral, y gestiona los delegates de Bluetooth, estás en buena forma. 123456789101112131415161718192021class BluetoothManager : NSObject, CBCentralManagerDelegate { private var central: CBCentralManager! override init() { super.init() central = CBCentralManager( delegate: self, queue: nil, options: [:] ) } func startScanning() { central.scanForPeripherals(withServices: nil, options: [CBCentralManagerScanOptionAllowDuplicatesKey: true]) } func connect(periperal: CBPeripheral) { central.connect(periperal) } // El resto omitido} Para ahorrar tiempo y evitar duplicar código, puedes compartir fácilmente el archivo que contiene la clase BluetoothManager con ambos targets de tu aplicación iOS y watch app. Con esta configuración, puedes usar la clase BluetoothManager en tu watch app de la misma manera que lo harías en tu aplicación iOS. 1234567891011121314struct ContentView: View { var body: some View { VStack { Image(systemName: \"globe\") .imageScale(.large) .foregroundStyle(.tint) Text(\"Hello, world!\") } .padding() .onAppear(perform: { BluetoothManager.shared.startScanning() }) }} Notas importantes Para probar la funcionalidad Bluetooth de tu proyecto, es esencial ejecutarlo en un Apple Watch real ya que el simulador no soporta Bluetooth. Ten en cuenta que el tiempo de conexión en el Apple Watch puede verse influenciado por el estado de la batería del dispositivo, incluso si el modo de bajo consumo no está habilitado. Asegúrate de agregar manualmente la capacidad necesaria al archivo plist de la Watch App. Este paso es crucial; de lo contrario, tu aplicación no podrá escanear, conectar o ejecutar ningún comando Bluetooth cuando esté en background. 1234&lt;key&gt;UIBackgroundModes&lt;/key&gt;&lt;array&gt; &lt;string&gt;bluetooth-central&lt;/string&gt;&lt;/array&gt; A diferencia de Bluetooth en iOS, donde puedes aprovechar State preservation and restoration para despertar la aplicación si ha sido terminada por el sistema debido a eventos Bluetooth (ver Mejores prácticas: Best practice: How to deal with Bluetooth Low Energy in background), es importante notar que no existe un mecanismo equivalente de State preservation and restoration en watchOS. El tiempo de conexión en iOS y WatchOS es bastante igual. Medí la API de Connect realizando 200 llamadas (mismos dispositivos, mismo entorno de pruebas). El promedio en iOS es aproximadamente 0.69 segundos, mientras que en WatchOS es 0.78 segundos. ConclusiónEn resumen, al aprender cómo conectar tu Apple Watch a dispositivos Bluetooth, has potenciado las características de tu reloj. Este tutorial te ha guiado a través del uso de Core Bluetooth en watchOS, manejando problemas comunes en el camino. Ya seas un profesional o un principiante, lo hemos desglosado para ti. Ahora, tu Watch App no solo funciona bien sino que también impresiona a los usuarios. Mientras continúas creando aplicaciones, usa estas habilidades para crear experiencias geniales y fluidas. ¡Feliz codificación! Referencias[1] WWDC 2021[2] WWDC 2022[3] Core Bluetooth in watchOS Tutorial","link":"/es/posts/Core-Bluetooth-on-WatchOS/index.html"},{"title":"Fallar temprano en Swift","text":"Anoche, leí un capítulo de un libro que es uno de mis favoritos: &quot;The pragmatic programmer&quot; (De Andrew Hunt y David Thomas). Este capítulo discute cómo usar assertion para hacer el código más fácil de depurar. Todos sabemos que assertion es una herramienta esencial para escribir tests, pero hace más que eso. Vamos conmigo a conocer a este chico: Assertion. Fallar, no corromper¿Alguna vez has tenido una de las siguientes conversaciones contigo mismo o con tus colegas en una discusión técnica? “Este caso nunca ocurrirá así que no necesitamos procesar este.” “Esta clase debe ser “Dog”, nunca puede ser “Cat”, vamos a hacer force unwrap de este objeto.” “Este error nunca ocurrirá, solo ignóralo.” “¡Idiota! ¿por qué manejamos este caso cuando tu código nunca llega a esta línea?” Pero, ¿y si “este caso” ocurre de alguna manera? ¿La aplicación aún responderá de la manera que esperamos? ¿Hay alguna posibilidad de que la situación inesperada dañe nuestra base de datos esencial?Al principio de este capítulo, el autor introduce algunas situaciones en las que puedo verme en esos ejemplos: “Este código no se usará en 30 años, así que las fechas de dos dígitos están bien.” “Esta aplicación nunca se usará en el extranjero, así que ¿por qué internacionalizarla?” “count no puede ser negativo.” “Este printf no puede fallar.” 1SI NO PUEDE SUCEDER, USA ASSERTIONS PARA ASEGURARTE DE QUE NO SUCEDERÁ Si creemos que algo no puede suceder, o algo es verdadero, ¡usa assertions para asegurarte de que tu creencia es verdadera! Si la condición de assertion no se cumple, inmediatamente hará crash a la aplicación. Es muy útil durante el desarrollo porque nos lleva exactamente a los problemas. Antes de continuar, hablemos de los niveles de optimización de SwiftDependiendo de si la compilación está en modo Release o modo Debug, el compilador de Swift activará o desactivará las assertions (Las líneas con declaraciones assert se omiten), es bueno conocer los niveles de optimización de Swift antes de continuar.Hay 3 tipos de nivel de optimización para una compilación en Xcode None (Onone): El predeterminado para compilaciones de debug. Compila sin ninguna optimización. Fast (O): El predeterminado para compilaciones de release. Compila con optimizaciones. Unchecked (Ounchecked): Compila con optimizaciones y elimina las comprobaciones de seguridad en tiempo de ejecución, incluyendo la comprobación de array fuera de límites, desenvolver nil, precondition y preconditionFailure. Por eso no debemos usar el modo Ounchecked en compilación de release porque puede llevar a corrupciones de memoria y la aplicación podría comportarse inapropiadamente. Actualizaciones: Como puedes ver, ya no existe el modo -Ounchecked en Xcode10, en su lugar se introdujo una nueva opción Optimize for Size. La principal diferencia entre el modo O y el modo Osize es “Cuando se compila con -O, el compilador intenta transformar el código para que se ejecute con el máximo rendimiento. Sin embargo, esta mejora en el rendimiento en tiempo de ejecución a veces puede venir con un compromiso de mayor tamaño de código. Con el nuevo modo de optimización -Osize, el usuario tiene la opción de compilar para un tamaño de código mínimo en lugar de para la máxima velocidad” (swift.org) Aplicar Assertion a SwiftA decir verdad, antes de leer este capítulo del libro, pensaba que “Assertion” solo se usaba al escribir unit tests. El hecho es que los desarrolladores usan Assertion en el desarrollo para hacer el proceso de desarrollo más seguro y fácil para rastrear un error.Swift proporciona 5 tipos de funciones de assertion que difieren entre sí en términos de cómo afectan el flujo del código: assert() y assertionFailure(): Úsalos cuando queramos verificar nuestro código, pero si realmente es un problema, no necesariamente saldría de la aplicación. El compilador ignorará las declaraciones assert() y assertionFailure() para una versión de release (En modo -O). Por ejemplo, uso assert para asegurar que no haya solicitudes inesperadas en mi flujo de negocio. Al hacerlo, garantizo que si aparece un “tipo extraño” en mi flujo, el flujo se romperá y la aplicación se terminará. Además, el depurador me llevará directamente al problema para que pueda identificar problemas de lógica y eliminar errores lo antes posible. precondition() y preconditionFailure(): Usa estas funciones para detectar una condición que debe cumplirse antes de continuar procesando, incluso en versión de release (modo -O). Por ejemplo, digamos que necesitamos cargar un archivo de configuración cuando la aplicación se inicia. Si no hay archivo de configuración, entonces debemos detener la aplicación inmediatamente en lugar de continuar la ejecución.123guard let fileConfig = Bundle.main.path(forResource: \"config\", ofType: \"json\") else { preconditionFailure(\"Unable to load config file.\")} fatalError(): Lo mismo que las funciones precondition() y preconditionFailure(), excepto que fatalError() funciona para todos los niveles de optimización en todas las configuraciones, significa que tu aplicación SIEMPRE será terminada si se alcanza la línea de fatalError(). En el siguiente ejemplo, uso fatalError() para forzar a cada clase heredada a sobrescribir el parseData(files:) de su superclase. Consejos destacados del autor &quot;Todos los errores te dan información. Podrías convencerte de que el error no puede suceder, y elegir ignorarlo. En cambio, los Programadores Pragmáticos se dicen a sí mismos que si hay un error, algo muy, muy malo ha sucedido.&quot; Si ocurre un error, ¿podemos recuperarlo? Si no podemos manejar algunos problemas inesperados, entonces falla temprano para proteger nuestros datos vitales (Especialmente en aplicaciones bancarias que requieren alta seguridad para la base de datos). &quot;No pongas assertion en el código de manejo de errores real.&quot; Es un malentendido si ponemos assertion en todas partes del código, particularmente en el código de manejo de errores real. Assertion no está destinado a usarse de esta manera. Si simplemente terminamos un programa en ejecución, afectará la experiencia del usuario, resultando en que los usuarios ya no abrirán tu aplicación. El principio más simple para verificar si debemos salir del programa cuando ocurren errores es Cuando tu código descubre que algo que se suponía era imposible acaba de suceder, tu programa ya no es viable. Cualquier cosa que haga desde este punto en adelante se vuelve sospechosa, así que termínalo lo antes posible. Un programa muerto normalmente hace mucho menos daño que uno lisiado. &quot;La condición pasada a un assertion no debería tener un efecto secundario&quot;. Es vergonzoso si ponemos un código para verificar errores que realmente causa otros errores. Para el siguiente ejemplo, el siguiente código (En Java) tiene agregado assert para asegurar que el siguiente elemento no es nil, pero en realidad crea un nuevo error. ¿Puedes encontrarlo?12345while (iter.hasmoreElements () { Test.ASSERT(iter.nextElements() != null); object obj = iter.nextElement(); // ....} ConclusiónEn este artículo, revisamos estos cinco métodos para una salida temprana en Swift. En general, la forma correcta de elegir cuál usar depende del contexto del error: ¿El error puede ser recuperable o no? Si la respuesta es no, entonces fallar es lo mejor que podemos hacer para proteger nuestra aplicación de comportamientos impredecibles. A veces, la aplicación está en una situación donde sería demasiado peligroso continuar.Espero que hayas encontrado útil esta publicación para que puedas aplicar esta idea a tu próximo proyecto.¡Gracias por leer!","link":"/es/posts/Crash-early-in-Swift/index.html"},{"title":"Crear y Distribuir Bibliotecas Privadas con Cocoapods","text":"CocoaPods es un gestor de dependencias para proyectos Swift y Objective-C. Esta herramienta no solo nos permite integrar fácilmente esas dependencias, sino que también nos permite crear nuestras propias bibliotecas. En esta publicación voy a guiarte sobre cómo crear una biblioteca privada y distribuirla a tu equipo privado sin publicar la biblioteca. Inicializar repositoriosVe a Github o Bitbutket, luego crea dos repositorios. Uno para nuestro código fuente que se comparte entre nuestro equipo, el otro para Podspec, que define toda la información sobre ese Pod. Imagen 1. Crear repositorio Github para almacenar nuestro código fuente Imagen 2. Crear repositorio Github para almacenar nuestros archivos Podspec Siguiendo las instrucciones en la página de Github, te guía sobre cómo agregar tu proyecto a estos repositorios. 123456$ echo \"# MyAwesomeKit-Spec\" &gt;&gt; README.md$ git init$ git add README.md$ git commit -m \"first commit\"$ git remote add origin git@github.com:uynguyen/MyAwesomeKit-Spec.git$ git push -u origin master Crear nuestra propia bibliotecaAbre XCode y crea un nuevo Cocoa Touch Framework llamado MyAwesomeKit. Después de eso, crea una clase simple llamada HaHaHaManager, esta clase define nuestros métodos públicos para los clientes. Para hacerlo más fácil, defino un método simple, que toma 2 números como argumentos y luego retorna su suma: 123456public class HaHaHaManager { public init() { } public func awesomeFunction(a: Int, b: Int) -&gt; Int { return a + b }} Nota: Dado que estamos creando un Framework público, tenemos que sobrescribir el constructor por defecto de la clase HaHaHaManager, haciéndolo público. De lo contrario, nuestros clientes que usen este Framework no podrán crear una instancia de esta clase porque el alcance por defecto de las clases en Swift es internal. Después, envía nuestro código al repositorio que creamos en el primer paso. Asegúrate de agregar un tag como versión para este commit. 1234$ git add .$ git commit -m \"Our first commit\"$ git tag MyAwesomeKit_1.0.0$ git push -u origin master --tags Agregar tu Repositorio Privado a tu Instalación de CocoaPodsUsa el siguiente comando para crear tu nuevo repositorio privado en tu CocoaPods 1$ pod repo add REPO_NAME SOURCE_URL 1$ pod repo add MyAwesomeKit https://github.com/uynguyen/MyAwesomeKit Asegúrate de tener los derechos de acceso correctos al repositorio. Puedes configurar ssh para acceder al repositorio a través de clave ssh. Ver también: Generating a new SSH key and adding it to the ssh-agentPara verificar si tu instalación fue exitosa, usa los siguientes comandos: 12$ cd ~/.cocoapods/repos/MyAwesomeKit$ pod spec lint . --allow-warnings Este comando se usa para validar especificaciones. El flag --allow-warnings indica que omitimos todas las advertencias al validar el archivo Pod. (Faltan algunas opciones como licencia, autor o descripción). Generar nuestro archivo PodspecEscribe el comando para generar nuestro archivo Podspec. Este archivo contiene toda la información sobre nuestro código, incluyendo el repositorio git, la versión de la biblioteca, dependencias, etc. 1$ pod spec create MyAwesomeKit Verás algo como esto 123456789101112131415Pod::Spec.new do |s| s.name = \"MyAwesomeKit\" s.version = \"1.0.0\" s.summary = \"An awesome KIT can do anything for you\" s.homepage = \"https://github.com/uynguyen/MyAwesomeKit\" s.author = { \"Uy Nguyen\" =&gt; \"uynguyen.itus@gmail.com\" } s.source = { :git =&gt; \"git@github.com:uynguyen/MyAwesomeKit.git\", :tag =&gt; \"MyAwesomeKit_#{s.version}\" } s.platform = :ios, '8.0' s.requires_arc = true s.dependency 'AFNetworking', '~&gt; 3.1.0' [1] s.source_files = \"MyAwesomeKit/**/*.{swift}\" [2] s.frameworks = 'UIKit', 'CoreText' [3] s.library = 'z', 'c++' s.module_name = 'MyAwesomeKit'end Esto es lo que está pasando: 1: Las dependencias de tus otros Podspecs. Para más de una dependencia, agrega una nueva línea para definirla. 2: Los archivos fuente que se incluirán. (Reemplázalo por .m, .mm, .c o .cpp si lo necesitas) 3: Los frameworks que están vinculados con tu biblioteca. Para otras opciones, por favor consulta Podspec Syntax Reference Enviar al Repositorio Spec 1$ pod repo push MyAwesomeKit MyAwesomeKit.podspec --allow-warnings La estructura de tu carpeta será así 12345.├── MyAwesomeKit-Spec └── MyAwesomeKit └── 1.0.0 └── MyAwesomeKit.podspec Cada vez que actualices la biblioteca, tienes que ejecutar el comando de actualización para actualizar tus repositorios Pod 1$ pod repo update Usar nuestro increíble KitEs hora de usar nuestro poderoso Kit. Abre XCode y crea un nuevo proyecto llamado MyAwesomeApp. Después de eso, escribe el siguiente comando para inicializar el archivo Pod 1$ Pod init Abre el archivo Pod, agrega el siguiente código para instalar nuestra biblioteca. 123456789101112131415161718# Uncomment the next line to define a global platform for your projectsource 'git@github.com:uynguyen/MyAwesomeKit-Spec.git'source 'https://github.com/CocoaPods/Specs.git'platform :ios, :deployment_target =&gt; '8.0'target 'MyAwesomeApp' do # Comment the next line if you're not using Swift and don't want to use dynamic frameworks use_frameworks! pod 'MyAwesomeKit', '1.0.0' # Pods for MyAwesomeApp target 'MyAwesomeAppTests' do inherit! :search_paths # Pods for testing end target 'MyAwesomeAppUITests' do inherit! :search_paths # Pods for testing endend Veamos nuestros resultados (Recemos y esperemos que funcione bien) ConclusiónAcabamos de publicar nuestro primer Pod privado para nuestro equipo. Desde ahora, nuestro equipo puede usar esta biblioteca de forma privada. Además, es fácil actualizar y distribuir la biblioteca cuando se actualiza. ¡Gracias a CocoaPod!Si tienes alguna pregunta o comentario sobre la publicación, no dudes en enviarme un correo electrónico. Referencias[1] Private Pods","link":"/es/posts/Create-and-Distribute-Private-Libraries-with-Cocoapods/index.html"},{"title":"Documentando una Arquitectura de Software","text":"Está claro que documentar arquitecturas es una de las tareas más aburridas importantes de la Ingeniería de Software. Una actividad de dos carasHay muchas buenas razones por las que debemos documentar nuestros proyectos de software: Otros miembros pueden entender y evaluar el diseño de este software. Podemos entender lo que implementamos cuando volvemos a él después de cierto tiempo. Podemos hacer análisis del diseño para evaluar el rendimiento de este sistema, prevenir errores antes de comenzar la fase de implementación. Documentar arquitecturas también tiene algunas desventajas, como: Los documentos gradualmente quedarán desactualizados con respecto al código. Mantener los documentos de arquitecturaactualizados es a menudo una actividad olvidada, especialmente bajo las presiones de un proyecto. Documentar consume tiempo y es costoso. Entonces, ¿cuándo debemos documentar arquitecturas de software?Hay muchos factores a considerar si necesitamos documentar o no. Los proyectos con pocas perspectivas de una larga vida probablemente no necesitan mucha documentación. El otro factor a considerar al documentar son las necesidades de las partes interesadas del proyecto, incluyendo los diversos roles como desarrolladores, testers, gerentes, etc. En un equipo pequeño, la documentación puede ser mínima y puede ser reemplazada por comunicación interpersonal, esto ahorra tiempo. En un equipo grande, sin embargo, la documentación se vuelve más importante para describir el sistema, especialmente en empresas que trabajan en múltiples países y en muchas oficinas. Por lo tanto, es importante pensar cuidadosamente antes de documentar porque toma tiempo desarrollar y mantener junto con los proyectos.En este post, te presentaré el lenguaje más popular para documentar arquitecturas de software: Unified Modeling Language. Unified Modeling Language (UML)UML es un lenguaje de modelado de Ingeniería de Software. Proporciona una forma estándar de visualizar el diseño de un sistema o una aplicación. UML incluye tanto diagramas estructurales como de comportamiento para representar un sistema de software: Un diagrama estructural describe arquitecturas estáticas de su sistema. Un diagrama de comportamiento muestra las interacciones entre entidades dentro de un sistema. Ten en cuenta que nunca he usado Component diagrams, Package diagram, Deployment diagrams, Profile Diagram, Composite Structure diagrams, Communication diagrams, Interaction Overview diagrams y Timing diagrams así que voy a omitir estos diagramas en este post. Diagramas estructuralesDiagramas de claseUn diagrama de clase describe la estructura de un sistema mostrando las relaciones entre sus clases. También muestra atributos y métodos de cada clase. El propósito principal de los diagramas de clase es obtener una visión general del sistema. Donde vis = visibilidad Sintaxis Tipo de visibilidad + Public Si una variable o método es static, debe estar subrayado. # Protected - Private ~ Package Las siguientes líneas introducen algunas relaciones principales en los diagramas de clase. Marca Significado Implementation La Clase B implementa los comportamientos definidos en la Clase A. Inheritance La Clase B tiene una relación ES-UN con la clase A, o podemos decir que la Clase B es un tipo de Clase A. Dependency Existe entre dos elementos si los cambios en la definición de uno pueden causar cambios en el otro. Association Una asociación binaria (con dos extremos) normalmente se representa como una línea. Indica que la Clase A contiene una o más propiedades pertenecientes a la clase B, o viceversa. Aggregation Es un caso especial de Association. Podemos decir que la Clase A está agregada con la Clase B si el Objeto X como instancia de la clase A es destruido pero el Objeto Y como instancia de la clase B todavía existe. Aquí, las vidas tanto del Employee como del Department son independientes entre sí. Los empleados pueden existir sin un departamento. Composition Es un caso especial de Aggregation pero es más fuerte que la relación Aggregation. Si el Objeto X como instancia de la clase A es destruido, el Objeto Y como instancia de la clase B también será destruido. También decimos que Composition es una relación TIENE-UN. Aquí, si eliminamos el objeto verhicle entonces todos los engines son eliminados automáticamente. Los engines no tienen su ciclo de vida independiente, depende de la vida del objeto verhicle. Un ejemplo de diagrama de clase. Diagramas de instancia (Diagramas de objeto)Básicamente, un diagrama de instancia es similar al diagrama de clase del cual depende. Sin embargo, un diagrama de instancia es solo una instantánea del sistema en algún punto en el tiempo, y muestra qué valores contienen esos objetos en este momento especificado. Los diagramas de instancia se usan a menudo para hacer prototipos de un sistema, y para obtener mayor comprensión del sistema desde una vista práctica.Los símbolos y notaciones de los diagramas de instancia pueden utilizarse en los diagramas de clase. Ejemplo Transferencia de un diagrama de clase a un diagrama de instancia. Diagramas de comportamientoDiagramas de actividadUn diagrama de actividad muestra el flujo de una actividad a otra actividad (Una actividad es una función realizada por el sistema). Ten en cuenta que los mensajes no están incluidos en los diagramas de actividad.Un diagrama de actividad se usa a menudo para describir el alto nivel del sistema, principalmente para usuarios de negocio o personas no técnicas. También puede describir los pasos en un diagrama de casos de uso.Símbolos y componentes básicos: Símbolo básico Significado Start point Representa el estado de acción inicial. Activity Representa una actividad del proceso. Condition Usa este símbolo cuando una actividad requiere una decisión antes de pasar a la siguiente actividad Synchronization Indica que múltiples actividades se realizan sincrónicamente. Time event Se refiere a un evento que detiene el flujo por un tiempo. Interrupting Edge Un evento que interrumpe el flujo. End Point Representa el estado de acción final. Diagramas de secuenciaUn diagrama de secuencia muestra cómo los objetos y componentes interactúan entre sí para completar una función.Símbolos y componentes básicos: Símbolo básico Significado Actor Muestra entidades que interactúan con el sistema. Object Representa un objeto en UML. Activation box Representa el tiempo necesario para completar una tarea. Loop Indica declaraciones de bucle. Alternative Indica declaraciones de condición. Parallel Cada tarea en el marco representa un hilo de ejecución realizado en paralelo. Synchronous message El emisor debe esperar una respuesta a un mensaje antes de continuar. El diagrama debe mostrar tanto la llamada como la respuesta. Asynchronous message El emisor no necesita esperar una respuesta a un mensaje antes de continuar. Return message Los mensajes se responden a las llamadas. Delete object Indica que el objeto será destruido. Diagramas de máquina de estadosEl propósito principal de los diagramas de máquina de estados es mostrar el cambio de estado de un objeto durante su vida útil. Símbolo básico Significado State Un estado representa una situación durante la vida de un objeto. Initial State El estado inicial del objeto. Final State El estado final del objeto. El siguiente ejemplo muestra la transición de estado de un pedido. Diagramas de casos de usoUn diagrama de casos de uso muestra cómo los usuarios u otras aplicaciones externas interactúan con el sistema. También muestra el alcance del sistema. Símbolo básico Significado Actors Representan los usuarios o sistemas externos que interactúan con nuestro sistema. Use cases Representan los diferentes usos que un usuario podría tener. Associations Hay dos tipos de asociaciones: Actor-caso de uso y caso de uso - caso de uso. Una asociación Actor - caso de uso indica qué actores están asociados con qué casos de uso. Una asociación Caso de uso - Caso de uso muestra la relación de dos casos de uso: - Include: Un caso de uso “incluye” otro si es una acción requerida por el caso de uso. - Extend: Un caso de uso “extiende” otro si es un uso opcional del caso de uso. - Generalization: El caso de uso hereda la estructura, comportamiento y relaciones de otro. ¿Has oído hablar de Business Process Model and Notation (o BPMN)?“Business Process Model and Notation (BPMN) es un estándar para modelado de procesos de negocio que proporciona una notación gráfica para especificar procesos de negocio en un Business Process Diagram (BPD).” (Wiki).Los principales objetivos de BPMN son: Proporcionar un conjunto de notación estándar que sea comprensible por las partes interesadas del negocio. A menudo se usa para definir lógica de negocio porque tiene conceptos más completos de eventos y soporta intercambios de mensajes asíncronos, que son importantes en el procesamiento de negocios. BPMN es similar al diagrama de actividad de UML. Un ejemplo de BPMN. Un proceso de compra descrito usando BPMN (Fuente de imagen de Google) ## Diferencias entre UML y BPMN, ¿cuál usar? Usamos BMPN para describir el sistema a alto nivel, sin preocuparnos demasiado por los detalles computacionales. En contraste, UML se usa para definir los detalles de este sistema, ¿cómo está construido? ¿cómo está organizado? ¿cómo interactúa con otros componentes? ¿cómo se procesan los datos? etc. ConclusiónEn este post, te mostré las ideas generales de algunos diagramas UML populares, y te mostré la diferencia principal entre UML y BPMN. Por supuesto, todavía hay muchos propósitos y notaciones de esos diagramas que no puedo listar aquí debido al alcance de este post.Si estás interesado en UML, puedes descargar el documento completo de UML aquí (La última versión de UML es 2.5.1).Gracias por leer. Referencias[1] Essential Software Architecture (2011, Springer-Verlag Berlin Heidelberg)Ian Gorton (auth.), Capítulo 8 Documenting a Software Architecture.","link":"/es/posts/Documenting-a-Software-Architecture/index.html"},{"title":"Arrastrar y Soltar","text":"","link":"/es/posts/Drag-and-Drop/index.html"},{"title":"Dark Hat - v1.0 ha sido lanzado","text":"Después de años trabajando en tecnología BLE, descubrí que a pesar de que hay muchas aplicaciones que ayudan a probar dispositivos BLE, ninguna de ellas cumple bien su función. Por eso decidí implementar una aplicación BLE por mi cuenta - Dark Hat. El objetivo principal de esta aplicación es compartir una mejor herramienta contigo, un ingeniero que trabaja en el campo de BLE. Características PrincipalesDescubre dispositivos cercanos con múltiples filtros soportados para mostrar solo los dispositivos que importan al usuario. Filtrar por RSSI. Filtrar por nombre del dispositivo. Filtrar por UUID de servicio: Solo recupera y escanea dispositivos que tengan tu UUID de servicio. Soporta muchas opciones en la configuración que permiten a los usuarios personalizar la aplicación para cumplir con sus requisitos. Gestión de estado: Reconexión automática cuando se pierde la conexión. Preservación y Restauración: El usuario ahora puede optar por probar “Preservación y Restauración”. Para más detalles sobre esta técnica, consulta Mejores prácticas: Cómo manejar Bluetooth Low Energy en segundo plano Los pasos en el flujo de conexión ahora son controlados por el usuario: tiempo de espera de conexión, establecer estado de notificación y más. La pantalla principal muestra toda la información y servicios que realmente te importan.La vista de registro en línea te ayuda a tener una mejor observación de lo que está sucediendo en tu dispositivo.La aplicación también ofrece una opción que permite al usuario establecer su propio nombre para las características para una mejor visualización, activar | desactivar notificaciones, copiar UUID al portapapeles, y más. La aplicación soporta un editor inteligente que sugiere automáticamente todos los comandos recientes - una pequeña mejora pero que ayuda a reducir tu tiempo de pruebas.La pantalla de detalle de características ahora ofrece una opción que permite mostrar todas las respuestas de múltiples características lo que te ayuda a captar todo el flujo durante las pruebas. Fácil de compartir: Comparte tu resultado con solo 1 clic. ArquitecturaEn el corazón de esta aplicación hay un SDK llamado BLEFramework - implementado por mí - que envuelve toda la lógica de trabajo con el framework BLE de Apple y proporciona interfaces simples para las capas de alto nivel - la aplicación. Al hacerlo de esta manera, podemos separar la lógica compleja de la aplicación de UI, facilitando el desarrollo y mantenimiento.Además, planeo mover todas las vistas de UI a una tecnología multiplataforma (quizás React Native) para soportar Android en una capa de vista única y unificada. Todo lo que necesito hacer es crear otro SDK que soporte la plataforma Android. Próximos pasosTengo una hoja de ruta para agregar más características increíbles a la aplicación, por nombrar algunas: transmisión de datos en tiempo real, medición de velocidad, conexiones múltiples, control por script, iBeacons.No puedo esperar para entregar todas estas características geniales a los usuarios.Si tienes alguna idea o comentario, no dudes en enviar un correo electrónico a uynguyen.itus@gmail.com o dark.hat.ble@gmail.com, me encantaría saber de ti.","link":"/es/posts/Dark-Hat-v1-0-has-been-released-yay/index.html"},{"title":"Historias de la Universidad (Parte 1)","text":"Anoche, mientras navegaba por Facebook, apareció una publicación de un estudiante de primer año en la página de Confesiones de mi universidad. El estudiante compartía sobre sus experiencias estudiando en la Universidad.Confesó que estaba estresado y ansioso porque la cantidad de conocimientos en la Universidad era demasiado grande para seguir el ritmo, mientras que sus compañeros parecían absorber todo más rápido que él. Esto lo hizo sentir más inseguro y querer rendirse.Normalmente no tengo el hábito de comentar en páginas de Fans o Confesiones, pero al leer la publicación de este estudiante, me di cuenta de lo mucho que se parecía a mí hace 5 años. Por eso quiero escribir un breve artículo para compartir con ustedes el camino que recorrí hace 5 años, el mismo camino que ustedes recorrerán, en mayor o menor medida. 1. “¡Estudias Tecnología de la Información y ni siquiera sabes qué es Visual Basic, mejor déjalo ya!”Esa fue la respuesta de mi compañero de Defensa Nacional cuando le pregunté sobre el libro grueso que tenía en la mano. Me sentí muy triste en ese momento, como si fuera un extraterrestre que acababa de caer en este lugar.Después, en el dormitorio (donde conocí a Truong - Este chico era bueno desde la secundaria, había participado en todas las competencias de Informática a nivel de distrito y provincia), me preguntó: “¿Sabes qué son los punteros? ¿Sabes qué es la recursión? ¿Conoces el algoritmo de Dijkstra, el ciclo Hamiltoniano?” (¡¿QUÉ?!). No entendí nada de lo que dijo, solo pude sonreír. :))En clase (donde conocí a Tu), mientras yo todavía estaba luchando por depurar un simple Hello World, Tu ya estaba en la pizarra programando como un dios: i++, j++ (¡¿QUÉ DEMONIOS?!).“Oye, ¿qué es i++?” - dijo Uy =]].Así era mi experiencia en programación :). Pero aun así logré sobrevivir 4 años de Universidad, así que la buena noticia para ustedes es que, ya sea que conozcan o no los fundamentos de la programación, cuando entren a la Universidad todos comenzarán desde el mismo punto de partida, solo que aquellos que ya saben algo tendrán más ventajas. Y eso es justo, porque durante los años de secundaria ya habían dedicado tiempo a estudiar en lugar de salir, ver películas o pasear.Tengo un amigo que una vez me dijo que yo era como su meta, que se esforzaría hasta superarme, para ver quién alcanzaba su sueño primero. Le respondí: *”Yo no tomo a otros como mis metas, tengo mis propias metas. Además, cada persona nace con diferentes puntos de partida y diferentes esfuerzos, yo no sé cómo ha sido tu camino y tú tampoco sabes el mío. ¿Entonces cómo podemos compararnos?”* 2. Los conocimientos fundamentales en la UniversidadA continuación está la lista de materias generales en los primeros 3 semestres. Matemáticas generales: Matemáticas discretas: Aprenderán sobre Vectores, operaciones con Vectores, álgebra de Boole, tablas de verdad, tablas lógicas, conceptos básicos de grafos… Probabilidad y estadística: Aprenderán sobre operaciones de cálculo de probabilidades, técnicas de conteo, estadísticas… Álgebra B1, B2: Aprenderán sobre operaciones con matrices, determinantes, espacios vectoriales… Cálculo B1, B2: Aprenderán sobre diferenciación, integración, derivadas… Estas materias son extremadamente importantes para las materias de ciencias de la computación posteriores, así que concéntrense en aprenderlas bien. Las matemáticas discretas son importantes si más adelante se especializan en algoritmos, teoría de grafos, autómatas, compiladores, procesamiento de lenguaje natural. Probabilidad y estadística son necesarias si trabajan mucho en inteligencia artificial, Data Science, Machine Learning. El álgebra lineal, matrices, vectores, etc. tienen aplicaciones en Cryptography y análisis de complejidad de algoritmos. Informática general: Electrónica Básica: Ya olvidé qué aprendí en esta materia, y tampoco sé cómo la aprobé. Teoría de Circuitos Digitales: Esta materia enseña sobre puertas lógicas AND, OR, XOR, NOT. Sistemas de numeración, operaciones a nivel de bits, etc. Introducción a la Programación: Esta materia es suave, aprenden cosas muy básicas como escribir “Hola mundo”, sintaxis básica: bucles, control, bifurcaciones… Teoría de Grafos: Esta fue mi materia favorita durante los 4 años de Universidad porque la profesora Van era muy amable. Aprenderán sobre recorridos de grafos (BFS, DFS), algoritmos de camino más corto (Dijkstra, Floyd + Bellman), conceptos de grafos (conectividad, isomorfismo, etc.), ciclos de Euler y Hamilton… Deberían leer: Introduction To Algorithm [THOMAS H. CORMEN, CHARLES E. LEISERSON, RONALD L. RIVEST, CLIFFORD STEIN] Introducción a la Tecnología de la Información 1, 2: Estas dos materias son principalmente para “dar un vistazo general” por diversión, les presentarán la carrera de Tecnología de la Información, las especializaciones y las direcciones de investigación. Estas dos materias son ligeras, no se presionen. Bases de Datos: Aprenden sobre conceptos básicos en sistemas de información y bases de datos, sistemas de bases de datos y modelos de datos relacionales, uso de SQL para consultar bases de datos, diseño de bases de datos, análisis de calidad de un esquema de base de datos. Arquitectura de Computadoras y Lenguaje Ensamblador: Aprenden sobre diseño de arquitectura de computadoras, visión general de computadoras, arquitectura MIPS, x86, x32, diseño de CPU, sistemas de numeración y almacenamiento en computadoras… Deberían leer: Computer Architecture: A Quantitative Approach [John L.Hennessy and David A.Patterson] Sistemas Operativos: Esta materia es importante, necesitan aprenderla bien. Aprenderán cómo funcionan los sistemas operativos, sobre el Kernel del OS, sistemas de archivos FAT32 y FAT64, cómo el OS gestiona y programa procesos, sincronización entre procesos, gestión de memoria en el OS… Deberían leer: Operating System Concepts [Silberschatz, Galvin, Gagne]. Redes de Computadoras: Esta materia es importante, deberían invertir mucho tiempo en estudiarla. Aprenderán sobre redes de computadoras, cómo los sistemas de computadoras trabajan entre sí, cómo se transmite un paquete en el sistema de red, conceptos de redes (IP, subnet mask, …), el modelo OSI de 7 capas, y luego estudiarán en detalle cada capa del modelo de red. Deberían leer: Computer Networking: A Top-Down Approach [7th Edition, Kurose &amp; Ross] Programación Orientada a Objetos: Deben dominar esta materia, si aprenden bien esta materia podrán aprender rápidamente cualquier lenguaje de programación. Y recuerden, al final el lenguaje es solo una herramienta para implementar sus ideas. No deberían priorizar el lenguaje de programación sobre los fundamentos para construir ese lenguaje. Deberían leer: Head First Design Pattern [Head First], Design Patterns [Gang Of Four] Técnicas de Programación: Esta materia les enseñará conceptos de programación (Punteros, memoria, matrices, stack, heap…) y técnicas de programación muy útiles (Programación dinámica, backtracking, y mi favorita es greedy) Jeje. Estructuras de Datos y Algoritmos: Esta materia les enseñará los tipos de estructuras de datos en programación (Tree, Stack, Heap, Queue…). Cómo usar cada tipo de datos en casos específicos. También les enseña algoritmos básicos (Ordenamiento, Búsqueda…), evaluación de complejidad entre algoritmos. Cuándo usar esto, cuándo usar aquello, cuál es mejor, qué hay que sacrificar, etc. Para aprender bien esta materia, además del material del curso, deberían leer: Introduction To Algorithm [Steven S.Skiena] o Introduction To Algorithm [THOMAS H. CORMEN, CHARLES E. LEISERSON, RONALD L. RIVEST, CLIFFORD STEIN] para mejorar sus habilidades. Además, para convertirse en un programador con conciencia, que escribe código con pocos bugs, y que otros no se frustren al leer su código, deberían leer: Clean Code [Robert C.Martin], Code Complete [Steve McConnell], Refactoring [Martin Fowler, Steve McConnell], Pragmatic Programmer [Andrew Hunt, David Thomas]. 3. Elegir una especialización:Después de los primeros 3 semestres, podrán elegir una especialización según sus preferencias.PODRÁN ELEGIR su especialización, no serán forzados ni tendrán que preocuparse por quedarse sin cupo, ya que algunos estudiantes me preguntaron sobre esto, así que lo aclaro aquí.Nuestra facultad actualmente tiene 6 especializaciones: Ingeniería de Software (Software Engineering): Aprenden sobre el proceso de desarrollo de software; análisis de requisitos, diseño de software, implementación y pruebas de software. Sistemas de Información (Information System): Aprenden a desarrollar y construir sistemas de información complejos, inteligentes y optimizados; investigación en seguridad de información, extracción de información multilingüe. Redes de Computadoras y Telecomunicaciones (Computer Networks and Telecommunication): Desarrollo de aplicaciones de red, sistemas operativos para dispositivos de red, desarrollo de sistemas. Ciencias de la Computación (Computer Science): Minería de datos, análisis y diseño de algoritmos para optimizar problemas, desarrollo de sistemas de inteligencia artificial (AI)… Ingeniería del Conocimiento (Knowledge Engineering): Investigación en procesamiento de lenguaje natural (voz) o multimedia (archivos de audio); investigación en criptografía y seguridad de la información. Visión por Computadora y Ciencia de Robots (Computer Vision and Robotics): Integración de técnicas de gráficos por computadora y procesamiento de imágenes digitales en dispositivos móviles y robots. Apoyo en detección, reconocimiento, consulta y recreación de objetos en diferentes entornos. En esta etapa, ustedes mismos registrarán las materias apropiadas para su especialización. Por ejemplo, si eligen “Ingeniería de Software”, deben acumular N créditos de materias de software y completar N materias obligatorias en ingeniería de software.Un consejo para ustedes es que no solo elijan materias dentro del alcance de su especialización, también deberían elegir materias de otras especializaciones que sean interesantes, útiles y complementen su especialización principal. Por ejemplo, si eligen Ingeniería de Software, pueden tomar materias adicionales de Ciencias de la Computación como “Análisis de Complejidad de Algoritmos”, “Análisis y Diseño de Algoritmos” o “Tema Especial de Sistema Operativo Linux” o “Seguridad de Bases de Datos” o “Minería de Datos y Aplicaciones” o “Machine Learning”… En resumen, deben saber elegir las materias correctas.Para más información sobre las especializaciones, consulten aquí Especializaciones en TI 4. ¿Son realmente importantes las calificaciones?*”Bah, estudiar es solo por el conocimiento, las calificaciones no importan.”*Les digo directamente que esta frase es solo una excusa de los estudiantes perezosos que no hacen las tareas. Si completan todas las tareas, sus calificaciones serán proporcionales a su esfuerzo.Volviendo al tema, ¿son realmente importantes las calificaciones en la Universidad? Mi opinión es que no son extremadamente importantes, pero tampoco son algo que se pueda ignorar.Las calificaciones, dentro de la Universidad, por un lado sirven para que no paguen la matrícula de tonto reprueben materias, por otro lado tienen un significado más importante para aquellos que necesitan becas para pagar la matrícula o los gastos mensuales. A más largo plazo, les permitirán aplicar a becas de estudio en el extranjero.Las calificaciones, fuera de la Universidad, son lo primero que los empleadores mirarán (para recién graduados) para ver si pasan la primera ronda. Pónganse en el lugar del empleador: eres recién graduado, no saben nada de ti, ¿qué usan para evaluar tu capacidad y tu persona? No sé exactamente cómo evalúan los empleadores, pero creo que el GPA dirá algo sobre ti: ¿eres una persona responsable (con tus estudios)? ¿Tienes las condiciones para llegar a la ronda técnica, a la entrevista? Las calificaciones son como el boleto para entrar a un salón de eventos, donde se mostrará tu verdadera capacidad. Si ni siquiera tienes el boleto de invitación, ¿cómo tendrás la oportunidad de mostrarte?Entonces, ¿son importantes las calificaciones? 5. Actividades extracurriculares, ¿sirven para algo?Hablando de actividades extracurriculares, les digo directamente que no participé en muchas actividades de la Unión de Estudiantes. Solo seleccioné algunas actividades realmente significativas (para mí y para otros) para participar. Por ejemplo, donación de sangre, festival de medio otoño, visitas a zonas rurales… Estas actividades son beneficiosas, te dan experiencias y ayudan a otros.Estas actividades extracurriculares serán puntos destacados importantes en las solicitudes de becas de estudio o becas internacionales.Además de las actividades en la universidad, pueden encontrar otras actividades de organizaciones benéficas. Participé en actividades de caridad de la organización no gubernamental Habitat en conjunto con la Universidad Nacional de Ho Chi Minh, la corporación POSCO de Corea y estudiantes coreanos para construir casas de caridad para personas pobres en Vung Tau. Estas actividades son muy significativas y también les ayudan a hacer amigos y conexiones para el futuro.Pueden consultar más aquí: Habitat for Humanity Vietnam. 6. Becas, ¿dónde encontrarlas?Cada semestre nuestra universidad tiene muchas becas para apoyarles: Beca de incentivo académico para estudiantes con altas calificaciones (se asignan de mayor a menor hasta agotar el cupo). Cuando era estudiante de primer año, el valor era de 2.5 millones de dong, luego en cuarto año aumentó a casi 4 millones por semestre (probablemente por la inflación :))). Esta cantidad es suficiente para cubrir (parte de) la matrícula.En realidad, no creo que sea demasiado difícil obtener esta beca. Sus calificaciones promedio solo necesitan estar por encima de 8.0 para tener la oportunidad de recibirla. En cuanto a los puntos de desarrollo personal, creo que no es necesario dedicar demasiado tiempo a participar en actividades de la Unión de Estudiantes, solo necesitan participar en algunas actividades principales (ver la sección de actividades extracurriculares) y no violar ninguna de las ‘reglas’ de la universidad (faltar a sesiones cívicas, confirmación de residencia, etc.) para cumplir con los requisitos. Además, nuestra facultad también tiene alianzas con empresas para otras becas. Grandes empresas como KMS, ELCA, CSC, Global Cybersoft, NTTData, GameLoft, VNG… todas tienen alianzas con nuestra facultad para otorgar becas semestrales (anuales) a los estudiantes. El valor de las becas varía de 3 a 5 millones de dong dependiendo de la empresa.Para obtener estas becas, sus calificaciones promedio no necesitan ser muy altas (solo 7.5+). Generalmente, estas becas están dirigidas a estudiantes con dificultades económicas en la facultad, por lo que habrá un requisito (opcional) de presentar un certificado de situación familiar difícil de su localidad. Para este certificado, vayan al Comité Popular de su localidad y soliciten el certificado.Estas becas, además del valor material (dinero), algunas empresas también les ofrecen oportunidades de prácticas (KMS, que yo sepa), o les enviarán una invitación para trabajar inmediatamente después de graduarse. ¿Genial, verdad? Información adicional: nuestra facultad también tiene un Fondo de Becas de antiguos alumnos para estudiantes con situaciones realmente difíciles (este parece no requerir calificaciones altas, 7.0+).Serán entrevistados por los profesores encargados del Fondo de Becas, ellos decidirán su destino :). Según sé, esta beca se otorga mensualmente durante los 4 años de estudio con el requisito de que completen satisfactoriamente el programa de estudios.Para más información, visiten: Fondo de Becas de Antiguos Alumnos de la Facultad de TI. Más adelante están las becas más grandes, que requieren más logros (GPA muy alto: 8.5+, buen inglés: Essay, algunas becas requieren prueba técnica, contribución a la sociedad: actividades extracurriculares, bonus: proyectos de investigación, artículos científicos, premios internacionales, etc.).En este punto, sus actividades extracurriculares realmente demostrarán su valor, las actividades que sirven a la sociedad y la comunidad serán muy valoradas por el comité de evaluación, lo que en parte revelará su carácter como persona. Las grandes becas evalúan a las personas desde muchos aspectos, no solo el estudio, es como si el Talento y la Virtud debieran ir juntos.A continuación listo solo las becas que he obtenido, nuestra universidad tiene muchas otras becas equivalentes, pueden buscar más en el sitio web de la universidad: Beca Odon Vallet 2016 de Recontres du Vietnam – Fundación Vallet para estudiantes con logros sobresalientes. (Valor 15 millones de dong) Beca Sunflower Mission Engineering and Technology de eSilicon Corporation y la fundación Sunflower Mission. (Valor $300) Beca Pony Chung patrocinada por la fundación Pony Chung, Hyundai Development Company y la Universidad Nacional de Vietnam. (Valor $500 + Oportunidad de beca de posgrado en Corea) Beca Lawrence S.Ting del Lawrence S.Ting Memorial Fund para estudiantes con logros sobresalientes. (Valor 10 millones de dong)La sección de Essay para becas, cuando tenga tiempo escribiré sobre mi experiencia con Essays, ahora me da pereza =]].3 segundos de publicidad del diploma de Sunflower (Este diploma es bonito así que lo presumo :)): 7. ¿Cómo estudiar?Lo más importante sigue siendo ustedes mismos, no habrá ningún método de estudio que sea perfecto para ustedes. Deben encontrarlo por sí mismos.Pero mi consejo es que deberían tener un grupo de estudio. Para mí, este grupo no necesita ser de los mejores de la clase, solo necesitan que estén dispuestos a estudiar juntos (recuerden, estudiar más que jugar), compartir conocimientos entre ustedes, de vez en cuando dejarse copiar código =]], porque la cantidad de conocimiento en la Universidad es muy grande, especialmente en nuestra carrera, así que necesitan compañeros de estudio, y para invitarse a faltar a clase para ir al cine o karaoke. En ese entonces vivía en el dormitorio con Truong, él era aplicado en los estudios así que me pegué a él para que me enseñara; los dos nos desvelábamos para cumplir con las fechas límite, gracias a eso mejoramos. (y)En Ingeniería de Software hay un concepto llamado Trade-off, que significa que deben saber equilibrar entre lo que se gana y lo que se pierde, entre costo de memoria y tiempo, entre esta materia y aquella, en circunstancias específicas, la elección que hagan es su decisión :).*”You can not write perfect softwares. Because a perfect software does not exist. No one in the brief history of computing has ever written a piece of perfect software. It’s unlike that you’ll be the first. And unless you accept this as a fact, you’ll end up wasting time and energy chasing an impossible dream”* (Pragmatic Programmer).También deben practicar el pensamiento crítico, es decir, cuando alguien presenta un problema o una solución, deben saber cuestionar: “¿Por qué hacerlo de esta manera y no de otra?”, “¿Cuáles son las ventajas y desventajas de este método comparado con el otro?”, “¿Será fácil de escalar o mantener en el futuro?”, “¿Hay alguna forma más inteligente?”… ese tipo de preguntas.Hacer preguntas les ayudará a entender mejor el problema, la persona con la que hablan también sabrá que entienden el problema lo suficiente como para hacer preguntas, en lugar de solo asentir y seguir sin saber si está bien o mal, entonces no tienen lo que se llama Critical thinking.Otro punto es que antes de hacer preguntas, deberían investigar a fondo sobre el tema, solo cuando no encuentren la respuesta o no sepan qué palabras clave usar para buscar, entonces deberían preguntar a otros. Así ahorran tiempo a otros (a veces si la pregunta es muy tonta y te regañan, no seas inmaduro y discutas), y se ayudan a desarrollar la habilidad de auto-investigación. Cuando salgan a trabajar, si el jefe les da una tarea y no saben cómo investigar, ¿a quién van a preguntar? ¿Van a volver a preguntarle al compañero de la universidad? =]]Aquí hay algunos canales que pueden consultar: Medium, Stack overflow, Quora. Además, hay grupos de estudio en Facebook de la facultad, deberían seguir estas páginas para mantenerse informados.Método para absorber conocimiento en una materia: traten de aprender los conceptos básicos (cómo funciona el algoritmo, cómo funciona el protocolo, ventajas y desventajas de cada tipo de base de datos, …) en lugar de enfocarse demasiado en la sintaxis y las bibliotecas.Y deben dedicar tiempo a leer libros adicionales, el conocimiento en la universidad es el mismo para todos. Entonces, ¿qué los diferencia de los demás? Es el conocimiento que recopilan por su cuenta fuera del aula. Leer libros adicionales les ayudará a tener una visión más profunda de lo aprendido en clase. A veces lo que dice el profesor en clase no es 100% correcto. Leer libros nunca es inútil :). Ya listé algunos libros famosos en la sección 2. Conocimientos fundamentales en la Universidad.Recuerden que son un Engineer, no un Coder. 8. “¿Tu salario es suficiente para vivir?”Esta es la última pregunta después de que me extraen todas las experiencias de estudio. Siempre respondo “No” =]]¿Qué es suficiente? ¿Solo suficiente para sobrevivir? Entonces supongo que es suficiente porque todavía estoy vivo escribiendo este artículo.Hay un dicho que encuentro muy cierto: Sigue tu pasión y las deudas te seguirán “Sigue tu pasión y el éxito te seguirá“. Cuando trabajas con todo tu esfuerzo y capacidad, otros lo notarán, evaluarán correctamente lo que has aportado, y recibirás lo que te mereces.Otra historia de una entrevista: después de preguntarme el salario que esperaba, la amable señora de recursos humanos me compartió: 1234La carrera de cada persona pasará por 3 etapas:Recién graduado: En este momento no tienes nada, concéntrate en recopilar conocimiento, mejorar tu nivel, sigue a personas talentosas para aprender su sabiduría y habilidades. Crea tu propia marca personal, tu nombre.Ganar dinero: Cuando ya tengas conocimiento, empieza a dedicarte a ganar dinero.Vivir con pasión: En este punto el dinero ya no es importante para ti, lo más importante es hacer lo que te gusta, lo que te apasiona, lo que naciste para hacer. Al final ella respondió “El salario que propones es demasiado alto, nuestra empresa no puede pagarlo” =]].Le conté esta historia a mis amigos cercanos, ellos dijeron que es una teoría de conspiración para lavarle el cerebro a los estudiantes =]].Personalmente, creo que lo que ella dijo también es cierto, “Follow your passion and success will follow you.”El día de la graduación, el director de la Facultad les garantizará 100% de empleo después de graduarse, así que no se preocupen por el desempleo o los salarios (aunque ese trabajo podría ser mecanografiar documentos :3) 9. ConclusiónEn general, el camino universitario que recorrí, y que ustedes recorrerán, probablemente sea el período más hermoso de la vida.Antes solía escuchar a los estudiantes mayores decir “Trabajar es más triste que estudiar” o “Ahora desearía volver a ese mes de entrenamiento de Defensa Nacional, seguro que la pasaría increíble en el Centro de Defensa Nacional”. En ese momento yo también decía “Sí, también lo creo”, aunque en ese momento no tenía ninguna experiencia para decir eso =]].Ahora, habiendo pasado esa época estudiantil, finalmente entiendo los sentimientos de quien lo decía.Hablando mucho, en resumen, 4 años pasarán muy rápido, así que tómense las cosas con calma, disfruten lentamente las fechas límite con sus amigos. Al final, mirando hacia atrás, no es nada del otro mundo. ¡NOT A BIG DEAL! Lo que obtendrán son los recuerdos de la época estudiantil llena de pasión :).Por cierto, un minuto de silencio por la contribución de los compañeros: Dap Xich Lo (DevOps &amp; Security Engineer), Canh Nguyen (Back-end Engineer) que ayudaron a revisar y corregir este artículo.","link":"/es/posts/Chuyen-o-Dai-Hoc-Phan-1/index.html"},{"title":"Fork y publicar tu biblioteca personalizada en npm - React Native Wheel Picker","text":"Cuando desarrollamos una nueva característica de nuestro software, tendemos a buscar si hay una biblioteca o framework “similar” disponible en la comunidad para reutilizarla. A nadie le gusta reinventar la rueda, ¿verdad? Sin embargo, la biblioteca que más se ajusta a nuestros requisitos a veces no soporta una característica que necesitas o solo una propiedad personalizada. Puedes abrir un pull request al repositorio original, pero puede tomar tiempo y depende del autor si aprueba tus cambios o no. En ese caso, puedes crear tu propia biblioteca desde la original, lo llamamos proceso “Fork”.En este post, resumiré brevemente los pasos para publicar una biblioteca en npm, y te contaré sobre una situación que enfrenté al usar la biblioteca React Native Wheel Picker. Es bastante simple publicar una biblioteca en npm. Solo necesitas hacer los siguientes pasos: Asegúrate de tener una cuenta de npm. Ve a https://www.npmjs.com para registrar una cuenta si no tienes una. Después, inicia sesión en tu cuenta en tu computadora a través de la línea de comandos npm login. Para verificar qué usuario ha iniciado sesión, usa npm whoami. La biblioteca que uso para mi proyecto soporta un componente Wheel Picker, pero ha sido deprecada, y no soporta establecer el color del elemento seleccionado en Android. Además, quiero crear mi propia biblioteca para poder agregar más características fácilmente después. Así que decidí hacer fork y personalizar mi propio wheel picker. Para hacer fork de una biblioteca, ve al repositorio de la biblioteca que quieres modificar, luego presiona el botón fork en la esquina superior derecha. Después de hacer fork exitosamente, deberías ver el repositorio en tu dashboard. Luego, clona el código a tu computadora, y agrega tus nuevas características.En mi caso, necesito agregar una nueva característica que soporte establecer el color para el elemento seleccionado (Consulta este PR) Cuando termines tu modificación, haz commit de tus cambios. Actualiza la información del repositorio en el archivo package.json si es necesario (Autor, versión, descripción, etc.). Finalmente, ejecuta npm publish --access public para entregar tu increíble biblioteca. Es hora de probar la nueva biblioteca. Si instalas la nueva biblioteca @uynguyen505/react-native-wheel-picker e intentas usarla, deberías ver el resultado como se muestra abajo. ¡Feliz fin de semana! Referencias Creating and publishing scoped public packages Forking, Modifying, and Publishing NPM Packages — For those almost-perfect packages","link":"/es/posts/Fork-and-publish-your-custom-lib-to-npm/index.html"},{"title":"Integrar Google Drive en una app iOS","text":"En Fossil, tuve la oportunidad de experimentar con la integración de Google Drive, como almacenamiento basado en la nube. La principal ventaja de usar Google Drive es compartir con otros miembros fácilmente, con una buena interfaz web para modificar los contenidos de las carpetas, y es gratis. Sin embargo, tuve dificultades al intentar hacer funcionar Google Drive debido a la falta de documentación y artículos relacionados con las APIs de Google Drive, especialmente en Swift. Además, el código y los ejemplos en los sitios de Google están desactualizados. Por lo tanto, decidí escribir este artículo con la esperanza de ahorrarte tiempo cuando quieras integrar Google Drive a tus apps. Comencemos. Crear tu app y acceso a la API de GooglePara usar las APIs de Google, primero debemos ir a Google Console Dashboard para crear un proyecto. Así que dirígete a Google cloud console, haz clic en el menú desplegable para crear un nuevo proyecto.Tu API de Google Drive está deshabilitada por defecto cuando creas nuevos proyectos. Para habilitar la API de Google Drive manualmente, haz clic en el elemento “APIs &amp; Services” en la barra lateral izquierda, te llevará a otra página donde puedes habilitar los servicios de Google para tus apps.Haz clic en el botón “Enable APIs and services”, luego escribe para buscar “Google drive”, después selecciona Google Drive de los resultados, finalmente haz clic en “Enable” para activar la app.Eso es todo lo que necesitas para crear una app usando la API de Google. Agregar credenciales para tu app iOSLas credenciales permiten que tu iOS acceda a tus APIs habilitadas. Haz clic en el botón “Credentials” en la barra lateral izquierda para agregar tu app iOS. Luego, ingresa la información de tu app incluyendo el nombre de tu app y el bundle id, por favor ten en cuenta que necesitas escribir exactamente el bundle id, de lo contrario no funcionará.Después de crear las nuevas credenciales exitosamente, deberías poder descargar el archivo plist que contendrá las claves necesarias para configurar tu proyecto Xcode. Guarda este archivo en un lugar seguro, lo usaremos en el siguiente paso. 1234567891011121314&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\"&gt;&lt;plist version=\"1.0\"&gt;&lt;dict&gt; &lt;key&gt;CLIENT_ID&lt;/key&gt; &lt;string&gt;YOUR_CLIENT_ID&lt;/string&gt; &lt;key&gt;REVERSED_CLIENT_ID&lt;/key&gt; &lt;string&gt;YOUR_REVERSED_CLIENT_ID&lt;/string&gt; &lt;key&gt;PLIST_VERSION&lt;/key&gt; &lt;string&gt;1&lt;/string&gt; &lt;key&gt;BUNDLE_ID&lt;/key&gt; &lt;string&gt;com.example&lt;/string&gt;&lt;/dict&gt;&lt;/plist&gt; Configuración del proyectoGoogle APIs Client Library es una biblioteca escrita por Google para acceder a las APIs de Google. Adelante y agrega la siguiente biblioteca a tu archivo Pod. 12pod 'GoogleAPIClientForREST/Drive', '~&gt; 1.2.1'pod 'GoogleSignIn', '~&gt; 4.1.1' Encontrarás YOUR_REVERSED_CLIENT_ID y YOUR_CLIENT_ID en el archivo plist de configuración del cliente que descargaste previamente. Selecciona tu proyecto objetivo, ve a la pestaña “Info”, agrega un nuevo elemento en la sección “URL Types”, luego ingresa YOUR_REVERSED_CLIENT_ID en el cuadro “URL Schemes”.En caso de que no sepas para qué sirven los URL Schemes, cada elemento en la sección URL Schemes te permite definir un esquema de URL personalizado para tu app. Por ejemplo, tu app podría permitir a los usuarios tocar una URL personalizada en un correo electrónico para lanzar tu app en un contexto específico. Por defecto, Apple soporta esquemas comunes asociados con apps del sistema como mail, sms, facetime, etc. Para más información, por favor consulta Defining a Custom URL Scheme for Your AppSi no agregas YOUR_REVERSED_CLIENT_ID como un esquema de URL personalizado, tu app tendrá el siguiente crash al intentar autorizar con la API de Google. Así que asegúrate de no omitir este paso importante.Luego, abre el archivo AppDelegate.swift, agrega tu client id a la instancia de Google Sign In. 1234func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -&gt; Bool { GIDSignIn.sharedInstance().clientID = \"YOUR_CLIENT_ID\" return true} Después, abre tu ViewController donde permites al usuario iniciar sesión con su cuenta de Google e implementa los dos delegados GIDSignInUIDelegate y GIDSignInDelegate de Google Sign in. 123456789101112131415extension ViewController: GIDSignInDelegate { func sign(_ signIn: GIDSignIn!, didSignInFor user: GIDGoogleUser!, withError error: Error!) { if let _ = error { } else { print(\"Authenticate successfully\") } } func sign(_ signIn: GIDSignIn!, didDisconnectWith user: GIDGoogleUser!, withError error: Error!) { print(\"Did disconnect to user\") }}extension ViewController: GIDSignInUIDelegate {} Finalmente, asigna el delegado de Google sign in a tu view controller. 123456private func setupGoogleSignIn() { GIDSignIn.sharedInstance().delegate = self GIDSignIn.sharedInstance().uiDelegate = self GIDSignIn.sharedInstance().scopes = [kGTLRAuthScopeDrive] GIDSignIn.sharedInstance()?.signInSilently()} Podrías notar la línea de código GIDSignIn.sharedInstance().scopes. Esta línea de código define qué permisos otorga el usuario a tu app para acceder a sus datos al autenticarse. En este caso, usamos el scope kGTLRAuthScopeDrive que permite a nuestra app ver y administrar todos los archivos en el Google Drive del usuario, incluyendo team drive. El método signInSilently intentará iniciar sesión silenciosamente con un usuario previamente autenticado. Si realizas todos los pasos anteriores correctamente, deberías poder autenticar tu app con la API de Google. ![](/Post-Resources/GoogleDrive/GoogleSignIn.png \"Google Sign in\") ![](/Post-Resources/GoogleDrive/GrantPermission.png \"Grant permission\") APIs comunesTrabajar con “My Drive”Búsqueda12345678public func search(_ name: String, onCompleted: @escaping (GTLRDrive_File?, Error?) -&gt; ()) { let query = GTLRDriveQuery_FilesList.query() query.pageSize = 1 query.q = \"name contains '\\(name)'\" self.service.executeQuery(query) { (ticket, results, error) in onCompleted((results as? GTLRDrive_FileList)?.files?.first, error) }} Listado12345678 public func listFiles(_ folderID: String, onCompleted: @escaping (GTLRDrive_FileList?, Error?) -&gt; ()) { let query = GTLRDriveQuery_FilesList.query() query.pageSize = 100 query.q = \"'\\(folderID)' in parents and mimeType != 'application/vnd.google-apps.folder'\" self.service.executeQuery(query) { (ticket, result, error) in onCompleted(result as? GTLRDrive_FileList, error) }} Subida123456789101112131415private func upload(_ folderID: String, fileName: String, data: Data, MIMEType: String, onCompleted: ((String?, Error?) -&gt; ())?) { let file = GTLRDrive_File() file.name = fileName file.parents = [folderID] let params = GTLRUploadParameters(data: data, mimeType: MIMEType) params.shouldUploadWithSingleRequest = true let query = GTLRDriveQuery_FilesCreate.query(withObject: file, uploadParameters: params) query.fields = \"id\" self.service.executeQuery(query, completionHandler: { (ticket, file, error) in onCompleted?((file as? GTLRDrive_File)?.identifier, error) })} Descarga12345678910111213public func download(_ fileItem: GTLRDrive_File, onCompleted: @escaping (Data?, Error?) -&gt; ()) { guard let fileID = fileItem.identifier else { return onCompleted(nil, nil) } self.service.executeQuery(GTLRDriveQuery_FilesGet.queryForMedia(withFileId: fileID)) { (ticket, file, error) in guard let data = (file as? GTLRDataObject)?.data else { return onCompleted(nil, nil) } onCompleted(data, nil) }} Eliminación123456789public func delete(_ fileItem: GTLRDrive_File, onCompleted: @escaping ((Error?) -&gt; ())) { guard let fileID = fileItem.identifier else { return onCompleted(nil) } self.service.executeQuery(GTLRDriveQuery_FilesDelete.query(withFileId: fileID)) { (ticket, nilFile, error) in onCompleted(error) }} Trabajar con “Team Drive”Lo único que necesitamos hacer para trabajar con “Team Drive” es establecer el parámetro corpora de la consulta a teamDrive. Por defecto, se aplica el corpora user. Eso significa que la consulta solo se aplica a las carpetas propiedad del usuario. Al establecerlo en teamDrive, indicamos que la consulta afectará al team drive del usuario. Podemos combinar múltiples corpora en una sola consulta si necesitas hacerlo. Reflexiones finalesGoogle Drive es un almacenamiento ideal para integrar con nuestras aplicaciones. En este artículo, cubrimos cómo configurar la API de Google Drive y cómo ejecutar APIs comunes. Espero que hayas aprendido algo hoy.Puedes encontrar todo el código fuente de demostración en mi Github Referencias[1] Google Developer https://developers.google.com/drive/api/v3/about-sdk","link":"/es/posts/Integrate-Google-Drive-to-iOS-app/index.html"},{"title":"Fuga de memoria","text":"Como Ingeniero de Software, definitivamente has escuchado sobre el concepto de fuga de memoria. La fuga de memoria es una situación donde los bloques de memoria están ubicados por el programa y permanecen en la memoria a pesar de que ya no están referenciados. Las fugas desperdician espacio llenando páginas de memoria con datos inaccesibles. Como resultado, el tamaño de memoria usado en tus aplicaciones sigue aumentando, afectando la experiencia del usuario y el rendimiento de tu aplicación. Peor aún, tu aplicación se cerrará aleatoriamente porque un proceso será terminado por el sistema si consume demasiada memoria.En este tema, discutiremos cómo se gestiona la memoria en iOS y cómo usar la memoria eficientemente. Continúa leyendo. Conteo Automático de ReferenciasARCLa mayoría de los lenguajes de programación modernos (como Java, C#, Go, etc.) tienen un proceso incorporado que automáticamente encuentra objetos no utilizados y los elimina para liberar memoria. El propósito principal de esta tecnología es reducir las fugas de memoria y dejar que los programadores se enfoquen en su lógica de negocio sin preocuparse demasiado por la gestión de memoria.Como lenguaje de programación de alto nivel, Swift también tiene Conteo Automático de Referencias (ARC) para gestionar la memoria usada en nuestras aplicaciones. Cómo funciona ARCCada vez que creamos una nueva instancia de una clase, ARC asignará un espacio de memoria para almacenar información sobre esa instancia. Esta memoria guarda información sobre el tipo de la instancia, cualquier propiedad almacenada asociada con esa instancia. Especialmente, esta memoria guarda la información de cuántas propiedades, constantes y variables están actualmente refiriendo a esa instancia. ARC nunca desasignará esa instancia mientras exista al menos una referencia activa a esa instancia.Una vez que el número de objetos que refieren a esa instancia llega a cero, ARC desasignará esa instancia y liberará la memoria retenida por esa instancia.Al aplicar esta técnica, Apple asegura que las instancias de clase no sigan ocupando espacio en memoria cuando ya no son necesarias, generalmente evitando el problema de fugas de memoria. Fuga de memoriaEn la mayoría de los casos, ARC hace bien su trabajo. Usualmente no nos preocupamos por la gestión de memoria. Sin embargo, las fugas aún ocurren en iOS por accidente. Esto es cuando dos objetos mantienen referencias fuertes entre sí de manera que cada objeto evita que el otro sea desasignado. Tomemos un ejemplo, hay dos clases llamadas Person y Car. 1234567891011121314151617181920212223242526272829class Person { let name: String var car: Car? lazy var greeting: () -&gt; String = { return \"Hello, my name is \\(self.name). I have \\(self.car?.name ?? \"no cars\")\" } init(name: String) { self.name = name } deinit { print(\"Person \\(self.name) is being destroyed.\") }}class Car { let name: String var owner: Person? init(name: String) { self.name = name } deinit { print(\"car \\(self.name) is being destroyed.\") }} Cada instancia de Person tiene una propiedad name de tipo String y una propiedad opcional Car que inicialmente es nil porque una persona puede no siempre tener un auto.De manera similar, cada instancia de Car tiene una propiedad name de tipo String y una propiedad opcional Person que inicialmente es nil porque un auto puede no siempre tener un dueño.A continuación, definamos dos variables llamadas Foo y BMW de las clases Person y Car, respectivamente. Ahora, enlazamos las dos instancias juntas para que la persona tenga un auto, y el auto tenga un dueño. 123456# Bloque principalvar foo: Person? = Person(name: \"Foo\")var car: Car? = Car(name: \"BMW\")foo!.car = carseat!.owner = fooprint(foo!.greeting()) El siguiente fragmento de código liberará estas dos instancias estableciéndolas a nil. 12foo = nilseat = nil Como podrías saber, una vez que establecemos una variable a nil, significa que no hay referencias a esta instancia de clase, ARC desasignará el espacio de este objeto para liberar memoria. Como expectativa, deberíamos ver que los métodos deinit de Student y Car son llamados. Sin embargo, esos dos métodos nunca son llamados, no hay ningún mensaje, indicando que los objetos son liberados, impreso en la consola. Esto significa que foo y car nunca son desinicializados.La razón por la que estos dos objetos no son liberados es porque estos dos objetos mantienen referencias fuertes entre sí de manera que cada objeto evita que el otro sea desasignado, resultando en que nunca son desinicializados. Esta situación se llama ciclo de referencia fuerte en programación. Romper ciclos de referencia fuerteHay dos formas de romper ciclos de referencia fuerte en Swift. Dependiendo de qué situación estemos enfrentando, elegiremos un enfoque sensato para resolver el problema. Ambos métodos permiten que una instancia referencie a otra sin mantener un agarre fuerte sobre ella. Referencia débilLas referencias débiles deben usarse cuando el objeto al que se refiere podría volverse nil en el futuro. Como tal, los objetos capturados son tipos opcionales.En el ejemplo anterior, es apropiado para un auto poder no tener dueño en algún punto de su vida, y así una referencia débil es una forma apropiada de romper el ciclo de referencia en este caso.Hagamos algunos cambios para que la magia suceda 123456789101112class Car { let name: String weak var owner: Person? init(name: String) { self.name = name } deinit { print(\"Car \\(self.name) is being destroyed.\") }} Ejecutemos el código, todavía no hay mensajes impresos en la consola, significa que los dos objetos no son liberados. ¡Qué demonios!Rastreemos nuestro código para verificar qué está mal.¿Lo ves? Hay otro problema con el código: El closure. Referencia unownedEn el ejemplo anterior, la clase Person no solo crea un ciclo de referencia fuerte con la clase Car sino también entre sí misma y el closure greeting. Así es como se ve el ciclo:Para resolver este problema, usaremos “Referencia unowned”. Las referencias unowned deben usarse cuando el closure y el objeto al que se refiere siempre tendrán el mismo tiempo de vida el uno con el otro. Esto significa que los dos objetos serán desasignados al mismo tiempo. Como resultado, una referencia unowned nunca puede volverse nil.Hagamos algunos cambios para que la magia suceda (De nuevo). 12345678910111213141516class Person { let name: String var car: Car? lazy var greeting: () -&gt; String = { [unowned self] in return \"Hello, my name is \\(self.name). I have \\(self.car?.name ?? \"no cars\")\" } init(name: String) { self.name = name } deinit { print(\"Person \\(self.name) is being destroyed.\") }} Ejecutemos el código, deberías ver los siguientes mensajes impresos en la consola. 123Hello, my name is Foo. I have BMWPerson Foo is being destroyed.Car BMW is being destroyed. Los dos objetos foo y car han sido liberados y la fuga ha sido resuelta.Así es como se ve el ciclo hasta ahora: Herramientas para detectar ciclos de referencia fuerteEncontrar fugas de memoria usualmente es una pesadilla para un desarrollador iOS porque es demasiado difícil descubrir la causa raíz. Afortunadamente, tenemos múltiples herramientas soportadas por Apple para rastrear fugas de memoria. Instrumento de Allocations y LeaksDesde la barra de herramientas de XCode, elige Product &gt; Profile &gt; Allocations para iniciar un nuevo perfil de instrumento para rastrear asignaciones de memoria. El instrumento Allocations rastrea todos los objetos que la aplicación asigna durante su tiempo de vida.Ahora, presiona el botón rojo en la parte superior izquierda del panel para comenzar a grabar.Hay mucha información relacionada con el mapeo de memoria mostrada en la herramienta. Para identificar fugas de memoria, solo necesitamos enfocarnos en dos columnas principales: #Persident y #Transident. Columna Persident: mantiene un conteo del número de objetos de cada tipo que actualmente existen en memoria. Columna Transident: muestra el número de objetos que han existido pero desde entonces han sido desasignados. Como puedes ver, la columna #Persident sigue aumentando cada vez que presionas el botón “Create a leak” para ejecutar el bloque principal. Cuando ves algo así suceder a tu aplicación, es hora de revisar tus clases para descubrir dónde está la fuga. Debug Memory GraphDebug Memory Graph es una herramienta introducida por primera vez en Xcode 8. Es capaz de capturar fugas como ciclos de retención.Desde el navegador de depuración, haz clic en modo debug &gt; View Memory Graph Hierarchy para visualizar el mapeo de memoriaDeberías ver algo como esto.Desde la visualización, podemos ver que hay dos ciclos de referencia fuerte que vienen de la relación Person-Car y de dentro de Person en sí. ConclusiónTodo desarrollador iOS debería tener un entendimiento profundo de cómo funciona ARC para evitar fugas de memoria. Innegablemente, una buena gestión de memoria contribuye al rendimiento de la aplicación y a la experiencia del usuario. Esperanzadamente, todos los conceptos que revisamos en este artículo te ayudarán a construir aplicaciones que tengan el mejor rendimiento. Siéntete libre de dejar tus comentarios aquí. Referencias[1] The Swift Programming Language (Swift 4.0.3), App Inc., capítulo de Automatic Reference Counting.","link":"/es/posts/Memory-leak/index.html"},{"title":"Jugando con Android Things","text":"","link":"/es/posts/Play-with-Android-Things/index.html"},{"title":"Patrones de diseño","text":"","link":"/es/posts/Design-patterns/index.html"},{"title":"Protobuf en la practica","text":"He trabajado en productos Bluetooth, incluyendo dispositivos wearables y cerraduras inteligentes, durante muchos anos. Facilitar la transferencia de mensajes entre componentes del sistema es un aspecto crucial debido a las diferencias en los lenguajes de programacion, la necesidad de consistencia y las limitaciones en el tamano de transferencia de datos. Para abordar estos desafios, utilizamos Protocol Buffers.Protocol Buffers, tambien conocido como Protobuf, es un formato de datos multiplataforma gratuito y de codigo abierto utilizado para serializar datos estructurados desarrollado por Google. Esta disenado para ser eficiente, extensible y facil de usar. En este tutorial, cubriremos los conceptos basicos de crear un mensaje simple de Protocol Buffers, definir un esquema y generar codigo en varios lenguajes de programacion. InstalacionPara instalar el compilador de protobuf, sigue las instrucciones descritas en protobuf-compiler-installation.El uso basico puede resumirse con la imagen a continuacion. Pasos para configurar: Instala el compilador de protobuf. En Mac, usa brew: brew install protobuf Valida si la instalacion se completo exitosamente: protoc --version. Instalando el plugin del generador de codigo: Protobuf soporta varios lenguajes de programacion diferentes. Necesitas encontrar e instalar el generador de codigo para el lenguaje especifico dependiendo de que lenguajes de programacion se usen en tu proyecto. Por ejemplo, para Swift, usa swift-protobuf: brew install swift-protobuf. Para JavaScript, usa npm install -g protoc-gen-js. Define tus esquemas: Visita Programming Guides para aprender como usar el lenguaje de protocol buffer para estructurar tus datos de protocol buffer example.proto12345message Person { optional string name = 1; optional int32 id = 2; optional string email = 3;} Compila archivos .proto para generar codigo para lenguajes especificos. 1234nguyenuy@192 ~/Desktop/protobuf protoc --js_out=. example.protonguyenuy@192 ~/Desktop/protobuf protoc --java_out=. example.protonguyenuy@192 ~/Desktop/protobuf protoc --cpp_out=. example.protonguyenuy@192 ~/Desktop/protobuf protoc --dart_out=. example.proto Distribuye (importa) los archivos generados a tus proyectos. Instala el plugin de runtime. Por ejemplo, en un proyecto iOS, incluye el framework SwiftProtobuf en el Podfile. Para proyectos Flutter, agrega protobuf al archivo pubspec.yaml. Para proyectos ReactJS, incluye google-protobuf en el archivo package.json. Implementa la serializacion y deserializacion:Ejemplo en Python 12345678910111213person = example_pb2.Person()# Set valuesperson.name = \"Uy Nguyen\"person.id = 1person.email = \"uynguyen.itus@gmail.com\"# Serialize the message to bytesserialized_data = person.SerializeToString()# Parse the bytes back into a messagenew_person = example_pb2.Person()new_person.ParseFromString(serialized_data) Ejemplo en Java 1234567891011Person person = Person.newBuilder() .setName(\"Uy Nguyen\") .setId(1) .setEmail(\"uynguyen@gmail.com\") .build();// Serialize the message to bytesbyte[] serializedData = person.toByteArray();// Parse the bytes back into a messagePerson newPerson = Person.parseFrom(serializedData); Ejemplo en Swift 12345678910var p = Person()p.id = 1p.email = \"uynguyen.itus@gmail.com\"p.name = \"Uy Nguyen\"// Serialize the message to byteslet data = try? p.serializedData()// Parse the bytes back into a messagelet converted = try? Person(serializedData: data!) A continuacion se muestra como lucen los archivos generados en diferentes lenguajes. Ventajas Formato binario: Protobuf usa un formato binario para la serializacion, que es mas compacto que el formato basado en texto de JSON. Esto resulta en tamanos de mensaje mas pequenos, haciendolo mas eficiente en terminos de ancho de banda y almacenamiento. Rendimiento: Debido a su formato binario y codificacion eficiente, los procesos de serializacion y deserializacion de Protobuf son generalmente mas rapidos que JSON. Esto puede ser particularmente importante en escenarios con requisitos de alto rendimiento o baja latencia, como sistemas que aplican BLE. Generacion de codigo: Protobuf depende de la generacion de codigo para crear clases de datos en varios lenguajes de programacion basados en el esquema definido. Esto puede llevar a codigo con tipos seguros y eficiente, reduciendo las posibilidades de errores en tiempo de ejecucion relacionados con desajustes en la estructura de datos. Soporte para multiples lenguajes: Protobuf soporta la generacion de codigo en una variedad de lenguajes de programacion, haciendolo adecuado para proyectos con diferentes tecnologias. Esto permite que diferentes servicios escritos en diferentes lenguajes se comuniquen facilmente usando las mismas estructuras de datos. Desventajas Legibilidad humana: El formato binario de Protobuf no es legible por humanos, lo que puede hacer que la depuracion y solucion de problemas sea mas desafiante comparado con JSON. El formato de texto plano de JSON permite a los desarrolladores inspeccionar los datos facilmente. Complejidad de depuracion: Debido a la naturaleza binaria de protobuf, la depuracion puede ser mas compleja cuando se compara con JSON. A menudo se necesitan herramientas especializadas para inspeccionar el contenido de los mensajes codificados en protobuf. Menos comun en tecnologias web: JSON es mas prevalente en el desarrollo web y es soportado nativamente por muchas APIs web. Si la interoperabilidad con tecnologias web es una prioridad principal, JSON podria ser una opcion mas natural. Complejidad en estructuras anidadas: Tratar con estructuras anidadas en mensajes protobuf a veces puede ser menos intuitivo que en JSON. Se debe tener cuidado al disenar estructuras anidadas para evitar complejidad innecesaria. ResumenEn resumen, mientras protobuf ofrece ventajas significativas en terminos de eficiencia y rendimiento, su adopcion debe considerarse basandose en los requisitos y restricciones especificos del proyecto. Es esencial considerar las ventajas y desventajas y elegir el formato de serializacion que mejor se alinee con los objetivos y restricciones de tu proyecto. Referencias Protocol Buffers Documentation","link":"/es/posts/Protobuf/index.html"},{"title":"Integrar Google Sign In en una App MacOS con Swift","text":"Como desarrollador iOS, podrías tener la oportunidad de escribir aplicaciones en Mac OS. Y a veces, tus aplicaciones requieren que los usuarios se autentiquen antes de poder usar tu app. Habilitar Google Sign in te ayuda a ahorrar mucho tiempo para implementar el flujo de autenticación. Desafortunadamente, hay falta de documentación sobre cómo integrar Google Sign in en apps de MacOS, particularmente en Swift. Una vez tuve la oportunidad de implementar esta característica en mi app. Ahora quiero compartir contigo cómo podemos hacerlo. Comencemos. ConfiguraciónPrimero creemos tu aplicación de Mac OS, nómbrala como quieras. Luego, ejecuta el comando pod init para inicializar el workspace de Pod.Después, agrega la siguiente línea a tu archivo Pod. 123456use_frameworks!pod 'GTMAppAuth' # GTMAppAuth is an alternative authorizer to GTMOAuth2, supports for authorizing requests with AppAuth.pod 'SwiftyJSON' # JSON parserpod 'PromiseKit' # Make async requestspod 'Kingfisher' # Cached imagepod 'SnapKit' # Autolayout Luego ejecuta pod install para descargar todas estas dependencias. Obtener un OAuth client IDAntes de comenzar con el ejemplo, primero ve a Google Console y crea un nuevo proyecto. Luego presiona “Create credentials” &gt; “OAuth client ID” &gt; tipo de aplicación “Other” &gt; Sigue las instrucciones para obtener tus credenciales.Después de crear el OAuth client ID, toma nota del client ID y el client secret, los cuales necesitarás para configurar Google Sign-in en tu app. Opcionalmente puedes descargar el archivo de configuración que contiene la información de tu proyecto para referencia futura. Configurar el proyectoAsegúrate de configurar tu app para permitir conexiones de red entrantes y salientes yendo a Signing &amp; Capabilities &gt; App Sandbox &gt; Marca tanto Incoming Connections como Outgoing Connections. Si no haces eso, obtendrás el siguiente error porque tu app no tiene permiso para realizar solicitudes. 122019-12-11 22:22:49.472046+0700 GoogleSignInDemo[3955:65750] Metal API Validation Enabled2019-12-11 22:22:51.444494+0700 GoogleSignInDemo[3955:66166] dnssd_clientstub ConnectToServer: connect() failed path:/var/run/mDNSResponder Socket:11 Err:-1 Errno:1 Operation not permitted Después, abre el Info.plist y agrega un nuevo valor para CFBundleURLTypes, que es la forma de notación DNS inversa de tu client ID. Safari usará esta notación DNS para abrir tu app después de que el proceso de autenticación se realice exitosamente. 1234567891011&lt;key&gt;CFBundleURLTypes&lt;/key&gt;&lt;array&gt; &lt;dict&gt; &lt;key&gt;CFBundleTypeRole&lt;/key&gt; &lt;string&gt;Editor&lt;/string&gt; &lt;key&gt;CFBundleURLSchemes&lt;/key&gt; &lt;array&gt; &lt;string&gt;com.googleusercontent.apps.REPLACE_BY_YOUR_CLIENT_ID&lt;/string&gt; &lt;/array&gt; &lt;/dict&gt;&lt;/array&gt; Realizando la autorizaciónPrimero creemos nuestro objeto de servicio, la clase GoogleSignInService, que maneja todas las solicitudes relacionadas con Google Sign in. También contiene todas las credenciales de tu proyecto. 123456789class GoogleSignInService: NSObject, OIDExternalUserAgent { static let kYourClientNumer = \"REPLACE_BY_YOUR_CLIENT_ID\" static let kIssuer = \"https://accounts.google.com\" static let kClientID = \"\\(Self.kYourClientNumer).apps.googleusercontent.com\" static let kClientSecret = \"REPLACE_BY_YOUR_CLIENT_SECRET\" static let kRedirectURI = \"com.googleusercontent.apps.\\(Self.kYourClientNumer):/oauthredirect\" static let kExampleAuthorizerKey = \"REPLACE_BY_YOUR_AUTHORIZATION_KEY\" // The rest omitted} Descubre el endpoint del servicio de Google y define una solicitud. 1234567891011OIDAuthorizationService.discoverConfiguration(forIssuer: URL(string: Self.kIssuer)!) { // The rest omitted let request = OIDAuthorizationRequest(configuration: config, clientId: Self.kClientID, clientSecret: Self.kClientSecret, scopes: [OIDScopeOpenID, OIDScopeProfile, OIDScopeEmail], redirectURL: URL(string: Self.kRedirectURI)!, responseType: OIDResponseTypeCode, additionalParameters: nil) // The rest omitted} Mira el parámetro scopes, este parámetro define a qué información del usuario puede acceder tu app. Google Sign In ofrece 5 scopes diferentes, incluyendo: NSString *const OIDScopeOpenID = @”openid”; NSString *const OIDScopeProfile = @”profile”; NSString *const OIDScopeEmail = @”email”; NSString *const OIDScopeAddress = @”address”; NSString *const OIDScopePhone = @”phone”; Puedes seleccionar cuáles se ajustan a los requisitos de tu app.Finalmente, inicia el proceso de autenticación. 1234567OIDAuthState.authState(byPresenting: request, externalUserAgent: self, callback: { (state, error) in guard error == nil else { seal.reject(error!) return } // You got the OIDAuthState object here}) Después de que el proceso de autenticación se realiza exitosamente, obtendrás un objeto OIDAuthState que se usará como parámetro para inicializar el objeto GTMAppAuthFetcherAuthorization.Normalmente, deberías guardar este objeto GTMAppAuthFetcherAuthorization en un keychain y reutilizarlo para las siguientes llamadas a la API REST. 123456private func saveState() { // The rest omitted if auth.canAuthorize() { GTMAppAuthFetcherAuthorization.save(auth, toKeychainForName: Self.kExampleAuthorizerKey) }} Realizando solicitudesDespués de guardar el objeto de servicio en el keychain, ahora puedes recuperarlo para hacer cualquier solicitud. Haré una solicitud para obtener el perfil del usuario actual. 12345678910111213func loadProfile() -&gt; Promise&lt;GoogleSignInProfile&gt; { return Promise { (seal) in // The rest omitted if let url = URL(string: \"https://www.googleapis.com/oauth2/v3/userinfo\") { let service = GTMSessionFetcherService() service.authorizer = auth service.fetcher(with: url).beginFetch { (data, error) in // Process the data here // data = [\"locale\", \"family_name\", \"given_name\", \"picture\", \"sub\", \"name\", emai] } } }} Solución de problemas Después de iniciar sesión, si tu Safari no puede redirigir de vuelta a tu app. Solo limpia tu proyecto (Shift + Cmd + K) y luego ejecútalo de nuevo. Otros navegadores web (Chrome, Firefox, etc) no pueden abrir tu app así que asegúrate de lanzar la web de inicio de sesión en Safari.1NSWorkspace.shared.open([url], withAppBundleIdentifier: \"com.apple.Safari\", options: .default, additionalEventParamDescriptor: nil, launchIdentifiers: nil) { Reflexiones finalesPuedes encontrar la demostración completa aquíAhora puedes usar Google Sign in dentro de tu macOS para reducir tus esfuerzos en la autenticación. Para obtener el código fuente completo, por favor descárgalo a través del enlace de Github.En caso de que tengas algún problema, no dudes en contactarme.","link":"/es/posts/Integrate-Google-Sign-In-on-MacOS-App-in-Swift/index.html"},{"title":"Grand Central Dispatch en Swift","text":"Grand Central Dispatch, o GCD para abreviar, es una API de bajo nivel en C para gestionar tareas concurrentes. Nos ayuda a mejorar el rendimiento de nuestra aplicacion ejecutando un bloque de codigo en hilos apropiados, como realizar tareas computacionalmente costosas en segundo plano. GCD proporciona varias opciones para ejecutar tareas como sincronicamente, asincronicamente, despues de un cierto retraso, etc.En esta publicacion explicare mas detalles sobre GCD y como funciona, tambien proporcionare algunos puntos interesantes cuando trabajamos con GCD. Comencemos. IntroduccionEn el corazon de GCD estan las colas de despacho (dispatch queues) que son grupos de hilos gestionados por GCD. Apple creo GCD para que los desarrolladores no necesiten preocuparse demasiado por estas colas, simplemente despachan un bloque de codigo a una cola dada sin preocuparse por cual hilo se usa. Conceptos de GCDConcurrenciaLa concurrencia se logra cuando mas de dos tareas se ejecutan al mismo tiempo. De hecho, la palabra “Concurrencia” no significa exactamente “al mismo tiempo” o “ocurrir en paralelo”. Internamente, la CPU le da a cada tarea una cierta porcion de tiempo para hacer su trabajo. Por ejemplo, si hay 5 tareas para ejecutar en un segundo, con la misma prioridad, el sistema operativo dividira 1,000 milisegundos entre 5 (tareas) y dara a cada tarea 200 milisegundos de tiempo de CPU. Como resultado, pareceran haberse ejecutado concurrentemente. Cola serial y cola concurrenteUna cola serial ejecutara sus tareas en forma primero en entrar, primero en salir (FIFO). Esto significa que solo pueden ejecutar un bloque de codigo a la vez. No se ejecutan en el hilo principal, por lo tanto, no bloquean la interfaz de usuario.En contraste, una cola concurrente permite ejecutar multiples tareas en paralelo. Significa que las tareas pueden terminar en cualquier orden y no sabras el tiempo que tomara. Metodos sincronos (sync) y asincronos (async)Cuando despachas una tarea a una cola, determinas si el bloque se ejecuta sincronicamente o asincronicamente. Hay algunas diferencias principales entre las dos tecnicas: Un metodo sincrono devuelve el control al llamador solo despues de que la tarea se completa, mientras que un metodo asincrono devuelve el control al llamador inmediatamente. Como los metodos asincronos devuelven el control inmediatamente, no bloquean el hilo actual. Ten en cuenta que la palabra “sincrono” no significa que el programa tenga que esperar a que el codigo termine antes de continuar. Solo significa que la cola concurrente esperara hasta que la tarea haya terminado antes de ejecutar el siguiente bloque de codigo en la cola.El codigo a continuacion demuestra como usar ejecuciones async y sync.1234567891011121314151617DispatchQueue.global().sync { [1] print(\"A\") DispatchQueue.global().async { for i in 0...5 { print(i) } }}DispatchQueue.global().sync { [2] print(\"B\") DispatchQueue.global().async { for i in 6...10 { print(i) } }} Generalmente, no podemos predecir la salida cuando ejecutamos el codigo anterior porque cada vez que ejecutamos el programa, se imprimiran numerosas salidas diferentes. Solo podemos decir que “B” siempre se imprimira despues de “A” ya que el llamador necesita esperar a que el bloque [1] devuelva el control para poder ejecutar el siguiente bloque [2].Si editamos estos bloques internos a sync, garantizamos que la salida siempre sera A 0 1 2 3 4 5 B 6 7 8 9 10.Tres tipos principales de colasHay tres tipos principales de colas en GCD: Cola principal (Main queue): Las tareas despachadas a esta cola se ejecutaran en el hilo principal, donde se llaman los trabajos relacionados con la interfaz de usuario. La cola principal es una cola serial. Nota importante, el metodo sync no puede ser llamado en el hilo principal porque bloqueara el hilo completamente y llevara a la aplicacion a un deadlock. Por lo tanto, todas las tareas enviadas a la cola principal deben ser enviadas asincronicamente. 1234567override func viewDidLoad() { super.viewDidLoad() let mainQueue = DispatchQueue.main mainQueue.sync { // -&gt; Este codigo llevara a un Deadlock print(\"Inner block called\") }} Colas globales (Global queues): Son colas concurrentes y son compartidas por el sistema. Usamos colas globales para cualquier tarea que no involucre la interfaz de usuario. Por ejemplo, descargar una imagen de internet y luego mostrarla al usuario despues de que se descargue, obtener datos de un servidor, etc.Cuando trabajamos con colas globales, no especificamos la prioridad sino que usamos una Calidad de Servicio (QoS) para ayudar a GCD a determinar la prioridad de las tareas. Es importante tener en cuenta que las aplicaciones usan varios recursos como CPU, memoria, interfaz de red, etc. Por lo tanto, debemos elegir el QoS correcto de la cola para mantener la capacidad de respuesta y eficiencia de la aplicacion. El sistema operativo se basara en el QoS dado para tomar decisiones inteligentes sobre cuando y donde ejecutarlas.Hay cuatro tipos de QoS: User-interactive: Esto indica que las tareas necesitan ejecutarse inmediatamente para mantener la capacidad de respuesta en la interfaz de usuario. Lo usamos para actualizaciones de UI o realizar animaciones. User-initiated: Trabajo que el usuario ha iniciado y requiere resultados inmediatos (en unos segundos o menos). Lo usamos para realizar una accion cuando los usuarios hacen clic en algo en la UI. Utility: Las tareas pueden tomar algun tiempo para completarse y no requieren un resultado inmediato (toma desde unos segundos hasta unos minutos) como descargar datos. Background: Esto representa tareas de las cuales el usuario no esta directamente consciente. Normalmente, lo usamos para obtener datos o cualquier tarea que no requiera interaccion del usuario. Colas personalizadas (Custom queues): Cuando creas una cola personalizada, puedes especificar que tipo de cola es (Serial o concurrente). Por defecto, son colas seriales. DeadlockLa palabra Deadlock se refiere a una situacion en la que un conjunto de diferentes hilos que comparten el mismo recurso estan esperando que los demas liberen el recurso para terminar sus tareas.Cuando trabajamos con GCD, si no entendemos completamente los conceptos de GCD, podemos crear un deadlock en nuestro codigo. Por ejemplo, el codigo a continuacion esta creando un deadlock. 123456789func deadLock() { let myQueue = DispatchQueue(label: \"myLabel\") myQueue.async { myQueue.sync { print(\"Inner block called\") } print(\"Outer block called\") }} Primero, creamos una cola personalizada con una etiqueta dada. Luego despachamos asincronicamente un bloque de codigo que llama a otro bloque de codigo sincronicamente. Esta claro que los bloques interno y externo se estan ejecutando en la misma cola. Por defecto, una cola personalizada es serial, por lo que el bloque interno no comenzara antes de que el bloque externo termine. Por otro lado, el bloque externo no puede terminar porque el bloque interno esta manteniendo el control del hilo actual (sincronicamente). Por lo tanto, ocurre un deadlock.Hay dos formas de solucionar el problema. La primera es cambiar el tipo de la cola a concurrent. Al hacerlo de esta manera, aseguramos que el bloque interno no tenga que esperar a que el bloque externo haya terminado para poder comenzar. 1let myQueue = DispatchQueue(label: \"myLabel\", attributes: .concurrent) La segunda es cambiar el bloque interno a async. Esta vez, el bloque externo no esperara a que el bloque interno se complete para poder comenzar. 123456myQueue.async { myQueue.async { print(\"Inner block called\") } print(\"outer block called\")} Hay una recomendacion en el documento de Apple sobre Deadlock en el capitulo de Dispatch queues y seguridad de hilos&quot;No llames a la funcion dispatch_sync desde una tarea que se esta ejecutando en la misma cola que pasas a tu llamada de funcion. Hacerlo causara un deadlock en la cola. Si necesitas despachar a la cola actual, hazlo asincronicamente usando la funcion dispatch_async.&quot; LivelockHay otro concepto de bloqueo ademas del deadlock llamado Livelock. A diferencia del deadlock, el livelock no bloquea el hilo actual. Simplemente no pueden avanzar mas. O mas precisamente, livelock es “una situacion en la que dos o mas procesos cambian continuamente sus estados en respuesta a cambios en los otros procesos sin hacer ningun trabajo util”.Hay un buen ejemplo humano de livelock en StackOverflowUn esposo y una esposa estan tratando de comer sopa, pero solo tienen una cuchara entre ellos. Cada conyuge es demasiado educado y pasara la cuchara si el otro aun no ha comido.Hay otros tipos de bloqueos cuando trabajamos con concurrencia como recursos limitados, exclusion mutua, inanicion. Debido al alcance de esta publicacion, no explicare todos ellos aqui. Por favor consulta otras fuentes para mas detalles. Notas importantes En iPhones, las operaciones discrecionales y de fondo, incluyendo redes, se pausan cuando el Modo de Bajo Consumo esta habilitado. Cuando usas Xcode 9 con iOS 11, se emitira una advertencia cuando se accede a un objeto de interfaz de usuario desde un hilo que no es el principal. La prioridad user interactive deberia ser rara en tu programa. Si todo es de alta prioridad, nada lo es. ConclusionEn esta publicacion, te mostre algunos puntos interesantes sobre GCD en Swift. En la proxima publicacion, discutiremos mas sobre otros conceptos avanzados de programacion concurrente como DispatchGroup, Operation Queue, Group Tasks, etc. Luego implementaremos un pequeno proyecto para mezclarlos todos juntos.Si tienes algun comentario, no dudes en contactarme. Referencias[1] Documentacion de Apple: Guia de Programacion de Concurrencia[2] iOS 8 Swift Programming Cookbook por O’Reilly, Cap.7: Concurrencia y Multitarea.","link":"/es/posts/Grand-Central-Dispatch-in-Swift/index.html"},{"title":"Reseña del Libro: Clean Code","text":"Este es un libro que me regaló hace mucho tiempo un antiguo colega, que también es uno de mis amigos cercanos. Este es uno de los libros de software que más me gustan pero que no tuve oportunidad de comprar cuando era estudiante. IntroducciónSobre el autor, Robert C. Martin, es considerado uno de los ingenieros más veteranos en la industria del software. Tiene muchos años de experiencia trabajando en el campo del software en diversas posiciones, desde desarrollador, gerente, hasta CEO. Es conocido principalmente por escribir guías de software que describen principios de software, patrones de software y prácticas de software. Ha publicado muchos libros como Clean Coder, Clean Code, Clean Architecture, etc. Clean Code es uno de los libros de software que muchos ingenieros de software en el mundo recomiendan leer.El autor dijo que *”Con el tiempo, el desorden se vuelve tan grande, tan profundo y tan alto, que no pueden limpiarlo”*. Necesitamos leer y pensar mucho antes de escribir código. Debemos evitar escribir código con prisa. Apresurarse a escribir código malo llevará a gastar más tiempo después en mantenimiento. Clean Code se enfoca en los aspectos técnicos: instruye al programador sobre cómo organizar el código y escribir código limpio. No aprenderás ningún framework nuevo, pero te proporcionará un conjunto fundamental de reglas de estilo de codificación. Vale la pena leer el libro. El contenido del libroEl contenido del libro se divide en tres partes: Los primeros capítulos explicarán los principios, patrones y prácticas para escribir código limpio. La segunda parte consiste en muchos casos de estudio, cada caso de estudio es un ejercicio de transformación de código que tiene algunos problemas en código que tiene menos problemas. La última parte es el desenlace. ¿Por qué código limpio?Bjarne Stroustrup (Inventor de C++): Elegante, Eficiente.Grady Booch (Autor de Object Oriented Analysis): Legibilidad.David Thomas (Fundador de OTI): Fácil de mejorar por otras personas.Warn Cunningham (Inventor de Wiki): Hacer que el lenguaje parezca simple.Yo: Para poder recordar lo que escribiste hace un mes. Criterios de evaluación de código limpioGeneral No te repitas: La duplicación puede ser la raíz de todo mal en el software. Muchos principios y prácticas han sido creados con el propósito de controlarla o eliminarla. A veces podemos usar el patrón Template method para eliminar la duplicación de nivel superior. Nombrado de variables, métodos, argumentos, clases, archivos El nombre de una variable, función o clase debe responder la pregunta de por qué existe, qué hace y cómo se usa. Usa nombres que se puedan buscar. Las clases y objetos deben tener nombres de sustantivos o frases nominales. Los métodos deben ser un verbo o frase verbal. Inconsistencia: Ten cuidado con las convenciones que elijas, y una vez elegidas, continúa siguiéndolas. Comentarios Los comentarios deben decir cosas que el código no puede decir por sí mismo: Explica la idea en el código, si no se puede, entonces escribe comentarios. Los comentarios deben reservarse para notas técnicas sobre el código y el diseño. Usa gramática y puntuación correctas. No comentes código, elimínalo. Funciones Las funciones deben ser pequeñas: Menos de 100 líneas. Esto hace que la función sea más fácil de leer y entender. Las funciones deben hacer solo una cosa. Las funciones deben tener un número pequeño de argumentos (Menos de 4 argumentos). No pases valores booleanos como argumentos. Las funciones que nunca se llaman deben eliminarse. Separa el procesamiento de errores del procesamiento normal. Encapsula los condicionales. Manejo de errores El manejo de errores es importante, pero si oscurece la lógica, está mal. No retornes Null: Considera lanzar una excepción o retornar un objeto SPECIAL CASE en su lugar. Si codificas de esta manera, minimizarás la posibilidad de NullPointerException y tu código será más limpio. No pases Null como argumentos. Límites Envolviendo APIs de terceros: Minimiza tu dependencia de ellas. Cuando hay nuevas versiones del paquete de terceros, debemos ejecutar las pruebas para ver si hay diferencias de comportamiento. Evita que demasiado de tu código conozca los detalles particulares de terceros: Usa un Adapter para manejarlo. Clases Una clase debe ser pequeña: La medimos por responsabilidades. (Lo conocemos como el principio SRP) El código debe colocarse donde un lector naturalmente esperaría encontrarlo. (¿Dónde debería ir la constante PI? ¿Debería estar en la clase Math? ¿O quizás en la clase Circle?). Ten cuidado al crear métodos estáticos. Un método estático no opera en una sola instancia. Todos los datos que el método usa provienen de sus argumentos, y no de ninguna instancia de esta clase. Además, asegúrate de que no haya posibilidad de que quieras que se comporte polimórficamente. Concurrencia Hay algunas definiciones básicas que debemos conocer cuando hablamos de concurrencia y hilos: Recursos limitados, exclusión mutua, inanición, deadlock y livelock. La concurrencia no siempre mejora el rendimiento. A veces incurre en cierta sobrecarga y los errores que provienen de ella usualmente no son repetibles. Limita el acceso a los datos que se comparten entre más de dos hilos. Usa copias de datos si hay oportunidad. Mantén las secciones sincronizadas lo más pequeñas posible porque los bloqueos crean retrasos y agregan sobrecarga. Son costosos. El código multihilo se comporta de manera diferente en diferentes entornos: Ejecuta las pruebas en cada entorno de despliegue potencial. Lo que me gusta El conocimiento en este libro es útil. Totalmente puede aplicarse a la realidad. Después de leer el libro, mi estilo de codificación ha cambiado mucho. El libro es fácil de entender y seguir. Leerás mucho código, tendrás desafíos para pensar qué está bien de ese código y qué está mal. Después de cada capítulo, el autor resume las ideas principales. Me ayuda a recordar los puntos principales por más tiempo. Lo que no me gusta El autor usa código Java como ejemplos en el libro. A veces para entender las ideas del autor tenemos que investigar más sobre conceptos de Java. (Spring framework, JUnit framework, tipos de excepciones, etc.) Las ideas del autor están duplicadas en algunos capítulos. En generalPor supuesto, en el alcance del artículo, no puedo describir completamente las ideas del autor. Este es un buen libro que recomiendo, especialmente para desarrolladores junior que se graduaron recientemente. Ya que en la escuela, los profesores pueden no enseñarnos cómo se llama código limpio, tus estilos de codificación no son evaluados. De hecho, tu código puede funcionar correctamente pero no ser limpio.Si puedes permitirte comprar este libro para que puedas consultarlo cuando lo necesites, será muy útil.“Estás leyendo este libro por dos razones. Primero, eres un programador. Segundo, quieres ser un mejor programador.”","link":"/es/posts/Review-Book-Clean-Code/index.html"},{"title":"React Native en Mi Mundo Real","text":"React Native fue presentado en enero de 2015 en React.js Con: La primera vista previa pública. En marzo de 2015, React Native se abre y está disponible en Github. Después de su lanzamiento, React Native rápidamente se volvió popular y es constantemente actualizado por miles de desarrolladores en el mundo. Actualmente, React Native es uno de los repositorios con más estrellas en Github. ThreadsRendimientoMódulos nativos123$ react-native run-ios --simulator 'iPad Pro (9.7 inch)'$ react-native run-ios --device 'qa'$ react-native run-ios --configuration Release --device 'qa' 123456789#import &lt;React/RCTBridgeModule.h&gt;@interface RCT_EXTERN_MODULE(SDKWrapper, NSObject)RCT_EXTERN_METHOD(supportedEvents)RCT_EXTERN_METHOD(startScanning)RCT_EXTERN_METHOD(stopScanning)RCT_EXTERN_METHOD(playAnimation)RCT_EXTERN_METHOD(connectToDevice:(NSString *)serialNumber:(RCTPromiseResolveBlock)resolve:(RCTPromiseRejectBlock)reject) //PromiseRCT_EXTERN_METHOD(disConnectToDevice:(RCTPromiseResolveBlock)resolve:(RCTPromiseRejectBlock)reject) //Promise@end 123456789101112public class SDKWrapper extends ReactContextBaseJavaModule{ public SDKWrapper(ReactApplicationContext reactContext) { super(reactContext); } @Override public String getName() { return \"SDKWrapper\"; } @ReactMethod public void startScanning() {. . .}} 123456import {NativeModules} from 'react-native';const {SDKWrapper} = NativeModules;....SDKWrapper.doSomething();SDKWrapper.saySomething();.... Ventajas y desventajasVentajas Rendimiento nativo Aprende una vez, ejecuta en todas partes Flex box Hot reloading Detección de plataforma en código Desventajas No es estable, difícil de mantener al día Falta de documentación Thread dedicado único para el dispositivo Llamadas a callback Conclusión","link":"/es/posts/React-Native-In-My-Real-World/index.html"},{"title":"Desempeñar Roles de Central y Periférico con CoreBluetooth","text":"IntroducciónComo mencioné en la publicación anterior, CoreBluetooth nos permite crear aplicaciones que pueden comunicarse con dispositivos BLE como monitores de frecuencia cardíaca, sensores corporales, rastreadores o dispositivos híbridos.Hay dos roles a desempeñar en los conceptos de CoreBluetooth: Central y periférico. Central: Obtener datos de los periféricos. Periférico: Publicar datos para ser accedidos por un central. Podemos hacer que un dispositivo Bluetooth actúe como periférico desde el lado del firmware o del software. En esta publicación, te mostraré cómo crear un periférico usando nuestros propios identificadores. También usaremos otro dispositivo, como central, para conectar y explorar nuestros servicios. Comencemos. Configurar un PeriféricoPara crear un servicio, necesitas tener un identificador único llamado UUID. Un servicio estándar tiene un UUID de 16 bits y un servicio personalizado tiene un UUID de 128 bits. Adelante, escribe el siguiente comando para generar un uuid único desde tu terminal. 1$ uuidgen Como puedes ver, el comando devuelve un uuid en formato hexadecimal (128 bit): A56E51F3-AFFE-4E14-87A2-54927B22354C. Usaremos esta cadena para configurar nuestro propio servicio. 123456789101112131415161718192021class ViewController: UIViewController, CBPeripheralManagerDelegate { let kServiceUUID = \"A56E51F3-AFFE-4E14-87A2-54927B22354C\" // Other properties ... override func viewDidAppear(_ animated: Bool) { super.viewDidAppear(animated) peripheralManager = CBPeripheralManager(delegate: self, queue: nil) [1] } func peripheralManagerDidUpdateState(_ peripheral: CBPeripheralManager) { print(\"peripheralManagerDidUpdateState \\(peripheral.state.rawValue)\") if peripheral.state == .poweredOn { let serviceUUID = CBUUID(string: kServiceUUID) [2] self.service = CBMutableService(type: serviceUUID, primary: true) [3] } // Other code }} Esto es lo que hacen estos métodos: [1] Creas una instancia de la clase PeripheralManager, que actuará como periférico en nuestro ejemplo. Ten en cuenta que hay un parámetro queue en el constructor. Los eventos del rol de periférico se despacharán en la cola proporcionada. Si pasamos nil, se usará la cola principal. [2] Para configurar un servicio, necesitamos crear una instancia de la clase CBUUID. El constructor recibe un uuid único como parámetro, que diferencia nuestro servicio de otros. [3] Creamos una instancia de la clase CBMutableService. El constructor recibe dos parámetros: El primero es nuestro uuid único, que se definió en [2]; el segundo parámetro indica si nuestro servicio es primario o no. Si no lo es, nuestro servicio no será encontrado cuando la aplicación esté en segundo plano. Ten en cuenta que puedes agregar tantos servicios como quieras. Para simplificar, solo creo un servicio en esta publicación.OK, pasemos al siguiente paso. Definiremos características para nuestro servicio usando el siguiente código. 12345let characteristic = CBMutableCharacteristic.init( type: CBUUID(string: kCharacteristicUUID), [1] properties: [.read, .write, .notify], [2] value: nil, [3] permissions: [CBAttributePermissions.readable, CBAttributePermissions.writeable]) [4] Esto es lo que está pasando: [1] Como un servicio, una característica también necesita un uuid único para diferenciarse de otras. [2] Configuramos las propiedades para la característica. Hay una variedad de permisos de características, pero a menudo uso algunos de ellos: Read: Usado para características que no cambian muy a menudo, ej. número de versión. Write: Modificar el valor de la característica. Indicate y notify: El periférico notifica continuamente el valor actualizado de la característica al central. El central no tiene que preguntar constantemente por él. IndicateEncryptionRequired: Solo los dispositivos de confianza pueden habilitar indicaciones del valor de la característica.Para otras propiedades, consulta el documento de Apple [3] El valor de la característica. Nota importante: Si proporcionas un valor para una característica, la característica debe ser de solo lectura. De lo contrario, obtendrás una excepción en tiempo de ejecución como esta.2018-03-03 12:48:32.938615+0700 Peripheral[4238:3046876] *** Terminating app due to uncaught exception 'NSInternalInconsistencyException', reason: 'Characteristics with cached values must be read-only'Por lo tanto, debes especificar el valor como nil si esperas que el valor cambie durante el tiempo de vida del servicio publicado (write). [4] Todas las características deben incluir el permiso “readable” para que los centrales puedan leer su valor. Si queremos que un central pueda enviar comandos a los periféricos, necesitamos establecer el permiso “writeable” a la característica. Ahora tenemos un servicio y una característica. Vamos a publicarlo. 1234self.service?.characteristics = []self.service?.characteristics?.append(characteristic)self.peripheralManager.add(self.service!) Después de agregar un servicio al peripheral manager, se llamará al método delegado peripheralManager(_ peripheral: CBPeripheralManager, didAdd service: CBService, error: Error?). 1234567func peripheralManager(_ peripheral: CBPeripheralManager, didAdd service: CBService, error: Error?) { if let error = error { print(\"Add service failed: \\(error.localizedDescription)\") return } print(\"Add service succeeded\")} Ya casi terminamos, solo un paso más: Comenzar a hacer advertising del periférico para que pueda ser encontrado por otros centrales. 12peripheralManager.startAdvertising([CBAdvertisementDataLocalNameKey: \"TiTan\", CBAdvertisementDataServiceUUIDsKey : [self.service!.uuid]]) Después del advertising, se activará el método delegado peripheralManagerDidStartAdvertising para indicar si el periférico hizo advertising exitosamente o no. 1234567func peripheralManagerDidStartAdvertising(_ peripheral: CBPeripheralManager, error: Error?) { if let error = error { print(\"Start advertising failed: \\(error.localizedDescription)\") return } print(\"Start advertising succeeded\")} En este punto, ya hemos definido y publicado nuestro(s) servicio(s). A partir de ahora, el periférico puede ser descubierto por centrales a través de CoreBluetooth. Configurar un CentralPrimero, necesitamos crear una instancia de la clase CBCentralManager. 12345678class ViewController: UIViewController, CBCentralManagerDelegate, UITableViewDelegate, UITableViewDataSource, CBPeripheralDelegate { override func viewDidLoad() { super.viewDidLoad() // Do any additional setup after loading the view, typically from a nib. centralManager = CBCentralManager(delegate: self, queue: nil) ... }} Como un peripheral manager, hay un parámetro queue en el constructor. Los eventos del rol central se despacharán en la cola proporcionada. Si pasamos nil, se usará la cola principal.Necesitamos esperar a que el central manager esté listo, luego comenzaremos a escanear dispositivos cercanos. 1234567func centralManagerDidUpdateState(_ central: CBCentralManager) { print(\"peripheralManagerDidUpdateState \\(central.state.rawValue)\") if central.state == .poweredOn { self.centralManager.scanForPeripherals(withServices: nil, options: nil) }} Si encuentra un periférico, se llamará al método delegado func centralManager(_ central: CBCentralManager, didDiscover peripheral: CBPeripheral, advertisementData: [String : Any], rssi RSSI: NSNumber). 123456789101112func centralManager(_ central: CBCentralManager, didDiscover peripheral: CBPeripheral, advertisementData: [String : Any], rssi RSSI: NSNumber) { if let name = peripheral.name { if (!checkIfExisted(name)) { let tupleDeviceInfo = (device: peripheral, rssi: RSSI) self.scannedDevices.append(tupleDeviceInfo) } DispatchQueue.main.async { self.tbvScannedDevices.reloadData() } }} Dentro del método, verificaremos si el periférico es válido, después lo agregaremos a la lista actual, luego recargaremos la table view. Ten en cuenta que el valor RSSI representa la intensidad de la señal de transmisión. Podemos estimar la distancia actual entre el central y el periférico basándonos en el valor. Cuanto mayor sea el valor, más cerca está el dispositivo.Compila y ejecuta el proyecto, verás la lista de dispositivos descubiertos así. Ahora, conectémonos a nuestro periférico (El dispositivo “Titan”) haciendo clic en la fila correspondiente.Una vez que se realiza una conexión exitosamente, se llamará al método delegado func centralManager(_ central: CBCentralManager, didConnect peripheral: CBPeripheral). De lo contrario, se activará el método centralManager(_ central: CBCentralManager, didFailToConnect peripheral: CBPeripheral, error: Error?). 123456func centralManager(_ central: CBCentralManager, didConnect peripheral: CBPeripheral) { self.centralManager.stopScan() peripheral.delegate = self self.peripheral = peripheral self.peripheral?.discoverServices(nil) [1]} 123centralManager(_ central: CBCentralManager, didFailToConnect peripheral: CBPeripheral, error: Error?) { // Fail to connect peripheral} Ten en cuenta que después de conectarse al periférico, necesitamos descubrir los servicios del periférico para usarlo ([1]).El método delegado func peripheral(_ peripheral: CBPeripheral, didDiscoverServices error: Error?) se llamará después de descubrir los servicios. 1234567891011func peripheral(_ peripheral: CBPeripheral, didDiscoverServices error: Error?) { if let err = error { print(\"didDiscoverServices fail \\(err.localizedDescription)\") return } // [1] Start discovering all chars for service in (peripheral.services)! { peripheral.discoverCharacteristics(nil, for: service) }} Aún no hemos terminado =.= Después de descubrir los servicios, también necesitamos descubrir todas las características de los servicios en [1].Como otros, el método func peripheral(_ peripheral: CBPeripheral, didDiscoverCharacteristicsFor service: CBService, error: Error?) se llamará después de descubrir las características de un servicio. 123456789101112func peripheral(_ peripheral: CBPeripheral, didDiscoverCharacteristicsFor service: CBService, error: Error?) { if let error = error { print(\"didDiscoverCharacteristicsFor Error \\(error.localizedDescription)\") return } for char in service.characteristics! { if char.properties.contains(.notify) { peripheral.setNotifyValue(true, for: char) [1] } ... }} Como puedes ver, necesitamos establecer notify a la característica que contiene la propiedad notify para recibir actualizaciones de ella. [1]Finalmente, hemos terminado de configurar una conexión entre el periférico y el central. Ahora exploremos los datos. Leer y escribir datos desde el periféricoTienes que especificar qué característica quieres leer. 1self.peripheral?.readValue(for: discovererChars[kCharacteristicUUID]!) Desde el lado del periférico, recibirás una solicitud de lectura dentro del método 12345func peripheralManager(_ peripheral: CBPeripheralManager, didReceiveRead request: CBATTRequest) { print(\"Read request\") request.value = myValue.data(using: .utf8) peripheral.respond(to: request, withResult: .success)} Después de que el periférico responde a las solicitudes de lectura, se llamará al método delegado func peripheral(_ peripheral: CBPeripheral, didUpdateValueFor characteristic: CBCharacteristic, error: Error?) desde el lado del central. 1234 func peripheral(_ peripheral: CBPeripheral, didUpdateValueFor characteristic: CBCharacteristic, error: Error?) { let value = String.init(data: characteristic.value!, encoding: .utf8)! ...} Si el valor se recupera exitosamente, puedes acceder a él a través de la propiedad value de la característica, como arriba.A veces queremos escribir el valor de una característica, que es escribible. Podemos escribir el valor llamando al método writeValue del periférico así. 1self.peripheral?.writeValue(data, for: discovererChars[kCharacteristicUUID]!, type: .withResponse) Hay un argumento llamado type, especificas qué tipo de escritura quieres realizar. En el ejemplo anterior, el tipo de escritura es .withResponse, que instruye al periférico a informar a tu aplicación si la escritura tiene éxito o no.Desde el lado del periférico, recibirás una solicitud de escritura dentro del método 1234func peripheralManager(_ peripheral: CBPeripheralManager, didReceiveWrite requests: [CBATTRequest]) { print(\"Write request\") peripheral.respond(to: requests[0], withResult: .success)} Después de que la solicitud de escritura recibe la respuesta, se llamará al método peripheral(_ peripheral: CBPeripheral, didWriteValueFor characteristic: CBCharacteristic, error: Error?). 12345func peripheral(_ peripheral: CBPeripheral, didWriteValueFor characteristic: CBCharacteristic, error: Error?) { if let err = error { print(\"Did write value with error \\(err.localizedDescription)\") }} Valores de características encriptadosA veces queremos asegurar datos sensibles. Podemos configurar las propiedades y permisos de características apropiados. Algo como esto 12345let encryptedChar = CBMutableCharacteristic.init( type: CBUUID(string: kCharacteristicUUID), properties: [.read, .notify, .notifyEncryptionRequired], value: nil, permissions: [.readable]) De esta manera, aseguramos que solo los dispositivos de confianza tengan permisos para acceder a estos datos.En mi ejemplo, una vez que se realiza una conexión, CoreBluetooth intenta emparejar el periférico (iPad) con el central (iPhone) para crear una conexión segura. Ambos dispositivos recibirán una alerta indicando que el otro dispositivo desea emparejarse. Después del emparejamiento, el central puede acceder a los valores de características encriptados del periférico. Algunas notas importantes El modelo cliente-servidor de BLE se llama modelo de publicar y suscribir. El periférico solo consume energía cuando está haciendo advertising de sus servicios, o recibiendo o respondiendo a la solicitud de un central. Puedes pasar una lista de UUIDs de servicios dentro del método scanForPeripherals. Cuando especificas una lista de UUIDs de servicios, el central manager devuelve solo periféricos que hacen advertising de esos servicios, permitiéndote escanear solo dispositivos que te puedan interesar. Necesitas otorgar permisos para permitir que tu aplicación use accesorios Bluetooth LE, y actúe como un accesorio Bluetooth LE para los lados del periférico. (Ve a proyecto -&gt; Capabilities para configurar). También necesitas agregar una propiedad de información más a tu info.plist, agreguemos una entrada con la clave Privacy - Bluetooth Peripheral Usage Description y el valor App communicates using CoreBluetooth (O lo que quieras describir). Un vistazo rápido a mi aplicaciónProbemos un ejercicio ligero de mi ejemplo. Resumir el flujo de programación para BLEPara resumir el flujo de trabajo general de programación de CoreBluetooth en iOS, por favor mira la imagen a continuación. Reflexiones finalesEn esta publicación, te guié sobre cómo usar CoreBluetooth para crear un periférico, así como cómo crear un central para conectar y obtener datos de un periférico. En el futuro, podemos ver que todos los dispositivos a nuestro alrededor están conectados entre sí a través de Bluetooth, hacia el mundo IoT.Puedes descargar el proyecto completo del central aquí o el del periférico aquí.Si tienes alguna pregunta o comentario, no dudes en dejarlo en mi publicación. Cualquier comentario es bienvenido. Referencias[1] Core Bluetooth Programming Guide de Apple","link":"/es/posts/Play-Central-And-Peripheral-Roles-With-CoreBluetooth/index.html"},{"title":"Notificaciones Remotas","text":"Las notificaciones push permiten que tu aplicación llegue a los usuarios con más frecuencia, y también pueden realizar algunas tareas. En este tutorial, aprenderemos cómo configurar aplicaciones para recibir notificaciones remotas, mostrar contenido y luego realizar algunas acciones cuando el usuario presiona sobre ellas.Comencemos. APNsAPNs, que significa Apple Push Notification service, es un servicio que entrega mensajes a tus aplicaciones. La información de notificación enviada puede incluir badges, sonidos, contenido personalizado o alertas de texto personalizadas. Ten en cuenta que necesitas una cuenta de desarrollador de pago para poder configurar tu aplicación con la capacidad de Push Notification. También necesitas un dispositivo físico para probar si quieres lanzar notificaciones remotas ya que las notificaciones push no están disponibles en el simulador. Solo puedes simular notificaciones en simuladores. ConfiguraciónPrimero, necesitas agregar el entitlement de notificaciones push a tu proyecto,Dirígete a Project Setting &gt; Signing Capabilities &gt; + Capability &gt; Agrega Push Notification Si quieres enviar notificaciones a dispositivos reales, necesitas hacer algunos pasos extra para tener una clave de notificación: Inicia sesión en Apple developer En la sección Keys &gt; Agregar nuevas claves &gt; Ingresa el nombre de tu clave &gt; Selecciona Apple Push Notifications service (APNs) &gt; Continuar. Descarga la clave y guárdala en cualquier ubicación donde quieras guardar esta clave. Nota que el nombre del archivo de la clave tiene un patrón AuthKey_[Key ID].p8 Solicitar permisos del usuarioA continuación, la aplicación necesita pedir al usuario permiso para mostrar notificaciones.Abre el archivo AppDelegate.swift y agrega el siguiente código 123456789101112131415161718192021222324func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -&gt; Bool { // The rest omitted self.registerPushNotifications() ...}func registerPushNotifications() { UNUserNotificationCenter.current() .requestAuthorization(options: [.alert, .sound, .badge]) { granted, error in guard granted else { return } // If the user allows showing notification, then register the device to receive a push notification self.registerForRemoteNotification() }}func registerForRemoteNotification() { UNUserNotificationCenter.current().getNotificationSettings { settings in guard settings.authorizationStatus == .authorized else { return } DispatchQueue.main.async { UIApplication.shared.registerForRemoteNotifications() } }} Si el proceso se completa exitosamente, se llamará al callback didRegisterForRemoteNotificationsWithDeviceToken: incluyendo tu token de dispositivo (Un valor único para identificar tu dispositivo, nota que es diferente cada vez que reinstalas la aplicación).Si ocurre un error, se activará didFailToRegisterForRemoteNotificationsWithError:. 12345678func application(_ application: UIApplication, didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data) { print(\"Did register remote notification successfully \\(deviceToken.hexadecimalString)\")}func application(_ application: UIApplication, didFailToRegisterForRemoteNotificationsWithError error: Error) { print(\"Did failed register remote notification \\(error.localizedDescription)\") // e.g Did failed register remote notification no valid \"aps-environment\" entitlement string found for application} Nota que Alert, sound y badge es la combinación común al solicitar autorización.Hay otras opciones que puedes encontrar en la documentación de Apple.Otra advertencia es que si ejecutas tu aplicación en un simulador, obtendrás el evento didFailToRegisterForRemoteNotificationsWithError ya que las notificaciones remotas no son soportadas en simuladores. Manejar notificaciones mientras la aplicación está en primer planoDespués de registrarte para notificaciones remotas exitosamente, si quieres manejar notificaciones mientras tu aplicación está en primer plano, necesitas implementar userNotificationCenter:willPresent:withCompletionHandler en tu clase. 1234public func userNotificationCenter(_ center: UNUserNotificationCenter, willPresent notification: UNNotification, withCompletionHandler completionHandler: @escaping (UNNotificationPresentationOptions) -&gt; Void) { ... completionHandler([.alert, .sound, .badge])} Si no implementas esta función, las notificaciones no se mostrarán si tu aplicación está en primer plano. Es hora de enviar notificacionesHay 2 formas de probar tu implementación. Si no tienes un dispositivo físico, no te preocupes, aún puedes simular notificaciones de una manera simple, o puedes enviar notificaciones reales a dispositivos reales. Simular APNsCrea un archivo con extensión .apns. ej. SimulateNoti.apns, luego copia tu contenido a este archivo 1234567891011{ \"Simulator Target Bundle\": \"YOUR_APP_BUNDLE_ID\", &lt;--- CAMBIA A TU APP BUNDLE ID \"aps\": { \"alert\": { \"title\" : \"Your title\", \"subtitle\" : \"Your subtitle\", \"body\" : \"Your body\" }, \"sound\": \"default\" }} Arrastrar y soltar esto en el simulador objetivo presentará la notificación Enviar a dispositivos realesPrimero, necesitas una herramienta cliente de notificaciones remotas que te ayude a enviar una notificación. Una gran herramienta para probar es Push notification tester. Navega a este sitio web para descargar y lanzar la aplicación. Después de lanzar la aplicación exitosamente, Cambia a la pestaña TOKEN en la sección Authentication. Presiona SELECT P8 y selecciona tu archivo P8 que descargaste del paso anterior, luego completa el resto de la información KEY ID, TEAM ID. El KEY ID es parte del nombre del archivo P8 AuthKey_[Key ID].p8. Para el TEAM ID, puedes encontrarlo en tu página de membresía. En la sección Body, completa tu bundle Id de la aplicación (ej. com.example.yourapp) y tu token de dispositivo que se generó del callback didRegisterForRemoteNotificationsWithDeviceToken:. Compón tu contenido. Aquí hay un cuerpo común para notificaciones push.ej. 12345678910{ \"aps\": { \"alert\": { \"title\" : \"Your title\", \"subtitle\" : \"Your subtitle\", \"body\" : \"Your body\" }, \"sound\": \"default\" }} Para todas las opciones disponibles en una notificación, por favor consulta la documentación de Apple: generating_a_remote_notification Presiona el botón Send para entregar tu notificación al dispositivo seleccionado. Aparecerá un mensaje en la parte superior del botón para mostrar el resultado. Notificación silenciosaDesde mi perspectiva, la característica más interesante de las notificaciones Push es la “Notificación silenciosa”, que puede despertar tu aplicación para realizar algunas tareas mientras tu aplicación está en segundo plano, incluso si tu aplicación fue terminada por el usuario. Muchos ingenieros están buscando una manera de mantener su aplicación viva en segundo plano tanto como puedan. Hay varias formas de lograrlo usando restauración y preservación, core location, iBeacon. La notificación push silenciosa es una de ellas. Tendré otra publicación hablando sobre notificación silenciosa y mi experimento para que tengamos más detalles e información. Para enviar una notificación silenciosa, simplemente cambia el contenido JSON a 12345{ \"aps\": { \"content-available\": 1 }} Después de presionar el botón Send, no hay notificación mostrándose en tu aplicación. Reflexión finalAl usar notificaciones push sabiamente, puedes involucrar a los usuarios para que vuelvan a tu aplicación nuevamente. Sin embargo, si abusas de las notificaciones, puede llevar a efectos negativos como que los usuarios desactiven los permisos de tu aplicación o califiquen tu aplicación con 1* con quejas en la tienda (Igual que nuestra historia en el pasado :)).Las notificaciones no solo ayudan a entregar tus mensajes a los usuarios sino que también pueden usarse para otros propósitos avanzados como despertar tu aplicación usando notificaciones silenciosas. En la próxima publicación, tendremos una mirada profunda a esta increíble característica.Si tienes alguna duda o comentario, házmelo saber.¡Feliz de compartir! Referencias Apple doc: Generating a remote notification Raywenderlich: Push notification tutorial","link":"/es/posts/Remote-Notification/index.html"},{"title":"Reseña del libro: Building Applications With iBeacon","text":"En la publicación anterior, básicamente te di un vistazo rápido a iBeacon - Un protocolo Bluetooth construido sobre BLE por Apple, e hice una demostración simple de cómo iBeacon puede despertar una aplicación después de ser terminada por el usuario. Sin embargo, no mencioné otros conceptos fundamentales en Beacon, tampoco te di una visión profunda de las ventajas y desventajas de esta poderosa tecnología.Hoy, me gustaría presentarte un buen libro que proporciona un conocimiento sólido en el campo de Beacon, especialmente iBeacon: Building Applications With iBeacon publicado por O’Reilly.Después de leer este libro, te aseguro que obtendrás un buen conocimiento en el campo de iBeacon y tu mente estará más abierta a las próximas ideas.¡Empecemos! Contenido principalEl libro se enfoca principalmente en desarrolladores que buscan una forma eficiente de integrar el protocolo beacon a sus aplicaciones. Para usar el libro eficientemente, te recomiendo que tengas algún conocimiento previo de BLE ya que iBeacon está construido sobre BLE.Al principio, el libro describe una breve historia de las tecnologías de proximidad en particular. También explica por qué y cuándo usarlas en algunas circunstancias específicas.Las dos principales razones para usar iBeacon son, primero y ante todo, las tecnologías GPS luchan por hacer mejor que unos pocos metros, y GPS frecuentemente está limitado en interiores. Los iBeacons pueden permitir una determinación dentro de centímetros. La segunda es los iBeacons ofrecen micro-localización de alta precisión, junto con la capacidad de actuar según lo que está cerca de un dispositivo móvil. Ninguna otra tecnología ofrece todavía esa combinación.Para convencer al lector, el libro compara GPS versus Beacon, en otras palabras ubicación versus proximidad; dando algunas limitaciones de la tecnología GPS actual, el escritor muestra algunas áreas en las que Beacon es muy superior a GPS.A continuación, el libro explica cómo funciona el protocolo Beacon internamente; te presenta los términos fundamentales y cómo interactúan entre sí.Finalmente, en algunos capítulos, el libro te guía sobre cómo configurar tus propios beacons en Mac OS, dispositivos móviles o computadoras pequeñas como Ras. Pi o Arduino. Conceptos clave La relación entre iBeacons, beacons genéricos, beacons BLE y dispositivos BLE se describe a continuación Los iBeacons son un subconjunto de la especificación de beacons BLE. Todos los iBeacons son beacons BLE, y todos los beacons BLE son dispositivos BLE. Sin embargo, hay beacons que no están basados en Bluetooth, y hay dispositivos BLE que no son beacons. Un iBeacon necesita ser configurado con su tupla numérica identificadora (UUID, número major y número minor).Identificador de Beacon = UUID + Major + Minor. En Core Location, una región es un espacio en el que se recibe una combinación específica de UUID, número major y número minor. Core Location soporta tres tipos de filtrado de una región: Solo UUID: cualquier iBeacon instalado que coincida con el uuid. UUID más número major: Como la opción de solo UUID, es probable que coincida con varios iBeacons, muy probablemente instalados en una ubicación particular. UUID más números major y minor: Esta opción coincidirá solo con un iBeacon específico. El siguiente código ilustra cómo definir esas tres regiones en Swift, respectivamente.123let region1 = CLBeaconRegion(uuid: \"uuid1\", identifier: \"Your region's name 1\")let region2 = CLBeaconRegion(proximityUUID: \"uuid2\", major: 1, identifier: \"Your region's name 2\")let region3 = CLBeaconRegion(proximityUUID: \"uuid3\", major: 1, minor: 0, identifier: \"Your region's name 3\") iOS e iBeacon: Apple proporciona dos acciones principales cuando se trabaja con iBeaconMonitoreoEl monitoreo proporciona una capacidad de suscripción a la aparición de una región, que se combina con uno o más beacons.Un evento in y out se disparará cuando un dispositivo entre o salga de una región, respectivamente. Se realiza tanto en primer plano como en segundo plano en iOS, se usa para determinar cuándo un dispositivo ha entrado o salido del área de cobertura de un iBeacon. Uno de los mayores beneficios de usar beacon es que las regiones son rastreadas por el sistema operativo, no por la aplicación. Incluso cuando las aplicaciones no están ejecutándose (terminadas por el SO o forzadas a cerrar por el usuario), el SO puede relanzar la app para manejar los eventos. Después de volver al segundo plano, la app tiene unos segundos para ejecutar sus tareas (Alrededor de 10s). El administrador de ubicación define un método para didEnterRegion, que se llama cuando un dispositivo cruza el límite para entrar a una región El administrador de ubicación define un método para didExitRegion, que se llama cuando un dispositivo cruza el límite para salir de una región. Limitaciones del monitoreo iOS solo puede monitorear hasta 20 regiones en una sola aplicación como se describe en la documentación de Apple Las regiones son un recurso del sistema compartido, y el número total de regiones disponibles en todo el sistema es limitado. Por esta razón, Core Location limita a 20 el número de regiones que pueden ser monitoreadas simultáneamente por una sola app” Apple doc. El sistema también tarda algún tiempo en disparar el evento de salida, en la práctica es alrededor de 30 ~ 40s. RangingUsa sus transmisiones para estimar la distancia desde un dispositivo móvil hasta un beacon. Un uso común de las operaciones de ranging es determinar qué iBeacon está más cerca de esta área.El administrador de ubicación disparará el método didRangeBeacons después de hacer ranging exitosamente, una lista de iBeacons que tienen datos de ranging se pasará al método delegado, junto con la región en la que fueron detectados. También proporciona el indicador de intensidad de señal recibida (RSSI) para estimar un rango en metros (Es una propiedad del objeto CLBeacon). Limitación del ranging: Una desventaja principal de las operaciones de ranging es que requiere mucha más actividad en el hardware Bluetooth y consume energía significativa, porque la interfaz Bluetooth está mucho más activa cuando hace ranging Lo que me gusta Nunca pensé que el tema de iBeacon sería escrito como un libro completo pero el autor lo hizo muy bien: El libro describe iBeacon con una explicación profunda. Clarifica los términos fundamentales que se usan comúnmente en la tecnología beacon. Analiza los pros y contras de iBeacon con ejemplos. Presenta otras aplicaciones de beacon en las que nunca había pensado antes, lo cual abre mucho mi mente: Ubicación en interiores y proximidad: Reemplazo de mapas, asistencia de tránsito, búsqueda de direcciones en interiores, ¿dónde está mi carro?, guías de museo, mejora de tiendas minoristas. Acciones activadas por proximidad: Anuncios móviles, validación de boletos, búsqueda del tesoro, integración de información del paciente. Gestión de colas: Medición de colas, paginador de mesas de restaurante, completar transacciones en retail. Fácil de entender: el contenido está bien organizado, es fácil seguir el flujo del contenido. Lo que no me gustaNo hay nada de qué quejarse del libro, desde el contenido hasta la forma. En generalExisten muchas tecnologías para ayudar a los teléfonos a interactuar con el mundo que los rodea. Este libro te presenta iBeacons, una tecnología Bluetooth que permite a un dispositivo descubrir sujetos cercanos con una precisión relativamente alta. No hay duda de que las aplicaciones de beacon se aplican cada vez más ampliamente en muchos campos, especialmente en marketing y publicidad.Desde mi punto de vista, deberías leer el libro para que puedas abrir tu mente sobre iBeacon. Tal vez tu próxima startup se construya sobre Beacon, ¿quién sabe?En el próximo tutorial, te llevaré a la práctica con iBeacon en iOS, también te presentaré algunas técnicas para tratar con iBeacon en un análisis profundo.Si tienes alguna pregunta o comentario sobre esta publicación, ¡no dudes en contactarme!","link":"/es/posts/Review-book-Building-Applications-With-iBeacon/index.html"},{"title":"Programar tareas en segundo plano desde un servicio en primer plano","text":"Si estas ejecutando tu servicio en Android, ten en cuenta que Android ha introducido restricciones mas estrictas de ejecucion en segundo plano en versiones recientes. A partir de Android 8.0 (nivel de API 26) y superior, los servicios en segundo plano tienen limitaciones en su tiempo de ejecucion, especialmente cuando la aplicacion esta en segundo plano. Asegurate de conocer estas restricciones y adaptar tu servicio en consecuencia. TimerCuando usas Timer para programar tareas, depende de un solo hilo en segundo plano. Si la pantalla se apaga, el dispositivo puede entrar en un estado de bajo consumo o en modo de suspension, y esto puede afectar la ejecucion de tareas programadas con Timer. En tales casos, las caracteristicas de ahorro de energia del dispositivo podrian pausar o retrasar la ejecucion de tareas, llevando a un comportamiento inesperado. 1234567private final Timer syncTimer = new Timer();syncTimer.scheduleAtFixedRate(new TimerTask() { @Override public void run() { // Do your task }}); En mi caso, mi aplicacion necesita programar una tarea repetida en segundo plano para sincronizar datos y verificar si el usuario todavia tiene permiso para acceder al dispositivo Bluetooth. En el primer intento, usamos Timer, y no funciono como se esperaba ya que el Timer no se ejecuta cuando el dispositivo entra en modo doze (El modo Doze es una caracteristica de ahorro de energia introducida en Android 6.0 (Marshmallow) que ayuda a extender la vida de la bateria reduciendo el consumo de energia del dispositivo cuando esta inactivo y no en uso. Optimiza el comportamiento de la aplicacion para minimizar la actividad en segundo plano, el acceso a la red y el uso de CPU durante periodos de inactividad. Cuando un dispositivo esta en modo Doze, restringe el procesamiento en segundo plano, el acceso a la red y los wake locks para ahorrar energia de la bateria.).Por lo tanto, necesitamos encontrar una alternativa, y hay dos otros candidatos que me gustaria compartir contigo: AlarmManager y WorkManager. Alarm managerSi necesitas programar tareas que deben ejecutarse incluso cuando la aplicacion no esta activamente en ejecucion, puedes usar la clase AlarmManager. Te permite programar tareas en momentos o intervalos especificos, incluso si tu aplicacion esta en segundo plano o no esta ejecutandose. La clase AlarmManager en Android es un servicio del sistema que te permite programar tareas o eventos para que se ejecuten en momentos o intervalos especificos, incluso cuando tu aplicacion no esta activamente en ejecucion. Proporciona una forma de realizar acciones o activar la ejecucion de codigo en momentos especificados, como configurar alarmas, programar tareas recurrentes o ejecutar operaciones en segundo plano. Las caracteristicas clave de AlarmManager incluyen: Precision de tiempo: AlarmManager proporciona una sincronizacion precisa para programar tareas. Usa el reloj del sistema del dispositivo para determinar cuando ha transcurrido el tiempo o intervalo especificado. Flexibilidad en la programacion: Puedes programar tareas para que se ejecuten una vez (set()), se repitan a intervalos fijos (setRepeating()), o se repitan a intervalos especificos con flexibilidad (setInexactRepeating()). Esta flexibilidad te permite programar tareas segun tus requisitos especificos. Persistencia de ejecucion: Las tareas programadas registradas con AlarmManager persisten incluso si el dispositivo se reinicia. Esto asegura que las tareas se ejecutaran segun lo programado incluso despues de reinicios del sistema. Capacidad de despertar el dispositivo: AlarmManager puede despertar el dispositivo del modo de suspension para ejecutar las tareas programadas. Esto es util para escenarios donde necesitas realizar operaciones en segundo plano que requieren que el dispositivo este despierto. Compatibilidad y soporte hacia atras: AlarmManager ha estado disponible desde las primeras versiones de Android y proporciona compatibilidad hacia atras con versiones anteriores de Android. Esto asegura que tus tareas programadas puedan ejecutarse en una amplia gama de dispositivos. Aqui hay un ejemplo basico de uso de AlarmManager para programar una tarea: Primero, necesitaras configurar los permisos necesarios en tu archivo AndroidManifest.xml: 1&lt;uses-permission android:name=\"android.permission.WAKE_LOCK\"/&gt; Luego, crea una clase para manejar la tarea que se ejecutara cuando se active la alarma, y usala 123456789101112131415161718192021public class MyAlarmReceiver extends BroadcastReceiver { @Override public void onReceive(Context context, Intent intent) { // Do your task }}Intent intent = new Intent(this, MyAlarmReceiver.class);PendingIntent pendingIntent = PendingIntent.getBroadcast(this, 0, intent, 0);// Get the AlarmManager serviceAlarmManager alarmManager = (AlarmManager) getSystemService(Context.ALARM_SERVICE);// Set the repeating alarmalarmManager.setRepeating( AlarmManager.RTC_WAKEUP, System.currentTimeMillis() + ALARM_INTERVAL_MS, ALARM_INTERVAL_MS, pendingIntent); Work managerWorkManager es una biblioteca de Android Jetpack introducida por Google para simplificar y gestionar tareas en segundo plano en aplicaciones Android. Esta disenada para facilitar a los desarrolladores la programacion de tareas diferibles, periodicas y unicas que necesitan ejecutarse incluso cuando la aplicacion no esta en ejecucion o el dispositivo esta en un estado de bajo consumo. Usando WorkManager, puedes realizar tareas como subir datos a un servidor, sincronizar datos desde un servidor remoto, actualizaciones periodicas de datos, limpieza de base de datos, y mas, mientras aseguras una ejecucion en segundo plano eficiente y amigable con la bateria. Abstrae la complejidad de lidiar con varias versiones de Android y caracteristicas de ahorro de energia, convirtiendola en una solucion poderosa y recomendada para el procesamiento en segundo plano en aplicaciones Android modernas. Primero, abre el archivo build.gradle de tu aplicacion y agrega la dependencia de Guava al bloque de dependencias: 12implementation \"androidx.work:work-runtime:2.8.1\"implementation 'com.google.guava:guava:30.1-android' Luego, crea una clase para manejar la tarea que se ejecutara y usala 123456789101112131415161718192021222324class SyncDataWorker extends Worker { public SyncDataWorker( @NonNull Context context, @NonNull WorkerParameters params) { super(context, params); } @Override public Result doWork() { // Do your task return Result.success(); }}// somewhere in your codePeriodicWorkRequest periodicWorkRequest = new PeriodicWorkRequest.Builder( SyncDataWorker.class, TIME_IN_MILLISECONDS, TimeUnit.MILLISECONDS) .setConstraints(new Constraints.Builder() .setRequiredNetworkType(NetworkType.CONNECTED) // Set it if your task requires network to be completed .build()) .build();WorkManager.getInstance(context).enqueue(periodicWorkRequest); Cuando usas WorkManager y la pantalla del dispositivo esta apagada, hay algunas limitaciones y consideraciones a tener en cuenta: Ejecucion retrasada: Cuando la pantalla del dispositivo esta apagada, Android puede entrar en estados de bajo consumo como el modo Doze o el modo de espera de aplicaciones para conservar bateria. En estos estados, las tareas en segundo plano, incluyendo las programadas por WorkManager, pueden retrasarse. WorkManager intenta ejecutar tareas durante ventanas de mantenimiento, pero todavia puede haber retrasos en la ejecucion de tareas. Restricciones de acceso a la red: Android puede restringir el acceso a la red para tareas en segundo plano cuando la pantalla esta apagada. Si tu tarea depende de la conectividad de red, puede experimentar retrasos o tener acceso limitado a recursos de red. Puedes usar restricciones como setRequiredNetworkType() en WorkManager para especificar requisitos de red para tus tareas. Limites de ejecucion en segundo plano: A partir de Android 8.0 (nivel de API 26), Android introdujo limites mas estrictos de ejecucion en segundo plano. Las aplicaciones en segundo plano, incluyendo las que ejecutan tareas en segundo plano programadas por WorkManager, tienen restricciones en su capacidad para ejecutar tareas intensivas en CPU o acceder a ciertos recursos. Aunque WorkManager esta disenado para manejar estas limitaciones y asegurar una ejecucion eficiente de tareas, todavia puede estar sujeto a restricciones impuestas por el sistema operativo. Comportamiento especifico del dispositivo: Diferentes dispositivos Android y fabricantes pueden tener sus propias caracteristicas de ahorro de energia u optimizaciones que pueden afectar la ejecucion de tareas en segundo plano cuando la pantalla esta apagada. Estas optimizaciones pueden variar, llevando a diferentes comportamientos y limitaciones. Es importante probar tu aplicacion en varios dispositivos para asegurar un comportamiento consistente. Para optimizar la ejecucion de tareas en segundo plano cuando la pantalla del dispositivo esta apagada, considera lo siguiente: Usa restricciones apropiadas: Especifica restricciones como requisitos de red (setRequiredNetworkType()), estado de carga (setRequiresCharging()), y mas para asegurar que las tareas se ejecuten bajo las condiciones deseadas. Respeta las optimizaciones de bateria: Anima a los usuarios a excluir tu aplicacion de las optimizaciones de bateria o ponerla en lista blanca en cualquier configuracion de ahorro de energia en su dispositivo. Esto puede ayudar a asegurar que tu aplicacion y sus tareas en segundo plano no sean excesivamente restringidas. Optimiza la ejecucion de tareas: Estructura tus tareas para que sean lo mas eficientes posible, minimizando el impacto en la vida de la bateria y los recursos. Divide las tareas mas grandes en unidades mas pequenas y manejables y considera usar ListenableWorker o CoroutineWorker de WorkManager para mejor rendimiento. Al considerar estos factores y disenar tus tareas en segundo plano y estrategias de programacion en consecuencia, puedes optimizar su ejecucion incluso cuando la pantalla del dispositivo esta apagada y trabajar dentro de las limitaciones impuestas por el sistema Android. Cual usar?La eleccion entre AlarmManager y WorkManager depende de tu caso de uso especifico y requisitos. Aqui hay algunos factores a considerar al decidir cual es mejor para tus necesidades: Tiempo y flexibilidad AlarmManager: Ofrece una sincronizacion precisa para ejecutar tareas en momentos o intervalos especificos, incluso cuando la aplicacion no esta activamente en ejecucion. AlarmManager es adecuado para tareas criticas en tiempo que requieren una sincronizacion de ejecucion exacta. WorkManager: Proporciona mas flexibilidad y optimizacion para tareas en segundo plano. WorkManager considera factores como optimizaciones de bateria, disponibilidad de red y estado inactivo del dispositivo para ejecutar tareas eficientemente. Es muy adecuado para tareas que no requieren precision estricta de tiempo, como sincronizar datos o actualizaciones periodicas que pueden aceptar algun retraso. Eficiencia energetica y optimizacion de bateria AlarmManager: Permite una ejecucion mas inmediata y puede despertar el dispositivo del modo de suspension. Sin embargo, si se usa incorrectamente, puede tener un impacto significativo en la vida de la bateria. WorkManager: Aprovecha las optimizaciones del sistema para minimizar el uso de bateria. WorkManager agrupa tareas, respeta los estados inactivos del dispositivo y se adapta a las caracteristicas de ahorro de energia. Proporciona un enfoque mas eficiente energeticamente para ejecutar tareas en segundo plano. Compatibilidad y soporte hacia atras AlarmManager: Ha estado disponible desde las primeras versiones de Android y ofrece compatibilidad hacia atras con versiones anteriores de Android. Puede usarse en una amplia gama de dispositivos Android. WorkManager: Es parte de la biblioteca Android Jetpack y es compatible hacia atras hasta el nivel de API 14 de Android (Ice Cream Sandwich). WorkManager esta disenado para funcionar consistentemente en diferentes versiones y dispositivos Android. Manejo de errores y mecanismo de reintento AlarmManager: No proporciona mecanismos integrados para manejar fallos de tareas o reintentos automaticos. WorkManager: WorkManager puede reintentar automaticamente tareas fallidas con restricciones configurables. En general, si necesitas sincronizacion precisa, ejecucion inmediata o la capacidad de despertar el dispositivo del modo de suspension, AlarmManager podria ser la mejor opcion. Por otro lado, si requieres eficiencia energetica, programacion flexible de tareas, manejo de errores y compatibilidad entre diferentes versiones de Android, WorkManager es una opcion mas adecuada.En algunos casos, incluso puedes usar tanto AlarmManager como WorkManager juntos, dependiendo de los requisitos especificos de tu aplicacion. Por ejemplo, puedes usar AlarmManager para tareas sensibles al tiempo y WorkManager para procesamiento en segundo plano eficiente energeticamente. ConclusionEn resumen, mientras usar Timer podria llevar a un comportamiento impredecible cuando la pantalla se apaga debido a la ejecucion de un solo hilo y la falta de optimizaciones de ahorro de energia, WorkManager y AlarmManager pueden manejar la ejecucion de tareas de manera mas eficiente y confiable, incluso cuando la pantalla esta apagada o el dispositivo esta en un estado de bajo consumo. Para programar tareas en segundo plano, generalmente se recomienda usar WorkManager o AlarmManager en lugar de usar Timer.","link":"/es/posts/Schedule-task-in-background-from-foreground-service/index.html"},{"title":"Reseña del libro: RxSwift Reactive Programming with Swift","text":"En el mundo en constante evolución del desarrollo iOS, dominar la programación reactiva puede diferenciarte como desarrollador. Uno de los mejores recursos para sumergirse en la programación reactiva con Swift es el libro “RxSwift: Reactive Programming with Swift.” Esta guía completa proporciona todo lo que necesitas para entender y aprovechar RxSwift en tus aplicaciones. Exploremos qué hace de este libro una lectura esencial para los desarrolladores Swift. ¿Qué es la Programación Reactiva?La programación reactiva es un paradigma que te permite trabajar con flujos de datos asíncronos y eventos de manera declarativa. En lugar de administrar manualmente callbacks y cambios de estado, la programación reactiva te permite declarar cómo deben fluir los datos y responder a eventos. Esto resulta en código más limpio y mantenible, especialmente para aplicaciones complejas. Comenzando con RxSwiftEl libro comienza con los fundamentos de la programación reactiva, introduciendo conceptos centrales como Observables, Subscribers y el Observer Pattern. Te guía a través de la configuración de RxSwift en tu proyecto usando administradores de dependencias populares como CocoaPods y Swift Package Manager. Conceptos CentralesEl libro profundiza en los conceptos centrales de RxSwift: Observables y Observers: Aprende cómo los Observables emiten elementos y cómo los Observers se suscriben a estos flujos. Esta es la columna vertebral de la programación reactiva. Operadores: RxSwift proporciona un rico conjunto de operadores para transformar y combinar flujos. El libro cubre varios operadores, incluyendo: Operadores de Creación: create, just, from Operadores de Transformación: map, flatMap, concatMap Operadores de Filtrado: filter, distinctUntilChanged, throttle Operadores de Combinación: merge, combineLatest, zip Subjects: Entiende los diferentes tipos de Subjects como PublishSubject, BehaviorSubject, ReplaySubject y AsyncSubject y sus casos de uso. Temas Avanzados y Mejores Prácticas: Una vez que estés cómodo con lo básico, el libro introduce temas más avanzados: Schedulers: Administra la concurrencia y el manejo de hilos con los schedulers de RxSwift, incluyendo MainScheduler y ConcurrentDispatchQueueScheduler. Manejo de Errores: Descubre estrategias para manejar errores dentro de flujos reactivos usando operadores como catchError y retry. Gestión de Memoria: Aprende las mejores prácticas para administrar suscripciones y evitar fugas de memoria con herramientas como DisposeBag. Integrando RxSwift con UIKit: Una de las fortalezas de RxSwift es su capacidad de integrarse perfectamente con UIKit. El libro demuestra cómo vincular Observables de RxSwift a componentes de UIKit como UITableView y UICollectionView. También cubre el manejo de entradas de usuario de forma reactiva, haciendo tu código de UI más responsivo y fácil de administrar. Testing y Debugging: Probar y depurar código reactivo puede ser desafiante. “RxSwift: Reactive Programming with Swift” proporciona consejos prácticos sobre escribir pruebas unitarias para código RxSwift y usar herramientas como TestScheduler. También ofrece tips para depurar flujos reactivos, ayudándote a asegurar que tus aplicaciones funcionen sin problemas. Aplicaciones del Mundo Real: El libro está lleno de ejemplos del mundo real y casos de estudio. Verás cómo RxSwift puede aplicarse a problemas prácticos como solicitudes de red, validación de formularios y administración de interacciones complejas de UI. Estos ejemplos ayudan a solidificar tu comprensión y muestran cómo usar RxSwift efectivamente en tus proyectos. Pros Explicaciones Claras: El libro es elogiado por sus explicaciones claras y estructuradas, haciendo los conceptos complejos de programación reactiva más accesibles. Ejemplos Prácticos: Proporciona una variedad de ejemplos prácticos que ayudan a entender cómo usar RxSwift efectivamente. Cobertura Completa: Cubre tanto temas básicos como avanzados, atendiendo a lectores con diferentes niveles de experiencia. Contras Versión de Swift: Dependiendo de la fecha de publicación, algo del contenido podría estar basado en versiones anteriores de Swift o RxSwift, lo que podría requerir algunos ajustes si estás usando las versiones más recientes. Profundidad de Cobertura: Algunos lectores podrían encontrar que aunque el libro cubre mucho terreno, ciertos temas avanzados podrían requerir recursos adicionales para dominarlos completamente. ConclusiónEste es un recurso invaluable para desarrolladores iOS que buscan dominar la programación reactiva. Con sus explicaciones claras, ejemplos prácticos y cobertura completa de temas básicos y avanzados, es una lectura obligada para cualquiera que esté serio sobre usar RxSwift en sus aplicaciones. Ya seas nuevo en la programación reactiva o busques profundizar tu conocimiento, este libro te guiará en cada paso del camino.","link":"/es/posts/Review-book-RxSwift-Reactive-Programming-with-Swift/index.html"},{"title":"Serie React Native y BLE: Parte 1 - Construyendo un framework BLE para iOS","text":"He estado trabajando en desarrollo móvil tanto en proyectos nativos como en plataformas cruzadas (React Native, Flutter), y también tengo experiencia trabajando con BLE. A veces recibo correos electrónicos preguntando sobre la comunicación de RN/Flutter con BLE. Por eso, decidí introducir esta serie React Native y BLE para guiarte sobre cómo desarrollar un framework BLE nativo y conectarlo a React Native.Por supuesto, habrá otra serie para Flutter y BLE después de terminar la serie de React Native.En esta serie, te guiaré a través de un proceso completo desde el desarrollo hasta la distribución. Crear un framework iOS / Android. Script para construir y distribuir tu framework. Importar los frameworks a tu proyecto React Native. Usar tu framework nativo en React Native. Distribuir tu aplicación. Y otras cosas interesantes que quiero compartir contigo… Si te gusta lo que hago, considera apoyarme en buy a coffee for Uy Nguyen :)Vamos. Xcode 13, iOS 15, Swift 5, React 17.0.1, React Native 0.64.1. Preparar el framework iOSEl primer paso es crear un framework BLE. Tampoco tienes que crear un framework, puedes incluir tu código fuente dentro del proyecto iOS directamente si lo deseas.Sin embargo, la razón por la que recomiendo mover toda la lógica BLE a un framework es que es reutilizable, puedes compartir tu framework con otros proyectos como Flutter o proyectos Nativos sin tener que duplicar la lógica.Otra razón es que mejorará el tiempo de compilación de Xcode, dividir tu aplicación en varios frameworks puede acelerar los tiempos de construcción. Esto es porque el sistema de construcción de Xcode no tiene que recompilar frameworks para los cuales los archivos Swift no han cambiado. Desde la barra superior izquierda de Xcode, selecciona File &gt; New &gt; Project &gt; Desde la sección &quot;Framework &amp; Library&quot;, selecciona &quot;Framework&quot; &gt; Ingresa el nombre de tu framework (yo uso &quot;BLEFramework&quot;) Ahora, puedes desarrollar tu lógica BLE en el proyecto que acabas de crear. No voy a detallar la implementación de todos los métodos individuales del framework ya que depende de tu lógica de negocio y tu arquitectura. Puedes encontrar mis tutoriales anteriores para tener una idea de cómo implementar un framework BLE. Bluetooth Low Energy OniOS, Play Central And Peripheral Roles With CoreBluetoothTomaré un método simple en mi framework BLE como ejemplo: el método startScanning. 12345678910/**Class: CentralManager*//*** @discussion Start scanning nearby peripherals and returns to the `ScanningDelegate`*/public func startScanningFor(delegate: ScanningDelegate, filter: DeviceFilter = DeviceFilter()) throws { //... BLE implementation.} OK ahora tenemos un framework BLE, pasemos al siguiente paso: Construir y distribuir tu framework. Construir y distribuirHay muchas formas de distribuir un framework como usar CocoaPod, o manualmente enviando un archivo compilado, etc. En esta publicación, te proporcionaré un script para convertir tu framework en un framework universal que oculta toda tu lógica, y puede usarse tanto para dispositivos físicos como simuladores. Asegúrate de activar la bandera “Build Libraries for Distribution” en “Build Settings” a YES. La bandera indica que el compilador debe generar una de las interfaces estables para que el framework pueda usarse cuando se lancen versiones más nuevas de Xcode o el compilador Swift. A continuación, crea un archivo bash, ponlo en la raíz de la carpeta ios, y copia los siguientes comandos al archivo. Luego ejecuta el script. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546### SCRIPT TO BUILD A SWIFT UNIVERSAL FRAMEWORKPRODUCT_NAME=\"REPLACE_BY_YOUR_TARGET_NAME\"BUILD_CONFIGURATION=\"Release\"DERIVED_DATA_PATH=\"$(pwd)/build\"RELEASE_DIR=\"$(pwd)/RELEASE\"BUILD_SCHEME=\"${PRODUCT_NAME}\"FRAMEWORK_NAME=\"${PRODUCT_NAME}.framework\"RELEASE_DEVICE_PATH=\"${RELEASE_DIR}/device/${FRAMEWORK_NAME}\"RELEASE_SIMULATOR_PATH=\"${RELEASE_DIR}/simulator/${FRAMEWORK_NAME}\"rm -rf \"${DERIVED_DATA_PATH}\"rm -rf \"${RELEASE_DIR}\"mkdir -p \"${DERIVED_DATA_PATH}\"mkdir -p \"${RELEASE_DIR}\"mkdir -p \"${RELEASE_DIR}/simulator\"mkdir -p \"${RELEASE_DIR}/device\"# Build library for simulatorfastlane ios build scheme:\"${BUILD_SCHEME}\" \\ configuration:\"${BUILD_CONFIGURATION}\" \\ sdk:iphonesimulator \\ build_dir:\"${DERIVED_DATA_PATH}\" \\ --verboseSIMULATOR_FRAMEWORK_PATH=\"${DERIVED_DATA_PATH}/Build/Products/${BUILD_CONFIGURATION}-iphonesimulator/${FRAMEWORK_NAME}\"mv \"${SIMULATOR_FRAMEWORK_PATH}\" \"${RELEASE_SIMULATOR_PATH}\"# Build library for iphoneosfastlane ios build scheme:\"${BUILD_SCHEME}\" \\ configuration:\"${BUILD_CONFIGURATION}\" \\ sdk:iphoneos \\ build_dir:\"$DERIVED_DATA_PATH\" \\ --verboseDEVICE_FRAMEWORK_PATH=\"${DERIVED_DATA_PATH}/Build/Products/${BUILD_CONFIGURATION}-iphoneos/${FRAMEWORK_NAME}\"mv \"${DEVICE_FRAMEWORK_PATH}\" \"${RELEASE_DEVICE_PATH}\"# Merge SDKsxcodebuild -create-xcframework -output \"${RELEASE_DIR}/${PRODUCT_NAME}.xcframework\" \\ -framework \"${RELEASE_DEVICE_PATH}\" \\ -framework \"${RELEASE_SIMULATOR_PATH}\"open \"${RELEASE_DIR}\" Una vez que ejecutes el script exitosamente, deberías ver el resultado como se muestra a continuación Donde: YOUR_TARGET_NAME.xcframework: El framework universal que puede usarse tanto para dispositivos físicos como simuladores. carpeta device: contiene YOUR_TARGET_NAME.framework que solo puede usarse en dispositivos físicos. carpeta simulator: contiene YOUR_TARGET_NAME.framework que solo puede usarse en simuladores. Ahora tenemos un framework BLE para nuestra aplicación, pasemos al siguiente paso - Crear un nuevo proyecto React Native. Inicializar proyecto React NativePara crear un proyecto React Native sin usar Expo (recomiendo no usar Expo porque vamos a agregar mucho código Nativo para Android e iOS a nuestro proyecto, para más detalles puedes consultar what is the difference between expo and react native), abre el terminal y escribe 1react-native init projectName Espera un momento para configurar tu proyecto. Después de ejecutar exitosamente, deberías ver la estructura de carpetas como se muestra a continuación: 12345|---projectName |---ios |---projectName.xcworkspace |---android |---...Other files, folders Abre el archivo projectName.xcworkspace, configuraremos el código nativo en el siguiente paso. ConectándolosPrimero, arrastra y suelta el YOUR_TARGET_NAME.xcframework a tu espacio de trabajo de Xcode.Como mi SDK está construido en Swift, voy a crear una clase Swift como puente para que podamos comunicarnos desde el SDK a React Native.Desde el proyecto Xcode, selecciona File &gt; New &gt; File &gt; Swift File &gt; Ingresa el nombre de tu archivo (ej. BLEManager) &gt; Add. Aparecerá un diálogo preguntando si quieres crear un bridging header, selecciona sí. Para aquellos que no saben para qué se usa el bridging header, el bridging header es donde defines todas las clases Objective-C que están expuestas a Swift. Para usar clases RCT, asegúrate de hacer #import de todos los headers relacionados a tu ...-Bridging-Header.h. De lo contrario, obtendrás errores de compilación. 1234#import &lt;React/RCTBridgeModule.h&gt;#import \"React/RCTEventEmitter.h\"#import \"React/RCTViewManager.h\"#import &lt;React/RCTLog.h&gt; A continuación, agrega la interfaz RCTEventEmitter a la clase BLEManager que acabamos de crear en el paso anterior. 1234567891011121314151617181920212223242526272829@objc(BLEManager) &lt;--- Remember to add this [1]public class BLEManager: RCTEventEmitter, ScanningDelegate { static let didFoundDeviceEvent = \"didFoundDevice\" @objc &lt;--- Remember to add this public static let shared = BLEManager() override init() { super.init() _ = BLEWrapper.shared } @objc(startScanning) &lt;--- Remember to add this func startScanning() { BLEWrapper.shared.startScanning(self) } public func managerDidFoundDevice(_ manager: CentralManager, device: Device, rssi: Int) { self.sendEvent(withName: Self.didFoundDeviceEvent, body: [\"name\": device.localName, \"rssi\": rssi]) [2] } public override static func requiresMainQueueSetup() -&gt; Bool { return true } override public func supportedEvents() -&gt; [String]! { return [Self.didFoundDeviceEvent] [3] }} [1] Asegúrate de decorar tu clase y funciones con la palabra clave @objc para asegurar que la clase y funciones se exporten correctamente al runtime de Objective-C.[2] Una vez que se descubre un periférico, envía un evento a Javascript.[3] Registra el soporte de eventos del módulo nativo. Finalmente, para exponer los métodos de tu módulo nativo, crea un nuevo archivo BLEManager.m y agrega el siguiente código. 12345@interface RCT_EXTERN_MODULE(BLEManager, RCTViewManager)RCT_EXTERN_METHOD(startScanning)@end Eso es todo. Javascript ahora puede invocar la función startScanning y escuchar el evento didFoundDeviceEvent. PruebasEs hora de probar nuestra implementación, React Native proporciona instancias NativeEventEmitter y NativeModules que te permiten trabajar con módulos nativos.Desde la carpeta raíz, abre App.js e importa las cosas necesarias. 12345import { NativeEventEmitter, NativeModules,} from 'react-native';const {BLEManager} = NativeModules; &lt;-- You can then access the BLEManager native module En el método componentDidMount, agrega lo siguiente 123456789101112componentDidMount() { let beaconManagerEmitter = new NativeEventEmitter(BLEManager); [1] this.didFoundDevice = beaconManagerEmitter.addListener( [2] 'didFoundDevice', data =&gt; { console.log(data); }, ); setTimeout(() =&gt; { BLEManager.startScanning(); [3] }, 3000); // Just to make sure the Bluetooth is on, we will improve it later} [1] Crea una nueva instancia de NativeEventEmitter y escucha el evento didFoundDevice [2][3] Porque aún no soportamos el evento de cambios de estado de Bluetooth, temporalmente retrasamos 3s antes de llamar al escaneo solo para asegurar que el Bluetooth está encendido. Lo mejoraremos más tarde soportando más eventos y métodos. OK, vamos a construir y ejecutar tu proyecto. Si ves tu consola de log imprimiendo los resultados del proceso de escaneo, felicitaciones, ¡lo hiciste bien! Siguiente pasoEn esta publicación, te mostré cómo crear un framework BLE y cómo usar un módulo nativo BLE en un proyecto React Native como invocar un método desde Javascript a Swift y manejar un evento desde Swift a Javascript. En el siguiente tutorial, haremos lo mismo en la plataforma Android.Si enfrentas algún problema, no dudes en contactarme. Me encantaría ayudar.Felices fiestas. Referencias[1] React Native - Native module ios","link":"/es/posts/Series-React-Native-and-BLE-Part-1-Building-BLE-framework-for-iOS/index.html"},{"title":"Serie React Native y BLE: Parte 2 - Construyendo un framework BLE para Android","text":"Cuando se trata de tecnología móvil, iOS y Android son los dos sistemas operativos dominantes que impulsan la mayoría de smartphones y tablets en todo el mundo. Como desarrolladores, es esencial que tengamos el conocimiento y las herramientas para trabajar con ambas plataformas de manera efectiva. Esto es especialmente cierto cuando se trata de utilizar la tecnología Bluetooth, que es un componente crucial de muchas aplicaciones móviles modernas.En la parte 1 de esta serie de tutoriales, creamos un framework BLE (Bluetooth Low Energy) que podía conectarse a la UI usando React Native. Sin embargo, este framework solo funcionaba en iOS, lo que significaba que necesitábamos desarrollar una solución separada para Android.En la parte 2 de esta serie de tutoriales, nos enfocaremos en definir un nuevo SDK para Android y vincularlo a la UI, tal como hicimos en iOS. Esto nos permitirá soportar completamente ambos sistemas operativos y proporcionar una experiencia Bluetooth fluida para todos los usuarios, independientemente de su dispositivo de elección. Crear nuevo SDK de AndroidEl primer paso es crear tu propia biblioteca Bluetooth. Normalmente, los ingenieros tienden a usar una biblioteca de código abierto como RxAndroidBle o Android-BLE-Library powered by Nordic. Sin embargo, el objetivo principal de este tutorial es guiarte sobre cómo crear un nuevo módulo Android y vincularlo a React Native. Esto no solo aplica a Bluetooth sino también a cualquier biblioteca que necesites usar en tu aplicación. El otro objetivo es obtener conocimiento fundamental de Android BLE en caso de que necesites modificar algo o crear tu propia característica que no ha sido soportada en el mercado. Al crear tu propia biblioteca Bluetooth, tienes la libertad de personalizar y adaptar la biblioteca a tus necesidades específicas. Esto puede proporcionar ventajas significativas sobre usar bibliotecas preexistentes, ya que puedes optimizar la biblioteca para tu caso de uso particular y evitar posibles problemas de compatibilidad. Desde tu proyecto, ve a File &gt; New &gt; New Module &gt; Completa la información.Se agregará una nueva biblioteca a tu proyecto. Una cosa muy diferente de Android e iOS es que desde Android 6.0, Google requiere que el Location Permission esté habilitado para el escaneo Bluetooth Low Energy (Ver más Android 6.0 Changes). A continuación, agrega los siguientes permisos a tu AndroidManifest.xml en android/app/src/main/AndroidManifest.xml 123&lt;uses-permission android:name=\"android.permission.BLUETOOTH\" /&gt;&lt;uses-permission android:name=\"android.permission.BLUETOOTH_ADMIN\" /&gt;&lt;uses-permission android:name=\"android.permission.ACCESS_FINE_LOCATION\" /&gt; note:123456Android 12 update:From Android 12 (API level 31+):- Google requires new permission for scanning nearby devices: + If your app looks for Bluetooth devices, such as BLE peripherals, declare the BLUETOOTH_SCAN permission. + If your app communicates with already-paired Bluetooth devices, declare the BLUETOOTH_CONNECT permission.- If your app does not use Bluetooth scan results for physical location, you can skip declaring location permission by adding `android:usesPermissionFlags` Para propósitos de demostración, el SDK expone solo 2 APIs simples startScan para comenzar a escanear dispositivos cercanos e isBluetoothOn para verificar si el Bluetooth está encendido. 12345/*Start scanning nearby devices.Accept `callback` as param and return found devices via `callback`*/fun startScan(callback: (device: Device) -&gt; Unit) 1234/*Check if BLE is ready for scanning*/fun isBluetoothOn() : Boolean Para solicitar permisos en React Native, vamos a usar este módulo https://github.com/zoontek/react-native-permissions para obtener los permisos que la aplicación necesita. Construir y lanzar módulo SDK de AndroidA continuación, distribuyamos el módulo para que otras aplicaciones puedan usarlo.Desde la carpeta raíz, ejecuta ./gradlew kTrackingSDK:assembleRelease para generar un archivo .aar.El archivo de salida estará ubicado en ./KTrackingSDK/build/outputs/aar, luego puedes importar el archivo .aar al proyecto android. Conectar a la parte de React NativeAhora, ya tenemos la biblioteca Bluetooth. El siguiente paso es vincular el módulo a la parte de React Native. Primero, la parte de React Native necesita entender el módulo Nativo. Agrega la siguiente configuración a tu /src/main/java 1234567891011121314151617181920212223242526272829class BLEManager(context: ReactApplicationContext) : ReactContextBaseJavaModule(context) { init { Log.d(\"BLEManager\", \"Init package\") BLEManagerLib.shared.config(context) } override fun getName(): String { return \"BLEManager\" } @ReactMethod fun isBluetoothOn(promise: Promise) { promise.resolve(BLEManagerLib.shared.isBluetoothOn()) } @ReactMethod fun startScanning() { Log.d(\"BLEManager\", \"Start scanning\") BLEManagerLib.shared.startScan { val params: WritableMap = Arguments.createMap() params.putString(\"name\", it.name) params.putInt(\"rssi\", it.rssi) params.putString(\"address\", it.address) this.reactApplicationContext .getJSModule(RCTDeviceEventEmitter::class.java) .emit(\"didFoundDevice\", params) } }} Creando un nuevo archivo para definir el BLEManagerPackage 1234567891011class BLEManagerPackage: ReactPackage { override fun createNativeModules(reactContext: ReactApplicationContext): MutableList&lt;NativeModule&gt; { val modules = ArrayList&lt;NativeModule&gt;() modules.add(BLEManager(reactContext)) return modules } override fun createViewManagers(reactContext: ReactApplicationContext): MutableList&lt;ViewManager&lt;View, ReactShadowNode&lt;*&gt;&gt;&gt; { return ArrayList() }} A continuación, agrégalo a la lista de paquetes en MainApplication.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class MainApplication extends Application implements ReactApplication { ... @Override protected List&lt;ReactPackage&gt; getPackages() { Log.d(\"BLEManager\", \"Running\"); @SuppressWarnings(\"UnnecessaryLocalVariable\") List&lt;ReactPackage&gt; packages = new PackageList(this).getPackages(); /* Add your custom modules here */ packages.add(new BLEManagerPackage()); /* */ return packages; } ...}Finalmente, la aplicación necesita pedir a los usuarios que otorguen permisos.```js// somewhere in your codeimport { check, PERMISSIONS, request, RESULTS } from 'react-native-permissions';checkPermission = () =&gt; { check(PERMISSIONS.ANDROID.ACCESS_FINE_LOCATION) .then((result) =&gt; { if (result !== RESULTS.GRANTED) { requestLocation(() =&gt; { // On granted }, () =&gt; { // On denied }); } }) .catch((error) =&gt; { // … });}requestLocation = (grantedCallback, deniedCallback) =&gt; { request(PERMISSIONS.ANDROID.ACCESS_FINE_LOCATION).then(result =&gt; { switch (result) { case RESULTS.DENIED: console.log('User denied permission',); deniedCallback(); break; case RESULTS.GRANTED: console.log('The permission is granted'); grantedCallback(); break; } });} ResultadoDado que usamos el mismo código para Android e iOS en la parte de React Native, no hay necesidad de modificar el código de React Native del tutorial anterior. Mientras sigas el protocolo que definimos, todo debería funcionar según lo previsto. Al mantener un protocolo consistente en ambas plataformas, podemos asegurar que el código sea fácilmente portable y que cualquier cambio realizado en una plataforma no afecte a la otra. Esto puede simplificar significativamente el proceso de desarrollo y reducir el riesgo de errores o problemas de compatibilidad. ConclusiónDespués de pasar incontables horas investigando y experimentando, finalmente hemos aprendido cómo crear nuestra propia biblioteca Bluetooth y usarla en nuestro proyecto React Native. Con este nuevo conocimiento, el proceso de agregar nuevas características se ha vuelto significativamente más fácil y eficiente. Solo necesitamos implementar la lógica en Código Nativo en lugar de tener que desarrollar la parte de UI dos veces. Esto no solo nos ha ahorrado una tremenda cantidad de tiempo y esfuerzo, sino que también nos ha permitido enfocarnos más en mejorar la funcionalidad de nuestra aplicación. Ahora podemos dedicar más recursos a desarrollar nuevas características, optimizar las existentes y mejorar la experiencia general del usuario. Además, nuestra nueva capacidad de crear bibliotecas personalizadas ha abierto un mundo completamente nuevo de posibilidades para nuestro equipo de desarrollo. Ahora podemos aprovechar nuestro conocimiento de React Native para crear características aún más avanzadas e innovadoras, todo mientras mantenemos un proceso de desarrollo simplificado. ¡Feliz codificación! Referencias Android Native Modules. Android Bluetooth permissions.","link":"/es/posts/Series-React-Native-and-BLE-Part-2-Building-BLE-framework-for-Android/index.html"},{"title":"Enviando tu aplicación iOS a la Store","text":"Enviar tu aplicación a la Apple Store no es tan simple como presionar un botón “mágico” que hace todo, pero tampoco es tan complicado como piensas. Quizás es tu primera vez lanzando tu primera aplicación, y no has tenido la oportunidad de familiarizarte con el proceso de envío antes. Este tutorial paso a paso te mostrará el flujo principal para enviar aplicaciones desde cero hasta ser un experto. Ten en cuenta que necesitas tener una Cuenta de Desarrollador de Pago para completarlo.¡Comencemos! Certificados, app Ids y perfiles de aprovisionamientoPara enviar tu aplicación a la App Store, necesitas entender qué son los certificados, app IDs y perfiles de aprovisionamiento. Básicamente, un certificado de distribución identifica a tu equipo/organización dentro de un perfil de aprovisionamiento de distribución y te permite enviar tu aplicación a la Apple App Store. La siguiente imagen describe la relación entre ellos. Crear un Certificado de Distribución En tu Mac, abre la aplicación Key Chain Access. Ve a Certificate Assistant &gt; Request a Certificate From a Certificate Authority. Ingresa tu correo electrónico en el campo de email. El Keychain Access creará una clave privada, que se almacena en el keychain, y un archivo .certSigningRequest que se subirá a Apple. Apple emitirá un certificado para ti basado en el .certSigningRequest. El Certificado contiene la clave pública. Después de eso, puedes descargar el archivo y abrirlo. La clave pública se agregará al Keychain y se emparejará con la clave privada para crear la “Code Signing Identity”. Para que sepas qué es CSR Un CSR o Certificate Signing Request es un bloque de texto codificado que se entrega a una Autoridad de Certificación cuando se solicita un Certificado SSL. Generalmente se genera en el servidor donde se instalará el certificado y contiene información que se incluirá en el certificado, como el nombre de la organización, nombre común (nombre de dominio), localidad y país. También contiene la clave pública que se incluirá en el certificado. Una clave privada generalmente se crea al mismo tiempo que se crea el CSR, formando un par de claves. Después de tener el archivo .certSigningRequest, ve a la página de desarrolladores de Apple, inicia sesión con tu Cuenta de Apple &gt; Certificates, Identifiers &amp; Profiles &gt; Presiona el botón “+” para crear una nueva certificación &gt; Recuerda seleccionar la opción “iOS Distribution (App Store and Ad Hoc)”. A continuación, selecciona para subir tu archivo .certSigningRequest que acabas de crear en el paso 3. Finalmente, ahora puedes descargar el archivo del Certificado a tu Mac, ábrelo y la clave se agregará al keychain automáticamente. Eso es todo para crear un Certificado de Distribución, pasemos al siguiente paso, crear tu app id. Crear App Id Presiona el botón “+” en la página “All Identifiers” Completa la información de tu aplicación, incluyendo tu bundle Id. Ten en cuenta que este bundle id debe coincidir con tu bundle id en XCode. También puedes usar el patrón wildcard para definir bundle Id para más de un app Id. Crear Perfil de Aprovisionamiento Presiona el botón “+” en la página “Profiles”, luego selecciona la opción “App Store”. Selecciona tu app Id que acabas de crear en el paso anterior, Crear App Id. Selecciona tu Certificado que acabas de crear en el paso anterior, Crear un Certificado de Distribución Ahora tienes un perfil que vincula tu Certificado y tus app Ids. Descarga este archivo y ábrelo. Los Perfiles de Aprovisionamiento se agregarán a XCode automáticamente. SubiendoEs hora de subir tu aplicación a la Store.Regresa a tu proyecto, desde la Barra de Herramientas Superior &gt; Product &gt; Archive, XCode reconstruirá tu proyecto. Después de eso, el XCode Organizer se iniciará y mostrará todos los archives que has creado en el pasado.Selecciona el build actual, luego haz clic en “Distribute App” en el panel de la derecha. La siguiente ventana te permite seleccionar tus credenciales incluyendo el Certificado de Distribución y los Perfiles de Aprovisionamiento que creaste en la primera sección. Finalmente, presiona el botón de subir, XCode hará el resto por ti. Se te enviará un correo electrónico para notificarte justo después de que Apple complete el proceso de procesamiento, generalmente toma algunos minutos.Tu aplicación ha sido subida exitosamente a tu Perfil de iTunes, vamos al paso final. EnviandoNavega a App Store Connect, selecciona “My Apps”. verás tu aplicación aparecer en la página. Necesitas preparar la siguiente información para completar en estas páginas: Nombre de la Aplicación, URL de Política de Privacidad, Clasificación de Edad, Categoría. Capturas de pantalla en diferentes tamaños: Esto podría tomarte la mayor parte del tiempo, tus capturas de pantalla necesitan cumplir con los requisitos de Apple en Screenshot specifications. Ten en cuenta que los usuarios verán estas capturas de pantalla relacionadas con sus dispositivos actuales, así que asegúrate de que tus fotos sean atractivas y llamativas tanto como puedas. Fastlane también soporta tomar capturas de pantalla automáticamente, puedes encontrar la documentación si estás interesado. ¡Las herramientas de Fastlane pueden automatizar este proceso haciéndolo rápido y consistente mientras te dan hermosos resultados! Descripción de la versión, palabras clave, URL de soporte. Si tu aplicación requiere inicio de sesión, completa la información de cuenta con nombre de usuario y contraseña. Notas de la aplicación: Algunas notas importantes que quieres enviar al revisor para asegurar que funcione correctamente. (ej. recomendamos encarecidamente usar el servicio con conexión Wifi para mejor calidad) Adjunto: Es mejor tener una demostración corta de tu aplicación. Información de contacto: Si hay algún problema, Apple te contactará a través de esta información. Has terminado. Ahora presiona el botón “Submit” para iniciar el proceso de revisión. Proceso de revisiónTu proceso de revisión toma algo de tiempo para completarse, puede ser un par de días a un par de semanas dependiendo de la categoría de tu aplicación, características, y… el revisor.Si tu aplicación viola las reglas de Apple como usar APIs privadas no aprobadas, falta de descripción de permisos, fallas o bajo rendimiento, será rechazada. Al final, tenemos que aceptar que Apple tiene la última palabra para permitir cualquier cosa en la App Store. Solo porque pienses que tu aplicación es genial no significa que Apple la permitirá en la App Store. Yo mismo experimenté este proceso estricto-aleatorio-emocional al enviar mi aplicación. El primer envío fue sin problemas. El segundo, que actualizaba algo de UI, fue rechazado porque Apple piensa que mi aplicación contiene una característica que no está permitida en la App Store. Con muchos correos electrónicos y llamadas telefónicas, finalmente tuve que eliminar esta característica de mi aplicación. (?!) Palabras finalesEn esta publicación, te guié sobre cómo enviar tu aplicación a la Store en un paso muy detallado. Espero que esta publicación ahorre tu tiempo al entregar tus increíbles aplicaciones a los usuarios. No puedo esperar.En la próxima publicación, te mostraré los pasos para subir tu aplicación a Google Play.¡Feliz programación!","link":"/es/posts/Shipping-your-iOS-app-to-Store/index.html"},{"title":"Conferencia Swift Summit en San Francisco 2017","text":"La Conferencia Swift Summit 2017 se celebró en el Palace Of Fine Arts, San Francisco, que es uno de los diez palacios en el corazón de la Exposición Panama-Pacific. En la conferencia, desarrolladores de Swift de todo el mundo compartieron nuevos conocimientos, herramientas e ideas sobre la plataforma iOS y el lenguaje Swift. Imagen 1. Estuve allí, en la conferencia Swift Summit 2017 La conferencia albergó más de 20 sesiones técnicas y laboratorios para desarrolladores. Especialmente, había una sala de exhibidores con las principales empresas tecnológicas como Facebook, IBM, Lyft, Capital One, etc. Allí, conocí a otros desarrolladores, hablamos sobre nuevas tecnologías y recibí regalos promocionales de los patrocinadores. Imagen 2. Mi bolsa (y otra de mi amigo) estaba llena de regalos promocionales de la conferencia :)). Diez días para disfrutar de EE.UU., dos días para disfrutar de la conferenciaComo era la primera vez que iba a San Francisco, no estaba cómodo con el clima de allí. Recuerdo que en la primera mañana que fui al Palace of Fine Arts, la temperatura era de 13 grados centígrados en ese momento. ¡Me estaba congelando!Cuando entré por primera vez al salón principal, me sentí mejor debido a la luz cálida. Los organizadores prepararon mucha comida y frutas en una mesa en el centro del salón. Mis amigos y yo recorrimos las empresas tecnológicas, probamos sus nuevas tecnologías y recibimos sus regalos promocionales.El tamaño de la conferencia no fue como esperaba. Era bastante pequeña, alrededor de cien personas, supongo. Pero los organizadores y los ponentes prepararon los contenidos muy bien. A continuación se presentan algunas sesiones clave que considero las mejores durante los dos días de conferencia. Programación asíncronaLos métodos asíncronos (Async para abreviar) son los métodos que no devuelven resultados inmediatamente como la mayoría de los métodos, los métodos asíncronos toman algo de tiempo para producir resultados.Antes de asistir a esta sesión, a menudo usaba callbacks para manejar métodos asíncronos como escanear dispositivos bluetooth o recuperar algunos recursos de internet. De hecho, callback es una mala técnica de programación. Los callbacks hacen que nuestro código sea difícil de leer, difícil de depurar y tome mucho más tiempo de mantener después. Al final, nuestro código se convertirá en algo que llamamos el callback hell.En esta sesión, el ponente presentó un framework que nos ayuda a simplificar la programación asíncrona, PromiseKit. Es fácil de aprender, fácil de usar y resulta en un código más claro y legible.Para más detalles sobre esta sesión, consulta otra de mis publicaciones: Programación Asíncrona en Swift BuglifeBugLife es un framework abierto que ayuda a nuestros usuarios a enviar un informe de errores desde su teléfono, y aparece inmediatamente en nuestro panel de incidencias. Los mejores beneficios que encontré al usar BugLife son que es gratuito y fácil de integrar en nuestras aplicaciones sin esfuerzo.Para más detalles sobre cómo usar este framework, consulta otra de mis publicaciones: BugLife en la vida real MixpanelMixpanel es una biblioteca que nos ayuda a rastrear comportamientos de usuarios y otros eventos que ocurren en nuestras aplicaciones. Muchas empresas tecnológicas usan Mixpanel para analizar sus datos y conocer mejor a sus usuarios. A partir de los resultados, pueden tomar decisiones para mejorar su aplicación y satisfacer a los usuarios. Imagen 3. Los desarrolladores estaban asistiendo a un laboratorio para desarrolladores. Swift en el Servidor: Estado de la UniónEsta sesión describió el estado actual de Swift en el servidor y realizó algunas predicciones sobre lo que traerá el próximo año. Desafortunadamente, me quedé dormido en esta sesión así que no capté muchas ideas del ponente.Para más detalles sobre cómo usar este framework, consulta otra de mis publicaciones: Swift en el lado del servidor Arquitecturas iOS en Contexto¿Por qué tenemos que preocuparnos por elegir una arquitectura?Hoy en día tenemos tantas arquitecturas de software para elegir, que si no elegimos una arquitectura adecuada para nuestras aplicaciones, un día nos encontraremos incapaces de encontrar y corregir cualquier problema dentro de nuestras aplicaciones. Durante esta sesión, el ponente discutió sobre algunas arquitecturas iOS como MVC, MVP, MVVM, VIPER, etc. Con muchos años de experiencia trabajando en arquitecturas de software, evaluó tanto las ventajas como las desventajas una por una.Para mí, esta sesión fue bastante difícil de captar todas las ideas del ponente ya que no tengo mucha experiencia en diseño de arquitecturas de software. Después de eso, tuve que dedicar más tiempo a leer otros documentos y blogs técnicos para entender lo que dijo. Imagen 4. El ambiente alrededor de la conferencia Después de todo …Al final del segundo día, tuvimos una fiesta de Halloween en el salón del palacio. Esta es mi primera vez asistiendo a una conferencia tecnológica en un país líder en tecnología, EE.UU. Después de dos días asistiendo a la conferencia, he actualizado algunas nuevas tecnologías y también apliqué algunas tecnologías a proyectos en mi empresa. A decir verdad, hay algunas sesiones que son un poco aburridas y solo introductorias. Además, el jet lag me hizo sentir cansado así que no me concentré completamente en algunas sesiones. Eso es un arrepentimiento.Al final, ¡este sigue siendo el mejor viaje de todos! Imagen 5. Un viaje inolvidable","link":"/es/posts/Swift-Summit-conference-in-San-Francisco-2017/index.html"},{"title":"Notificaciones silenciosas","text":"En el mundo en constante evolucion del desarrollo de aplicaciones moviles, mantener a los usuarios comprometidos e informados es clave. Para los desarrolladores de iOS, las notificaciones en segundo plano son una herramienta poderosa que mejora la experiencia del usuario sin interrumpir sus actividades actuales. Pero, que son exactamente las notificaciones en segundo plano y como funcionan? Profundicemos en los detalles. Que son las notificaciones en segundo plano?Las notificaciones en segundo plano, o notificaciones silenciosas, son un tipo de notificacion en iOS que permite que las aplicaciones se activen y realicen tareas en segundo plano sin alertar al usuario con una notificacion visible. A diferencia de las notificaciones estandar que aparecen en la pantalla y requieren interaccion del usuario, las notificaciones en segundo plano estan disenadas para actualizar silenciosamente el contenido de la aplicacion o realizar operaciones en segundo plano. Estas notificaciones son particularmente utiles para aplicaciones que necesitan mantener los datos actualizados o realizar tareas periodicas sin molestar al usuario. Por ejemplo, una aplicacion del clima puede usar notificaciones en segundo plano para actualizar la informacion meteorologica, o una aplicacion de noticias puede obtener los ultimos articulos en segundo plano. Como funcionan las notificaciones en segundo plano?Las notificaciones en segundo plano dependen del Apple Push Notification Service (APNs), que es un servicio proporcionado por Apple que entrega notificaciones a dispositivos iOS. Aqui hay una descripcion simplificada de como funcionan: Registro de la aplicacion: La aplicacion se registra con APNs y recibe un token de dispositivo unico. Solicitud del servidor: El servidor de la aplicacion envia una solicitud de notificacion push a APNs, especificando el token del dispositivo e incluyendo el payload de la notificacion. Entrega de notificacion: APNs entrega la notificacion al dispositivo. Para las notificaciones en segundo plano, este payload incluye la clave content-available establecida en 1, indicando que la notificacion esta destinada a despertar la aplicacion en segundo plano. Activacion de la aplicacion: Al recibir una notificacion en segundo plano, iOS activa la aplicacion para manejar los datos o realizar tareas en segundo plano. Esto se hace sin mostrar ninguna alerta visual al usuario. Manejo de la notificacion: El codigo de la aplicacion procesa la notificacion en segundo plano, actualizando contenido o realizando acciones necesarias. Consideraciones clave Eficiencia y limitaciones: Las notificaciones en segundo plano deben usarse eficientemente para evitar el uso innecesario de bateria y recursos de red. iOS puede limitar la frecuencia y el tamano de las notificaciones en segundo plano para preservar el rendimiento del sistema y la vida de la bateria. Privacidad del usuario y permisos: Aunque las notificaciones en segundo plano no muestran alertas, todavia requieren permiso del usuario para recibir notificaciones. Asegurate de que tu aplicacion comunique claramente por que necesita este permiso. Manejo de tareas en segundo plano: Al manejar notificaciones en segundo plano, es crucial gestionar las tareas eficientemente. iOS proporciona APIs especificas para tareas en segundo plano para asegurar que las operaciones se completen de manera oportuna. Pruebas y depuracion: Probar notificaciones en segundo plano puede ser desafiante. Usa herramientas de depuracion y simuladores para probar diferentes escenarios y asegurar que tu aplicacion maneje las notificaciones como se espera. Casos de uso practicos Aplicaciones de noticias: Mantener a los usuarios actualizados con los ultimos titulares sin pedirles alertas. Aplicaciones de redes sociales: Actualizar feeds de contenido o notificar a la aplicacion sobre nuevos mensajes o solicitudes de amistad silenciosamente. Aplicaciones de productividad: Sincronizar datos o actualizar contenido en segundo plano para asegurar que los usuarios siempre tengan la informacion mas reciente cuando abran la aplicacion. ConclusionLas notificaciones en segundo plano en iOS son una caracteristica poderosa que mejora la funcionalidad y la experiencia del usuario de las aplicaciones moviles. Al permitir que las aplicaciones realicen tareas en segundo plano sin interrumpir al usuario, permiten interacciones mas fluidas y eficientes. Sin embargo, deben usarse de manera reflexiva para equilibrar el rendimiento, la vida de la bateria y la experiencia del usuario.Si estas desarrollando una aplicacion iOS, considera integrar notificaciones en segundo plano para proporcionar una experiencia mas dinamica y receptiva. Con la implementacion correcta, puedes mantener el contenido de tu aplicacion actualizado y a tus usuarios comprometidos, todo mientras mantienes una experiencia de usuario fluida e ininterrumpida.","link":"/es/posts/Silent-notification/index.html"},{"title":"Web Bluetooth","text":"¿Alguna vez has querido crear una aplicación web que permita a los usuarios comunicarse con tu dispositivo usando Bluetooth? Hasta la introducción de Web Bluetooth, esto solo era posible a través de aplicaciones móviles nativas. Sin embargo, con la llegada de Web Bluetooth ahora puedes convertir tu idea en realidad.Web Bluetooth es una tecnología revolucionaria que permite a los desarrolladores web conectar sus aplicaciones directamente a dispositivos Bluetooth, abriendo un amplio rango de posibilidades para IoT, wearables y otros dispositivos habilitados para Bluetooth. Al aprovechar el poder de Web Bluetooth, puedes crear aplicaciones web que pueden comunicarse con dispositivos sin la necesidad de una aplicación nativa separada.Así que si has estado soñando con crear una aplicación web que pueda interactuar con dispositivos Bluetooth, ahora es el momento de explorar las posibilidades de Web Bluetooth y llevar tus habilidades de desarrollo al siguiente nivel. ¿Qué es Web Bluetooth?Web Bluetooth es un conjunto de APIs que proporcionan la capacidad de conectar y realizar acciones como leer valores, escribir datos, escuchar notificaciones, etc. con periféricos BLE usando el Generic Attribute Profile (GATT). Esto puede habilitar un amplio rango de casos de uso, como controlar dispositivos IoT, sincronizar datos de fitness desde un smartwatch, o transferir datos entre un smartphone y una computadora.Web Bluetooth es soportado por varios navegadores web principales, incluyendo Chrome, Firefox y Opera, y también incluye un conjunto de protocolos estándar de la industria para comunicación segura y eficiente. Sin embargo, es importante notar que no todos los dispositivos Bluetooth pueden ser compatibles con Web Bluetooth, ya que el soporte para la tecnología varía entre diferentes dispositivos y fabricantes. Ventajas de Web Bluetooth Multiplataforma: Web Bluetooth permite a los desarrolladores crear aplicaciones web que pueden comunicarse con dispositivos Bluetooth en múltiples plataformas, incluyendo dispositivos de escritorio y móviles. Facilidad de uso: Web Bluetooth simplifica el proceso de conexión a dispositivos Bluetooth, reduciendo la necesidad de aplicaciones nativas complejas o software. Accesibilidad: Web Bluetooth permite a los desarrolladores web crear aplicaciones que pueden comunicarse con dispositivos Bluetooth sin requerir que los usuarios instalen aplicaciones separadas o plugins. Flexibilidad: Web Bluetooth puede usarse para conectar con un amplio rango de dispositivos Bluetooth, incluyendo dispositivos IoT, wearables y dispositivos domésticos inteligentes. Desventajas de Web Bluetooth Soporte de navegadores: Mientras que la mayoría de los navegadores modernos soportan Web Bluetooth, algunos navegadores antiguos pueden no ser compatibles. Seguridad: Web Bluetooth puede presentar riesgos de seguridad si no se implementa correctamente. Por ejemplo, si una aplicación tiene acceso al dispositivo Bluetooth de un usuario, puede ser capaz de acceder a otra información sensible en el dispositivo. Funcionalidad limitada: Web Bluetooth puede no ofrecer el mismo nivel de funcionalidad que las aplicaciones Bluetooth nativas. Esto puede limitar los tipos de aplicaciones que se pueden desarrollar usando la tecnología. Duración de batería: Bluetooth puede ser una tecnología intensiva en energía, lo que puede agotar la vida de la batería de dispositivos móviles. Los desarrolladores deben ser conscientes de esto al diseñar aplicaciones que dependen de la conectividad Bluetooth. APIs soportadasLas APIs soportadas por Web Bluetooth son similares a las disponibles en iOS y Android, lo que hace que sea sencillo trabajar con ellas para desarrolladores que ya están familiarizados con la tecnología Bluetooth en dispositivos móviles.Puedes revisar el flujo para establecer una conexión a un periférico en Play Central And Peripheral Roles With CoreBluetooth navigator.bluetooth.requestDevice(): Esta API se usa para solicitar acceso a un dispositivo BLE cercano. Cuando un usuario hace clic en un botón “Conectar” en tu aplicación web, esta API se llama para escanear dispositivos disponibles y presentar un cuadro de diálogo al usuario. 123456789101112131415161718192021222324/**// Discovery options match any devices advertising:// . The standard heart rate service. OR// . Service uuid0, and devices with name \"ExampleName1\", and devices with name starting with \"Prefix1\" OR// . Both service uuid1 and uuid2. OR// . Devices with name \"ExampleName2\". OR// . Devices with name starting with \"Prefix2\". OR//// And enables access to the battery service if devices// include it, even if devices do not advertise that service.**/const device = await navigator.bluetooth.requestDevice({ acceptAllDevices: true, filters: [ { services: [\"heart_rate\"] }, { services: [uuid0], name: \"ExampleName1\", namePrefix: \"Prefix1\" }, { services: [uuid1, uuid2] }, { name: \"ExampleName2\" }, { namePrefix: \"Prefix2\" } ], optionalServices: [ \"battery_service\", ],}); BluetoothDevice.gatt.connect(): Esta API se usa para establecer una conexión con el servidor GATT en el dispositivo BLE seleccionado. Una vez que se establece una conexión, tu aplicación web puede interactuar con los servicios y características del dispositivo. 1const server = await device.gatt.connect(); BluetoothDevice.gatt.disconnect(): Esta API se usa para desconectar del dispositivo BLE una vez que la interacción se ha completado. 1const server = await device.gatt.disconnect(); Obtener servicios y características:BluetoothDevice.gatt.getPrimaryService(serviceUuid): Esta API se usa para recuperar un servicio primario del servidor GATT en el dispositivo BLE seleccionado.BluetoothRemoteGATTService.getCharacteristic(characteristicUuid): Esta API se usa para recuperar una característica específica de un servicio. 12345const services = await server.getPrimaryServices();services.forEach(async (e) =&gt; { const chars = await e.getCharacteristics(); // Doing your logic}); Leer y escribir valores:BluetoothRemoteGATTCharacteristic.readValue(): Esta API se usa para leer el valor de una característica.BluetoothRemoteGATTCharacteristic.writeValue(value): Esta API se usa para escribir un valor a una característica. 1234await char.writeValue( fromHexString(value));await char.readValue(); Escuchar evento disconnected: Este listener de eventos se activa cuando el dispositivo se desconecta del servidor GATT. 123device.addEventListener('gattserverdisconnected', () =&gt; { // Your callback}); Escuchar cambio de valor: Este listener de eventos se activa cuando el valor de una característica cambia. Esto puede usarse para recibir actualizaciones en tiempo real del dispositivo. 123device.addEventListener('characteristicvaluechanged', () =&gt; { // Your callback}); Escuchar notificaciones 12await char.stopNotifications();await char.startNotifications(); Un ejemplo simpleEn Web Bluetooth example, he creado un sitio web simple que muestra un conjunto de APIs. Este sitio web de demostración proporciona a los desarrolladores una interfaz fácil de usar para probar y entender la funcionalidad de las APIs. Al acceder a este sitio web de demostración, los desarrolladores pueden obtener rápidamente información sobre cómo las APIs pueden integrarse en sus aplicaciones. Por defecto, la web escanea todos los dispositivos cercanos. Para escanear dispositivos específicos con uuid predefinido, selecciona Filters e ingresa tu uuid de servicio en el cuadro de filtro. Aquí está la UI después de que la conexión se ha establecido exitosamente. Más ejemplosPuedes encontrar más ejemplos e ideas a través de este video WebBluetooth demos for Bluetooth.rocks from Niels Leenheer on Vimeo. Limitaciones Por propósitos de seguridad, no podemos escanear y conectar automáticamente a un dispositivo específico. El usuario decide si la aplicación web tiene permiso para conectarse, y a qué dispositivo tiene permiso para conectarse. Conexión HTTPS: Web Bluetooth requiere una conexión HTTPS segura para funcionar correctamente. Esto significa que la aplicación web debe estar alojada en un servidor seguro con un certificado SSL válido. Si la aplicación no está alojada en un servidor seguro, el usuario no podrá conectarse a dispositivos Bluetooth. Plataformas: Web Bluetooth es soportado en Chrome en escritorio y móvil (Requiere Android 6+, no soporta iOS), Opera, y algunas versiones de Microsoft Edge. Es importante notar que Web Bluetooth puede no funcionar en navegadores antiguos u obsoletos. Personalización: Desafortunadamente, no es posible personalizar el diálogo de escaneo de Web Bluetooth para mostrar información adicional más allá de las opciones predeterminadas. La API de Web Bluetooth está diseñada para proporcionar una interfaz simple y consistente para desarrolladores, y el diálogo de escaneo se mantiene intencionalmente simple para mantener esta simplicidad. Rendimiento: Es ampliamente reconocido que la estabilidad de las conexiones Bluetooth en aplicaciones nativas de Android a menudo no es tan confiable como en iOS, y puede verse afectada por factores como el modelo del teléfono, el fabricante y la versión de Android que se está usando. Como resultado, es importante notar que Web Bluetooth no funciona tan bien como las aplicaciones nativas, especialmente en dispositivos Android. Consejos y mejores prácticasAquí hay algunos consejos y mejores prácticas para optimizar el rendimiento de las aplicaciones Web Bluetooth: Minimiza las transferencias de datos: La comunicación Bluetooth es lenta comparada con otros canales de comunicación. Por lo tanto, es importante minimizar la cantidad de datos que tu aplicación envía y recibe a través de Bluetooth. Por ejemplo, puedes reducir el número de operaciones de lectura y escritura y solo transferir los datos necesarios para tu aplicación. Usa notificaciones en lugar de polling: En lugar de consultar continuamente el valor de una característica, usa notificaciones para recibir actualizaciones cuando el valor cambie. Este enfoque puede reducir el número de operaciones de lectura y mejorar el rendimiento de tu aplicación. Desconéctate cuando no esté en uso: Desconéctate del servidor GATT cuando no estés comunicándote activamente con el dispositivo. Esto puede reducir el consumo de energía y mejorar la vida de la batería del dispositivo. Usa caché: El caché puede usarse para almacenar datos que son accedidos frecuentemente por tu aplicación. Esto puede reducir el número de operaciones de lectura y mejorar el rendimiento de tu aplicación. Optimiza el proceso de escaneo: Escanear dispositivos puede ser una operación intensiva en recursos. Por lo tanto, es importante optimizar el proceso de escaneo reduciendo el tiempo de escaneo y filtrando los resultados para incluir solo dispositivos relevantes. Prueba tu aplicación en diferentes dispositivos: Prueba tu aplicación en diferentes dispositivos para asegurar que funcione bien en diferentes plataformas y configuraciones de hardware. Reflexión finalA pesar de estas limitaciones, Web Bluetooth sigue siendo una tecnología prometedora con muchos casos de uso potenciales. Los desarrolladores que estén interesados en usar Web Bluetooth deben considerar cuidadosamente estas limitaciones y diseñar sus aplicaciones en consecuencia. Referencias https://www.smashingmagazine.com/2019/02/introduction-to-webbluetooth/ https://googlechrome.github.io/samples/web-bluetooth/","link":"/es/posts/Web-Bluetooth/index.html"},{"title":"WWDC 2020 - Principales razones por las que una aplicacion es terminada en segundo plano","text":"Alguna vez te has preguntado por que tu aplicacion es terminada por el sistema cuando entra en segundo plano? Este articulo va a resumir las principales razones introducidas por Apple en WWDC 2020, y lo que puedes hacer para evitar que tu aplicacion sea terminada en segundo plano. Al aplicar estos consejos, podemos mejorar la experiencia de nuestra aplicacion porque no tendra que reiniciarse desde cero.Comencemos! Principales razonesA continuacion se describen las 6 principales razones por las que tu aplicacion es terminada mientras esta en segundo plano: Crashes: Fallo de segmentacion, instrucciones ilegales, asserts y excepciones no capturadas. Watchdog:Un bloqueo prolongado durante las transiciones de la aplicacion como deadlock, bucle infinito o tareas sincronas interminables en el hilo principal. En aproximadamente 20 segundos, tu aplicacion debe transicionar de un estado a otro. De lo contrario, sera terminada. 123+ application(_:didFinishLaunchingWithOptions)+ applicationDidEnterBackground(_:)+ applicationWillEnterForeground(_:) Uso excesivo de CPU:Alta carga de CPU sostenida en segundo plano. Si tu aplicacion realmente necesita hacer trabajos pesados en segundo plano, deberias considerar mover la tarea a una tarea de procesamiento en segundo plano que le da a tu aplicacion varios minutos de ejecucion mientras se carga sin limites de recursos de CPU. Limite de memoria excedido:Tu aplicacion esta usando demasiada memoria (igual en segundo plano y primer plano). Recuerda que la limitacion difiere de dispositivo a dispositivo. Antes del iPhone6s, 200M es la limitacion de memoria (Cuanto mas antiguo, mas pequeno). Salida por presion de memoria (tambien conocido como Jetsam):Ocurre cuando el sistema necesita liberar memoria de aplicaciones en segundo plano para las aplicaciones en primer plano (y otras aplicaciones en ejecucion como musica o aplicacion de navegacion). Para prevenir esto, intenta reducir la memoria lo mas pequena posible, menos de 50M (por ejemplo, limpiar vistas de imagenes). Sin embargo, no podemos eliminar el riesgo de jetsam por completo. El mejor consejo para superarlo es aprovechar la State Restoration de UI incorporada para restaurar el estado de la aplicacion justo antes de que fuera terminada en segundo plano. El siguiente video describe como ocurre Jetsam en dispositivos iOS. Digamos que abrimos la aplicacion de Amazon para comprar, luego seleccionamos un articulo favorito para ver su detalle. Digamos que tenemos que dejar la aplicacion en segundo plano por un momento, luego comenzamos a abrir otras aplicaciones (Google Maps, Musica, Fotos, Spotify, etc.). En algun momento, abrimos la aplicacion de Amazon de nuevo. Como notamos, la aplicacion se inicia desde cero. Esto es porque la aplicacion fue terminada por el sistema. Obviamente, la aplicacion de Amazon no hizo nada mal, es solo porque el sistema necesita liberar memoria para otras aplicaciones que estan ejecutandose en primer plano. Tiempo de espera de tarea en segundo plano:La ultima razon comun es usar tareas en segundo plano incorrectamente. 12UIApplication.beginBackgroundTask(exprirationHandler:)UIApplication.endBackgroundTask(_:) Cuando tu aplicacion pasa de primer plano a segundo plano, y quieres completar algunas tareas importantes, iOS te proporciona algo de tiempo de ejecucion extra (solo unos segundos) llamando al metodo UIApplication.beginBackgroundTask. Cuando la tarea esta terminada, recuerda llamar a UIApplication.endBackgroundTask para notificar al sistema que la tarea esta hecha. Si olvidas llamar a endBackgroundTask explicitamente, el tiempo de espera se activara 30 segundos despues de suspender la aplicacion, y ocurrira la terminacion. Por lo tanto, debes manejar cuidadosamente las tareas en segundo plano y no iniciar ningun trabajo costoso adicional cuando tu aplicacion entre en modo de segundo plano porque solo tenemos unos segundos de tiempo de ejecucion. Mientras depuras, XCode generara un mensaje de log para notificar si hay una tarea que se ha mantenido demasiado tiempo sin terminar. Cuando veas este mensaje, debes hacer una auditoria para ver que salio mal con las llamadas de tareas en segundo plano. 12345678Background task still not ended after expiration handlers were called: &lt;_UIBackgroundTaskInfo: 0x28190d140&gt;: taskID = 8, taskName = Called by AppGetKilled,from $s12AppGetKilled13SceneDelegateC23sceneDidEnterBackgroundyySo7UISceneCF, creationTime = 70784 (elapsed = 26).This app will likely be terminated by the system. Call UIApplication.endBackgroundTask(_:) to avoid this.Background Task 5 (\"Called by AppGetKilled, from $s12AppGetKilled13SceneDelegateC23sceneDidEnterBackgroundyySo7UISceneCF\"),was created over 30 seconds ago.In applications running in the background, this creates a risk of termination.Remember to call UIApplication.endBackgroundTask(_:) for your task in a timely manner to avoid this. ConclusionEn este articulo, resumi las 6 principales razones por las que una aplicacion puede ser terminada en segundo plano, como podemos hacer para prevenir los problemas, y como recuperar la aplicacion elegantemente de problemas impredecibles como Jetsam.Puedes encontrar el documento completo y video en WWDC 2020 - Why is my app getting killed","link":"/es/posts/WWDC-2020-Top-reasons-why-app-get-killed-in-background/index.html"},{"title":"Que es refactoring?","text":"","link":"/es/posts/What-is-refactoring/index.html"},{"title":"Reseña del libro: Swift Apprentice - Raywenderlich","text":"Mientras buscaba un libro para mejorar mis habilidades de desarrollo iOS, encontré este libro Swift Apprentice en la tienda de libros de Raywenderlich. Después de echar un vistazo rápido al contenido del libro, decidí agregarlo a mi biblioteca.En general, si tu nivel de iOS es intermedio o senior, y estás muy seguro de tu dominio de habilidades de programación, este libro no es para ti. Pero si estás buscando un libro para fortalecer tu conocimiento, o solo quieres asegurarte de que todo lo que entiendes sobre el lenguaje Swift es correcto - como fue mi propósito, entonces lleva este libro contigo.Aprenderás sobre cosas muy básicas como funciones, métodos, constantes, sentencias de control, etc. También tendrás la oportunidad de obtener conocimiento profundo sobre la asignación de Stack/Heap, programación orientada a protocolos y programación genérica, lo cual hace tu trabajo diario más conveniente, y te encontrarás como un maestro en el lenguaje Swift.¡Empecemos! Sobre el autorPara aquellos que no saben quién es Raywenderlich, es un sitio comunitario enfocado en crear tutoriales y libros de programación (principalmente enfocado en desarrollo móvil en Android e iOS). Su contenido cubre todos los niveles desde temas para principiantes hasta avanzados.A menudo accedo al sitio de Raywenderlich para obtener código de ejemplo y para mantener mi conocimiento actualizado. Sus tutoriales son extremadamente geniales, técnicamente precisos y están actualizados a las tecnologías más nuevas.Swift Apprentice es uno de su colección de programación iOS. Puntos clave Propiedad lazy: Si tienes una propiedad que podría tomar algo de tiempo calcular, no quieres ralentizar las cosas hasta que realmente necesites la propiedad, usa la propiedad almacenada lazy. Es útil para cosas como descargar la foto de perfil de un usuario o hacer un cálculo serio. El heap vs. el stack:El Stack se usa para almacenar cualquier cosa en el hilo de ejecución inmediato; está administrado y optimizado por la CPU. Cuando una función crea una variable, el stack almacena esa variable y luego la destruye cuando la función termina. Como el stack está tan estrictamente organizado, es muy eficiente, y por lo tanto bastante rápido.El heap, por otro lado, se usa para almacenar instancias de tipos de referencia. El heap es generalmente un gran conjunto de memoria del cual el sistema puede solicitar y asignar dinámicamente bloques de memoria. El tiempo de vida es flexible y dinámico. No destruye automáticamente sus datos (el stack sí lo hace). Se requiere trabajo adicional para liberar la memoria en el Heap, lo que hace que crear y eliminar datos en el heap sea un proceso más lento, comparado con el stack.Cuando se crea una instancia de una clase, tu código solicita un bloque de memoria en el heap para almacenar la instancia misma.Cuando se crea una instancia de un struct (que no es parte de una instancia de una clase), la instancia misma se almacena en el stack, y el heap nunca está involucrado. Cuándo usar una clase versus un struct: Valores vs. objetos: Usa estructuras como valores y clases como objetos con identidad. Para hacerlo simple, solo ten en cuenta que no hay dos objetos que se consideren iguales simplemente porque tienen el mismo estado. En contraste, las instancias de tipos de valor, que son valores, se consideran iguales si son el mismo valor. Por ejemplo, no se consideran iguales dos estudiantes, incluso si tienen el mismo nombre; Dos puntos (x, y) son iguales si x1 e y1 son iguales a x2 e y2, respectivamente, así que implementamos Point como un struct.Velocidad: Si estas instancias solo existirán en memoria por un corto tiempo — ve hacia usar un struct. Si tu instancia tendrá un ciclo de vida más largo en memoria, piensa en una clase.Otro enfoque es usar solo lo que necesitas. Si tus datos nunca cambiarán o necesitas un almacén de datos simple, entonces usa estructuras. Si necesitas actualizar tus datos y necesitas que contengan lógica para actualizar su propio estado, entonces usa clases. A menudo, es mejor empezar con un struct. Si necesitas las capacidades adicionales de una clase en algún momento posterior, entonces simplemente convierte el struct en una clase. Inicialización en dos fases:• Fase uno: Inicializa todas las propiedades almacenadas en la instancia de la clase, desde el fondo hasta la cima de la jerarquía de clases. Si usas propiedades y métodos antes de que la fase uno esté completa, el compilador lanzará errores.• Fase dos: Ya podemos usar propiedades y métodos del objeto. Protocolos en la Biblioteca Estándar: Equatable, Comparable, Hashable, CustomStringConvertible. Parámetros de función genéricos:123func swapped&lt;T, U&gt;(_ x: T, _ y: U) -&gt; (U, T) { (y, x)} Patrón wildcard:1234if case (_, 0, 0) = coordinate { // x puede ser cualquier valor. y y z deben ser exactamente 0. print(\"On the x-axis\") // Printed!} Patrón de vinculación de valores:123if case let (x, y, 0) = coordinate { print(\"On the x-y plane at (\\(x), \\(y))\") // Printed: 1, 0} Patrón de type-casting “Is”:12345switch element { case is String: print(\"Found a string\") default: break} Rethrows: Al usar rethrows en lugar de throws, las funciones indican que solo relanzarán errores lanzados por las funciones llamadas dentro de sí mismas pero nunca errores propios. Beneficios de la orientación a protocolos:Al usar protocolos en lugar de implementaciones, nos enfocamos en lo que el objeto puede hacer en lugar de cómo lo hace, lo que hace la aplicación más extensible y testeable.Herencia múltiple: Uno de los verdaderos beneficios de los protocolos es que permiten una forma de herencia múltiple. Swift es un lenguaje orientado a protocolos. Lo que me gusta Bien organizado. Ejemplos reales: Hay ejemplos para cada tema para asegurar que los lectores entiendan profundamente lo que acaban de mencionar. Fácil de entender: Como el contenido está bien organizado, es fácil seguir el flujo del contenido. Detente y piensa: Hay ejercicios cortos y desafíos a lo largo del libro para darte algo de práctica de programación y probar tu conocimiento en el camino. Puntos clave: Resumen los puntos clave al final de cada capítulo. Lo que no me gustaIntenté revisar el libro varias veces para encontrar algo que no me guste pero no hay nada de qué quejarse, desde el contenido hasta la forma. En generalSwift es divertido y está lleno de paradigmas de programación. Después de leer este libro, espero que ahora te sientas lo suficientemente cómodo con el lenguaje para pasar a construir cosas más grandes. Con los fundamentos del lenguaje que hemos ganado, estamos listos para explorar frameworks avanzados como Animation, UIKit, etc. para construir apps iOS, apps macOS y más.Espero que encuentres este libro interesante.¡Feliz fin de semana!","link":"/es/posts/Review-book-Swift-Apprentice-Raywenderlich/index.html"},{"title":"¿Qué hay de nuevo de App Clip en iOS 17?","text":"Con la introducción de iOS 17, las aplicaciones ahora tienen la capacidad de lanzar App Clips desde otras apps usando la URL de invocación del App Clip. Esta funcionalidad abre varias posibilidades. Por ejemplo, si has desarrollado un conjunto de aplicaciones, puedes permitirles lanzar App Clips entre sí, proporcionando a los usuarios acceso a funcionalidades específicas sin la necesidad de una instalación completa de la app. Además, tu app podría extender la oferta de lanzar App Clips de otros desarrolladores si tus flujos de trabajo involucran interacciones con esas apps. Este enfoque colaborativo mejora la conveniencia del usuario, permitiéndoles navegar sin problemas entre apps y aprovechar diversas funcionalidades. La interconectividad fomentada por esta característica promueve una experiencia más integrada y centrada en el usuario dentro del ecosistema iOS. https://developer.apple.com/videos/play/wwdc2023/10178/","link":"/es/posts/What-s-new-of-Appclip-on-iOS-17/index.html"},{"title":"Hola Mundo","text":"¡Bienvenido al blog de Uy Nguyen!Me encanta escribir, así que construí este sitio para escribir cualquier estupidez tontería cosa de mi vida, mi trabajo o cualquier cosa relacionada con la Ingeniería de Software. De esta manera, recuerdo estos temas por más tiempo. También quiero compartir lo que aprendí con cualquiera que lo necesite.No dudes en enviarme un correo electrónico si necesitas contactarme. “Sé un Ingeniero de Software, no un Programador.” - Uy Nguyen","link":"/es/posts/hello-world/index.html"},{"title":"Trabajando con Thread Safe en iOS","text":"Como ya sabes, el termino “Thread safe” se refiere a un concepto de ciencias de la computacion en el contexto de programas multi-hilo. Un codigo se llama “Thread safe” si cualquier dato compartido es accedido por solo un hilo en cualquier momento dado. Ten en cuenta que estos datos compartidos se llaman secciones criticas en un sistema operativo.El punto es que los tipos de coleccion de Swift como Array y Dictionary no son thread-safe cuando se declaran como mutables (con la palabra clave var).En esta publicacion, discutiremos algunas tecnicas para hacer nuestro codigo thread safe en iOS. Caso de estudioDigamos que tenemos un array que contiene datos cruciales. En la realidad, puede ser una cantidad de dinero en una tarjeta de credito, estados de transacciones, etc. Son realmente importantes, asi que si no protegemos estos valores con precision, enfrentaremos errores significativos en tiempo de ejecucion.Para simular una condicion de carrera, voy a usar DispatchQueue.concurrentPerform para crear 10 hilos concurrentes ejecutandose al mismo tiempo. 12345678910111213class ViewController: UIViewController { var array = [Int]() override func viewDidAppear(_ animated: Bool) { super.viewDidAppear(animated) // Do any additional setup after loading the view, typically from a nib. DispatchQueue.concurrentPerform(iterations: 10) { index in self.array.append(index) } } // The rest of code} El resultado del codigo anterior es impredecible. Caeras en 2 casos: La mayoria de las veces que ejecutes este codigo, obtendras un error en tiempo de ejecucion como esteEl problema fundamental es porque las colecciones de Swift como Array y Dictionary no son thread-safe pero dejamos que multiples hilos modifiquen el array al mismo tiempo. Stackoverflow Si tienes suerte de no obtener este error, los elementos del array se veran aleatorios como esto:Element count 5Element count 9Element count 10El punto es que no siempre obtenemos 10 elementos como se esperaba. Como sucedio esto?No es seguro dejar que un hilo modifique el valor mientras otro lo esta leyendo. SolucionesLa forma de evitar condiciones de carrera es sincronizar los datos, o las secciones criticas. Sincronizar datos generalmente significa “bloquearlos” para que solo un hilo pueda acceder a esa parte del codigo a la vez.Como Swift no soporta soluciones de concurrencia incorporadas, vamos a usar Grand Central Dispatch para implementar thread safe en su lugar. Usando cola serialAprovechando las colas seriales, podemos prevenir condiciones de carrera en un recurso. Como introduje como funciona una cola serial en una publicacion anterior, Grand-Central-Dispatch-in-Swift, una cola serial permite que solo un proceso se ejecute a la vez, por lo que el array esta protegido de procesos concurrentes. 123456789101112131415161718class SafetyArray&lt;T&gt; { var array = [T]() let serialQueue = DispatchQueue(label: \"com.uynguyen.queue\") var last: T? { var result: T? self.serialQueue.sync { result = self.array.last } return result } func append(_ newElement: T) { self.serialQueue.async() { self.array.append(newElement) } } } Aunque protegemos el array de ser accedido por multiples hilos, usar una cola serial no es la mejor solucion. Leer el ultimo valor no esta optimizado porque multiples solicitudes de lectura tienen que esperar unas a otras ya que estan en una cola serial. Las lecturas deberian poder ocurrir concurrentemente, siempre y cuando no hagamos una escritura al mismo tiempo. Usando cola concurrente con la bandera barrierLa idea principal de esta solucion es usar una cola concurrente en lugar de una cola serial.Swift nos permite despachar un bloque de codigo a una cola concurrente con una bandera llamada barrier. La bandera barrier asegura que la cola concurrente no ejecute ninguna otra tarea mientras ejecuta el proceso barrier. Una vez que el proceso barrier termina, entonces la cola permite ejecutar otras tareas simultaneamente por implementacion predeterminada. 123456789101112131415161718class SafeArray&lt;T&gt; { var array = [T]() let concurrentQueue = DispatchQueue(label: \"com.uynguyen.queue\", attributes: .concurrent) var last: T? { var result: T? self.concurrentQueue.sync { result = self.array.last } return result } func append(_ newElement: T) { self.concurrentQueue.async(flags: .barrier) { self.array.append(newElement) } } } Continuamos usando el metodo sync para leer el ultimo elemento, pero todos los lectores se ejecutaran en paralelo esta vez ya que estamos usando una cola concurrente. El compromisoTrabajar con multiples hilos es una parte dificil de la programacion. Aunque tenemos que proteger las secciones criticas de accesos multiples, debemos tener en cuenta que *”Manten las secciones sincronizadas lo mas pequenas posible porque los bloqueos crean retrasos y agregan sobrecarga. Son costosos”*. Clean code.Algunos consejos para lidiar con la concurrencia: La concurrencia no siempre mejora el rendimiento. A veces incurre en algo de sobrecarga y los errores que vienen de ella no suelen ser repetibles. Limita el acceso de los datos que se comparten entre mas de dos hilos. Usa copias de datos si hay una oportunidad. El codigo multihilo se comporta diferente en diferentes entornos: Ejecuta pruebas en cada entorno de despliegue potencial. Pensamientos finalesThread safe es uno de los conceptos mas importantes en ciencias de la computacion, especialmente en un sistema que permite acceder a datos simultaneamente. Entender como hacer el codigo thread safe nos permite evitar errores serios que ocurren en tiempo de ejecucion.Feliz programacion.","link":"/es/posts/Working-In-Thread-Safe-on-iOS/index.html"},{"title":"iOS 18: ¿Qué hay de nuevo en CoreBluetooth?","text":"AccessorySetupKit, introducido en iOS 18, revoluciona la forma en que los accesorios Bluetooth y Wi-Fi de terceros se integran con dispositivos iOS. Este framework ofrece una experiencia de configuración fluida, mejorando la comodidad para los usuarios y expandiendo las capacidades para los desarrolladores.Mientras que AccessorySetupKit soporta el descubrimiento de dispositivos Bluetooth, Wi-Fi y de Red Local, esta publicación se enfocará específicamente en BLE (Bluetooth Low Energy). El proceso de configuración para dispositivos Wi-Fi y de Red Local sigue un enfoque similar. Características principalesA continuación, exploraremos las funcionalidades clave que hacen de AccessorySetupKit un cambio importante para la gestión de accesorios. Proceso de Emparejamiento Simplificado: Los usuarios ahora pueden emparejar o desemparejar accesorios y activar Bluetooth directamente dentro de la aplicación, eliminando la necesidad de ir a la configuración del sistema. Este enfoque simplificado mejora la experiencia del usuario y reduce el tiempo de configuración. Gestión de Acceso Unificada: Una vez que un accesorio está emparejado, aparece en la nueva sección “Accesorios” dentro de la configuración de Privacidad. Aquí, los usuarios pueden gestionar permisos y ver dispositivos conectados, proporcionando una ubicación centralizada para la gestión de accesorios. Control Mejorado para Desarrolladores: Los desarrolladores pueden definir filtros de escaneo y proporcionar imágenes y nombres personalizados para dispositivos, asegurando una experiencia de configuración con marca. Flujo de configuraciónPuedes encontrar el proyecto de ejemplo proporcionado por Apple en WWWDC24.Para simular los accesorios, usé CoreBluetooth y definí mi perfil Bluetooth con dos UUIDs diferentes: 1FA2FD8A-17E0-4D3B-AF45-305DA6130E39 y 1FA2FD8A-17E0-4D3B-AF45-305DA6130E38, luego comencé a anunciarlos.A continuación, necesitas modificar el servicio UUID de escaneo en tu archivo Info.plist para que coincida con tus perfiles Bluetooth. Esto informa al sistema sobre los tipos de accesorios que tu aplicación soporta.Apple soporta diferentes tipos de filtros, como: 123456789101112131415161718&lt;dict&gt; &lt;key&gt;NSAccessorySetupBluetoothCompanyIdentifiers&lt;/key&gt; &lt;array&gt; #Matches the key of an advertised manufacturing data field &lt;/array&gt; &lt;key&gt;NSAccessorySetupBluetoothServices&lt;/key&gt; &lt;array&gt; #Matches either an advertised service UUID field or the key (service UUID) of an advertised service data field &lt;/array&gt; &lt;key&gt;NSAccessorySetupBluetoothNames&lt;/key&gt; &lt;array&gt; #Match any substring within the advertised name &lt;/array&gt; &lt;key&gt;NSAccessorySetupKitSupports&lt;/key&gt; &lt;array&gt; &lt;string&gt;Bluetooth&lt;/string&gt; &lt;/array&gt;&lt;/dict&gt; A continuación, crea una ASAccessorySession. Esta sesión es esencial para gestionar el proceso de configuración de accesorios, permitiéndote presentar el selector de accesorios a los usuarios y manejar varios eventos relacionados con accesorios de manera eficiente. 1private var session = ASAccessorySession() Luego, presenta el Accessory Picker. Esto te permite mostrar la interfaz del selector, permitiendo a los usuarios seleccionar y emparejar fácilmente sus accesorios con la aplicación. 123456789101112131415161718192021222324252627let pickerDevice1: ASPickerDisplayItem = { let descriptor = ASDiscoveryDescriptor() descriptor.bluetoothServiceUUID = ### return ASPickerDisplayItem( name: ###, productImage: UIImage(named: ###)!, descriptor: descriptor )}()let pickerDevice2: ASPickerDisplayItem = { let descriptor = ASDiscoveryDescriptor() descriptor.bluetoothServiceUUID = ### return ASPickerDisplayItem( name: ###, productImage: UIImage(named: ###)!, descriptor: descriptor )}()session.showPicker(for: [pickerDevice1, pickerDevice2]) { error in if let error { print(\"Failed to show picker due to: \\(error.localizedDescription)\") }} El usuario ahora verá una lista de dispositivos descubiertos y puede seleccionar uno para comenzar el proceso de emparejamiento, siguiendo el flujo estándar. 1234567891011121314151617private func handleSessionEvent(event: ASAccessoryEvent) { switch event.eventType { case .accessoryAdded, .accessoryChanged: guard let device = event.accessory else { return } # Save your device case .activated: guard let device = session.accessories.first else { return } # Save your device case .accessoryRemoved: # Clean up case .pickerDidPresent: # Your logic case .pickerDidDismiss: # Your logic default: ### }} ¿Qué es importante?AccessorySetupKit simplifica el proceso de configuración para los usuarios, haciéndolo más intuitivo y eficiente mientras elimina la complejidad frecuentemente asociada con la conexión de accesorios de terceros.Para los desarrolladores, proporciona un framework de integración estandarizado, asegurando experiencias de usuario consistentes y bases de código simplificadas. Al adoptar AccessorySetupKit, los desarrolladores pueden ofrecer una experiencia fluida y cohesiva que alinea los accesorios de terceros con los altos estándares que los usuarios asocian con los productos Apple. ReferenciasMeet AccessorySetupKit, WWWDC 2024iOS 18 AccessorySetupKit: Everything BLE Developers Need To Know","link":"/es/posts/iOS-18-What-s-news-in-CoreBluetooth/index.html"},{"title":"Concurrencia Avanzada en iOS: Operations [1]","text":"Hay dos tecnicas para manejar la Concurrencia en iOS: GCD - Grand Central Dispatch y Operations. La mayoria del tiempo, GCD proporciona la mayoria de las capacidades de concurrencia que necesitas. Sin embargo, a veces querras algunas personalizaciones avanzadas adicionales. Es hora de usar Operations. Este tutorial introducira Operations en Swift, tambien explicara cuando y por que usar Operation en lugar de GCD.Cambiemos de marcha! Hay una gran brecha entre conocer el camino y recorrerlo. Introduccion a OperationsOperation es una clase que te permite enviar un bloque de codigo que deberia ejecutarse en un hilo diferente, esta construida sobre GCD. Basicamente, tanto GCD como Operation tienen roles similares. Sin embargo, Operations tienen otros beneficios que nos dan mas control sobre la tarea. Diseno OOP: como Operation es una clase de Swift, puedes crear subclases y sobrescribir sus metodos si es necesario. Sera facil de usar y reutilizar en el futuro. Gestion de estados: Una Operation tiene su propia maquina de estados que cambia durante su ciclo de vida. La operacion misma maneja los cambios de sus estados. No podemos modificar estos estados de un objeto. Dependencia entre operaciones: Si quieres iniciar una tarea despues de que otras tareas hayan terminado de ejecutarse, entonces Operation deberia ser tu eleccion. Una operacion no comenzara a ejecutarse hasta que todas las operaciones de las que depende hayan terminado exitosamente sus trabajos. Cancelar la tarea enviada: Al usar Operations, tenemos la capacidad de cancelar una operacion en ejecucion. Es muy util en un caso donde queremos detener operaciones que son irrelevantes en un momento determinado. Por ejemplo, para cancelar la descarga de datos cuando el usuario desplaza la tabla haciendo que algunas celdas desaparezcan. La dependencia y la capacidad de cancelar hacen que las Operations sean mucho mas controlables que GCD. Llevemoslo a la practicaSupongamos que estamos construyendo una aplicacion que obtendra algunas de mis publicaciones. Despues de descargar las imagenes de portada, se les aplicara un filtro simple, luego se mostraran en una table view.Adelante, crea un proyecto. El proyecto simplemente contiene solo una pantalla principal con una table view que muestra publicaciones con un titulo y una imagen de portada. Para simplificar la fuente de datos, cree un archivo JSON que contiene 100 filas describiendo una publicacion con clave como titulo y valor como la URL vinculada a la imagen de portada. 123456789[ // input.json {\"Building your personal page with Hexo\": \"https://uynguyen.github.io/Post-Resources/Hexo/Cover.png\"}, {\"Beta Test and TestFlight\": \"https://uynguyen.github.io/Post-Resources/TestFlight/Cover.png\"}, {\"iOS: Mix and Match\": \"https://uynguyen.github.io/Post-Resources/MixMatch/mix-match-banner.png\"}, {\"Best practice: Core Data Concurrency\": \"https://uynguyen.github.io/Post-Resources/CoreDataConcurrency/banner.png\"}, {\"Two weeks at Fossil Group in the US\": \"https://uynguyen.github.io/Post-Resources/Fossil_Group/Fossil_Group.jpg\"}, ...] Dentro del MainViewController, leamos el archivo de entrada 12345678910111213141516171819202122class ViewController: UIViewController { @IBOutlet weak var tbPosts: UITableView! var urls = [(title: String, url: String)]() override func viewDidLoad() { super.viewDidLoad() self.setup() // ... } func setup() { let inputUrl = Bundle.main.url(forResource: \"input\", withExtension: \"json\")! do { let data = try Data(contentsOf: inputUrl) if let jsonDict = try JSONSerialization.jsonObject(with: data) as? [[String: String]] { self.urls = jsonDict.map { ($0.first!.key, $0.first!.value) } } } catch { } } Usando una funcion simple de CoreImage, el metodo grayScale(input:) transformara una UIImage a una imagen en blanco y negro con el filtro Tonal 12345678910111213141516171819func grayScale(input: UIImage) -&gt; UIImage? { let context = CIContext(options: nil) var inputImage = CIImage(image: input) let filters = inputImage!.autoAdjustmentFilters() for filter: CIFilter in filters { filter.setValue(inputImage, forKey: kCIInputImageKey) inputImage = filter.outputImage } let cgImage = context.createCGImage(inputImage!, from: inputImage!.extent) let currentFilter = CIFilter(name: \"CIPhotoEffectTonal\") currentFilter!.setValue(CIImage(image: UIImage(cgImage: cgImage!)), forKey: kCIInputImageKey) let output = currentFilter!.outputImage let cgimg = context.createCGImage(output!, from: output!.extent) return UIImage(cgImage: cgimg!)} Es hora de configurar la table view, usamos URLSession para descargar la imagen desde la URL de entrada, luego mostrarla en la celda despues de descargarla exitosamente. 1234567891011121314151617181920extension ViewController: UITableViewDataSource { // The rest omitted func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell { let cell = tableView.dequeueReusableCell(withIdentifier: \"CellId\", for: indexPath) as! PostTableViewCell let input = urls[indexPath.row] URLSession.shared.dataTask(with: URL(string: input.url)!, completionHandler: { (data, res, error) in guard error == nil, let data = data, let image = UIImage(data: data) else { return } DispatchQueue.main.async { cell.lblPostTitle.text = input.title cell.imgPostImage.image = self.grayScale(input: image) } }).resume() return cell }} Compila y ejecuta el proyecto, deberias ver las imagenes aparecer en la lista. Intentemos desplazar la tabla. Puedes sentir el lag?Podrias notar de donde viene el problema. Para configurar una celda, primero descargamos la imagen de internet, luego aplicamos un filtro Tonal a la imagen. Estas dos acciones se estan realizando en el hilo principal, poniendo demasiada presion en el hilo que solo deberia usarse para la interaccion del usuario. Usando GCDPodemos despachar el codigo de descarga y filtrado de imagen a otra cola separada 12345678910111213DispatchQueue.global(qos: .background).async { URLSession.shared.dataTask(with: URL(string: input.url)!, completionHandler: { (data, res, error) in guard error == nil, let data = data, let image = UIImage(data: data) else { return } let filteredImage = self.grayScale(input: image) DispatchQueue.main.async { cell.lblPostTitle.text = input.title cell.imgPostImage.image = filteredImage } }).resume()} Al ejecutar el codigo en una cola de fondo, descargamos trabajo de la cola principal y hacemos la UI mucho mas receptiva.Recompila el proyecto, veras las diferencias.Aunque resolvemos el problema de interaccion del usuario, el rendimiento de la app todavia no esta optimizado.Que se puede hacer para mejorar esto?A medida que el usuario desplaza la tabla, las celdas van y vienen. No tiene sentido continuar descargando y procesando una imagen de una celda invisible. Es mejor cancelar el bloque de codigo para mejorar el rendimiento y reducir el consumo de bateria de la app. Pero como podemos cancelar una tarea que se esta ejecutando en GCD?Aqui es donde entra Operation. Cambiemos a OperationDividamos la tarea de configurar una celda de table view en dos tareas: una es descargar la imagen y otra es aplicar el filtro. 12345678910111213141516171819class DownloadImageOperation: Operation { let url: URL var outputImage: UIImage? init(url: URL) { self.url = url } override func main() { guard !isCancelled else { return } URLSession.shared.dataTask(with: self.url, completionHandler: { (data, res, error) in guard error == nil, let data = data else { return } self.outputImage = UIImage(data: data) }).resume() }} 123456789101112131415161718192021222324252627282930313233343536class ImageFilterOperation: Operation { let context = CIContext(options: nil) var processedImage: UIImage? func grayScale(input: UIImage) -&gt; UIImage? { var inputImage = CIImage(image: input) let filters = inputImage!.autoAdjustmentFilters() for filter: CIFilter in filters { filter.setValue(inputImage, forKey: kCIInputImageKey) inputImage = filter.outputImage } let cgImage = context.createCGImage(inputImage!, from: inputImage!.extent) let currentFilter = CIFilter(name: \"CIPhotoEffectTonal\") currentFilter!.setValue(CIImage(image: UIImage(cgImage: cgImage!)), forKey: kCIInputImageKey) let output = currentFilter!.outputImage let cgimg = context.createCGImage(output!, from: output!.extent) return UIImage(cgImage: cgimg!) } override func main() { guard !isCancelled else { return } let dependencyImage = self.dependencies .compactMap { $0 as? DownloadImageOperation } .first if let image = dependencyImage?.outputImage { guard !isCancelled else { return } self.processedImage = self.grayScale(input: image) } }} Para usar Operation, simplemente creamos una subclase de la clase Operation y sobrescribimos el metodo main donde se coloca nuestra tarea. Por defecto, las operaciones se ejecutan en segundo plano, asi que no hay preocupaciones sobre bloquear el hilo principal.Volviendo a la tarea de configurar la celda de table view, podrias notar que hay una dependencia entre estas dos tareas, solo hacemos el proceso de filtrado despues de descargar la imagen. En otras palabras, la operacion ImageFilterOperation depende de la operacion DownloadImageOperation. Las Dependencias de Operaciones es una de las “funciones estrella” de Operation junto con la capacidad de cancelar una operacion en ejecucion. Al vincular las dos operaciones, aseguramos que la operacion dependiente no comience antes de que la operacion prerequisito se haya completado. Adicionalmente, el vinculo crea una forma limpia de pasar datos de la primera a la segunda. 1234e.glet dependencyImage = self.dependencies .compactMap { $0 as? DownloadImageOperation } .first Es hora de hacer la mejora.Primero definamos un OperationQueue en el ViewController. La clase OperationQueue es lo que usamos para gestionar Operations. 123456789101112131415161718192021222324class ViewController: UIViewController { private let queue = OperationQueue() // The rest omiited // ... func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell { let cell = tableView.dequeueReusableCell(withIdentifier: \"CellId\", for: indexPath) as! PostTableViewCell let input = urls[indexPath.row] let downloadOpt = DownloadImageOperation(url: URL(string: input.url)!) let grayScaleOpt = ImageFilterOperation() grayScaleOpt.addDependency(downloadOpt) grayScaleOpt.completionBlock = { DispatchQueue.main.async { cell.lblPostTitle.text = input.title cell.imgPostImage.contentMode = .scaleToFill cell.imgPostImage.image = grayScaleOpt.processedImage } } self.queue.addOperation(downloadOpt) self.queue.addOperation(grayScaleOpt) return cell }} Aqui, inicializamos dos nuevas instancias de las clases DownloadImageOperation e ImageFilterOperation. Luego, establecemos que la operacion grayScaleOpt depende de downloadOpt lo que asegurara que grayScaleOpt solo se ejecute despues de que downloadOpt se haya completado. Finalmente, agregamos estas dos operaciones al OperationQueue. Una vez que una operacion se agrega a la cola, la operacion sera programada. Si la cola encuentra un hilo disponible en el cual ejecutar la operacion, el trabajo se ejecutara hasta que se complete o sea cancelado. Cuando la operacion se completa, se llama al completionBlock. “Las operaciones tienen efectos importantes en el rendimiento de tu aplicacion. Por ejemplo, si quieres descargar mucho contenido de Internet, podrias querer hacerlo solo cuando sea absolutamente necesario. Tambien, podrias decidir asegurar que solo un numero especifico de operaciones puedan ejecutarse al mismo tiempo. Si decides limitar el numero de operaciones concurrentes en una cola, puedes cambiar la propiedad maxConcurrentOperationCount de tu cola de operaciones. Esta es una propiedad entera que te permite especificar cuantas operaciones, como maximo, pueden ejecutarse en una cola en un momento dado.” (iOS 8 Swift Programming Cookbook) Aprender las teorias anteriores es suficiente, ahora recompila el proyecto para ver el resultado. Ops! Nada aparece, la imagen no se descargo! Algo salio mal ???En el siguiente tutorial, descubriremos que paso con nuestro codigo y por que Operation no funciono correctamente como se esperaba.Gracias por leer.","link":"/es/posts/iOS-Concurrency-Operations/index.html"},{"title":"iOS: Introduccion a Stack Views Programaticamente","text":"A medida que tu habilidad de desarrollo iOS crece, creo que usas UIScrollView, UICollectionView, UITableView y otras vistas nativas regularmente y con competencia en tus aplicaciones. Sin embargo, algunos desarrolladores iOS todavia no saben que es exactamente UIStackView, para que se usa o en que situacion debemos usar UIStackView.En este tutorial, te presentare UIStackView - Una vista que nos ayuda a simplificar nuestros layouts de iOS. Imaginemos que vas a construir una aplicacion que permite al usuario agregar o eliminar vistas en tiempo de ejecucion. Recuerdas como lograremos esta tarea? Primero tenemos que eliminar todas las constraints en el area relativa y actualizarlas todas de nuevo. O recuerda el caso donde implementas la vista de inicio de sesion / registro, agregas muchos campos de texto y estableces constraints manualmente entre esas vistas. En tales situaciones, UIStackView parece ser mas util que otras vistas. Para demostrar como aplicar UIStackView a tus proyectos, vamos a construir una aplicacion simple que permite al usuario controlar dispositivos inteligentes en su hogar; Los usuarios pueden agregar o eliminar que habitacion quieren que se muestre en su lista de control. La clave principal aqui es que todas las acciones del usuario se ejecutan en tiempo de ejecucion dinamicamente. Adicionalmente, en lugar de usar Storyboard en este proyecto, voy a usar codigo dinamicamente junto con la ayuda del framework AutoLayout (SnapKit - es solo una cuestion de preferencia). Dejemos de lado otras implementaciones complejas, la aplicacion contiene solo dos vistas: Una vista de inicio de sesion y una pagina principal. Ademas, no habra codigo de logica en absoluto. Propiedades clavePara entender como funciona un Stack View, primero necesitamos echar un vistazo a sus propiedades. Sin importar que tipo de Stack View sea (Horizontal o Vertical), hay cuatro propiedades principales: Axis, Spacing, Alignment y Distribution. La siguiente imagen resume la relacion entre esos atributos. Axis: determina la orientacion del stack, incluyendo Horizontal y Vertical. Spacing: determina el espacio minimo entre las vistas del stack. Alignment: determina el layout de las vistas del stack perpendicular a su eje.Tanto los stack views horizontales como verticales tienen las opciones Fill y Center. Fill: Las vistas organizadas del Stack se redimensionaran para que se ajusten al stack view perpendicularmente a su eje. Los bordes leading y trailing de los elementos apilados verticalmente o los bordes superior e inferior de los horizontales, respectivamente. Center: Como su nombre sugiere, centra las vistas del stack horizontalmente (Stack vertical) o verticalmente (Stack horizontal). Fill Center Hay algunas opciones de alignment que aplican solo para stack views horizontales: Top: Como su nombre sugiere, centra las vistas del stack horizontalmente (Stack vertical) o verticalmente (Stack horizontal). Bottom: Como su nombre sugiere, centra las vistas del stack horizontalmente (Stack vertical) o verticalmente (Stack horizontal). First baseline: Un layout donde el stack view alinea sus vistas organizadas basandose en su primera linea base. Last baseline: Un layout donde el stack view alinea sus vistas organizadas basandose en su ultima linea base. Top Bottom First baseline Last baseline Similarmente, hay algunas opciones de alignment que funcionan solo para stack views verticales: Leading: El stack view alinea el borde leading (Izquierdo) de sus vistas organizadas a lo largo de su borde leading. Similar al alignment top para stacks horizontales. Trailing: El stack view alinea el borde trailing (Derecho) de sus vistas organizadas a lo largo de su borde leading. Similar al alignment bottom para stacks horizontales. Leading Trailing Distribution: determina el layout de las vistas del stack a lo largo de su eje. Las subvistas se redimensionan basandose en esta configuracion. Fill: Este se establece como la distribucion predeterminada cuando se crea un Stack View. Cuando ponemos vistas dentro de un UIStackView con Fill establecido como distribucion, seguira intentando estirar el tamano de una de las vistas para llenar el espacio.Entonces la pregunta es, en que criterio se basara para elegir la vista a redimensionar? Content Hugging Priority (CHP) sera. Para determinar que vista se estirara, el stack view se basara en CHP para la evaluacion, cuanto menor sea su prioridad, mas probable es que sea elegida. Si todas las vistas tienen el mismo CHP, se elegira la primera. Fill Equally: Cada control en un UIStackView sera de igual tamano. Fill Proportionally: Todos los controles necesitan tener un tamano de contenido intrinseco, Stack view asegurara que los controles mantengan la misma proporcion. Equal Spacing: Este tipo de distribucion mantendra un espaciado igual entre las subvistas. Equal Centering: Este tipo de distribucion mantendra un espacio igual entre el centro de las subvistas. Fill Fill Equally Fill Proportionally Equal Spacing Equal Centering Nota: UIStackView es una vista sin renderizado, lo que significa que no puedes establecer la propiedad background-color, o sobrescribir el metodo draw, etc. Llevemoslo a la practicaAhora, con ese conocimiento en mente, vamos a aplicarlo a un proyecto existente que actualmente no usa UIStackView para organizar su vista en absoluto. Al aplicar UIStackView en la practica, realmente entenderemos como funciona un UIStackView y que problemas puede resolver. Auto organizar vistasLo primero que UIStackView nos trae es la libertad de establecer constraints para todas las vistas.La vista de inicio de sesion es bastante simple, contiene dos campos de texto, un boton de inicio de sesion y algunas etiquetas de texto. Sin usar UIStackView, tenemos que establecer constraints manualmente para todos esos campos de texto. 12345678910111213141516171819view.addSubview(lblLogin)lblLogin.snp.makeConstraints { (make) in make.centerX.equalToSuperview() make.centerY.equalToSuperview().offset(-250) make.left.equalToSuperview().offset(20) make.right.equalToSuperview().offset(-20) make.height.equalTo(30)}view.addSubview(lblUsername)lblUsername.snp.makeConstraints { (make) in make.centerX.left.right.equalTo(lblLogin) make.top.equalTo(lblLogin.snp.bottom).offset(30) make.height.equalTo(30)}view.addSubView(btnLogin)//...// The rest omitted Pero todavia no es una pesadilla. Imagina que ahora quieres agregar algunas otras vistas, como una etiqueta y una vista switch para permitir al usuario recordar la sesion de inicio de sesion. Ahora tenemos que alterar todas las otras vistas para insertar esas nuevas vistas en el lugar correcto en la pantalla! La tarea sera mas facil y simple si usamos StackView. Ahora veamos como podemos hacerlo.Primero, agreguemos una nueva propiedad al controlador de vista de inicio de sesion. 12345678910111213lazy var stackView: UIStackView = { let stack = UIStackView() stack.axis = .vertical stack.spacing = 20.0 stack.alignment = .fill stack.distribution = .fillEqually [self.lblUsername, self.txtUserName, self.lblPassword, self.txtPassword, self.btnLogin].forEach { stack.addArrangedSubview($0) } [1] return stack}() Observa en [1], asi es como agregamos vistas organizadas a un stack view. Luego, solo necesitamos establecer constraints para el stackView. 12345678910override func viewDidLoad() { super.viewDidLoad() // ... view.addSubview(stackView) stackView.snp.makeConstraints { (make) in make.centerX.left.right.equalTo(lblLogin) make.top.equalTo(lblLogin.snp.bottom).offset(30) make.height.equalTo(280) }} En el futuro, si queremos agregar nuevas vistas, solo necesitamos ponerlas en el array de vistas organizadas. Como se muestra a continuacion. 123456789lazy var keepLoginStackView: UIStackView = { let stackView = UIStackView() stackView.axis = .horizontal stackView.alignment = .trailing stackView.distribution = .fill [self.lblRememberMe, self.swKeepLogin].forEach { stackView.addArrangedSubview($0) } return stackView}() 12345// ...self.txtPassword,self.keepLoginStackView,self.btnLogin].forEach { stack.addArrangedSubview($0) }// ... Puedes ver las diferencias? El codigo base ahora es mas limpio y mantenible que el anterior, no es asi? Vistas dinamicasAhora cambiemos al caso donde implementaremos la pagina principal de la aplicacion.Cuando el usuario presiona el boton derecho de la pantalla, una nueva vista, que representa una habitacion a controlar en este caso, se colocara en la pagina principal. El usuario tambien puede eliminar cualquier habitacion en la lista presionando el boton “Remove”. Dentro de cada habitacion, hay un boton “Hide” / “Show” que permite ocultar y mostrar la imagen de la habitacion. Recuerda en el pasado donde tenias que implementar una caracteristica similar en tu app sin usar UIStackView, que harias? Algo doloroso! Primero necesitamos eliminar todas las constraints en el area relativa y actualizarlas todas de nuevo. Aqui esta lo que vamos a hacer con UIStackView, la pagina principal contiene un stack view vertical embebido dentro de un scroll view. Cuando se presiona el boton Add, una nueva vista TaskView se agregara a este stack view. 1234567func addMoreView() { let view = TaskView(delegate: self, data: room[Int.random(in: 0..&lt;room.count)]) let constraint1 = view.heightAnchor.constraint(lessThanOrEqualToConstant: 400.0) constraint1.isActive = true self.taskStackView.addArrangedSubview(view) self.view.layoutIfNeeded()} Tambien necesitamos establecer constraints de altura para esta nueva vista. Debido a que la altura de la vista podria cambiar cuando se presiona el boton show/hide, necesitamos definir esta constraint como lessThanOrEqualToConstant:value para que el stack view pueda ajustar esta constraint de altura. 12345678910func onRemove(_ view: TaskView) { if let first = self.taskStackView.arrangedSubviews.first(where: { $0 === view }) { UIView.animate(withDuration: 0.3, animations: { first.isHidden = true first.removeFromSuperview() }) { (_) in self.view.layoutIfNeeded() } }} Cuando se hace clic en el boton remove en una vista de tarea, esta vista se eliminara del stack view. Podemos acceder a todas las vistas organizadas de un stack view accediendo a la propiedad arrangedSubviews. Primero iteramos por todas las vistas organizadas y encontramos la vista apropiada que tiene la misma direccion que el emisor, luego la eliminamos de la super vista. Adicionalmente, hago una pequena animacion, UIView.animate(withDuration:animations:), para que la transicion se vea mas suave y elegante que la anterior.Usando el mismo enfoque, puedes hacer lo mismo cuando el usuario hace clic en el boton Show / Hide para mostrar/ocultar la vista de imagen. Intentalo por ti mismo. Pensamiento finalEn este tutorial, te presente UIStackView - una subclase de UIView que ayuda a gestionar la posicion y el tamano de sus vistas organizadas. Tambien trabajamos a traves de una demostracion que lleva UIStackView a la practica. Ahora que tienes la idea de como funciona UIStackView y para que se usa, las proximas veces intenta usar UIStackView en tu app para aprovechar su poder. Yo lo hare, y tu?Puedes descargar la demo completa en Github,Feliz programacion!","link":"/es/posts/iOS-Introducing-Stack-Views/index.html"},{"title":"¿Qué hay de nuevo en iPad OS 14?","text":"Para ver las #5 principales actualizaciones en iPadOS 14.","link":"/es/posts/What-s-new-in-iPad-OS-14/index.html"},{"title":"iOS: Mix and Match","text":"A medida que Swift se ha convertido en un lenguaje insignia para el desarrollo iOS, la mayoria de los nuevos proyectos iOS hoy en dia se construyen en Swift. Sin embargo, hay muchas bibliotecas utiles que estan desarrolladas en otros lenguajes de programacion de bajo nivel como Objective-C y/o C++ para impulsar el rendimiento. Por otro lado, no todas las posiciones de ingenieria estan abiertas a nuevos proyectos, la mayoria de ellos son contratados para mantener y desarrollar nuevas caracteristicas basadas en el codigo base actual que esta construido en Objective-C.Tener el conocimiento para mezclar los dos lenguajes dentro de un solo proyecto es bueno para tus habilidades de desarrollo iOS ya que lo enfrentaras algun dia en tu trayectoria profesional. En esta publicacion, te mostrare no solo como usar Objective-C y Swift en un solo proyecto sino tambien como usar un conjunto de lenguajes de programacion en uno solo, incluyendo C++/ Objective-C/ Swift y React Native. Espero que encuentres esta publicacion interesante.Entremos en materia. C++ &lt;- Objective-C++Para aquellos que no han oido hablar de Objective-C++,Objective-C++ es en realidad un codigo fuente que mezcla clases de Objective-C y clases de C++ en un solo archivo.Solo necesitas cambiar tu archivo .m a .mm para que la magia funcione.Primero, creare una biblioteca de C++ que sera usada por clases de Objective-C++. 1234class CPlusPlusMath { public: int multiplyTwoNumbers(int a, int b);}; La implementacion 123int CPlusPlusMath::multiplyTwoNumbers(int a, int b) { return a * b;} Luego, necesitas crear un archivo bridging header para tu proyecto porque nuestro nuevo proyecto esta en lenguaje Swift. El bridging header es donde defines todas las clases de Objective-C que estan expuestas a Swift. Cuando agregamos una nueva clase de Objective-C al proyecto basado en codigo Swift, XCode automaticamente ofrece agregar este archivo al proyecto.A continuacion, renombras el archivo .m a .mm para cambiarlo de codigo Objective-C a Objective-C++.De ahora en adelante, puedes llamar a nuestra biblioteca de C++ (u otras) dentro de este archivo Objective-C++ 12345678#import \"CPlusPlusMath.hpp\"@implementation ObjMath- (long)multiplyTwoNumbers:(int) num1 num2:(int) num2 { CPlusPlusMath *a = new CPlusPlusMath(); return a-&gt;multiplyTwoNumbers(num1, num2);} Objective-C++ &lt;-&gt; SwiftLo interesante es que podemos llamar codigo Objective-C(++) desde codigo Swift y viceversa.Para usar clases de Objective-C desde Swift, necesitamos declarar sus headers en el archivo bridging header. Adelante e incluyamos nuestra biblioteca matematica en este archivo. 12345//// Use this file to import your target's public headers that you would like to expose to Swift.//#include \"ObjMath.h\" Eso es todo lo que necesitas hacer para construir la primera linea desde Objective-C a Swift. 1234func multiply(num1: Int, num2: Int) -&gt; Int { let objMath = ObjMath() return objMath.multiplyTwoNumbers(Int32(num1), num2: Int32(num2))} A continuacion, necesitamos construir la otra linea desde Swift a Objective-C.Usamos la palabra clave objc antes de cualquier clase y metodo que queramos exponer a clases de Objective-C. Una pequena nota es que estas clases expuestas necesitan heredar de la clase NSObject. De lo contrario, obtendremos el error de compilacion Only classes that inherit from NSObject can be declared @objc. 123456789@objcclass SwifthMath: NSObject { @objc func add(num1: Int, num2: Int) -&gt; Int { return num1 + num2 } // The rest omited} Swift &lt;-&gt; React NativePor favor encuentra mi serie en React Native y BLE Limitaciones Los objetos Swift pueden tener una subclase de una clase de Objective-C, como NSObject. Pero una clase de Swift no puede ser una clase base para una clase de Objective-C. Solucion de problemasConclusionesMuchos desarrolladores todavia usan Objective-C por muchas razones, y definitivamente usan bibliotecas de C++ en sus proyectos, especialmente en el desarrollo de juegos donde C++ alcanza todo su rendimiento.Espero que esta publicacion te de una vision rapida de como mezclar y combinar multiples lenguajes en un solo proyecto.Puedes encontrar el proyecto de demostracion en GithubGracias por leer.","link":"/es/posts/iOS-Mix-and-Match/index.html"},{"title":"Dos semanas en Fossil Group en EE.UU.","text":"La semana pasada, tuve la oportunidad de visitar EE.UU. nuevamente.","link":"/es/posts/Two-weeks-at-Fossil-Group-in-the-US/index.html"},{"title":"ANCS: Apple Notification Center Service","text":"Lời mở đầuANCS, viết tắt của Apple Notification Center Service, được thiết kế bởi Apple. Nó cho phép các phụ kiện Bluetooth kết nối với thiết bị iOS qua BLE một cách đơn giản để truy cập các thông báo xảy ra trên thiết bị iOS. Chi tiết kỹ thuật","link":"/vi/posts/ANCS-Apple-Notification-Center-Service/index.html"},{"title":"iOS Concurrency Nâng Cao: Async Operations [2]","text":"Trong bài viết trước, iOS Concurrency Nâng Cao: Operations, chúng ta đã đi qua các khái niệm về Operation trên iOS và xây dựng một ứng dụng demo để tải một số bài viết của tôi. Sau khi tải các hình ảnh bìa, chúng sẽ được áp dụng một filter đơn giản, sau đó được hiển thị trong table view. Tuy nhiên, ứng dụng vẫn chưa hoàn thiện. Có điều gì đó không đúng với ứng dụng của chúng ta khiến nó không hiển thị đúng các hình ảnh đã tải. Trong hướng dẫn này, chúng ta sẽ tiếp tục từ nơi đã dừng lại.Sẵn sàng nào! Vòng đời của OperationĐể tìm ra tại sao ứng dụng của chúng ta không hoạt động đúng, hãy xem lại mã nguồn hiện tại 123456789101112class DownloadImageOperation: Operation { override func main() { guard !isCancelled else { return } URLSession.shared.dataTask(with: self.url, completionHandler: { (data, res, error) in guard error == nil, let data = data else { return } self.outputImage = UIImage(data: data) }).resume() }} Hình ảnh sau mô tả các thay đổi về trạng thái của operation. Khi phương thức main được gọi, nó sẽ thực thi tác vụ bất đồng bộ của chúng ta và sau đó thoát ngay lập tức khiến trạng thái của operation chuyển sang isFinish. Tại thời điểm đó, tác vụ bất đồng bộ của chúng ta thực sự chưa hoàn thành.Hiện tại, chúng ta đang gọi tải hình ảnh bên trong phương thức main của Operation. Nguyên nhân gốc rễ liên quan đến chính Vòng đời của Operation. Do đó, để hỗ trợ các operation bất đồng bộ trong ứng dụng, chúng ta cần quản lý thủ công các trạng thái của operation. Key-Value ObservingTrước khi triển khai class Async Operation tùy chỉnh, chúng ta cần học một khái niệm mới trước: KVO. Tôi giả định rằng bạn chưa nghe về khái niệm này nên chúng ta sẽ có một cái nhìn nhanh về nó trước.Key-Value Observing, hay KVO, là một trong những kỹ thuật để theo dõi sự thay đổi trạng thái của một đối tượng trong Objective-C và Swift. Bất cứ khi nào giá trị của các thuộc tính được theo dõi thay đổi, khối mã theo dõi sẽ được thực thi. Cốt lõi của KVO dựa trên Observer Pattern.Các class Swift được kế thừa từ class NSObject có các phương thức cho phép các đối tượng khác theo dõi các thuộc tính của chúng. Key-value observing cung cấp một cơ chế cho phép các đối tượng được thông báo về sự thay đổi của các thuộc tính cụ thể của các đối tượng khác. Nó đặc biệt hữu ích cho việc giao tiếp giữa các lớp model và controller trong một ứng dụng. Hãy tạo một Playground để kiểm tra. 1234567891011121314151617181920212223242526272829class CreditCard: NSObject { @objc dynamic private(set) var number: Int = 1000 func increaseNumber(by value: Int) { self.number += value }}class Person: NSObject { let cretdit: CreditCard var kvoToken: NSKeyValueObservation? init(cretdit: CreditCard) { self.cretdit = cretdit kvoToken = self.cretdit.observe(\\.number, options: .new) { (credit, change) in guard let newNumber = change.newValue else { return } print(\"New number is \\(newNumber)\") } } deinit { kvoToken?.invalidate() }}let credit = CreditCard()let person = Person(cretdit: credit)credit.increaseNumber(by: 500) Ở đây, tôi định nghĩa hai class: CreditCard và Person. Một đối tượng Person giữ một đối tượng CreditCard như một thuộc tính. Điều tôi muốn là bất cứ khi nào thuộc tính number của thẻ tín dụng thay đổi, người đó sẽ được thông báo. Đây là lúc KVO xuất hiện.Chạy đoạn code trên trong playground, bạn sẽ thấy log New number is \\(newNumber) được in ra console. Tại sao chúng ta cần biết về KVO? Câu trả lời là vì class Operation sử dụng thông báo KVO. Bất cứ khi nào trạng thái của Operation thay đổi, một thông báo KVO sẽ được gửi đi.Không có thông báo KVO, OperationQueue sẽ không thể theo dõi trạng thái của các operation để cập nhật chính xác. Do đó, khi chúng ta tự quản lý trạng thái của operation, chúng ta phải đảm bảo các thông báo KVO đó được gửi đúng cách. Async OperationHãy tạo class AsyncOperation kế thừa từ class Operation. 12345678910class AsyncOperation: Operation { enum State: String { case ready, executing, finished var keyPath: String { return \"is\\(rawValue.capitalized)\" } } // Phần còn lại của code} Tiếp theo, chúng ta khai báo một thuộc tính để theo dõi trạng thái của đối tượng. 12345678910var state = State.ready { willSet { willChangeValue(forKey: newValue.keyPath) willChangeValue(forKey: state.keyPath) } didSet { didChangeValue(forKey: oldValue.keyPath) didChangeValue(forKey: state.keyPath) }} Class cơ sở Operation cần biết sự thay đổi của cả trạng thái cũ và mới.Lấy một trường hợp cụ thể làm ví dụ, trạng thái hiện tại là ready, sau đó chúng ta đặt trạng thái thành executing. Có 4 thông báo KVO nên được gửi: Đầu tiên, thông báo willChangeValue cho isReady. Sau đó, thông báo willChangeValue cho executing. Tiếp theo, thông báo willChange cho isReady. Cuối cùng, thông báo willChange cho executing. Sau đó, chúng ta override các thuộc tính của trạng thái. 123456789101112131415override var isReady: Bool { return super.isReady &amp;&amp; state == .ready}override var isExecuting: Bool { return state == .executing}override var isFinished: Bool { return state == .finished}override var isAsynchronous: Bool { return true} Đó là tất cả để quản lý trạng thái của class Async Operation. Khi thêm một operation vào operation queue, phương thức start là thứ được gọi đầu tiên. sau đó nó sẽ gọi phương thức main của operation để thực thi khối code chính mà bạn đã gán cho operation. 1234override func start() { main() state = .executing} Bạn còn nhớ khi tôi đề cập rằng Operation có các tính năng tuyệt vời khiến nó vượt trội hơn GCD? Tính năng đầu tiên là dependencies và tính năng còn lại là khả năng hủy một operation đang chạy. Nó rất hữu ích trong trường hợp chúng ta muốn dừng các operation không còn liên quan tại một thời điểm nhất định. Ví dụ, hủy tải dữ liệu khi người dùng cuộn table khiến một số cell biến mất.Hãy thêm tính năng này vào class Async Operation của chúng ta.Đầu tiên, chúng ta cần sửa đổi phương thức start để kiểm tra thuộc tính isCancelled trước khi thực sự gọi phương thức main. 123456789override func start() { if isCancelled { state = .finished return } main() state = .executing} Và sau đó override phương thức cancel để cập nhật trạng thái thành finished 123override func cancel() { state = .finished} Tại thời điểm này, chúng ta đã hoàn thành việc triển khai class Async Operation. Đã đến lúc kết hợp mọi thứ lại với nhau trong ứng dụng. Kết hợp tất cả lại với nhauVì class DownloadImageOperation thực thi bất đồng bộ, chúng ta không thể đặt class Operation làm class cơ sở của nó, giờ chúng ta đặt AsyncOperation thay thế. Xin lưu ý rằng để hỗ trợ việc hủy trong class DownloadImageOperation, chúng ta sẽ giữ giá trị trả về của việc tạo data task như một thuộc tính của class này để có thể hủy URLSessionDataTask này sau.Class DownloadImageOperation sẽ trông như dưới đây. 123456789101112131415161718192021222324252627282930class DownloadImageOperation: AsyncOperation { let url: URL var outputImage: UIImage? private var task: URLSessionDataTask? init(url: URL) { self.url = url } override func main() { self.task = URLSession.shared.dataTask(with: self.url, completionHandler: { [weak self] (data, res, error) in guard let `self` = self else { return } defer { self.state = .finished } guard !self.isCancelled else { return } guard error == nil, let data = data else { return } self.outputImage = UIImage(data: data) }) task?.resume() } override func cancel() { super.cancel() task?.cancel() }} Hãy quay lại ViewController chính của chúng ta. Để hủy các operation đang chạy, trước tiên chúng ta thêm dictionary mới như một thuộc tính của ViewController để theo dõi tất cả các operation đang chạy cho mỗi cell của table view tại index path tương ứng. 1private var operations: [IndexPath: [Operation]] = [:] Bên trong delegate func tableView(_ tableView:cellForRowAt indexPath:), sau khi thêm hai operation vào operation queue, chúng ta cũng sẽ thêm chúng vào dictionary operations để theo dõi. Ngoài ra, nếu có operation cho index path này, hủy nó trước khi giữ cái mới. 123456if let existingOperations = operations[indexPath] { for operation in existingOperations { operation.cancel() }}operations[indexPath] = [grayScaleOpt, downloadOpt] Khi người dùng cuộn table, một số cell biến mất và delegate func tableView(_ tableView:didEndDisplaying cell:indexPath:) được gọi. Tại thời điểm đó, chúng ta cũng sẽ hủy các operation đang chạy cho cell đó để đảm bảo rằng chỉ các operation của các cell hiển thị mới đang thực thi. 1234567func tableView(_ tableView: UITableView, didEndDisplaying cell: UITableViewCell, forRowAt indexPath: IndexPath) { if let operations = operations[indexPath] { for operation in operations { operation.cancel() } }} Bây giờ, bạn sẽ thấy ứng dụng hoạt động đúng. Ngoài ra, bằng cách bắt đầu và hủy các operation một cách thông minh, chúng ta đang tiết kiệm lưu lượng mạng cũng như giảm tiêu thụ pin. Những điều này có thể giúp ứng dụng của chúng ta chạy nhanh hơn. Kết luậnCó một số lợi ích của Operation so với GCD giúp mã nguồn của chúng ta dễ bảo trì và tái sử dụng.Cuối cùng cần đề cập, hãy cẩn thận khi sử dụng Operation hoặc GCD vì Concurrency đôi khi tạo ra các bug không phải lúc nào cũng rõ ràng để tìm và sửa. Trong Clean Code Book, Robert C. Martin nêu ra một số điểm quan trọng khi làm việc với nhiều thread Có một số định nghĩa cơ bản chúng ta nên biết khi nói về concurrency và thread: Bound resources, mutual exclusion, starvation, deadlock, và livelock. Concurrency không phải lúc nào cũng cải thiện hiệu suất. Đôi khi nó tạo ra một số overhead và các bug từ nó thường không lặp lại được. Hạn chế việc truy cập dữ liệu được chia sẻ giữa nhiều hơn hai thread. Sử dụng bản sao của dữ liệu nếu có thể. Giữ các phần synchronized càng nhỏ càng tốt vì Lock tạo ra độ trễ và thêm overhead. Chúng rất tốn kém. Code đa luồng hoạt động khác nhau trong các môi trường khác nhau: Chạy test trong mọi môi trường triển khai tiềm năng. Bạn có thể tìm thấy dự án hoàn chỉnh qua linkCảm ơn bạn đã đọc. Tài liệu tham khảo Chapter 6: Operations, Concurrency By Tutorials - Multithreading in Swift with GCD and Operations, Raywenderlich, Chapter 7: Concurrency and Multitasking, iOS 8 Swift Programming Cookbook, O’Reilly.","link":"/vi/posts/Advanced-iOS-Concurrency-Async-Operations-2/index.html"},{"title":"Tất Tần Tật Về Alamofire","text":"Nếu bạn từng có cơ hội làm việc với networking trên iOS, chắc chắn bạn đã nghe về Alamofire, một thư viện networking được viết bằng Swift cho iOS và MacOS. Nó đơn giản hóa tất cả các công việc networking phổ biến trong ứng dụng của bạn.Nếu bạn chưa gặp Alamofire, đừng lo, hướng dẫn này sẽ giới thiệu cho bạn tất cả các tác vụ mà Alamofire có thể xử lý cho bạn. Nếu bạn đã quen thuộc với nó, không sao, hãy coi bài viết này như một bản tóm tắt và tập trung cho cẩm nang Alamofire của bạn.Hãy bắt đầu nào! Sắp ra mắt! Xây dựng server của riêng bạnThiết kế tầng networkingDependencies SwiftyJSON, một thư viện hỗ trợ xử lý dữ liệu JSON. [SnapKit][https://github.com/SnapKit/SnapKit], Autolayout dựa trên Swift. Chủ đề nâng caoSuy nghĩ cuối cùng","link":"/vi/posts/All-About-Alamofire/index.html"},{"title":"Best practice: Core Data Concurrency","text":"Một số ứng dụng có thể tồn tại mà không cần bất kỳ bộ lưu trữ dữ liệu nào. Tuy nhiên, hầu hết các ứng dụng hữu ích khác đều lưu một số trạng thái như cấu hình người dùng, hồ sơ người dùng, mục tiêu, v.v. Trên iOS, Apple cung cấp Core Data như một framework để lưu trữ dữ liệu quý giá của bạn. Một điều cần lưu ý là mặc dù CoreData có thể lưu trữ dữ liệu trong cơ sở dữ liệu quan hệ nhưng thực tế nó không phải là một database engine.Trong bài hướng dẫn này, tôi sẽ chia sẻ với bạn một trải nghiệm tồi tệ tôi gặp phải khi làm việc với Core Data. Hy vọng rằng sau khi đọc chia sẻ của tôi, bạn sẽ tránh được vấn đề tương tự trong các dự án của mình.Hãy bắt đầu. Ba thành phần chính của core data stackTrước hết, tôi sẽ liệt kê ba thành phần chính của core data stack, bạn có thể hoặc không quen thuộc với các thuật ngữ này nhưng tốt hơn hết là hiểu sâu về core data stack trước khi đào sâu hơn.Core Data API, còn được gọi là stack, bao gồm ba thành phần chính: NSManagedObjectModel: Data model mô tả một entity (đối tượng). NSManagedObjectContext: Các object khi được fetch từ persistent storage được đặt trong managed object context. Nó thực hiện các validation và theo dõi các thay đổi được thực hiện trên các thuộc tính của object để các thao tác undo và redo có thể được áp dụng cho nó, nếu cần. Trong một context nhất định, một managed object cung cấp một đại diện của một record trong persistent store. Tùy thuộc vào tình huống, có thể có nhiều context, mỗi context chứa một managed object riêng biệt đại diện cho record đó. Tất cả các managed object được đăng ký với một managed object context. NSPersistentStoreCoordinator: NSManagedObjectContext không làm việc trực tiếp với NSPersistentStore để lưu trữ và truy xuất dữ liệu, mà NSPersistentStoreCoordinator sẽ làm điều đó. Vai trò chính của NSPersistentStoreCoordinator là quản lý trạng thái của managed object context và serialize các lệnh gọi đến NSPersistenStore để tránh sự dư thừa. Bạn có thể tìm thấy các vai trò chính của mỗi thành phần qua hình ảnh sau Chúng ta đã có đủ kiến thức về Core Data và các thành phần khác nhau của nó. Bây giờ, hãy chuyển sang phần chính. Core data hỗ trợ concurrencyCore Data hỗ trợ multi-threading trong một ứng dụng, có nghĩa là nhiều hơn một thread có thể được thực thi song song để tăng hiệu suất. Thậm chí một số tác vụ có thể được thực hiện ở chế độ nền bằng cách sử dụng một thread riêng biệt.Như bạn có thể biết, khi làm việc với CoreData, có hai cách để định nghĩa một managed object context: NSMainQueueConcurrencyType và NSPrivateQueueConcurrencyType. Tùy thuộc vào chúng ta để quyết định loại MOC nào nên tạo trong các ứng dụng của mình. Chủ yếu chúng ta sẽ làm việc trên main queue, nhưng để tránh xử lý dữ liệu trên main queue, vì nó có thể ảnh hưởng đến trải nghiệm người dùng khi thực hiện các tác vụ nặng trên main thread, đôi khi chúng ta cần tạo một private queue context và thực hiện các tác vụ nặng đó trên private context này.Concurrency chắc chắn làm cho ứng dụng hiệu quả hơn vì các tác vụ bây giờ có thể thực hiện song song, nhưng có một số quy tắc nghiêm ngặt được Apple định nghĩa mà chúng ta phải tuân theo nếu không sẽ gặp một số hành vi không mong đợi, bao gồm crash và mất dữ liệu. Quy tắc 1: Managed object context gắn liền với thread mà chúng được liên kết khi khai báo. Quy tắc đầu tiên nói rằng không sử dụng main queue context trong một background thread. Hầu hết thời gian, hoàn toàn không có lỗi nếu chúng ta vi phạm quy tắc. Tuy nhiên, khi đưa vào production, bạn sẽ sớm gặp crash trên dashboard giám sát của mình, dẫn đến trải nghiệm người dùng tồi và quan trọng hơn là mất dữ liệu. Quy tắc 2: Các managed object được truy xuất từ một context gắn liền với cùng queue mà context được liên kết. Điều đó có nghĩa là không truyền bất kỳ object nào được truy xuất từ main context sang private context và ngược lại. Vi phạm quy tắc này sẽ dẫn đến kết quả tương tự như quy tắc 1. Crash, crash, crash!Đây là lần đầu tiên tôi sử dụng CoreData để lưu trữ dữ liệu có giá trị của người dùng trong ứng dụng của chúng tôi. Một mặt, tôi đã không coi trọng core data concurrency vào thời điểm đó. Mặt khác, tôi không biết có một số quy tắc nghiêm ngặt khi làm việc với concurrency trong Core Data. Kết quả là, khi ứng dụng đưa vào production, số lượng crash đã được báo cáo lên dashboard giám sát. Lúc đó, tôi không biết chúng đến từ đâu. Tôi không thể tái tạo các vấn đề này để tìm ra nguyên nhân gốc rễ. Ngoài ra, crash được Firebase báo cáo không có đủ thông tin để điều tra. Tôi đã cố gắng xem xét luồng của ứng dụng, tìm kiếm trên StackOverFlow và sau đó đọc kỹ tài liệu của Apple về Core Data. Cuối cùng, nguyên nhân gốc rễ đến từ việc truy cập Core Data từ nhiều thread. Vì tôi đang làm việc với Core Bluetooth, điểm mấu chốt là Core Bluetooth dispatch các sự kiện Bluetooth trên main thread theo mặc định. Tuy nhiên, tôi đã cấu hình Bluetooth queue thành một background queue để tránh khóa UI queue. Và crash đến vì Core Data không cho phép truy cập NSManagedObject giữa các queue khác nhau một cách nghiêm ngặt. Để mô phỏng vấn đề này, tôi đã tạo một vòng lặp liên tục để chạy các hành động insert và delete trong một background queue liên tục. Code sau đây minh họa cách tôi thực hiện kiểm tra. 1234567891011121314override func viewDidLoad() { super.viewDidLoad() // Do any additional setup after loading the view. self.doSomething()}func doSomething() { self.managedContext?.insert(person: self.person) self.managedContext?.delete(person: self.person) DispatchQueue.global(qos: .background).asyncAfter(deadline: .now() + 0.1, execute: { self.doSomething() })} Sớm hay muộn, crash sẽ đến với chúng ta. 1232019-10-13 12:31:55.497690+0700 CoreData-Concurrency[90636:1151728] [error] error: Serious application error. Exception was caught during Core Data change processing. This is usually a bug within an observer of NSManagedObjectContextObjectsDidChangeNotification. -[__NSCFSet addObject:]: attempt to insert nil with userInfo (null)CoreData: error: Serious application error. Exception was caught during Core Data change processing. This is usually a bug within an observer of NSManagedObjectContextObjectsDidChangeNotification. -[__NSCFSet addObject:]: attempt to insert nil with userInfo (null)2019-10-13 12:31:55.569306+0700 CoreData-Concurrency[90636:1151728] *** Terminating app due to uncaught exception 'NSInvalidArgumentException', reason: '-[__NSCFSet addObject:]: attempt to insert nil' Dưới đây là một số câu trả lời từ cộng đồng bạn có thể tìm thấy trên Stackoverflow:https://stackoverflow.com/questions/36402366/core-data-crash-attempt-to-insert-nil-with-userinfo-nullhttps://stackoverflow.com/questions/55517083/ios-core-data-serious-application-error-attempt-to-insert-nil-in-less-than Tránh crashĐể tránh crash, có hai kỹ thuật chúng ta có thể áp dụng, cả hai đều đảm bảo rằng chúng ta không vi phạm các quy tắc concurrent-confinement. #1Kỹ thuật đầu tiên là đảm bảo rằng managedObjectContext được thực hiện trên queue mà nó được liên kết khi khởi tạo, trong trường hợp này là main queue. 1234567func doSomething() { self.managedContext?.insert(person: self.person) self.managedContext?.delete(person: self.person) DispatchQueue.main.asyncAfter(deadline: .now() + 0.1, execute: { // Dispatch to main queue self.doSomething() })} Trong trường hợp vì lý do nào đó, chúng ta không thể thực thi các hành động trên main queue (ví dụ: import dữ liệu lớn vào disk) chúng ta có thể tạo nhiều context để giải quyết vấn đề này. Chuyển sang #2. #2Sử dụng kỹ thuật Core data multiple context.Một child managed object context (MOC) không giữ tham chiếu đến persistent store coordinator (PSC). Thay vào đó, nó giữ tham chiếu đến một (MOC) khác làm parent của nó. Bất cứ khi nào một child thực hiện saveContext, các thay đổi sẽ được đẩy lên parent của nó, và tiếp tục đẩy lên các parent khác (nếu có). Chỉ khi root parent MOC thực hiện saveContext, các thay đổi mới được lưu vào PSC. Hãy tạo một private MOC bên trong class PersonManagedObject của chúng ta. 1private let privateMOC = NSManagedObjectContext(concurrencyType: .privateQueueConcurrencyType) Sau đó đặt parent của nó là main MOC. 12345init?() { ... privateMOC.parent = self.managedObjectContext} Từ bây giờ, tất cả hành động sẽ được thực hiện trên privateMOC này. Phương thức performAndWait chặn caller không return cho đến khi block được thực thi.Phương thức perform(_:) return ngay lập tức và context thực thi các phương thức block trên thread của riêng nó. Với phương thức performAndWait(_:), context vẫn thực thi các phương thức block trên thread của riêng nó, nhưng phương thức không return cho đến khi block được thực thi. 12345678func insert(person: Person) { ... // Some code are obmitted self.privateMOC.performAndWait { self.privateMOC.insert(object) synchronize() }} Đừng quên gọi phương thức saveContext của parent context để lưu các thay đổi vào PSC. 1234567891011121314private func synchronize() { do { try self.privateMOC.save() // We call save on the private context, which moves all of the changes into the main queue context without blocking the main queue. self.managedObjectContext.performAndWait { do { try self.managedObjectContext.save() } catch { print(\"Could not synchonize data. \\(error), \\(error.localizedDescription)\") } } } catch { print(\"Could not synchonize data. \\(error), \\(error.localizedDescription)\") }} Sau khi sửa đổi code bằng cách sử dụng #1 hoặc #2, tôi đã chạy chương trình một thời gian dài nhưng không còn crash nữa! Kết luậnCore data là một framework rất hữu ích và chắc chắn là không thể thiếu trong hầu hết các ứng dụng di động ngày nay. Để tránh các tình huống tồi tệ tương tự như tôi vừa trải qua, hãy đảm bảo bạn tìm hiểu sâu về các thành phần của nó trước khi bắt đầu code, đặc biệt là core data concurrency.Bạn có thể tìm thấy dự án hoàn chỉnh của tôi tại Github - Core Data ConcurrencyCảm ơn bạn đã đọc. Tài liệu tham khảo[1] B.M. Harwani - Core Data iOS Essentials-Packt Publishing (2011)[2] Core Data, Multithreading, and the Main Thread[3] [Multiple context CoreData] https://www.cocoanetics.com/2012/07/multi-context-coredata/","link":"/vi/posts/Best-practice-Core-Data-Concurrency/index.html"},{"title":"Thực hành tốt nhất: Cách xử lý Bluetooth Low Energy ở chế độ background","text":"Lời mở đầuKhi làm việc với CoreBluetooth, bạn đã bao giờ quan tâm rằng ứng dụng BLE trên iOS có thể tồn tại như thế nào khi nó bị hệ thống terminate? Làm thế nào chúng ta có thể đưa nó trở lại background? Có thứ gì giống như service trên Android có thể tồn tại mãi mãi không? Bạn có thể tìm thấy câu trả lời cho tất cả các câu hỏi này trong bài viết này. Hãy đọc tiếp! Vòng đời ứng dụng trên iOSTrước khi hiểu sâu về cách chúng ta có thể giữ ứng dụng tồn tại ở background, tốt nhất là bắt đầu với vòng đời ứng dụng trên iOS.Như bạn có thể biết, có năm trạng thái chính của mọi ứng dụng iOS.Not running Ứng dụng chưa được khởi chạy hoặc đang chạy nhưng đã bị hệ thống hoặc người dùng terminate.Inactive Đây là trạng thái ban đầu trước khi ứng dụng thực sự chuyển sang trạng thái khác.Active Ứng dụng đang chạy ở foreground và nhận các event từ người dùng.Background Ứng dụng ở background và không hiển thị với người dùng. Tuy nhiên, một ứng dụng yêu cầu thêm thời gian thực thi có thể duy trì ở trạng thái này trong một khoảng thời gian. Ngoài ra, ứng dụng sẽ chuyển sang trạng thái inactive trước khi vào chế độ background.Suspended Ứng dụng ở background nhưng nó không được phép thực thi bất kỳ code nào. Ứng dụng được hệ thống tự động chuyển sang trạng thái này và nó sẽ không nhận được bất kỳ event nào trước khi hệ thống thực hiện điều đó. Khi các ứng dụng foreground cần thêm bộ nhớ, hệ thống có thể terminate các ứng dụng suspended để tạo thêm không gian cho các ứng dụng foreground. Lưu ý rằng chúng ta không thể dự đoán khi nào ứng dụng suspended sẽ bị hệ thống terminate. Sau khi bị terminate, ứng dụng trở về trạng thái not running. Các vấn đề BLE với vòng đời ứng dụngNhư đã đề cập, khi ứng dụng vào background, ứng dụng có thể bị hệ thống terminate nếu cần giải phóng tài nguyên cho các ứng dụng khác. Không giống như Android OS, sau khi bị hệ thống kill, chúng ta có thể khởi động lại một service để giữ cho ứng dụng của bạn sống. Trên iOS, một khi ứng dụng bị hệ thống terminate, không có cách nào để đưa nó trở lại background. Kết quả là, bất kỳ event Bluetooth nào dispatch từ thiết bị sẽ không bao giờ đến được ứng dụng. Điều này có nghĩa là ứng dụng của bạn có thể bỏ lỡ các indication được người dùng kích hoạt, chẳng hạn như phát một bản nhạc trên điện thoại của họ khi nhấn các nút vật lý từ thiết bị BLE. Apple đưa ra một ví dụ gọi là “Smart door”. Ý tưởng chính của ví dụ này là có một tương tác tự động giữa ứng dụng và khóa cửa. Hãy tưởng tượng chúng ta đang phát triển một ứng dụng có thể tự động khóa và mở khóa cửa khi người dùng đi vào và ra khỏi nhà của họ. Tuy nhiên, vấn đề chính của việc triển khai này là giữ kết nối giữa hai thiết bị, điện thoại và khóa cửa. Trong khi sử dụng điện thoại, người dùng thực hiện nhiều hành động khác nhau trên điện thoại: mở / đóng ứng dụng, bật / tắt cài đặt Bluetooth, vào chế độ máy bay, khởi động lại điện thoại, v.v. Các tương tác này có thể dẫn đến việc ứng dụng của chúng ta bị hệ thống kill, mãi mãi. Trong trường hợp này, ứng dụng sẽ không thể kết nối lại với khóa khi người dùng trở về nhà, và người dùng có thể không thể mở khóa cửa. Để giải quyết vấn đề này, Apple cung cấp một phương pháp gọi là State Preservation and Restoration (CoreBluetooth background processing). State Preservation and Restoration được tích hợp sẵn trong CoreBluetooth cho phép ứng dụng của chúng ta có thể được khởi chạy lại vào background khi nó bị hệ thống terminate.Về cơ bản, iOS chụp snapshot của tất cả các đối tượng liên quan đến Bluetooth đang hoạt động trong ứng dụng của chúng ta. Sau đó, nếu có bất kỳ event Bluetooth nào liên quan đến các đối tượng Bluetooth mà ứng dụng của chúng ta đang tương tác đến điện thoại, ứng dụng của chúng ta sẽ được đánh thức từ cõi chết. Thật tuyệt vời! Triển khai State Preservation and RestorationĐể minh họa kỹ thuật State Preservation and Restoration trên iOS, tôi sẽ tái sử dụng mã nguồn từ bài viết trước Đóng Vai Trò Central Và Peripheral Với CoreBluetooth nhưng chúng ta sẽ thêm một số code nữa vào các project để làm cho nó trở nên kỳ diệu.Đầu tiên, tôi đặt iPad của mình hoạt động như một Peripheral với uuid “1FA2FD8A-17E0-4D3B-AF45-305DA6130E39”, được tạo bằng lệnh uuidgen trên Mac. Sau đó, làm cho nó bắt đầu advertising với local name “iPad”. Nếu có một kết nối được thiết lập bởi central manager, các log in/out sẽ được in ra để chúng ta biết liệu kết nối có được thực hiện thành công hay không. Khi nút “Send Notify” được chạm vào, ứng dụng sẽ notify một chuỗi dữ liệu “Say something cool!” thông qua “463FED21-DA93-45E7-B00F-B5CD99775150” được định nghĩa là một encrypted notifiable characteristic của ứng dụng đến central manager đã kết nối. Điều tiếp theo chúng ta cần làm là quay lại ứng dụng Central Manager và tạo một Restore Identifier cho các đối tượng CBCentralManager để được hệ điều hành tiếp quản khi ứng dụng bị terminate, tôi chọn chuỗi “YourUniqueIdentifierKey”. Tiếp theo, chúng ta sẽ triển khai willRestoreState được Apple cung cấp. 123456789101112131415161718public func centralManager(_ central: CBCentralManager, willRestoreState dict: [String : Any]) { LocalNotification.shared.showNotification(id: \"willrestorestate\", title: \"Manager will restore state\", body: \"\", timeInterval: 1.0) let systemSoundID: SystemSoundID = 1321 AudioServicesPlaySystemSound (systemSoundID) if let peripherals = dict[CBCentralManagerRestoredStatePeripheralsKey] as? [CBPeripheral] { peripherals.forEach { (awakedPeripheral) in print(\"\\(Date.now). - Awaked peripheral \\(String(describing: awakedPeripheral.name))\") guard let localName = awakedPeripheral.name, localName == \"iPad\" else { return } self.connectedDevice = Device.init(peripheral: awakedPeripheral) } }} Ở đây, khi centralManager(_:, willRestoreState) được gọi, tôi sẽ phát một soundtrack và hiển thị một pop-up với tên của peripheral được đánh thức để thông báo rằng ứng dụng thực sự được hệ thống đánh thức. Bên trong method, chúng ta cũng có thể lấy một dictionary chứa đầy thông tin trạng thái. Khi chúng ta lấy với key CBCentralManagerRestoredStatePeripheralsKey, nó chứa các thứ như một mảng CBPeripheral, chứa tất cả các peripheral đã kết nối hoặc đang chờ kết nối tại thời điểm ứng dụng bị hệ thống terminate. Ở đây, tôi lặp qua mảng các peripheral, kiểm tra xem có peripheral mà tôi quan tâm không, sau đó khởi tạo một Device và đặt nó trở lại biến connectedDevice để tôi có thể nhận các giá trị cập nhật từ peripheral. Tôi cũng thêm code sẽ popup một local notification tại delegate appDidFinishLaunching và tại method peripheral(:didUpdateValueFor:chacracteristic) để test. 123456func peripheral(_ peripheral: CBPeripheral, didUpdateValueFor characteristic: CBCharacteristic, error: Error?) { if let data = characteristic.value { let str = String.init(data: data, encoding: .utf8) ?? \"\" LocalNotification.shared.showNotification(id: \"DidUpdateValue\", title: \"Peripheral did update value from grave!\", body: \"\\(str)\", timeInterval: 1.0) }} 12345678func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) -&gt; Bool { let _ = BluetoothManager.sharedInstance let _ = LocalNotification.shared LocalNotification.shared.showNotification(id: \"didfinishlaunch\", title: \"App did finish launching\", body: \"Options: \\(launchOptions?[UIApplicationLaunchOptionsKey.bluetoothCentrals] ?? \"nil\")\", timeInterval: 1.0) return true} Đã đến lúc chạy thử nghiệm của chúng ta! Tôi sẽ sử dụng hai phương pháp để mô phỏng việc hệ thống terminate ứng dụng ở background.Phương pháp đầu tiên là sử dụng XCode. Chạy ứng dụng từ Xcode. Dừng ứng dụng bằng cách nhấn nút “Stop” từ Xcode. Khởi động lại ứng dụng từ Xcode. Phương pháp thứ hai là thực hiện các bước sau: Nhấn nút home để đưa ứng dụng vào background. Nhấn giữ nút nguồn cho đến khi bạn thấy “slide to power off”. Thả nút nguồn và nhấn giữ nút home khoảng 5 giây (cho đến khi bạn thấy màn hình home xuất hiện lại). Trong phần demo bên dưới, bạn sẽ thấy tôi sử dụng cả hai để test. Hãy xem điều gì tuyệt vời xảy ra! Đây là log được in từ Xcode. 123456789102018-08-18 19:46:35.6560 App did finish lauching with option nil2018-08-18 19:46:35.6620 Manager will restore state2018-08-18 19:46:35.6650. - Awaked peripheral Optional(\"iPad\")2018-08-18 19:46:35.6660 Manager did update state 52018-08-18 19:46:35.6950 App did become active2018-08-18 19:46:35.7080 Found iPad2018-08-18 19:46:35.7100 Did connect.2018-08-18 19:46:51.5170 App will resign active2018-08-18 19:46:52.1100 App did enter backgroundMessage from debugger: Terminated due to signal 9 Đầu tiên, tôi kết nối với thiết bị iPad, sau đó mô phỏng việc terminate bằng Xcode (Khởi chạy lại ứng dụng từ Xcode), sau đó bạn thấy delegate centralManager(_:, willRestoreState) được kích hoạt bởi popup. Sau đó, tôi mô phỏng việc terminate bằng phương pháp thứ hai, khi màn hình home xuất hiện lại, chắc chắn rằng ứng dụng đã bị terminate. Tiếp theo, tôi nhấn nút “Send notify” từ iPad (Đang đóng vai trò Peripheral) để gửi một event BLE đến ứng dụng. Đáng ngạc nhiên, centralManager(_:, willRestoreState) được gọi ngay lập tức như chúng ta có thể thấy một local notification hiện lên, sau đó một cái khác hiển thị dữ liệu BLE nhận được từ peripheral (Chuỗi “Say something cool!”). Nó thực sự hoạt động! Ứng dụng bây giờ có thể tồn tại mãi mãi! Nhưng khoan đã, nó không đơn giản như vậy. Cách tiếp cận này vẫn có một số hạn chế mà chúng ta sẽ thảo luận sau trong bài viết này. Như bạn có thể nhận thấy rằng có sự khác biệt giữa hai cách tôi sử dụng để mô phỏng việc terminate background, khi ứng dụng được khởi chạy lại từ cách đầu tiên, giá trị option của delegate application(application:didFinishLaunchingWithOptions:) luôn là nil, trong khi chúng ta có thể trích xuất [UIApplicationLaunchOptionsKey.bluetoothCentrals bằng cách sử dụng cách thứ hai (Giá trị của launchOptions?[UIApplicationLaunchOptionsKey.bluetoothCentrals] sẽ trả về chuỗi “YourUniqueIdentifierKey”). Tôi không biết lý do tại sao nó xảy ra. Nhưng có một điều chắc chắn rằng cách tiếp cận thứ hai tốt hơn cách đầu tiên vì nó khớp với tài liệu Apple. *”Khi ứng dụng của bạn được hệ thống khởi chạy lại, bạn có thể lấy tất cả các restoration identifier cho các đối tượng central manager mà hệ thống đang bảo tồn cho ứng dụng của bạn”.* Vì vậy, trong application(application:didFinishLaunchingWithOptions:), chúng ta có thể lấy danh sách UUID đại diện cho tất cả các đối tượng CBCentralManager đang hoạt động khi ứng dụng bị terminate và Core Bluetooth cùng iOS đã tiếp quản trong khi bạn bị terminate. Sử dụng UIApplicationLaunchOptionsBluetoothCentralsKey để lấy bất kỳ central nào chúng ta có thể đã khởi tạo trước khi bị zap. Lặp qua mảng centralManagerUUID và tìm cái khớp với Restoration Identifier mà chúng ta quan tâm. Hạn chếKhi người dùng force kill ứng dụng từ multiple task viewNếu người dùng force quit ứng dụng từ multiple task view, không có cơ hội nào để ứng dụng có thể thức dậy từ restoration event. Nhưng may mắn thay, có một công nghệ khác chúng ta có thể tận dụng để đưa ứng dụng trở lại background có tên là “iBeacon”. Trong bài viết tiếp theo, tôi sẽ hướng dẫn bạn cách triển khai công nghệ thú vị này vào ứng dụng của chúng ta. Khi người dùng khởi động lại điện thoạiNếu người dùng reset điện thoại, ứng dụng sẽ bị kill mãi mãi. Bằng cách tận dụng CoreLocation, chúng ta có thể giải quyết vấn đề. Trong phần tiếp theo, tôi sẽ hướng dẫn bạn cách làm điều đó. Suy nghĩ cuối cùngTrong bài viết này, chúng ta đã đi qua vòng đời ứng dụng iOS, tôi cũng đã hướng dẫn bạn cách giữ cho ứng dụng tồn tại ngay cả khi nó bị hệ thống terminate. Nội dung của bài viết này thực sự thú vị và chúng được hình thành từ các thí nghiệm làm việc thực tế của tôi.Hy vọng bạn sẽ thấy bài viết này hữu ích.","link":"/vi/posts/Best-practice-How-to-deal-with-Bluetooth-Low-Energy-in-background/index.html"},{"title":"Android Bluetooth: Một cạm bẫy","text":"Phát triển ứng dụng Android hỗ trợ BLE đầy rẫy thách thức, đặc biệt khi nói đến việc quản lý các thao tác đồng thời. Một trong những cạm bẫy phổ biến nhất mà các nhà phát triển gặp phải là hành vi không mong đợi xảy ra khi cố gắng thực hiện các thao tác BLE liên tiếp nhanh chóng. Trong bài blog này, chúng ta sẽ đi sâu vào lý do tại sao điều này xảy ra và cách bạn có thể vượt qua nó bằng cách triển khai cơ chế hàng đợi tùy chỉnh cho các thao tác BLE. Nếu bạn đã làm việc với BLE trên Android, bạn có thể đã gặp một vấn đề khó chịu: khi bạn cố gắng thực hiện nhiều thao tác BLE liên tiếp, như đọc và ghi characteristic hoặc descriptor, chỉ thao tác đầu tiên thành công, trong khi các thao tác khác dường như biến mất. Đây không chỉ là một bất tiện nhỏ; đây là một vấn đề nghiêm trọng vì logic ứng dụng của bạn thường phụ thuộc vào việc hoàn thành thành công các thao tác này. Nếu không có chúng, UI của bạn không thể cập nhật với dữ liệu mới từ thiết bị được kết nối, dẫn đến trải nghiệm người dùng kém. Vậy, điều gì đang xảy ra bên dưới? Vấn đề cốt lõi nằm ở cách BLE stack của Android xử lý các thao tác. Các thao tác BLE là bất đồng bộ, có nghĩa là chúng không hoàn thành ngay lập tức. Khi bạn thực hiện BLE stack với nhiều request liên tiếp nhanh chóng, hệ thống gặp khó khăn trong việc theo kịp, dẫn đến các thao tác bị drop và hành vi không thể đoán trước. Cách tiếp cận truyền thống: Giải pháp dựa trên CallbackMột cách để giảm thiểu vấn đề này là sử dụng callback để sắp xếp thứ tự các thao tác BLE của bạn.Ví dụ, bạn có thể đợi callback onCharacteristicWrite() được trigger trước khi bắt đầu thao tác tiếp theo. Điều này hoạt động cho các trường hợp sử dụng đơn giản khi các tương tác BLE của bạn được giới hạn trong một màn hình hoặc Activity đơn lẻ.Tuy nhiên, cách tiếp cận này nhanh chóng trở nên không thể quản lý được khi độ phức tạp của ứng dụng tăng lên. Khi bạn thêm nhiều thao tác BLE hơn - như đọc và ghi descriptor, xử lý kết nối và ngắt kết nối, cập nhật MTU, và thực hiện service discovery. Bạn sẽ thấy rằng cần một giải pháp có khả năng mở rộng hơn. Giải pháp có khả năng mở rộng: Triển khai cơ chế hàng đợiĐể xử lý các thao tác BLE đáng tin cậy hơn, cơ chế hàng đợi tùy chỉnh là điều cần thiết. Bằng cách xếp hàng các thao tác BLE, bạn đảm bảo rằng mỗi thao tác được thực hiện tuần tự, chỉ sau khi thao tác trước đó đã thành công hoặc thất bại. Cách tiếp cận này không chỉ ngăn các thao tác bị drop mà còn đơn giản hóa việc quản lý các tác vụ BLE trong ứng dụng của bạn. Đây là phác thảo cơ bản về cách bạn có thể triển khai cơ chế như vậy: Tạo Queue: Bắt đầu bằng cách tạo một queue (như LinkedList hoặc Queue) để chứa các thao tác BLE của bạn. Mỗi thao tác có thể được đại diện như một task hoặc command object chứa chi tiết của thao tác bạn muốn thực hiện. Operation Handler: Triển khai một handler hoặc manager class chịu trách nhiệm xử lý các thao tác trong queue. Class này nên lắng nghe việc hoàn thành của mỗi thao tác BLE, dù thành công hay thất bại, trước khi dequeue và thực hiện thao tác tiếp theo. Tích hợp Callback: Sửa đổi các callback BLE hiện có của bạn (như onCharacteristicWrite(), onCharacteristicRead(), v.v.) để trigger việc dequeue và thực hiện thao tác tiếp theo trong queue. Xử lý lỗi: Triển khai xử lý lỗi để đảm bảo rằng các thao tác thất bại không block queue. Bạn cũng có thể muốn thực hiện logic retry cho các lỗi tạm thời. Cập nhật UI: Vì UI của bạn có thể phụ thuộc vào kết quả của các thao tác BLE, hãy đảm bảo rằng queue manager của bạn trigger các cập nhật UI phù hợp khi thao tác hoàn thành. 1234567891011121314151617181920212223242526272829303132333435363738394041424344class BLEManager { ConcurrentLinkedQueue&lt;BLEBaseCommand&gt; commandQueue = new ConcurrentLinkedQueue&lt;&gt;(); // Lưu ý rằng chúng ta đang sử dụng ConcurrentLinkedQueue để ngăn các vấn đề đồng thời. private void terminateCommands() { commandQueue.clear(); currentCommand = null; } private void enqueueCommand(BLEBaseCommand command) { commandQueue.offer(command); if (currentCommand == null) { executeNextCommand(); } } private void signalCommandEnd() { currentCommand = null; if (!commandQueue.isEmpty()) { // Còn command? executeNextCommand(); } } private void executeNextCommand() { BLEBaseCommand next = commandQueue.poll(); if (next == null) { // Hoàn tất tất cả return; } currentCommand = next; try { if (!currentCommand.execute()) { runOnUiThread(currentCommand.fallback); // Xử lý lỗi từ hàm `fallback` tùy thuộc vào command signalCommandEnd(); } } catch (Exception ex) { signalCommandEnd(); } } private void runOnUiThread(Runnable runnable) { new Handler(Looper.getMainLooper()).post(runnable); }} Ở đâu đó từ class BluetoothGattCallback của bạn. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253@Override public void onConnectionStateChange(BluetoothGatt gatt, int status, int newState) { // Logic của bạn manager.signalCommandEnd();}@Overridepublic void onServiceChanged(@NonNull BluetoothGatt gatt) { // Logic của bạn manager.signalCommandEnd();}@Overridepublic void onServicesDiscovered(BluetoothGatt gatt, int status) { // Logic của bạn manager.signalCommandEnd();}@Overridepublic void onCharacteristicRead(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic, int status) { // Logic của bạn manager.signalCommandEnd();}@Overridepublic void onCharacteristicWrite(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic, int status) { // Logic của bạn manager.signalCommandEnd();}@Overridepublic void onDescriptorRead(BluetoothGatt gatt, BluetoothGattDescriptor descriptor, int status) { // Logic của bạn manager.signalCommandEnd();}@Overridepublic void onDescriptorWrite(BluetoothGatt gatt, BluetoothGattDescriptor descriptor, int status) { // Logic của bạn manager.signalCommandEnd();}@Overridepublic void onReadRemoteRssi(BluetoothGatt gatt, int rssi, int status) { // Logic của bạn manager.signalCommandEnd();}@Overridepublic void onMtuChanged(BluetoothGatt gatt, int mtu, int status) { // Logic của bạn manager.signalCommandEnd();} Dưới đây là sơ đồ class cơ bản Tại sao điều này quan trọngViệc triển khai cơ chế hàng đợi cho các thao tác BLE không chỉ là về việc tránh các thao tác bị drop; đó là về việc tạo ra một kiến trúc đáng tin cậy và có khả năng mở rộng hơn cho ứng dụng của bạn. Khi bạn mở rộng chức năng BLE của ứng dụng, bạn sẽ biết ơn sự ổn định và khả năng dự đoán mà hệ thống hàng đợi cung cấp. Đáng lưu ý rằng các paradigm hiện đại hơn như RxJava hoặc framework Kotlin có thể cung cấp các giải pháp thanh lịch hơn cho vấn đề này. Các công cụ này có thể giúp bạn quản lý các thao tác bất đồng bộ với tính linh hoạt cao hơn và ít boilerplate code hơn. Tuy nhiên, đối với nhiều nhà phát triển, cơ chế hàng đợi tùy chỉnh cung cấp một nền tảng vững chắc có thể dễ dàng hiểu và triển khai mà không cần thêm các dependency bổ sung. Chúng ta có thể thảo luận điều này trong một bài khác. Kết luậnBLE trên Android có thể đầy thách thức, nhưng với các chiến lược đúng đắn, bạn có thể xây dựng các ứng dụng mạnh mẽ giao tiếp đáng tin cậy với các thiết bị BLE. Bằng cách triển khai cơ chế hàng đợi tùy chỉnh, bạn có thể vượt qua nhiều vấn đề liên quan đến đồng thời. Dù bạn mới bắt đầu với BLE hay đang tìm cách nâng cao các ứng dụng hiện có, việc áp dụng cách tiếp cận hàng đợi sẽ làm cho quá trình phát triển của bạn mượt mà hơn và ứng dụng của bạn đáng tin cậy hơn.Happy Coding!","link":"/vi/posts/Android-Bluetooth-A-Pitfall/index.html"},{"title":"Thực hành tốt nhất: iBeacon","text":"Chào mừng bạn đến với phần tiếp theo của series “Cách xử lý BLE ở chế độ background“.Trong phần trước, tôi đã hướng dẫn bạn cách giữ cho ứng dụng của bạn sống càng lâu càng tốt khi ứng dụng vào chế độ background bằng cách sử dụng kỹ thuật State Preservation and Restoration được Apple hỗ trợ. Tuy nhiên, có một số trường hợp sử dụng mà kỹ thuật này không thể xử lý được, như mô tả bên dưới (tham khảo tài liệu Apple: Conditions Under Which Bluetooth State Restoration Will Relaunch An App)Như bạn thấy, có một trường hợp phổ biến khi người dùng force quit ứng dụng từ multiple task view (Dù vô tình hay cố ý), kỹ thuật Restoration không thể đánh thức ứng dụng của bạn. Hãy tưởng tượng rằng ứng dụng của bạn có một tính năng cho phép người dùng nhấn một nút trên thiết bị BLE đã kết nối của bạn để tìm điện thoại của họ ở đâu, nhưng nếu ứng dụng của bạn không chạy hoặc không thể thức dậy để xử lý tín hiệu BLE gửi từ thiết bị của bạn, tính năng này sẽ vô dụng.Trong bài viết này, tôi sẽ hướng dẫn bạn một kỹ thuật sử dụng iBeacon để giải quyết trường hợp này, giúp ứng dụng của bạn có thêm một cơ hội để thức dậy mặc dù nó đã bị người dùng terminate. Hãy bắt đầu! Chào mừng đến với thế giới iBeaconiBeacon là một protocol được Apple giới thiệu lần đầu tại WWDC 2013. “iBeacon dựa trên cảm biến độ gần Bluetooth low energy bằng cách truyền một universally unique identifier được nhận bởi một ứng dụng hoặc hệ điều hành tương thích. Identifier và một vài byte được gửi cùng với nó có thể được sử dụng để xác định vị trí vật lý của thiết bị, theo dõi khách hàng, hoặc kích hoạt một hành động dựa trên vị trí trên thiết bị như check-in trên mạng xã hội hoặc push notification” (Wiki).Ứng dụng của iBeacon rất đa dạng như dịch vụ dựa trên vị trí, thương mại di động hoặc quảng cáo, để kể tên một vài.“The Automatic Museum Guide” là một project rất ấn tượng với tôi được xây dựng trên công nghệ iBeacon. Ứng dụng cho phép khách tham quan khám phá các hiện vật bằng cách hiển thị nội dung phù hợp bằng cách theo dõi vị trí của họ và khoảng cách của họ với beacon. Đó là một ý tưởng tuyệt vời! Cách hoạt độngApple đã chuẩn hóa nội dung của dữ liệu advertisement iBeacon. Nó bao gồm một UUID 16 byte, phiên bản major và minor. Ba yếu tố này là duy nhất cho mỗi beacon. Một trường cuối cùng trong packet là TX power được sử dụng để xác định bạn gần beacon đến mức nào.Một beacon broadcast packet này trong phạm vi của nó, xa từ 20m đến 300m, theo các khoảng thời gian đều đặn. Các packet này được các điện thoại gần đó tự động phát hiện, sau đó ứng dụng sẽ thực hiện một hành động được định nghĩa trước như hiển thị notification hoặc pop-up một mã khuyến mãi. Mặc dù iBeacon dựa trên công nghệ Bluetooth low energy, một trong những khác biệt chính giữa hai là iBeacon là công nghệ truyền một chiều, nghĩa là chỉ điện thoại mới có thể nhận dữ liệu từ các thiết bị iBeacon. Tích hợp iOS: bắt đầu advertising như một iBeaconĐầu tiên, chúng ta cần một beacon để có thể thực hiện bước tiếp theo. Tôi sẽ sử dụng iPad của mình để hoạt động như một beacon bằng cách sử dụng đối tượng CLBeaconRegion trong CoreBluetooth trên iOS.UI chính chỉ đơn giản chứa hai nút chính sẽ bắt đầu và dừng advertisement của iBeacon, tương ứng. 123456let region = CLBeaconRegion(proximityUUID: self.uuid!, major: self.major, minor: self.minor, identifier: self.identifier)let peripheralData = region.peripheralData(withMeasuredPower: nil)peripheral.startAdvertising(((peripheralData as NSDictionary) as! [String : Any])) Sau đó, chúng ta triển khai delegate peripheralManagerDidStartAdvertising(CBPeripheralManager, Error?) để kiểm tra xem beacon có advertise thành công không. 1234567func peripheralManagerDidStartAdvertising(_ peripheral: CBPeripheralManager, error: Error?) { if error == nil { print(\"Successfully started advertising our beacon data.\") } else { print(\"Failed to advertise our beacon. Error = \\(String(describing: error))\") }} Để dừng advertising 1peripheralManager?.stopAdvertising() Tận dụng công nghệ iBeacon để làm cho ứng dụng của chúng ta tồn tại mãi mãiĐầu tiên, bên trong method didFinishLaunchingWithOptions của class AppDelegate, tôi sẽ hiển thị một notification để được thông báo bất cứ khi nào ứng dụng của chúng ta được khởi chạy lại. 1234func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -&gt; Bool { NotificationHandler.shared.showNotification(title: \"App did launch\", body: \"\") return true} Sau khi main view xuất hiện, tôi sẽ báo cho location manager bắt đầu monitoring region đã cho và bắt đầu ranging các iBeacon trong region đó 1234func startMonitoring() { locationManager.startMonitoring(for: beaconRegion) locationManager.startRangingBeacons(in: beaconRegion)} Theo mặc định, monitoring thông báo cho bạn khi region được enter hoặc exit bất kể ứng dụng của bạn có đang chạy hay không. Mặt khác, ranging chỉ giám sát độ gần của region khi ứng dụng của bạn đang chạy. Đó là tất cả cho việc thiết lập. Trong phần demo sau, bạn sẽ thấy tôi mở ứng dụng rồi terminate nó từ multiple task view. Sau đó, tôi nhấn nút “Start advertising” trên iPad của tôi (Beacon). Bạn sẽ thấy ứng dụng được khởi chạy lại ngay lập tức mặc dù nó đã bị kill (Notification “App did launch” hiện lên). Thật tuyệt vời. Lưu ý: Đừng mong đợi nhận được event ngay lập tức, vì chỉ boundary crossing mới tạo ra event. Đặc biệt, nếu vị trí của người dùng đã ở bên trong region tại thời điểm đăng ký, location manager không tự động tạo event. Thay vào đó, ứng dụng của bạn phải đợi người dùng vượt qua ranh giới region trước khi event được tạo và gửi đến delegate. Kết luậnMột trong những điều thú vị nhất của iBeacon là các ứng dụng iBeacon có thể được đánh thức ngay cả khi nó đã bị người dùng terminate. Điều này có nghĩa là các ứng dụng iBeacon có thể tồn tại mãi mãi. Để tải các project hoàn chỉnh, vui lòng click vào các link Github sau: Hoạt động như một iBeacon: https://github.com/uynguyen/iBeaconDevice Ứng dụng Central manager: https://github.com/uynguyen/CentralManager-iBeacon Hãy thoải mái gửi email cho tôi nếu bạn có bất kỳ câu hỏi nào. Tài liệu tham khảo[1] Region Monitoring and iBeacon","link":"/vi/posts/Best-practice-iBeacon/index.html"},{"title":"Lập Trình Bất Đồng Bộ trong Swift","text":"Promise Kit, một trong những framework tốt nhất để xử lý lập trình bất đồng bộ trong Swift Trong bài viết này, tôi sẽ sử dụng các thư viện bên thứ ba sau để hoàn thành dự án: Alamofire: Một framework HTTP networking trong Swift. SwiftyJSON: Để xử lý dữ liệu JSON. SwiftGifOrigin: Một extension UIImage để hiển thị file Gif. Bolts-Swift: Được thiết kế bởi Parse và Facebook, tôi sử dụng nó để tạo các phương thức bất đồng bộ. PromiseKit: Một framework giúp chúng ta đơn giản hóa lập trình bất đồng bộ. API của Giphy để tìm kiếm và tải ảnh gif. Bắt đầu Các phương thức bất đồng bộ, (viết tắt là Async), là các phương thức không trả về kết quả ngay lập tức như hầu hết các phương thức, các phương thức async mất một thời gian để tạo ra kết quả.Tôi thường sử dụng callback để xử lý các phương thức bất đồng bộ như quét thiết bị Bluetooth hoặc lấy một số tài nguyên từ internet. Thực tế, callback là một kỹ thuật lập trình không tốt. Callback sẽ làm code của chúng ta khó đọc, khó debug và tốn nhiều thời gian hơn để bảo trì sau này. Cuối cùng, code của chúng ta sẽ biến thành thứ mà chúng ta gọi là callback hell.Trong bài viết này, tôi sẽ tạo một dự án sử dụng từng kỹ thuật một để giải thích tại sao tôi nói callback là không tốt.Đầu tiên, hãy tiếp tục và tạo một dự án, đặt tên tùy ý, sau đó cài đặt các Pod framework này vào dự án của bạn. Bạn cũng cần chỉnh sửa key NSAllowsArbitraryLoads thành YES trong dictionary NSAppTransportSecurity trong file info.plist để chỉ định domain nào được miễn trừ khỏi các quy tắc bạn định nghĩa cho App Transport Security. Trong trường hợp của chúng ta, đây là domain giphy. Cho phép request HTTP chỉ cho domain giphy 1234567891011&lt;key&gt;NSAppTransportSecurity&lt;/key&gt; &lt;dict&gt; &lt;key&gt;NSExceptionDomains&lt;/key&gt; &lt;dict&gt; &lt;key&gt;api.giphy.com&lt;/key&gt; &lt;dict&gt; &lt;key&gt;NSExceptionAllowsInsecureHTTPLoads&lt;/key&gt; &lt;true/&gt; &lt;/dict&gt; &lt;/dict&gt;&lt;/dict&gt; Hoặc cho phép request HTTP cho tất cả domain, đây không phải là một ý tưởng tốt. 12345&lt;key&gt;NSAppTransportSecurity&lt;/key&gt;&lt;dict&gt; &lt;key&gt;NSAllowsArbitraryLoads&lt;/key&gt; &lt;true/&gt;&lt;/dict&gt; Hãy tạo một class có tên ImageLoader. Class này chứa hai phương thức giúp chúng ta tìm kiếm và tải ảnh gif từ server Giphy. 123456789101112//// ImageLoader.swift//class ImageLoader { func fetchImage(keyword: String) { // Tìm kiếm ảnh khớp với keyword trên server Giphy } func downloadImage(url: URL) { // Tải ảnh tại url }} Phiên bản đầu tiên: Sử dụng callbackĐầu tiên, chúng ta cần định nghĩa hai callback, sẽ được truyền vào các phương thức fetchImage và downloadImage. 12public typealias FetchImageBlock = (URL?, Error?) -&gt; Voidpublic typealias DownloadImageBlock = (URL?, Error?) -&gt; Void Sau đó, chúng ta triển khai hai phương thức này: fetchImage nhận keyword và callback làm tham số, gửi request đến server Giphy để truy vấn tất cả ảnh khớp với keyword, lấy cái đầu tiên và cuối cùng trả về url tải xuống qua callback. downloadImage nhận url và callback làm tham số, sau đó sử dụng framework Alamofire để tải ảnh. Cuối cùng, trả về url đích, nơi ảnh được lưu, qua callback. 123456789101112131415161718192021func fetchImage(keyword: String, callback: @escaping FetchImageBlock) { let endPoint = \"http://api.giphy.com/v1/gifs/search?q=\\(keyword)&amp;limit=1&amp;api_key=q4N1oD5jw3xvH2hIOkFAyHXWTTrh0D30\" let headers: HTTPHeaders = [ \"Content-Type\": \"application/json\" ] Alamofire.request(endPoint, headers: headers).responseData { (response) in if let error = response.error { return callback(nil, error) } let jsonData = JSON.init(data: response.data!) let dataArray = jsonData[\"data\"].array if let dataArray = dataArray, dataArray.count &gt; 0 { let imagesList = dataArray[0][\"images\"] let downsized_large = imagesList[\"downsized_large\"][\"url\"].stringValue return callback(URL.init(string: downsized_large), nil) } else { return callback(nil, nil) } }} 123456789101112131415func downloadImage(url: URL, callback: @escaping DownloadImageBlock) { let destination: DownloadRequest.DownloadFileDestination = { _, _ in let documentsURL = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)[0] let fileURL = documentsURL.appendingPathComponent(url.lastPathComponent) return (fileURL, [.removePreviousFile, .createIntermediateDirectories]) } Alamofire.download(url, to: destination).downloadProgress(closure: { (progress) in print(\"\\(progress)\") }).responseData(completionHandler: { (response) in if let error = response.error { return callback(nil, error) } callback(response.destinationURL, nil) })} Bên trong view controller chính, hãy định nghĩa một phương thức gọi là searchImageWithKeyword. Phương thức này nhận keyword làm tham số, sau đó truyền tham số vào phương thức fetchImage của một instance của class ImageLoader. Chúng ta cũng cần truyền một callback để xử lý kết quả.Bên trong callback fetchImage, hãy kiểm tra xem có lỗi nào không. Nếu có, chúng ta dừng gọi phương thức tiếp theo, downloadImage. Ngược lại, chúng ta gọi downloadImage của đối tượng imageLoader. Sau đó truyền url và callback làm tham số.Bên trong callback downloadImage, hãy kiểm tra xem có lỗi nào không. Nếu có, chúng ta dừng gọi cái tiếp theo. Ngược lại, chúng ta cập nhật image view trên main view bằng cách gọi phương thức updateImageAtURL. 12345678910111213141516171819202122232425262728func searchImageWithKeyword(keyword: String) { let imageLoader = ImageLoader() imageLoader.fetchImage(keyword: keyword, callback: {downloadLink, error in if let error = error { print(\"Error \\(error)\") } else { if let downloadLink = downloadLink { imageLoader.downloadImage(url: downloadLink, callback: {downloadedURL, error in if let error = error { print(\"Error \\(error)\") } else { if let downloadedURL = downloadedURL { self.updateImageAtURL(url: downloadedURL) } else { print(\"Error: downloadedURL is nil\") } } }) } else { print(\"Error: downloadLink is nil\") } } })} 123456789101112131415func updateImageAtURL(url: URL) { guard Thread.isMainThread else { DispatchQueue.main.async { self.updateImageAtURL(url: url) } return } do { let data = try Data.init(contentsOf: url) self.imgImage.image = UIImage.gif(data: data) } catch { print(\"Error \\(error)\") }} Như bạn thấy, searchImageWithKeyword khá phức tạp với nhiều câu lệnh if và else bên trong phương thức. Chúng ta phải kiểm tra lỗi trong nhiều dòng code. Hãy tưởng tượng nó sẽ phức tạp như thế nào nếu chúng ta có nhiều hơn ba phương thức bên trong nó? Một callback hell trong ngôn ngữ khác, Javascript Build và chạy dự án. Nhập keyword bạn muốn tìm kiếm trên server Giphy, nhấn nút tìm kiếm và bạn sẽ thấy kết quả đầu tiên. Dự án lập trình async Giải pháp tốt hơn: Sử dụng BoltsBolts là một framework được thiết kế bởi Parse và Facebook, tôi sử dụng nó để tạo các phương thức bất đồng bộ, mà không sử dụng callback. Framework Bolts cho phép chúng ta viết code như một chuỗi các hành động dựa trên các sự kiện. 123456789101112131415161718192021222324func fetchImage(keyword: String) -&gt; Task&lt;URL&gt;! { let mainTask = TaskCompletionSource&lt;URL&gt;() let endPoint = \"http://api.giphy.com/v1/gifs/search?q=\\(keyword)&amp;limit=1&amp;api_key=q4N1oD5jw3xvH2hIOkFAyHXWTTrh0D30\" let headers: HTTPHeaders = [ \"Content-Type\": \"application/json\" ] Alamofire.request(endPoint, headers: headers).responseData { (response) in if let error = response.error { return mainTask.set(error: error) } let jsonData = JSON.init(data: response.data!) let dataArray = jsonData[\"data\"].array if let dataArray = dataArray, dataArray.count &gt; 0 { let imagesList = dataArray[0][\"images\"] let fixed_height_still = imagesList[\"downsized_large\"][\"url\"].stringValue return mainTask.set(result: URL.init(string: fixed_height_still)!) } else { return mainTask.set(error: NSError.init(domain: \"myDomain\", code: 0, userInfo: nil)) } } return mainTask.task} 1234567891011121314151617181920212223func downloadImage(url: URL) -&gt; Task&lt;URL&gt;! { let mainTask = TaskCompletionSource&lt;URL&gt;() let destination: DownloadRequest.DownloadFileDestination = { _, _ in let documentsURL = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)[0] let fileURL = documentsURL.appendingPathComponent(url.lastPathComponent) return (fileURL, [.removePreviousFile, .createIntermediateDirectories]) } Alamofire.download(url, to: destination).downloadProgress(closure: { (progress) in print(\"\\(progress)\") }).responseData(completionHandler: { (response) in if let error = response.error { return mainTask.set(error: error) } if let destinationURL = response.destinationURL { return mainTask.set(result: destinationURL) } else { return mainTask.set(error: NSError.init(domain: \"myDomain\", code: 0, userInfo: nil)) } }) return mainTask.task} Hãy xem searchImageWithKeyword sẽ đơn giản như thế nào khi sử dụng Bolts. 12345678910func searchImageWithKeyword(keyword: String) { let imageLoader = ImageLoader() imageLoader.fetchImage(keyword: keyword).continueOnSuccessWith { (linkDownload) -&gt; Void in imageLoader.downloadImage(url: linkDownload).continueOnSuccessWith(continuation: { (downloadedURL) -&gt; Void in self.updateImageAtURL(url: downloadedURL) }) }.continueOnErrorWith { (error) in print(\"Error \\(error)\") }} Build và chạy dự án, không có gì thay đổi. Nhưng code dễ đọc hơn cái đầu tiên, phải không? Chúng ta tập hợp tất cả lỗi ở một nơi, cũng tách biệt việc xử lý lỗi và code thành công. Giải pháp tốt hơn nhiều: Sử dụng PromiseKitMột điều tôi không thích về framework Bolts là thiếu tài liệu và dự án mẫu. Khi tôi lần đầu sử dụng framework Bolts, tôi rất khó làm quen với các API của đối tượng Task.Tại hội nghị Swift Summit 2017, có một diễn giả đã giới thiệu một Framework để xử lý các phương thức async, PromiseKit. Sau hội nghị, tôi đã thay thế code sử dụng framework Bolts bằng PromiseKit trong các dự án của công ty tôi. Tôi nhận ra code của tôi bây giờ dễ đọc hơn. Tôi nghĩ cách viết của PromiseKit sẽ quen thuộc hơn với các developer so với cách viết của Bolts, đặc biệt là những người đã làm việc với Javascript như tôi.Một phương thức async được tạo bằng PromiseKit trả về một Promise generic mới, đây là class chính được cung cấp bởi PromiseKit. Constructor của nó nhận một khối thực thi đơn giản với hai tham số: fulfill: Một hàm để gọi khi giá trị mong muốn sẵn sàng để hoàn thành promise. reject: Một hàm để gọi nếu có lỗi. Hãy áp dụng PromiseKit vào dự án của chúng ta 12345678910111213141516171819202122func fetchImage(keyword: String) -&gt; Promise&lt;URL&gt; { return Promise { fullfil, reject in let endPoint = \"http://api.giphy.com/v1/gifs/search?q=\\(keyword)&amp;limit=1&amp;api_key=q4N1oD5jw3xvH2hIOkFAyHXWTTrh0D30\" let headers: HTTPHeaders = [ \"Content-Type\": \"application/json\" ] Alamofire.request(endPoint, headers: headers).responseData { (response) in if let error = response.error { return reject(error) } let jsonData = JSON.init(data: response.data!) let dataArray = jsonData[\"data\"].array if let dataArray = dataArray, dataArray.count &gt; 0 { let imagesList = dataArray[0][\"images\"] let fixed_height_still = imagesList[\"downsized_large\"][\"url\"].stringValue return fullfil(URL.init(string: fixed_height_still)!) } return reject(NSError.init(domain: \"myDomain\", code: 0, userInfo: nil)) } }} 12345678910111213141516171819202122func downloadImage(url: URL) -&gt; Promise&lt;URL&gt; { return Promise { fullfil, reject in let destination: DownloadRequest.DownloadFileDestination = { _, _ in let documentsURL = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)[0] let fileURL = documentsURL.appendingPathComponent(url.lastPathComponent) return (fileURL, [.removePreviousFile, .createIntermediateDirectories]) } Alamofire.download(url, to: destination).downloadProgress(closure: { (progress) in print(\"\\(progress)\") }).responseData(completionHandler: { (response) in if let error = response.error { return reject(error) } if let destinationURL = response.destinationURL { return fullfil(destinationURL) } reject(NSError.init(domain: \"myDomain\", code: 0, userInfo: nil)) }) }} Và kết quả cuối cùng, code đẹp làm sao! :)) 123456789101112func searchImageWithKeyword(keyword: String) { let imageLoader = ImageLoader() firstly { imageLoader.fetchImage(keyword: keyword) }.then { downloadLink -&gt; Promise&lt;URL&gt; in return imageLoader.downloadImage(url: downloadLink) }.then {downloadedURL -&gt; Void in self.updateImageAtURL(url: downloadedURL) }.catch { error in print(\"Error \\(error)\") }} Một tính năng mà tôi thấy rất thú vị trong cả hai framework, Bolts và PromiseKit, là chúng cho phép code của chúng ta chạy trên một thread nhất định (Main thread hoặc background thread). Đây là một tính năng tuyệt vời vì hầu hết công việc được thực hiện trong view controller là để cập nhật UI. Đôi khi, các tác vụ chạy lâu được xử lý tốt nhất trên background thread, để không làm nghẽn UI. Để biết thêm chi tiết về tính năng Thread này, vui lòng tham khảo tài liệu của họ: #Threading Kết luậnVì tôi đang làm việc với CoreBluetooth, tôi thường phải làm việc với các phương thức async. Quá nhiều callback làm dự án của tôi khó hiểu hơn và khó debug nếu có lỗi xảy ra. Promise làm code của tôi trở thành một cô gái đẹp hơn ;).Bạn có thể tải dự án mẫu hoàn chỉnh tại đây.Hãy để lại bình luận về bài viết của tôi.","link":"/vi/posts/Asynchronous-Programming-in-Swift/index.html"},{"title":"Thực tiễn tốt nhất: Xử lý nền iOS - Background App Refresh Task","text":"Không giống như Android, iOS có các hạn chế về việc sử dụng xử lý nền trong nỗ lực cải thiện thời lượng pin và trải nghiệm người dùng. Khi ứng dụng của bạn chuyển sang chế độ nền, đó là lúc developers mất quyền kiểm soát ứng dụng của họ. Cách thức và thời điểm ứng dụng của bạn có cơ hội thực thi task hoàn toàn phụ thuộc vào hệ thống. Ở trung tâm của iOS, Apple sử dụng thuật toán phức tạp nội bộ riêng để xác định ứng dụng nào được phép chạy trong nền, dựa trên nhiều yếu tố khác nhau như mô hình hoạt động của người dùng, trạng thái pin hiện tại, v.v.Trong hướng dẫn này, chúng ta sẽ học cách yêu cầu thời gian thực thi định kỳ trên iOS. Sau khi hiểu cách nó hoạt động, chúng ta sẽ áp dụng kỹ thuật này cho một ứng dụng dựa trên BLE trong một số trường hợp cụ thể ở hướng dẫn tiếp theo.Bắt đầu thôi! Kiến thức nền tảngTrước khi đi sâu vào thực hành, tốt hơn là hiểu cách iOS quản lý các trạng thái ứng dụng. Đây là lần đầu tiên Apple chính thức công bố một video mô tả các yếu tố hàng đầu ảnh hưởng đến thời gian khởi chạy ứng dụng tại WWDC (WWDC 2020 - Background execution demystified). Tóm lại, Apple thiết kế iOS theo cách cho phép ứng dụng giữ nội dung cập nhật một mặt. Mặt khác, iOS phải thích ứng với các mục tiêu chính: Thời lượng pin: cho phép thực thi nền trong khi vẫn duy trì thời lượng pin cả ngày. Hiệu suất: đảm bảo thực thi nền không có bất kỳ ảnh hưởng tiêu cực nào đến việc sử dụng chủ động. Quyền riêng tư: Người dùng nên biết về các background tasks dựa trên mô hình sử dụng cụ thể của họ. Tôn trọng ý định người dùng: nếu người dùng thực hiện một hành động nhất định, đảm bảo hệ thống phản hồi chính xác. Với những mục tiêu này trong đầu, đây là 7 yếu tố hàng đầu đóng vai trò trong việc lên lịch hệ thống cho thực thi nền. Pin yếu nghiêm trọng: Khi điện thoại sắp hết pin (&lt; 20%), thực thi nền sẽ bị hệ thống tạm dừng để tránh sử dụng pin. Chế độ tiết kiệm pin: Khi người dùng chuyển điện thoại sang chế độ tiết kiệm pin, người dùng rõ ràng chỉ ra rằng hệ thống nên bảo tồn pin chỉ cho các tác vụ quan trọng. Cài đặt Background App refresh: Người dùng có thể bật/tắt cài đặt để cho phép hoặc không cho phép một ứng dụng cụ thể chạy background tasks. Mức sử dụng ứng dụng: Có giới hạn tài nguyên trên điện thoại nên hệ thống phải ưu tiên ứng dụng nào nó nên phân bổ tài nguyên. Thông thường, các ứng dụng người dùng sử dụng nhiều nhất. Apple cũng đề cập đến “On-device predictive engine” học các ứng dụng người dùng thường sử dụng và khi nào. On-device predictive engine sẽ dựa vào thông tin này để ưu tiên thực thi nền. App switcher: Chỉ các ứng dụng hiển thị trong App Switcher mới có cơ hội chạy background tasks. Ngân sách hệ thống: Đảm bảo các hoạt động nền không tiêu hao pin và data plans, có giới hạn pin và data của thực thi nền trong suốt cả ngày. Giới hạn tốc độ: Hệ thống thực hiện một số giới hạn tốc độ cho mỗi lần khởi chạy. và một số yếu tố khác: Chế độ máy bay, nhiệt độ thiết bị, màn hình, trạng thái khóa thiết bị, v.v. CapabilitiesĐảm bảo ứng dụng của bạn đã thêm các capabilities sau Trước iOS 13Việc thiết lập background fetch trước iOS 13 khá đơn giản.Bên trong method application(_:didFinishLaunchingWithOptions), chúng ta nên thêm lệnh sau. 1UIApplication.shared.setMinimumBackgroundFetchInterval(UIApplication.backgroundFetchIntervalMinimum) setMinimumBackgroundFetchInterval chỉ định khoảng thời gian tối thiểu phải trôi qua giữa các lần thực thi background fetch. Tuy nhiên, thời điểm chính xác của sự kiện phụ thuộc vào hệ thống. Thông thường, UIApplicationBackgroundFetchIntervalMinimum là giá trị mặc định tốt để sử dụng. Khi ứng dụng của bạn có cơ hội thực hiện background tasks, sự kiện application(_:,performFetchWithCompletionHandler) sẽ được kích hoạt. 1234func application(_ application: UIApplication, performFetchWithCompletionHandler completionHandler: @escaping (UIBackgroundFetchResult) -&gt; Void) { Logger.shared.debug(\"\\(Date().toString()) perfom bg fetch\") completionHandler(.newData)} Đừng quên gọi callback completionHandler. Nếu bạn không gọi callback này, hệ thống không biết task của bạn đã hoàn thành, dẫn đến việc hạn chế ứng dụng của bạn được đánh thức trong các sự kiện tiếp theo Để simulate background fetch, từ tab bar &gt; Debug &gt; Simulate background fetch. Lưu ý rằng nó chỉ hoạt động khi chạy trên thiết bị thật. iOS 13+, Xử lý nền nâng cao - WWDC 2019 và Background execution demystified - WWDC 2020Tại WWDC 2019, Apple giới thiệu một framework mới để lên lịch công việc nền: BackgroundTasks. Framework mới này hỗ trợ tốt hơn cho các tasks cần được thực hiện trong nền. Có hai loại tasks được hỗ trợ bởi BackgroundTasks framework: BGAppRefreshTaskRequest, và BGProcessingTaskRequest. Với sự xuất hiện của framework mới, Apple đánh dấu deprecated cho framework cũ từ iOS 13, và không còn hỗ trợ trên MacOS.Đầu tiên, chúng ta phải đăng ký các identifiers của background tasks được thực thi trong ứng dụng. Mở file info.plist, và thêm thông tin sau. 12345&lt;key&gt;BGTaskSchedulerPermittedIdentifiers&lt;/key&gt;&lt;array&gt; &lt;string&gt;YOUR_REFRESH_TASK_ID&lt;/string&gt; &lt;string&gt;YOUR_PROCESSING_TASK_ID&lt;/string&gt;&lt;/array&gt; Quên bước trên dẫn đến crash ở runtime. 12020-10-11 08:24:40.648838+0700 TestBgTask[275:5188] *** Terminating app due to uncaught exception 'NSInternalInconsistencyException', reason: 'No launch handler registered for task with identifier com.example.bgRefresh' BGAppRefreshTaskRequest được sử dụng khi bạn cần thực thi một task trong nền trong thời gian ngắn.Các refresh tasks như fetching social media feed, emails mới, giá cổ phiếu mới nhất, v.v. phù hợp để lên lịch bởi BGAppRefreshTaskRequest. 30s là thời gian hệ thống cho phép task của bạn thực thi mỗi lần khởi chạy. Vài phút thời gian chạy để hoàn thành công việc khi bạn đăng ký BGProcessingTaskRequest. Các tasks như Core ML training trên thiết bị nên được đăng ký bởi BGProcessingTaskRequest. Để đăng ký background tasks, bên trong method application(_:didFinishLaunchingWithOptions), chúng ta nên thêm lệnh sau. 1234567891011121314151617181920212223242526272829303132333435363738394041424344 func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -&gt; Bool { if #available(iOS 13, *) { BGTaskScheduler.shared.register(forTaskWithIdentifier: appRefreshTaskId, using: nil) { task in Logger.shared.info(\"[BGTASK] Perform bg fetch \\(appRefreshTaskId)\") task.setTaskCompleted(success: true) self.scheduleAppRefresh() } BGTaskScheduler.shared.register(forTaskWithIdentifier: appProcessingTaskId, using: nil) { task in Logger.shared.info(\"[BGTASK] Perform bg processing \\(appProcessingTaskId)\") task.setTaskCompleted(success: true) self.scheduleBackgroundProcessing() } } } @available(iOS 13.0, *) func scheduleAppRefresh() { let request = BGAppRefreshTaskRequest(identifier: \"YOUR_REFRESH_TASK_ID\") request.earliestBeginDate = Date(timeIntervalSinceNow: 5 * 60) // Refresh after 5 minutes. do { try BGTaskScheduler.shared.submit(request) } catch { print(\"Could not schedule app refresh task \\(error.localizedDescription)\") } } @available(iOS 13.0, *) func scheduleBackgroundProcessing() { let request = BGProcessingTaskRequest(identifier: appProcessingTaskId) request.requiresNetworkConnectivity = true // Need to true if your task need to network process. Defaults to false. request.requiresExternalPower = true // Need to true if your task requires a device connected to power source. Defaults to false. request.earliestBeginDate = Date(timeIntervalSinceNow: 5 * 60) // Process after 5 minutes. do { try BGTaskScheduler.shared.submit(request) } catch { print(\"Could not schedule image fetch: (error)\") } }} Một điều nữa cần làm. Khi ứng dụng vào nền, chúng ta sẽ bắt đầu lên lịch background tasks. 1234567func applicationDidEnterBackground(_ application: UIApplication) { Logger.shared.info(\"App did enter background\") if #available(iOS 13, *) { self.scheduleAppRefresh() self.scheduleBackgroundProcessing() }} Như thường lệ, điều quan trọng là gọi task.setTaskCompleted(success: true) càng nhanh càng tốt.Bạn có thể nhận thấy rằng sau khi gọi task.setTaskCompleted(success: true), chúng ta cần gọi self.scheduleAppRefresh() và self.scheduleBackgroundProcessing() lại để lên lịch lại các tasks này cho hệ thống. Simulate background task và background processingMay mắn thay, Apple hỗ trợ cách để kích hoạt thực thi nền.Sau khi submit task của bạn cho hệ thống, tạm dừng ứng dụng bằng bất kỳ break point nào. Sau đó, nhập lệnh sau vào Xcode console. 1e -l objc -- (void)[[BGTaskScheduler sharedScheduler] _simulateLaunchForTaskWithIdentifier:@\"YOUR_REFRESH_TASK_ID || YOUR_PROCESSING_TASK_ID\"] Output sẽ là 12345672020-10-11 08:53:58.628667+0700 TestBgTask[381:17115] 💚-2020-10-11 08:53:58.628 +0700 Start schedule app refresh(lldb) e -l objc -- (void)[[BGTaskScheduler sharedScheduler] _simulateLaunchForTaskWithIdentifier:@\"com.example.bgRefresh\"]2020-10-11 08:54:01.927263+0700 TestBgTask[381:16973] Simulating launch for task with identifier com.example.bgRefresh2020-10-11 08:54:03.669153+0700 TestBgTask[381:17095] Starting simulated task: &lt;decode: missing data&gt;2020-10-11 08:54:07.560697+0700 TestBgTask[381:17095] Marking simulated task complete: &lt;BGAppRefreshTask: com.example.bgRefresh&gt;2020-10-11 08:54:07.560750+0700 TestBgTask[381:17012] 💙-2020-10-11 08:54:06.045 +0700 [BGTASK] Perform bg fetch com.example.bgRefresh2020-10-11 08:54:07.563846+0700 TestBgTask[381:17012] 💚-2020-10-11 08:54:07.562 +0700 Start schedule app refresh Kỳ vọng vs Thực tếBạn có thể kỳ vọng rằng thực thi nền sẽ được phân phối đều trong suốt cả ngày. Tuy nhiên, đây là những gì chúng ta quan sát được trong thực tế. Vì 7 yếu tố tôi đã giới thiệu ở đầu hướng dẫn này, “On-device predictive engine” học mô hình sử dụng của người dùng và hiểu rằng người dùng thường mở ứng dụng vào buổi sáng, giờ ăn trưa và buổi tối. Đó là lý do tại sao hệ thống sẽ cho phép background tasks của bạn khởi chạy ngay trước khi người dùng đưa ứng dụng lên foreground. Các yếu tố khác ảnh hưởng đến kết quả là nếu người dùng bật “Chế độ tiết kiệm pin”, hoặc nếu điện thoại rơi vào trạng thái pin yếu nghiêm trọng. Lời khuyên tốt nhất Background tasks sẽ không chạy cho đến khi thiết bị được mở khóa lần đầu tiên sau khi khởi động lại. Chúng ta có thể kiểm tra xem người dùng có đang ở chế độ tiết kiệm pin không:12ProcessInfo.processInfo.isLowPowerModeEnabledNSProcessInfoPowerStateDidChange Chúng ta cũng có thể kiểm tra trạng thái “background refresh setting”.12UIApplication.shared.backgroundRefreshStatusUIApplication.backgroundStatusDidChangeNotification Tối thiểu hóa sử dụng data: Sử dụng thumbnails thay vì full images, và chỉ download những gì thực sự cần thiết. Tối thiểu hóa tiêu thụ điện năng: tránh sử dụng phần cứng không cần thiết như GPS, accelerometer, v.v. Ngoài ra, đảm bảo bạn hoàn thành task càng sớm càng tốt. Sử dụng BackgroundURLSession để chuyển công việc từ ứng dụng sang hệ thống. Tổng kếtTrong bài viết này, chúng ta đã đi sâu vào các yếu tố góp phần vào thực thi nền của bạn, và hiểu sự khác biệt chính giữa BGAppRefreshTaskRequest và BGProcessingTaskRequest. Chúng ta cũng thực hiện một demo project để xem nó thực sự hoạt động như thế nào trong thực tế.Lần tới, bạn có thể chọn loại request phù hợp nhất với tasks của mình, và cách bạn có thể phản hồi một cách khéo léo với ý định của người dùng.Hy vọng, thông tin mà bài viết này mang lại giúp bạn xây dựng ứng dụng tốt hơn: tươi mới và tối ưu hóa.Có một kỹ thuật khác để đánh thức ứng dụng của bạn, silent notification. Chúng ta sẽ nói về nó trong hướng dẫn tiếp theo.Chúc cuối tuần vui vẻ! Tài liệu tham khảo Background execution demystified WWDC 2020 Advances in App Background Execution WWDC 2019","link":"/vi/posts/Best-practice-iOS-background-processing-Background-App-Refresh-Task/index.html"},{"title":"Best practice: iOS vs Android Bluetooth","text":"Công nghệ Bluetooth đã trở thành một phần không thể thiếu của các ứng dụng di động hiện đại, cho phép giao tiếp không dây liền mạch giữa các thiết bị. Dù là để kết nối với tai nghe không dây, truyền file, hay tương tác với các thiết bị smart home, Bluetooth đóng vai trò quan trọng trong việc nâng cao trải nghiệm người dùng. Đối với các nhà phát triển di động, việc hiểu cách triển khai chức năng Bluetooth là điều cần thiết. Trong bài viết này, chúng ta sẽ đi sâu vào so sánh chi tiết các framework phát triển Bluetooth cho iOS và Android. Chúng ta sẽ khám phá những điểm khác biệt và tương đồng chính giữa hai nền tảng này, bao gồm mọi thứ từ thiết lập ban đầu đến truyền dữ liệu và xử lý lỗi. Đến cuối bài so sánh này, bạn sẽ có hiểu biết rõ ràng về cách tận dụng công nghệ Bluetooth trong các ứng dụng di động của mình, bất kể bạn đang phát triển cho iOS hay Android. Để có cái nhìn trực quan hơn, tôi đã tạo hình ảnh bên dưới để tóm tắt quy trình thiết lập kết nối trên Android và iOS Thoạt nhìn, hai quy trình có vẻ khá giống nhau. Tuy nhiên, quy trình Android bao gồm các bước bổ sung. Mặc dù quy trình kết nối phức tạp hơn trên Android so với iOS, nhưng nó cung cấp quyền kiểm soát lớn hơn đối với dữ liệu trả về. Hãy chia quy trình thành ba bước chính để thảo luận: Scanning, Getting Ready, Interacting, và Closing. Mỗi bước này bao gồm các hành động và cân nhắc cụ thể đóng góp vào chức năng và hiệu quả tổng thể của quy trình kết nối. ScanningTrong giai đoạn scanning, các quy trình khá giống nhau giữa Android và iOS, từ việc bắt đầu scan đến tạo kết nối. Sự khác biệt chính là có nhiều thông tin hơn về peripheral trong kết quả scan trên Android so với iOS. Giá trị thú vị nhất là địa chỉ MAC của thiết bị. iOS không expose giá trị này và thay vào đó cung cấp một UUID ngẫu nhiên.UUID trên iOS được tạo theo từng ứng dụng và từng cặp thiết bị, và vòng đời của chúng gắn liền với session hoặc cho đến khi thiết bị bị quên, vì vậy đừng dựa vào nó để nhận dạng hoặc kết nối lại với thiết bị của bạn. iOS không expose địa chỉ MAC vì nhiều lý do, chủ yếu liên quan đến quyền riêng tư và bảo mật. Bằng cách ẩn địa chỉ MAC, Apple đảm bảo rằng các ứng dụng và bên thứ ba không thể lạm dụng thông tin này để theo dõi hoặc tạo profile người dùng và cũng giúp ngăn chặn các hoạt động bất hợp pháp của kẻ tấn công. Một giải pháp khả thi để vượt qua hạn chế này là bao gồm định danh duy nhất của riêng bạn trong gói tin advertising, sẽ có sẵn trên tất cả các nền tảng. Một lưu ý quan trọng khác là hệ điều hành Android ngăn chặn việc start-stop scan quá khoảng 5 lần trong 30 giây (xin lưu ý rằng giá trị này thay đổi từ thiết bị này sang thiết bị khác). Gọi method startScan quá thường xuyên trong thời gian ngắn sẽ dẫn đến không có thiết bị nào được phát hiện. Giá trị chung cuối cùng là giá trị cường độ tín hiệu, RSSI (Received Signal Strength Indicator), cho biết thiết bị cách điện thoại bao xa. Phạm vi từ -30 đến -99; giá trị càng gần -30, thiết bị càng gần. Getting ReadyKhi thiết bị của bạn đã được phát hiện, bước tiếp theo là làm cho nó sẵn sàng để bạn có thể thực hiện các hành động read và write. Có hai cách tiếp cận khác nhau để làm cho thiết bị “sẵn sàng.” Cách tiếp cận đầu tiên là action on-demand, bao gồm việc không làm gì cho đến khi cần thiết. Điều này có nghĩa là bạn không cần discover service/characteristic hoặc set notification cho đến khi ứng dụng của bạn thực hiện lệnh read hoặc write. Ưu điểm là giai đoạn kết nối ngắn hơn, vì ứng dụng của bạn không cần discover tất cả service và characteristic, set notification, hoặc xử lý lỗi nếu có bất kỳ lỗi nào xảy ra. Nhược điểm là thao tác read hoặc write đầu tiên sẽ mất nhiều thời gian hơn. Cách tiếp cận thứ hai bao gồm việc discover tất cả Bluetooth profile trước và làm cho thiết bị sẵn sàng cho bất kỳ lệnh nào. Nhược điểm và ưu điểm ngược lại với cách tiếp cận đầu tiên. Không có gì đúng hay sai với mỗi cách tiếp cận; đó chỉ là vấn đề sở thích. Vì vậy, hãy chọn cách phù hợp với bạn nhất. Đối với tôi, tôi thích đi với cách tiếp cận thứ hai, như được mô tả trong hình. Giai đoạn setup trên iOS khá đơn giản. Ứng dụng của bạn chỉ cần discover tất cả service. Với mỗi service, sau đó bạn gọi để discover tất cả characteristic của nó. Cuối cùng, set notification nếu characteristic hỗ trợ thay đổi giá trị. Bạn có thể muốn giữ reference đến mỗi item characteristic (CBPeripheral) để có thể thực hiện các thao tác read và write. Mặt khác, quy trình “make ready” khá phức tạp cho Android. Nếu bạn là nhà phát triển iOS, bạn có thể không tương tác nhiều với GATT Descriptor trong ứng dụng của mình. Đầu tiên, bạn cần làm quen với các khái niệm GATT Descriptor và MTU (Maximum Transmission Unit). GATT Descriptor cung cấp thông tin bổ sung về characteristic mà chúng được liên kết. Ví dụ, khi bạn đọc giá trị nhiệt độ từ nhiệt kế BLE, characteristic có thể có descriptor chỉ ra đơn vị đo lường bằng Celsius hoặc Fahrenheit. GATT Descriptor phổ biến nhất là Client Characteristic Configuration Descriptor (CCCD), mà bạn sẽ sử dụng để enable/disable notification/indicator cho characteristic.Sự khác biệt chính giữa loại notification và indication là độ tin cậy. Notification được gửi bởi peripheral mà không yêu cầu acknowledgment từ central device. Ngược lại, indication yêu cầu acknowledgment từ central device. Việc set notification trên iOS rất đơn giản bằng cách gọi CBCharacteristic.setNotify() và hệ thống sẽ làm phần còn lại cho bạn. Nó sẽ tự động xác định loại notification và set giá trị đúng. Trên Android, bạn phải tự gọi nó. Code mẫu sau minh họa cách bạn có thể set notification cho characteristic trên Android: 12345678910111213141516171819202122232425262728final UUID CCCD_UUID = UUID.fromString(\"00002902-0000-1000-8000-00805f9b34fb\");if (!gattServer.setCharacteristicNotification(characteristic, true)) { return false;}final boolean canNotify = (characteristic.getProperties() &amp; BluetoothGattCharacteristic.PROPERTY_NOTIFY) &gt; 0;final boolean canIndicate = (characteristic.getProperties() &amp; BluetoothGattCharacteristic.PROPERTY_INDICATE) &gt; 0;if (!canNotify &amp;&amp; !canIndicate) { // Không hỗ trợ notification/indication, không làm gì return true;}final BluetoothGattDescriptor cccDescriptor = characteristic.getDescriptor(CCCD_UUID);if (cccDescriptor == null) { // Không tìm thấy descriptor trên characteristic? return false;}if (cccDescriptor.setValue(canNotify ? BluetoothGattDescriptor.ENABLE_NOTIFICATION_VALUE : BluetoothGattDescriptor.ENABLE_INDICATION_VALUE)) { gattServer.writeDescriptor(cccDescriptor); return true;}return false; Bước cuối cùng là tùy chọn: yêu cầu thay đổi giá trị MTU.MTU (Maximum Transmission Unit) đề cập đến lượng dữ liệu lớn nhất có thể được gửi trong một gói tin Bluetooth. Mặc định, giá trị MTU trong BLE là 23 bytes, nói cách khác, cho một lệnh read và write đơn lẻ, số byte tối đa mà ứng dụng/thiết bị của bạn có thể truyền là 23 bytes (với header 3-byte), nhưng nó có thể được thương lượng giữa central và peripheral device lên đến 517 bytes. Trên iOS, bạn không trực tiếp yêu cầu kích thước MTU; thay vào đó, MTU được tự động thương lượng giữa central và peripheral device trong quá trình kết nối. Trên Android, sử dụng BluetoothGatt.requestMtu() để yêu cầu kích thước MTU cụ thể và xử lý response trong BluetoothGattCallback.onMtuChanged(). Một lỗi phổ biến là quên tăng MTU trong khi thiết bị của bạn đang gửi hơn 20 bytes mỗi request, dẫn đến thiếu dữ liệu trong gói tin. Một nhận xét quan trọng liên quan đến việc thiết lập kết nối là có số lượng thiết bị tối đa có thể kết nối đồng thời. Không có tài liệu chính thức cho con số này, nhưng nhiều nhà phát triển đã phát hiện rằng trên iOS khoảng 7 - 10 thiết bị, trong khi trên Android khoảng 10 - 20 tùy thuộc vào model điện thoại và phiên bản Android. 123456789101112private final BluetoothGattCallback gattCallback = new BluetoothGattCallback() { @Override public void onMtuChanged(BluetoothGatt gatt, int mtu, int status) { if (status == BluetoothGatt.GATT_SUCCESS) { // Thay đổi kích thước MTU thành công Log.d(\"MTU\", \"MTU changed to \" + mtu); } else { // Thay đổi kích thước MTU thất bại Log.d(\"MTU\", \"MTU change failed with status \" + status); } }}; InteractingSau khi hoàn thành thành công tất cả các bước trên, thiết bị của bạn giờ đã sẵn sàng sử dụng. Bạn có thể đọc giá trị từ characteristic, truyền dữ liệu đến một characteristic cụ thể, hoặc đọc giá trị RSSI để xác định khoảng cách. Đảm bảo bạn xử lý các thay đổi giá trị đúng cách bằng cách kiểm tra giá trị đến từ characteristic nào. Đáng lưu ý rằng trên iOS, nếu ứng dụng của bạn truyền một lượng lớn dữ liệu đến thiết bị (ví dụ: truyền file), bạn nên đợi sự kiện peripheralIsReady tiếp theo được trigger trước khi gửi gói tin tiếp theo. Việc liên tục gửi nhiều gói tin mà không đợi sự kiện này có thể gây áp lực lên buffer hàng đợi, dẫn đến mất gói tin. 123func peripheralIsReady(toSendWriteWithoutResponse peripheral: CBPeripheral) { // Sẵn sàng gửi gói tin tiếp theo} ClosingMột lần nữa, bước ngắt kết nối trên iOS rất đơn giản. Bạn chỉ cần gọi method cancelPeripheralConnection. Trên Android, bạn cần làm nhiều hơn một thao tác: disconnect thiết bị và close Bluetooth GATT. Hãy nhớ rằng việc gọi disconnect chỉ hủy kết nối với peripheral, nó không giải phóng tất cả resource (ví dụ: các slot khả dụng trong Bluetooth stack) cho đến khi bạn gọi close. Bạn sử dụng disconnect khi bạn muốn tạm thời kết thúc kết nối nhưng có thể kết nối lại với thiết bị sau mà không cần reset hoàn toàn cấu hình GATT. Bạn sử dụng close khi bạn hoàn toàn xong với kết nối Bluetooth và muốn đảm bảo tất cả resource được dọn dẹp. Kết luậnTrong bài viết này, chúng ta đã khám phá các điểm quan trọng của việc triển khai chức năng Bluetooth trong các ứng dụng di động cho iOS và Android. Thông qua so sánh chi tiết, một số điểm chính đã xuất hiện làm nổi bật cả điểm tương đồng và khác biệt giữa hai nền tảng này. iOS Core Bluetooth cung cấp một framework mạnh mẽ và đơn giản tích hợp liền mạch với hệ sinh thái iOS. Nó cung cấp API sạch và nhất quán. Android Bluetooth, mặt khác, cung cấp tính linh hoạt, khả năng mở rộng và hỗ trợ nhiều chức năng Bluetooth. Mặc dù việc setup và triển khai có thể phức tạp hơn một chút so với iOS, API Bluetooth của Android cung cấp các công cụ mạnh mẽ để xử lý các tương tác Bluetooth một cách hiệu quả. Tham khảoThe Ultimate Guide to Android Bluetooth Low EnergyThe Ultimate Guide to Apple’s Core Bluetooth","link":"/vi/posts/Best-practice-iOS-vs-Android-Bluetooth/index.html"},{"title":"Best practice: Quy trình quét BLE nâng cao trên iOS","text":"Các nhà phát triển iOS đang xây dựng các ứng dụng đóng vai trò cả Peripheral và Central để trao đổi dữ liệu với các bản sao ứng dụng khác. Dữ liệu có thể trao đổi một lượng nhỏ thông tin thông qua các gói tin BLE hoặc giá trị chỉ báo cường độ tín hiệu (RSSI) từ thiết bị này sang thiết bị khác. Tuy nhiên, việc giữ ứng dụng chạy mãi ở foreground là không thể. Sớm hay muộn, ứng dụng sẽ chuyển sang chế độ background bởi người dùng và cuối cùng sẽ bị hệ thống tạm dừng tùy thuộc vào RAM khả dụng, mức tiêu thụ năng lượng và các yếu tố khác. Do đó, việc hiểu quy trình advertising và scanning trên thiết bị iOS giúp bạn xây dựng các ứng dụng tốt đáp ứng kỳ vọng của bạn.Ở cuối hướng dẫn này, chúng ta sẽ xây dựng một ứng dụng đơn giản hoạt động vừa là scanner vừa là advertiser. Khi hai ứng dụng tìm thấy nhau, chúng sẽ ghi một bản ghi log để phân tích. Dựa trên kết quả, chúng ta sẽ tìm hiểu xem ứng dụng của mình sử dụng Core Bluetooth hiệu quả như thế nào.Hãy bắt đầu thôi! Kiến thức nền tảngTheo sách Getting Started With Bluetooth Low Energy, hai mục đích chính của các gói tin advertising là: Để broadcast dữ liệu cho các ứng dụng. Để khám phá các slave và kết nối với chúng. Kích thước tối đa của payload mỗi gói tin advertising là 31 bytes, cùng với thông tin header. Mỗi khoảng thời gian trôi qua, từ 20ms đến 10.24s, các gói tin advertising được broadcast một cách mù quáng để thông báo sự hiện diện của nó cho các thiết bị hoặc ứng dụng khác. Có hai loại phương pháp scanning: Passive Scanning: Scanner chỉ đơn giản nhận các gói tin advertising mà không có bất kỳ hành động nào tiếp theo. Active Scanning: Sau khi nhận được gói tin advertising, scanner thực hiện gói tin Scanning Request đến advertiser. Sau khi nhận được Scanning Request, advertiser phản hồi bằng gói tin Scanning Response cho phép advertiser gửi thêm dữ liệu (Thêm 31 bytes) đến scanner. Để phân loại các loại gói tin advertising, chúng ta dựa vào ba thuộc tính: connectability, scannability, và directability Loại gói tin Adv Connectability: Xác định scanner có thể tạo kết nối hay không Scannability: Xác định scanner có thể gửi scan request hay không Directability: Xác định gói tin này có nhắm đến bất kỳ scanner cụ thể nào không. ADV_IND Có Có Không ADV_DIRECT_IND Có Không Có ADV_NONCONN_IND Không Không Không ADV_SCAN_IND Không Có Không Có nhiều chủ đề nâng cao hơn được mô tả chi tiết trong sách Getting Started With Bluetooth Low Energy, như cách dữ liệu được tổ chức trong các thiết bị BLE và cách giao tiếp với phần cứng hiện có, v.v. Nếu bạn muốn biết thêm, vui lòng tham khảo sách.Vì phạm vi của bài viết này, việc hiểu về quy trình advertising là đủ tốt để chúng ta chuyển sang phần tiếp theo. Scanning và advertising trên iOSThiết lập advertiser - PeripheralChúng ta sẽ tái sử dụng repo trước đó của tôi cho phép điện thoại iOS advertise như một peripheral sử dụng Core Bluetooth.Đầu tiên, tôi sẽ tạo 5 UUID làm service của advertiser (Peripheral). 1234let kServiceUUID1 = \"1FA2FD8A-17E0-4D3B-AF45-305DA6130E39\"...let kServiceUUID4 = \"4FA2FD8A-17E0-4D3B-AF45-305DA6130E39\"let kServiceUUID5 = \"5FA2FD8A-17E0-4D3B-AF45-305DA6130E39\" Tiếp theo, tôi sẽ tạo một danh sách CBMutableService và sau đó thêm chúng vào đối tượng CBPeripheralManager. 12345678910111213141516services.forEach { (each) in let cbService = CBMutableService(type: each.uuid.cbUUID, primary: true) var charArr = [CBMutableCharacteristic]() each.characteristics.forEach { (char) in charArr.append(CBMutableCharacteristic.init( type: char.uuid.cbUUID, properties: [.read, .write, .notify], value: nil, permissions: CBAttributePermissions(char.permissions.map { $0.cbAttributePermission } ))) } cbService.characteristics = charArr self.peripheralManager.add(cbService)} Cuối cùng, chúng ta bắt đầu advertising peripheral khi state của nó sẵn sàng. 12self.peripheralManager.startAdvertising([CBAdvertisementDataLocalNameKey: \"uynguyen\", CBAdvertisementDataServiceUUIDsKey: self.cbServices.map { $0.uuid }]) Khi đoạn code trên được thực thi, chúng ta sẽ thấy log sau được in ra. 123456789101112Add service 1FA2FD8A-17E0-4D3B-AF45-305DA6130E39 Succeeded---&gt; Chars [&lt;CBMutableCharacteristic: 0x2802d4070 UUID = 463FED20-DA93-45E7-B00F-B5CD99775150, Value = (null), Properties = 0x1A, Permissions = 0x3, Descriptors = (null), SubscribedCentrals = ()&gt;, &lt;CBMutableCharacteristic: 0x2802d4380 UUID = 463FED21-DA93-45E7-B00F-B5CD99775150, Value = (null), Properties = 0x112, Permissions = 0x1, Descriptors = (null), SubscribedCentrals = ()&gt;, &lt;CBMutableCharacteristic: 0x2802d4620 UUID = 463FED22-DA93-45E7-B00F-B5CD99775150, Value = {length = 6, bytes = 0x486168616861}, Properties = 0x2, Permissions = 0x1, Descriptors = (null), SubscribedCentrals = ()&gt;]...Add service 5FA2FD8A-17E0-4D3B-AF45-305DA6130E39 Succeeded---&gt; Chars []===&gt; Start advertising Succeeded Thiết lập scanner - CentralBước tiếp theo là thiết lập Central Manager - scanner của chúng ta. Như bạn có thể biết từ hướng dẫn trước của tôi, code để quét các thiết bị gần đó khá đơn giản. 1234private func startScanning() { self.centralManager?.scanForPeripherals(withServices: nil, options: [CBCentralManagerScanOptionAllowDuplicatesKey: true])} Giá trị nil chúng ta truyền vào param withServices chỉ ra rằng chúng ta sẽ quét tất cả các thiết bị gần đó mà không chỉ định service uuid. Option CBCentralManagerScanOptionAllowDuplicatesKey chỉ định việc quét nên chạy mà không lọc trùng lặp. Khi central phát hiện một peripheral, chúng ta sẽ in thông tin của nó bao gồm local name và giá trị CBAdvertisementDataServiceUUIDsKey trong gói tin advertising. 12345public func centralManager(_ central: CBCentralManager, didDiscover peripheral: CBPeripheral, advertisementData: [String : Any], rssi RSSI: NSNumber) { print(\"Did found per \\(peripheral.name)\") print(\"CBAdvertisementDataServiceUUIDsKey adv value \" + advertisementData[CBAdvertisementDataServiceUUIDsKey])// ...} Hãy build và chạy project, 12345Did found peripheral name: Optional(\"Uy Nguyen iPad\")CBAdvertisementDataServiceUUIDsKey adv value:Optional(&lt;__NSArrayM 0x282a79350&gt;( 1FA2FD8A-17E0-4D3B-AF45-305DA6130E39)) Nhìn vào log, bạn có thể phát hiện điều gì sai không? Có một vấn đề với gói tin advertising: giá trị CBAdvertisementDataServiceUUIDsKey chỉ chứa 1 service, các service còn lại từ 2 đến 5 ở đâu? Hãy in ra toàn bộ gói tin advertising để xem nó chứa gì. 1234[\"kCBAdvDataServiceUUIDs\": &lt;__NSArrayM 0x283460630&gt;(1FA2FD8A-17E0-4D3B-AF45-305DA6130E39), \"kCBAdvDataLocalName\": uynguyen, \"kCBAdvDataTimestamp\": 620013184.4512661, \"kCBAdvDataRxPrimaryPHY\": 0, \"kCBAdvDataIsConnectable\": 1, \"kCBAdvDataRxSecondaryPHY\": 0] Vẫn không may, chúng ta không thể tìm thấy các service khác từ &quot;2FA2FD8A-17E0-4D3B-AF45-305DA6130E39&quot; đến &quot;5FA2FD8A-17E0-4D3B-AF45-305DA6130E39&quot;. Tìm hiểu vấn đềHóa ra gói tin advertising mà Central nhận được phụ thuộc vào cách chúng ta gọi method scanForPeripherals.Nếu chúng ta thay đổi param withServices thành một mảng các service của chúng ta từ &quot;1FA2FD8A-17E0-4D3B-AF45-305DA6130E39&quot; đến &quot;5FA2FD8A-17E0-4D3B-AF45-305DA6130E39&quot; một cách rõ ràng, chúng ta sẽ thấy sự khác biệt. 12345678private func startScanning() { self.centralManager?.scanForPeripherals(withServices: [CBUUID(string: \"1FA2FD8A-17E0-4D3B-AF45-305DA6130E39\"), CBUUID(string: \"2FA2FD8A-17E0-4D3B-AF45-305DA6130E39\"), CBUUID(string: \"3FA2FD8A-17E0-4D3B-AF45-305DA6130E39\"), CBUUID(string: \"4FA2FD8A-17E0-4D3B-AF45-305DA6130E39\"), CBUUID(string: \"5FA2FD8A-17E0-4D3B-AF45-305DA6130E39\")], options: [CBCentralManagerScanOptionAllowDuplicatesKey: true])} Đây là log nhận được. 12345678910[\"kCBAdvDataIsConnectable\": 1, \"kCBAdvDataServiceUUIDs\": &lt;__NSArrayM 0x280708750&gt;(1FA2FD8A-17E0-4D3B-AF45-305DA6130E39), \"kCBAdvDataLocalName\": uynguyen, \"kCBAdvDataRxSecondaryPHY\": 0, \"kCBAdvDataHashedServiceUUIDs\": &lt;__NSArrayM 0x280708720&gt;(2FA2FD8A-17E0-4D3B-AF45-305DA6130E39,3FA2FD8A-17E0-4D3B-AF45-305DA6130E39,4FA2FD8A-17E0-4D3B-AF45-305DA6130E39,5FA2FD8A-17E0-4D3B-AF45-305DA6130E39), \"kCBAdvDataRxPrimaryPHY\": 0, \"kCBAdvDataTimestamp\": 620013608.239601] Bây giờ, chúng ta có thể thấy giá trị mới chứa bên trong gói tin advertising, kCBAdvDataHashedServiceUUIDs. Nhưng nó là gì?Hãy quay lại phía Peripheral, nếu bạn nhìn kỹ hơn vào định nghĩa của method advertising của đối tượng Peripheral, bạn có thể biết nó thực sự là gì. Nói ngắn gọn, khi bạn làm cho iPhone advertise như một peripheral, nếu không có không gian cho bất kỳ service UUID nào chứa trong giá trị của CBAdvertisementDataServiceUUIDsKey, các service này sẽ được chuyển đến một không gian khác gọi là overflow area. Một thuật ngữ khác, T_T Chính xác overflow area có nghĩa là gì?Về cơ bản, overflow area được đặt trong gói tin scan response. Các service uuid này được hash bởi thuật toán của Apple và chỉ được phát hiện bởi thiết bị iOS quét chúng một cách rõ ràng. Trong trường hợp của chúng ta, vì chúng ta truyền các service uuid từ 1F đến 5F khi bắt đầu scanning, chúng ta sẽ nhận được giá trị kCBAdvDataHashedServiceUUIDs này trong các gói tin advertising. Để xác minh điều này, tôi sử dụng một công cụ được Apple giới thiệu để debug BLE - (A New Way to Debug iOS Bluetooth Applications), để lấy gói tin advertising từ Peripheral của chúng ta để phân tích.Và đây là kết quả Loại gói tin Advertising: ADV_IND, có nghĩa là scanner có thể tạo kết nối với nó; và scanner có thể gửi scan request; và các gói tin của nó không nhắm đến bất kỳ scanner cụ thể nào. Hộp màu vàng là dữ liệu advertising: (Data: 02 01 1A 11 06 39 0E 13 A6 5D 30 45 AF 3B 4D E0 17 8A FD A2 1F 09 09 75 79 6E 67 75 79 65 6E), độ dài = 31 bytes; nó chứa CBAdvertisementDataLocalName (75 79 6E 67 75 79 65 6E &gt; “uynguyen”) và service uuid đầu tiên của chúng ta 1F A2 FD 8A 17 E0 4D 3B AF 45 30 5D A6 13 0E 39 (39 0E 13 A6 5D 30 45 AF 3B 4D E0 17 8A FD A2 1F). Gói tin scan response (SCAN_RSP) chứa các thông tin khác mà gói tin advertising không đủ độ dài để mang theo. Trong trường hợp của chúng ta, nó chứa các service khác từ 2F đến 5F. Việc hiểu gói tin này khá phức tạp để đưa vào hướng dẫn này nên tôi sẽ bỏ qua việc giải thích nó bây giờ. Tôi có một hướng dẫn khác làm việc với gói tin này sau. Tóm lại, điều chúng ta đã tìm ra ở đây là: Advertising, khi ứng dụng ở background, hoạt động khác với khi ở foreground. CBAdvertisementDataLocalNameKey bị bỏ qua. Tất cả service UUID chứa trong giá trị của key CBAdvertisementDataServiceUUIDsKey được đặt trong vùng “overflow” đặc biệt; chúng chỉ có thể được phát hiện bởi thiết bị iOS đang quét chúng một cách rõ ràng. Kiểm thửBảng dưới đây tóm tắt những gì chúng ta đã điều tra. 1* YES có nghĩa là Central có thể tìm thấy Peripheral. Trường hợp 1 - Cả màn hình Peripheral và Central đều bật \\ Peripheral Background Peripheral Foreground Central Background Có Có Central Foreground Có Có Trường hợp 2 - Màn hình Peripheral tắt (khóa), màn hình Central bật \\ Peripheral Background Peripheral Foreground Central Background Có Có Central Foreground Có Có Trường hợp 3 - Màn hình Central tắt (khóa), màn hình Peripheral bật \\ Peripheral Background Peripheral Foreground Central Background Không Không Central Foreground Không Không Trường hợp 4 - Cả màn hình Peripheral và Central đều tắt (khóa) \\ Peripheral Background Peripheral Foreground Central Background Không Không Central Foreground Không Không Từ các thí nghiệm trên, bất kể trạng thái của thiết bị đóng vai trò Peripheral, màn hình của thiết bị đóng vai trò Central phải bật để nó có thể quét các peripheral gần đó. Nói cách khác, nếu chúng ta đang xây dựng một ứng dụng cho phép thiết bị iOS phát hiện các thiết bị iOS gần đó khác, chúng ta phải chạy cả chế độ Central và Peripheral trên mỗi thiết bị VÀ quan trọng nhất, nếu hai thiết bị muốn tìm thấy nhau, một trong hai màn hình phải được bật.Có một kỹ thuật (Có vẻ như là một mẹo) để vượt qua vấn đề này, đó là lên lịch định kỳ để đẩy notification đến các thiết bị iOS của bạn, việc này ngay lập tức bật màn hình lên để Central có thể phát hiện các Peripheral gần đó.Khi ứng dụng ở background, nó hoạt động khác với khi ở foreground. Một trong số đó là tần suất các gói tin advertising được gửi có thể giảm. Kết quả là, Scanner ở background tìm các peripheral gần đó chậm hơn so với khi ở foreground. Kết luậnChúc mừng! Chúng ta đã đi qua một hướng dẫn để có cái nhìn sâu hơn về cách CoreBluetooth trên iOS hoạt động ở cả chế độ Central và Peripheral. Hy vọng bạn thấy bài viết này thú vị!Nếu bạn có bất kỳ ý kiến nào, hãy gửi email cho tôi tại uynguyen.itus@gmail.com hoặc để lại câu hỏi của bạn trong hộp bình luận. Made with love.","link":"/vi/posts/Best-practice-Advanced-BLE-scanning-process-on-iOS/index.html"},{"title":"Beta Test và TestFlight","text":"Là một iOS developer, bạn có thể đã nghe về TestFlight - một sản phẩm của Apple cho phép bạn phân phối ứng dụng của mình đến người dùng beta. Vậy chúng ta có thể làm gì với nó? Nó có hữu ích không?Trong hướng dẫn này, chúng ta sẽ đi qua các bước tải một build lên TestFlight, và mời người dùng test ứng dụng của bạn.Bạn cũng cần tham khảo bài viết trước Đưa ứng dụng của bạn lên Store để hoàn thành hướng dẫn này.Hãy bắt đầu! TestFlight là gì?TestFlight là một sản phẩm của Apple cho phép developers phân phối ứng dụng của họ đến người dùng beta trước khi đưa lên production. Với bản cập nhật mới nhất của ứng dụng TestFlight trên iOS 13, testers có thể đưa phản hồi trực tiếp từ ứng dụng với screenshots, crashes và các thông tin hữu ích khác được cung cấp. Sử dụng TestFlight là một cách tuyệt vời để giúp test ứng dụng của bạn và cải thiện hiệu suất trước khi nó được phát hành chính thức.TestFlight cung cấp hai loại testers: Internal Tester: Cho phép tối đa 25 thành viên trong team của bạn đã được chỉ định vai trò cụ thể để test ứng dụng của bạn. Mỗi thành viên có thể test trên tối đa 30 thiết bị. Khi một beta build được gửi lên App Store Connect và sẵn sàng để testing, internal testers sẽ được thông báo để họ có thể cập nhật ứng dụng. External Tester: Bạn có thể mời tối đa 10.000 testers chỉ bằng địa chỉ email của họ hoặc bằng cách chia sẻ public link. Sự khác biệt chính giữa hai loại là để cho External Tester test ứng dụng của bạn, bạn phải gửi ứng dụng cho Apple để review. Quá trình review giống như một submission chính thức nhưng thường nhanh hơn các app reviews bình thường. Ngược lại, testing ứng dụng của bạn với internal testers không yêu cầu review từ Apple. Chọn build để testingSau khi hoàn thành bước cuối cùng tại Đưa ứng dụng của bạn lên Store, ứng dụng của bạn đã được gửi thành công lên App Store Connect. Bây giờ, điều hướng đến trang Apple developer và đăng nhập với Apple Id của bạn, sau đó chọn “My Apps” để xem tất cả các ứng dụng có sẵn &gt; Chọn một ứng dụng cụ thể &gt; Từ thanh công cụ trên cùng &gt; Chọn TestFlight &gt; Bạn sẽ thấy tất cả các builds sẵn sàng để testing.Hình ảnh sau đây cho bạn cái nhìn nhanh về TestFlight dashboard Từ cửa sổ chính, bạn có thể thấy tất cả các versions có sẵn của ứng dụng; khi nào hết hạn; bao nhiêu lời mời đã được gửi; bao nhiêu cài đặt thành công. v.v.Để thêm người dùng mới, click vào “App Store Connect Users” ở thanh bên trái &gt; Nhấn nút “+” &gt; Sau đó điền thông tin tester của bạn bao gồm App Id của họ. Sau đó, bạn có thể thêm tester của mình vào build. Ứng dụng TestFlightTesters cần cài đặt ứng dụng TestFlight trên thiết bị của họ. Ứng dụng này miễn phí và có sẵn trên App Store. Sau khi thêm testers của bạn vào build, testers sẽ sử dụng email mời hoặc public link để đăng ký testing.Mở ứng dụng TestFlight, tester cần đăng nhập với App Id của họ. Sau đó, họ sẽ thấy tất cả các ứng dụng có sẵn mà họ có thể cài đặt, giống như App Store. Một lưu ý nhỏ là bạn sẽ thấy một chấm màu cam nhỏ gần tên ứng dụng để chỉ ra build này được cài đặt từ TestFlight. Dễ dàng, phải không? Từ giờ trở đi, bất cứ khi nào một build của ứng dụng này có sẵn, tester của bạn sẽ nhận được thông báo và email từ TestFlight. Sau đó họ có thể cập nhật ứng dụng này qua TestFlight và tận hưởng phiên bản mới nhất. Sau khi testingKhi bạn hoàn tất testing, bạn có thể dừng ứng dụng khỏi testing, và sau đó tiến hành publish ứng dụng cho quá trình gửi ứng dụng lên App Store. Beta build của bạn sẽ không còn khả dụng trong TestFlight sau 90 ngày theo mặc định.Trong bài viết này, chúng ta đã có cái nhìn nhanh về TestFlight và cách phân phối beta test đến testers của bạn. Trong thực tế, beta testing là một thuật ngữ phổ biến trong quy trình phát triển phần mềm. Có kiến thức về cách phân phối ứng dụng sẽ hữu ích trong một số tình huống.Happy coding!!!","link":"/vi/posts/Beta-Test-and-TestFlight/index.html"},{"title":"Big Endian vs Little Endian","text":"Trong khoa học máy tính, bit là đơn vị thông tin nhỏ nhất. Nó đại diện cho một chữ số của hệ thống số nhị phân. Một chuỗi 8 bit được gọi là một byte. Có hai cách để lưu trữ một chuỗi dữ liệu trong máy tính: Big Endian và Little Endian. Nếu công việc của bạn liên quan đến dữ liệu theo byte, bạn nên biết cách xử lý byte theo hai định dạng này. Trong bài viết này, tôi sẽ giải thích cách dữ liệu được lưu trữ trong máy tính, sự khác biệt chính giữa hai định dạng này, sau đó cung cấp một số code hữu ích để làm việc với byte trong Swift và Objective-C. Các khái niệm cơ bảnĐể hiểu Big Endian và Little Endian, bạn cần biết Least Significant Byte (LSB) và Most Significant Byte (MSB) là gì. LSB là bit ngoài cùng bên phải trong một chuỗi, nó được gọi như vậy vì nó có ảnh hưởng ít nhất đến giá trị của số nhị phân. Ngược lại, byte ngoài cùng bên trái là MSB mang giá trị số lớn nhất.Sau khi hiểu hai khái niệm này, việc phân biệt giữa Big Endian và Little Endian trở nên dễ dàng: Trong Big Endian, MSB của dữ liệu được đặt tại byte có địa chỉ thấp nhất. Trong Little Endian, LSB của dữ liệu được đặt tại byte có địa chỉ thấp nhất. Đó là tất cả! Ưu điểm của Big Endian và Little Endian trong kiến trúc máy tínhTheo Wiki, Big endian là “định dạng phổ biến nhất trong mạng dữ liệu”, nhiều giao thức mạng như TCP, UPD, IPv4 và IPv6 đang sử dụng thứ tự Big endian để truyền dữ liệu. Little endian chủ yếu được sử dụng trên vi xử lý. Nhưng điểm quan trọng là tại sao họ làm như vậy?Khi làm việc với byte order trên iOS, tôi cũng đặt câu hỏi cho bản thân và đồng nghiệp, “tại sao họ làm như vậy?”, “Tại sao họ chọn Big Endian thay vì Little Endian?”. Sau khi nghiên cứu trên internet và nhận được câu trả lời từ một kỹ sư firmware cao cấp trong văn phòng, tôi dần hiểu được ưu điểm của cả hai cách sắp xếp này.Các ưu điểm của Little Endian là: Dễ dàng đọc giá trị với nhiều kích thước kiểu khác nhau. Ví dụ, biến A = 0x13 ở giá trị 64-bit trong bộ nhớ tại địa chỉ B sẽ là 1300 0000 0000 0000. A sẽ luôn được đọc là 19 bất kể sử dụng đọc 8, 16, 32, 64-bit. Ngược lại, trong Big Endian chúng ta phải biết kích thước mà giá trị đã được ghi để đọc nó chính xác. Dễ dàng ép kiểu giá trị sang một kiểu nhỏ hơn như từ int16_t sang int8_t vì int8_t là byte ở đầu của int16_t. Dễ dàng thực hiện các phép tính toán học “vì mối quan hệ 1:1 giữa offset địa chỉ và số byte (offset 0 là byte 0), các routine toán học đa độ chính xác tương ứng dễ viết.” Một số ưu điểm chính của Big Endian là Chúng ta luôn có thể kiểm tra số dương hay âm bằng cách nhìn vào byte tại offset zero, vì vậy dễ dàng thực hiện so sánh. Các số cũng được lưu trữ theo thứ tự in ra, vì vậy các routine chuyển đổi nhị phân sang thập phân đặc biệt hiệu quả. Byte order trên iOSCả Swift và Objective-C đều hỗ trợ các phương thức giúp chúng ta đọc và ghi dữ liệu theo hai cách Little Endian và Big Endian. Các phần sau đây trình bày cách chúng ta sử dụng các phương thức này để tương tác với dữ liệu trên bộ nhớ. Byte order trong Objective-C1234567891011121314NSString *strData = @\"001E653A\";NSData *data = [NSData dataWithHexString:strData];uint8_t *bytes = (uint8_t *)data.bytes;/* Functions for loading little endian to host endianess. */uint16_t firstInLittle = OSReadLittleInt16(bytes, 0); // 0x1E00 = 7680uint16_t secondInLittle = OSReadLittleInt16(bytes, 2); // 0x3A65 = 14949uint16_t firstInBig = OSReadBigInt16(bytes, 0); // 0x001E = 30uint16_t secondInBig = OSReadBigInt16(bytes, 2); // 0x653A = 25914/* Functions for storing host endianess to little endian. */uint8_t byte16[2];OSWriteLittleInt16(byte16, 0, firstInLittle); // byte16 = [0x00, 0x1E] Byte order trong Swift123456789101112let strData = \"3A651E00\"if let data = strData.hexadecimal() { let bytesArr = [UInt8](data) /* Functions for loading native endian values. */ let little = _OSReadInt16(bytesArr, 0) // 0x653A = 25914 let big = first.bigEndian // 0x3A65 = 14949 /* Functions for storing native endian values. */ let bytes = [UInt8](repeating: 0, count: 2) _OSWriteInt16(UnsafeMutableRawPointer(mutating:bytes), 0, second) // bytes = [0x65, 0x3A]} Kết luậnTrong bài viết này, tôi đã cho bạn thấy sự khác biệt giữa các định dạng endianness và cung cấp một số code hữu ích để làm việc với byte trên iOS. Nếu bạn có bất kỳ đề xuất nào, hãy cho tôi biết.Chúc cuối tuần vui vẻ.","link":"/vi/posts/Big-Endian-vs-Little-Endian/index.html"},{"title":"Tích hợp Bluetooth với App Clips: Hướng dẫn chi tiết","text":"Ngày nay, người dùng yêu cầu truy cập nhanh chóng và dễ dàng vào các dịch vụ họ cần, mà không cần tải xuống phiên bản đầy đủ của ứng dụng. App Clips - một tính năng được Apple giới thiệu trên iOS 14 - cung cấp giải pháp cho nhu cầu này bằng cách cho phép người dùng truy cập một phần nhỏ của ứng dụng. Bằng cách tích hợp ứng dụng hỗ trợ Bluetooth của bạn vào App Clip, bạn có thể nâng trải nghiệm người dùng lên tầm cao mới. Điều này mở ra những khả năng mới, như cho phép người dùng kết nối với các thiết bị gần đó, thực hiện một tính năng cụ thể, và nhiều hơn nữa. Trong hướng dẫn này, tôi sẽ hướng dẫn bạn cách tích hợp Bluetooth vào App Clip của bạn. Dù bạn là nhà phát triển dày dạn kinh nghiệm hay người mới, bạn sẽ tìm thấy mọi thứ cần thiết để bắt đầu. Vậy, hãy bắt đầu thôi! App Clips“App Clip là một phần nhỏ của ứng dụng có thể được khám phá vào đúng lúc cần thiết và cho phép người dùng hoàn thành một tác vụ nhanh chóng từ ứng dụng của bạn - ngay cả trước khi cài đặt ứng dụng đầy đủ.”. App Clips được thiết kế để nhẹ và nhanh, cung cấp truy cập nhanh chóng vào các tính năng và dịch vụ cốt lõi của ứng dụng.Có nhiều lợi ích của việc sử dụng App Clips. Thứ nhất, nó cung cấp một phần nhẹ của ứng dụng cho người dùng dùng thử tính năng mà không cần cam kết tải xuống đầy đủ. Thứ hai, App Clips có thể được khởi chạy thông qua nhiều kênh như thẻ NFS, mã QR, link từ Safari, hoặc Messages.Dưới đây là một số trường hợp sử dụng và ứng dụng mẫu sử dụng App Clips: Bán vé: App Clip có thể được sử dụng để nhanh chóng mua và truy cập vé cho các sự kiện như concert, phim, hoặc sự kiện thể thao. Đặt xe: App Clip có thể được sử dụng để dễ dàng yêu cầu dịch vụ xe. Ví dụ: Lyft. Bán lẻ: App Clips có thể được sử dụng để nhanh chóng truy cập thông tin sản phẩm, mua hàng, hoặc đổi coupon tại cửa hàng bán lẻ. Đặt đồ ăn: người dùng có thể nhanh chóng truy cập menu nhà hàng và đặt món. Ví dụ: Panera Bread. Đỗ xe: Người dùng chỉ cần quét mã QR hoặc chạm thẻ NFS để khởi chạy App Clip và thanh toán chỗ đỗ xe. Xin lưu ý rằng cần có tài khoản Apple trả phí để phát triển App Clip. Cấu hìnhMở hostingTrước khi khởi chạy App Clip, hệ thống đảm bảo rằng App Clip bao gồm chữ ký code trên website của bạn. Nếu bạn có website riêng, bạn có thể thêm các dòng sau vào Apple App Site Association (AASA) trên server và chuyển sang bước tiếp theo. 1234567{ &quot;appclips&quot;: { &quot;apps&quot;: [ &quot;[YOUR_TEAM_ID].[YOUR_APP_CLIP_BUNDLE_ID]&quot; ] }} Firebase Hosting có thể là lựa chọn tuyệt vời cho những ai không có server riêng. Với Firebase Hosting, bạn có thể dễ dàng cấu hình site mà không mất phí vì nó cung cấp gói miễn phí cho hosting. Cài đặt công cụ dòng lệnh Firebase qua lệnh sau sudo npm install -g firebase-tools Tiếp theo, đăng nhập vào tài khoản Firebase của bạn firebase login Sau khi đăng nhập thành công, điều hướng đến thư mục chứa file bạn muốn upload, và sau đó chạy firebase init để chọn option hosting. Thêm các dòng sau vào file firebase.json. 1234567891011121314...&quot;headers&quot;: [ { &quot;source&quot;: &quot;/.well-known/apple-app-site-association&quot;, &quot;headers&quot;: [ { &quot;key&quot;: &quot;Content-Type&quot;, &quot;value&quot;: &quot;application/json&quot; } ] }],&quot;appAssociation&quot;: &quot;NONE&quot;,... Tiếp theo, tạo file public/.well-known/apple-app-site-association. 1234567{ &quot;appclips&quot;: { &quot;apps&quot;: [ &quot;[YOUR_TEAM_ID].[YOUR_APP_CLIP_BUNDLE_ID]&quot; ] }} Cuối cùng, upload file lên firebase firebase deploy Sau khi deploy thành công, bạn sẽ được cung cấp URL cho website của mình. URL này sẽ được sử dụng để cấu hình khởi chạy App Clip của bạn. Thêm App Clip targetĐầu tiên, mở project Xcode của bạn và điều hướng đến menu File. Từ đó, chọn New và sau đó Target. Điều này sẽ hiển thị hộp thoại cho phép bạn chọn loại target mà bạn muốn tạo. Tiếp theo, chọn option App Clip và click Next. Điều này sẽ đưa bạn đến màn hình nơi bạn có thể cấu hình các cài đặt khác nhau cho App Clip của mình, như tên, identifier, và deployment target. Sau khi bạn đã cấu hình các cài đặt này, click Finish để tạo App Clip target mới. Điều này sẽ thêm các file và resource cần thiết vào project của bạn và cho phép bạn bắt đầu phát triển App Clip. Để cấu hình App Clip khởi chạy đúng cách, bạn cần làm theo một vài bước đơn giản.Đầu tiên, chọn App Clip target từ Xcode, sau đó điều hướng đến Signing &amp; Capabilities và chọn Associated Domains. Từ đó, bạn có thể thêm URL hosting của mình vào danh sách domain mà App Clip được liên kết. Ví dụ, giả sử URL hosting của bạn là awesomeapp-54431.web.app. Trong trường hợp này, bạn sẽ thêm appclips:awesomeapp-54431.web.app vào danh sách domain. Sau khi bạn hoàn thành các bước này, mọi thứ sẽ được thiết lập đúng cách và bạn có thể bắt đầu triển khai các chức năng App Clip của mình. Điều này có thể bao gồm viết code để tương tác với các API khác nhau, thiết kế giao diện người dùng, và nhiều hơn nữa. Chi tiết cụ thể sẽ phụ thuộc vào yêu cầu cụ thể của App Clip và các tính năng bạn muốn bao gồm. Triển khaiTôi sẽ phát triển một ứng dụng rất đơn giản cho phép quét các thiết bị Bluetooth gần đó và hiển thị chúng trên danh sách khi khởi chạy App Clip để minh họa cách sử dụng Bluetooth trong App Clip. Bạn có thể sửa đổi ứng dụng để phù hợp với nhu cầu của mình, như tự động nhận dạng thiết bị được chọn trước theo địa chỉ và tự động kết nối đến thiết bị để thực hiện một tác vụ cụ thể. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950struct ContentView: View { // Phần còn lại được lược bỏ ... var body: some View { NavigationView { VStack { Image(\"logo\").resizable() .scaledToFit() .frame(width: 120).padding(.top, 10) TitleLargeText(\"Awesome App\").padding(.bottom, 5).padding(.top, 10).padding(.bottom, 10) Spacer() LabelLargeText(\"Nearby Devices\").frame(maxWidth: .infinity, alignment: .leading).padding(.horizontal, 20) List(devices.map { $0.name ?? \"Unknown name\" }, id: \\.self) { deviceName in LabelMediumText(deviceName) } VStack { HStack { LabelMediumText(\"Powered By\") Link(destination: URL(string: \"https://uynguyen.github.io\")!, label: { LabelMediumText(\"Uy Nguyen\", underline: true) }) }.padding(.top, 5) } } .frame(maxWidth: .infinity, maxHeight: .infinity, alignment: .top) .background(Color.black).onContinueUserActivity(NSUserActivityTypeBrowsingWeb, perform: handleUserActivity) .navigationBarTitle(\"\") .navigationBarHidden(true) } } func handleUserActivity(_ userActivity: NSUserActivity) { // Bạn có thể trích xuất params từ url, xác thực url có hợp lệ không, v.v. guard let incomingURL = userActivity.webpageURL, let components = URLComponents(url: incomingURL, resolvingAgainstBaseURL: true), let queryItems = components.queryItems else { return } // Mọi thứ ổn, hãy bắt đầu scanning BluetoothManager.shared.config { device, rssi in if !(devices.contains(where: { $0.identifier.uuidString == device.identifier.uuidString })) { devices.append(device) } } } ...} Kiểm thửMã QR &amp; NFCApple hỗ trợ kiểm thử App Clip của bạn mà không cần phải publish nó bằng cách đăng ký Local Experience.Để đăng ký local experience, vào Settings điện thoại và chọn Developer. Từ đó, bạn có thể truy cập menu Local Experiences và click vào Register Local Experience.Sau khi bạn đã nhập URL prefix và Bundle ID, bạn sẽ có thể bắt đầu điền thông tin cho App Clip Card của mình. Đây là phần sẽ hiển thị cho người dùng khi họ click vào URL hoặc quét mã QR liên kết với App Clip của bạn.Trong phần App Clip Card, bạn sẽ có thể cung cấp cho người dùng thông tin quan trọng về App Clip của mình, bao gồm tên, banner, và mô tả. Thông tin này nên rõ ràng và ngắn gọn để người dùng có thể nhanh chóng hiểu App Clip của bạn làm gì và nó có thể hữu ích với họ như thế nào.Ngoài ra, bạn cũng cần chọn loại nút mà bạn muốn sử dụng cho App Clip của mình. Có ba loại nút khác nhau: Open, View, và Play.Nút Open được sử dụng để khởi chạy App Clip và đưa người dùng trực tiếp đến giao diện chính của nó.Nút View được sử dụng để hiển thị nội dung cụ thể trong App Clip, như một trang hoặc tính năng cụ thể.Cuối cùng, nút Play được sử dụng để khởi chạy trình phát media trong App Clip, cho phép người dùng nghe nhạc hoặc xem video.Bằng cách làm theo các bước đơn giản này và cung cấp cho người dùng App Clip Card rõ ràng và hấp dẫn, bạn có thể giúp đảm bảo rằng App Clip của mình thành công và được đón nhận tốt bởi đối tượng mục tiêu. Trong video dưới đây, bạn có thể xem minh họa về cách quét mã QR liên kết với website của tôi, tự động khởi chạy App Clip và bắt đầu quy trình Bluetooth scanning cho các thiết bị gần đó. Đây là một ví dụ đơn giản về cách App Clips có thể cung cấp trải nghiệm người dùng tiện lợi, loại bỏ nhu cầu người dùng phải điều hướng qua nhiều màn hình hoặc tải xuống ứng dụng đầy đủ. Lưu ý: Nếu bạn thấy mình không còn cần App Clip đã cài đặt trước đó trên thiết bị iOS, bạn có thể dễ dàng xóa nó bằng cách làm theo một vài bước đơn giản. Chỉ cần vào Settings và chọn option App Clips. Từ đó, bạn có thể chọn App Clip mà bạn muốn xóa và click vào option để delete nó. Nếu bạn đang gặp vấn đề với App Clip và nó không khởi chạy được mặc dù đã cấu hình đúng, điều đầu tiên bạn nên thử là invalidate cache và đăng ký lại local experience. Điều này có thể được thực hiện bằng cách vào Settings và chọn option Developer. Từ đó, bạn có thể truy cập menu Local Experiences và click vào option Invalidate Cache. Sau khi làm xong, bạn có thể đăng ký lại local experience và thử khởi chạy App Clip lại. Safari &amp; iMessageNgoài việc khởi chạy App Clips qua mã QR, Apple cũng hỗ trợ khởi chạy App Clip của bạn khi người dùng chia sẻ link đến website của bạn qua ứng dụng Messages, hoặc xem URL trực tiếp trên Safari. Người nhận có thể tap vào link để ngay lập tức khởi chạy App Clip để truy cập chức năng của App Clip nhanh chóng và dễ dàng. Điều quan trọng cần lưu ý là Smart App Banner của Safari và chia sẻ qua Messages chỉ khả dụng khi App Clip được publish trên App Store. App Clip banner trên Safari: yêu cầu thiết bị người dùng chạy iOS 15+. App Clip banner trên iMessage: yêu cầu thiết bị người dùng chạy iOS 14+, và có người gửi là contact trong ứng dụng Contacts. Để bật hiển thị App Clip card trong Safari và iMessage, cấu hình các dòng sau trên website của bạn. 1234&lt;meta name=&quot;apple-itunes-app&quot; content=&quot;app-id=YOUR_APP_ID, app-clip-bundle-id=YOUR_APP_CLIP_ID, app-clip-display=card&quot; /&gt;&lt;meta property=&quot;og:image&quot; content=&quot;BANNER_URL&quot; /&gt;&lt;meta property=&quot;og:title&quot; content=&quot;Awesome App&quot; /&gt;&lt;meta property=&quot;og:description&quot; content=&quot;Awesome App description&quot; /&gt; Best practice Giữ đơn giản: Mục đích của App Clip là cung cấp phiên bản đơn giản hóa chức năng của ứng dụng. Tập trung vào việc chỉ cung cấp các tính năng chính mà người dùng có khả năng cần nhất trong bối cảnh họ đang sử dụng App Clip. Tối ưu hóa tốc độ: App Clips nên nhẹ và tải nhanh (Apple yêu cầu kích thước App Clip phải nhỏ hơn 15MB, điều này để đảm bảo rằng App Clips có thể được tải xuống và khởi chạy nhanh chóng, ngay cả trên kết nối mạng chậm.) để đảm bảo người dùng có thể nhanh chóng truy cập chức năng họ cần. Giảm thiểu lượng nội dung và asset được tải để đảm bảo App Clip tải nhanh và không tiêu tốn quá nhiều dữ liệu. Điều quan trọng là giữ số lượng parameter ở mức tối thiểu và đảm bảo chúng dễ hiểu. Parameter càng phức tạp, người dùng càng khó biết cách sử dụng chúng. Giới hạn độ dài parameter: Tốt nhất là giới hạn độ dài parameter không quá 50 ký tự. Điều này sẽ giúp đảm bảo người dùng có thể dễ dàng đọc và hiểu các parameter. Validate parameter: Đảm bảo rằng App Clip của bạn validate tất cả parameter được truyền vào. Điều này sẽ giúp đảm bảo App Clip hoạt động đúng cách và người dùng không thể khai thác bất kỳ lỗ hổng nào. Ngoài việc quét mã QR, hiển thị trên Safari, và chia sẻ qua iMessage, Apple cung cấp một số phương pháp khác để khởi chạy App Clips, như tap vào link trong ứng dụng Maps, gợi ý dựa trên vị trí từ Siri Suggestions, và thẻ NFC. Để đảm bảo người dùng có thể dễ dàng khám phá App Clip của bạn, điều quan trọng là tận dụng phương pháp khởi chạy phù hợp và tối ưu hóa khả năng khám phá. Bằng cách đó, bạn có thể tăng cơ hội người dùng tìm thấy và tương tác với App Clip của mình. Bước tiếp theoTrong hướng dẫn sắp tới, tôi sẽ cung cấp cho bạn hướng dẫn chi tiết về cách publish App Clip và cấu hình nó để chạy trên Safari, Maps, và iMessage. Tuy nhiên, xin lưu ý rằng App Clips chỉ có thể được khởi chạy khi chúng được publish trên App Store. Do đó, tôi không thể minh họa quy trình cho đến khi App Clip của tôi vượt qua quy trình review của Apple. 😝 Kết luậnTóm lại, App Clips cung cấp cơ hội tuyệt vời để nâng cao trải nghiệm người dùng và đơn giản hóa quy trình tương tác với ứng dụng. Với App Clips, người dùng có thể nhanh chóng truy cập một tính năng cụ thể mà không cần tải xuống ứng dụng đầy đủ. Điều này có thể đặc biệt hữu ích cho người dùng muốn dùng thử ứng dụng của bạn hoặc có gói dữ liệu hoặc bộ nhớ hạn chế. Dù bạn là chủ nhà hàng, quản lý cửa hàng bán lẻ, hay bất kỳ loại hình kinh doanh nào khác, bạn có thể tận dụng App Clip để tạo trải nghiệm tổng thể tốt hơn cho người dùng của mình.Vậy bạn còn chờ gì nữa? Hãy thử App Clips và xem sự khác biệt mà chúng có thể mang lại cho ứng dụng và doanh nghiệp của bạn. Tham khảo https://developer.apple.com/app-clips/","link":"/vi/posts/Bluetooth-Integration-with-App-Clips-A-How-To-Guide/index.html"},{"title":"Bluetooth Low Energy Trên iOS","text":"Core Bluetooth (CB) framework cho phép các ứng dụng iOS và MacOS giao tiếp với các thiết bị BLE. Ứng dụng của bạn có thể khám phá, tìm hiểu và điều khiển các thiết bị BLE, chẳng hạn như máy đo nhịp tim, thiết bị theo dõi hoặc đồng hồ thông minh. Hình 1. Các thiết bị BLE (Nguồn từ Google) Trên MacOS 10.9 và iOS 6, các thiết bị Mac và iOS cũng có thể đóng vai trò là BLE peripheral để cung cấp dữ liệu cho các thiết bị khác, bao gồm cả các thiết bị Mac và iOS khác. Trong bài hướng dẫn này, tôi sẽ giới thiệu các khái niệm chính của Core Bluetooth framework và cách sử dụng framework này để khám phá, kết nối và lấy dữ liệu từ các thiết bị tương thích. Hãy thoải mái để lại bình luận về bài viết của tôi. ## Tổng quan BLE được giới thiệu vào đầu năm 2010 và dựa trên đặc tả Bluetooth 4.0. BLE sử dụng cùng tần số vô tuyến 2.4 GHz như Bluetooth cổ điển. Về lý thuyết và trong điều kiện lý tưởng (không có vật cản), phạm vi của BLE có thể đạt trên 100m nhưng thực tế, khoảng cách tối đa là 10m. Hình 2. BLE trong thực tế (Nguồn từ Google) Công nghệ này tiết kiệm năng lượng vì nó sử dụng ít năng lượng hơn các công nghệ không dây khác. Nhờ mức tiêu thụ năng lượng thấp, BLE được sử dụng để tích hợp vào các thiết bị điện tử yêu cầu tiêu thụ năng lượng thấp như máy đo nhịp tim, thiết bị theo dõi, đồng hồ, giày để làm cho chúng thông minh hơn.Vậy, nhược điểm của công nghệ BLE là gì? Đó là tốc độ truyền dữ liệu. Để giảm tiêu thụ năng lượng, chip BLE chỉ truyền dữ liệu trong một khoảng thời gian gọi là interval (Trong khi Bluetooth cổ điển có thể truyền dữ liệu bất cứ lúc nào), và lượng dữ liệu được truyền trong một interval cũng bị giới hạn trong vài chục byte. Một số thông tin về throughput tối đa trên iOS và MacOS (Được cung cấp bởi PunchThrough) iPhone 6, 6+, 6S, 6S+:12Normal Connection Interval of 30mSecs: 2,667 bytes/secConnection Interval for HID Over GATT is Present 11.25mSecs: 7,111 bytes/sec MacBook Pro - OS X (Thay đổi theo model):1Maximum Connection Interval range of (11.25 - 15mSecs): 7,111 bytes/sec - 5334 bytes/sec Để biết thêm chi tiết kỹ thuật về công nghệ Bluetooth, vui lòng tham khảo Bluetooth Special Interest Group (SIG). Các khái niệm cơ bản1. Các thành phần chínhCó hai vai trò chính tham gia vào tất cả giao tiếp BLE: Central và Peripheral: Peripheral: là các thiết bị có dữ liệu mà các thiết bị khác cần. Central: thường sử dụng thông tin được cung cấp bởi peripheral để thực hiện một số tác vụ. Ví dụ, đọc thông tin nhịp tim hoặc nhiệt độ từ các máy đo (một peripheral).Hình 3. Central và Peripheral (Nguồn từ [Apple doc](https://developer.apple.com/library/content/documentation/NetworkingInternetWeb/Conceptual/CoreBluetooth_concepts/AboutCoreBluetooth/Introduction.html)) 2. Các tham số kết nốiCác tham số kết nối cho một kết nối BLE là một tập hợp các tham số xác định khi nào và cách Central và Peripheral thực hiện truyền dữ liệu với nhau. Central sẽ chủ động thiết lập các tham số kết nối được sử dụng, nhưng Peripheral có thể gửi tham số khác mà Central sau đó có thể chấp nhận hoặc từ chối. Cả hai bên sẽ tiếp tục yêu cầu các tham số kết nối cho đến khi họ tìm thấy một con số hợp lý mà cả hai đều chấp nhận.Có 3 tham số khác nhau: Connection interval: Giá trị này xác định tần suất Central và Peripheral truyền dữ liệu cho nhau. Slave latency (Latency, viết tắt): Nếu chúng ta đặt giá trị latency khác không, Peripheral có thể bỏ qua các yêu cầu từ Central khi Central yêu cầu dữ liệu lên đến số lần slave latency. Tuy nhiên, nếu Peripheral muốn truyền dữ liệu đến Central, nó có thể gửi dữ liệu bất cứ lúc nào. Điều này cho phép peripheral ngủ lâu hơn để giảm tiêu thụ năng lượng. Connection supervision timeout: Giá trị này xác định thời gian chờ từ lần trao đổi gói tin cuối cùng cho đến khi việc truyền được coi là bị mất. Central sẽ không bắt đầu cố gắng kết nối lại trước khi hết thời gian chờ. Ví dụ, nếu bạn đặt {interval, latency, timeout} = {15, 0, 720} làm tham số kết nối cho peripheral: Cứ mỗi 15 (ms), peripheral sẽ được đánh thức và lắng nghe các yêu cầu từ central, đồng thời truyền dữ liệu nếu cần. Latency bằng 0, có nghĩa là Peripheral phải trả lời Central bất cứ lúc nào Central yêu cầu trong một interval (15 ms). Sau 720 (ms) kể từ khi gói tin cuối cùng được gửi, nếu Central vẫn không nhận được gói tin, Central sẽ xác định rằng gói tin đã bị mất và yêu cầu Peripheral gửi lại gói tin cuối cùng. 3. Bluetooth Low Energy Protocol StackCoreBluetooth ẩn nhiều chi tiết cấp thấp của đặc tả khỏi các nhà phát triển, giúp việc phát triển các ứng dụng tương tác với thiết bị BLE trở nên dễ dàng hơn nhiều. Advertising và General Advertising Profile (GAP)Các thiết bị BLE cho các thiết bị khác biết rằng chúng tồn tại bằng cách advertising sử dụng GAP. Các gói advertising chứa một số thông tin cơ bản như tên thiết bị, số serial hoặc giá trị RSSI, và cũng là danh sách các service mà nó cung cấp. Kích thước giới hạn của các gói advertising là 128 bit.RSSI là viết tắt của Received Signal Strength Indicator. Giá trị RSSI đại diện cho cường độ của tín hiệu truyền. Chúng ta có thể ước tính khoảng cách hiện tại giữa central và peripheral dựa trên giá trị này. Giá trị càng lớn, thiết bị càng gần. Hình 4. Advertising và discovery trong BLE General Attribute Profile (GATT)GATT là lớp định nghĩa các service và characteristic được sử dụng để truyền dữ liệu giữa Central và Peripheral, cũng cho phép các thao tác read, write, notify trên chúng.Trong hầu hết các trường hợp, Peripheral cũng được gọi là GATT server vì nó cung cấp các service và characteristic trong khi Central là GATT client. ServicesCác service được xác định bởi các số duy nhất được gọi là UUID. Các service tiêu chuẩn như Device Information Service (0x180A), cung cấp thông tin nhà sản xuất và thông tin cơ bản về thiết bị (Phiên bản Firmware, số serial, số model), có UUID 16-bit và các service tùy chỉnh có UUID 128-bit. (Ví dụ: 0x3dda0000957f7d4a34a674696673696d, v.v.) CharacteristicsMột characteristic chứa khai báo characteristic, thuộc tính characteristic (ReadWrite, ReadOnly, Notify, WriteWithoutResponse, v.v.), và một giá trị. Characteristic cho phép chúng ta truy cập giá trị và thông tin mà chúng chứa. Một service có thể có nhiều hơn một characteristic.Hình ảnh sau đây cho thấy mối quan hệ giữa Profile, Services, Characteristics. Hình 5. Mối quan hệ giữa Profile, Services, Characteristics 4. Các khái niệm Bluetooth và CoreBluetooth trên iOSTrong CoreBluetooth framework Một Central được đại diện bởi class CBCentralManager và được sử dụng để khám phá, thiết lập kết nối và điều khiển peripheral. Một peripheral được đại diện bởi class CBPeripheral, các service liên quan đến một peripheral cụ thể được đại diện bởi class CBService và các characteristic của service của peripheral được đại diện bởi class CBPeripheral. Hình ảnh sau đây cho thấy cấu trúc của Services và Characteristics của nó trên iOS: Hình 6. Mối quan hệ giữa các đối tượng CBPeripheral, CBService và CBCharacteristic trên iOS Tổng kếtBLE là một công nghệ cách mạng của Bluetooth cổ điển. Trong thực tế, BLE được sử dụng để tích hợp vào các thiết bị nhỏ như khóa, thiết bị theo dõi, đồng hồ, giày và một số loại trang sức (nhẫn) để làm cho chúng thông minh hơn, hướng tới môi trường IoT.Trong phần tiếp theo, tôi sẽ hướng dẫn bạn cách sử dụng CoreBluetooth để tạo các service của riêng bạn trên thiết bị iOS, cũng như sử dụng CoreBluetooth trên một thiết bị khác để khám phá, kết nối và điều khiển các BLE service của bạn. Nếu bạn thích bài viết này và muốn xem thêm trong tương lai, hãy cho tôi biết. Tài liệu tham khảo[1] Bluetooth Special Interest Group[2] Apple document: Core Bluetooth Concepts[3] Maximizing BLE Throughput on iOS and Android","link":"/vi/posts/Bluetooth-Low-Energy-On-iOS/index.html"},{"title":"Xây dựng trang cá nhân của bạn với Hexo","text":"Khi tôi xây dựng trang web cá nhân này, mục tiêu đầu tiên của tôi là tận hưởng sở thích viết lách. Tôi viết bất cứ điều gì tôi học được trong công việc hàng ngày, và chia sẻ nó. Tôi hy vọng những chia sẻ của tôi sẽ giúp ai đó khi họ cần. Đổi lại, tôi sẽ có hiểu biết sâu hơn về những gì tôi viết, và đôi khi, nhận được “một ly cà phê” (Buy me Coffee) từ một người bạn tôi chưa từng gặp. Sức mạnh đạt được bằng cách chia sẻ kiến thức, không phải bằng cách tích trữ nó Một số bạn bè đến hỏi tôi cách xây dựng một trang như của tôi. Tôi rất vui được chia sẻ với bạn cách tôi xây dựng nó.Sau hướng dẫn này, bạn có thể xây dựng trang web của riêng mình trong vòng 5 phút.Tôi hy vọng sớm thấy trang web của bạn ra mắt! Thiết lập công cụNodeJs cho macTruy cập trang NodeJS, tải xuống và cài đặt gói NodeJs cho macOS.Đối với những ai không biết NodeJs là gì, NodeJs là một môi trường runtime Js mã nguồn mở, đa nền tảng (OS X, Window, Linux), để viết server-side bằng Javascript.Bằng cách sử dụng mô hình non-blocking I/O, NodeJS là một lựa chọn tuyệt vời cho các ứng dụng real-time, chat, data streaming, v.v.Với một cộng đồng lớn, hệ sinh thái package của NodeJs ngày càng đa dạng và hiệu quả, khiến NodeJS trở thành một trong những xu hướng phát triển tốt nhất trong những năm gần đây. Bạn có thể tìm thêm thông tin về NodeJs trên internet nếu bạn thấy nó thú vị. HexoHexo là một blog framework được hỗ trợ bởi NodeJs. Các tính năng đơn giản và nhanh chóng của Hexo khiến nó trở nên nổi bật trong số các blog framework khác như Hugo, Wordpress, Grav, v.v.Tôi chọn Hexo để xây dựng blog của mình vì tôi đã quen với các lệnh NodeJS. Hơn nữa, Hexo cung cấp nhiều theme mà bạn có thể dễ dàng tích hợp vào blog của mình với đầy đủ khả năng tùy chỉnh.Sau khi cài đặt NodeJs thành công, mở terminal của bạn và gõ các dòng sau 12345npm install hexo-cli -g [1]hexo init blog [2]cd blog [3]npm install [4]hexo server [5] Đây là từng bước: Cài đặt hexo command line như một lệnh global. Tạo thư mục blog của bạn. Di chuyển đến thư mục. Cài đặt các node dependency. Chạy server của bạn. Hexo sẽ chạy tại localhost:4000 theo mặc định. Bây giờ mở http://localhost:4000 trong trình duyệt của bạn để xem kết quả. Cá nhân hóa website của bạnTại thư mục gốc, có một file _config.yml chứa các cấu hình trang của bạn. Bạn có thể chỉnh sửa một số thứ như tiêu đề trang, tác giả trang, định dạng bài viết, v.v. Để biết thêm thông tin, vui lòng tham khảo tài liệu Hexo. Bắt đầu viếtĐể tạo bài viết mới, gõ 1hexo new \"My first blog\" Ở đây, bạn tạo một bài viết có tên “My first blog”. Reload trình duyệt của bạn, bạn sẽ thấy kết quả. Xin lưu ý rằng Hexo sử dụng cú pháp Markdown để chỉnh sửa, vì vậy hãy đảm bảo bạn quen thuộc với cú pháp Markdown. ThemesCộng đồng của Hexo cung cấp rất nhiều theme mà bạn có thể chọn theo sở thích và cá nhân hóa theme này thành của riêng bạn. Nó tiết kiệm rất nhiều thời gian của bạn nhờ vào cộng đồng tuyệt vời.Truy cập Hexo themes và tìm theme bạn thích, làm theo hướng dẫn của họ để tải xuống thư mục blog của bạn.Tiếp theo, chỉnh sửa file _config.yml, tìm kiếm và thay thế cấu hình themes bằng tên theme mới của bạn. 1theme: whatever DeploymentBằng cách sử dụng command line hexo generate, Hexo sẽ tự động tạo tất cả các file static mà bạn có thể upload lên server và phân phối cho người dùng.Trong trường hợp bạn không sở hữu server, đừng lo! Có rất nhiều free-host server ngoài kia. Bạn có thể đã nghe về Github page. Về cơ bản, Github page cung cấp host và domain miễn phí cho trang của bạn, giống như của tôi “uynguyen.github.io”. Nếu bạn muốn sử dụng Github page làm host, vui lòng làm theo hướng dẫn để tạo repository github page của bạn.Sau khi có repository của riêng mình, cài đặt npm install hexo-deployer-git cho phép bạn deploy trang của mình.Tiếp theo, chỉnh sửa file _config.yml, từ phần “deploy” &gt; thêm thông tin deployment target của bạn 12345deploy: type: git repo: &lt;repository url&gt; branch: [branch] message: [message] Từ bây giờ, khi bạn viết xong, bạn có thể publish bài viết của mình qua lệnh 1hexo clean &amp;&amp; hexo deploy Bạn cũng có thể sử dụng Heroku để deployment thay vì sử dụng github. Để biết thêm thông tin, vui lòng tham khảo Hexo deployment Kết luậnNếu bạn muốn một trang cá nhân đơn giản để chia sẻ ý tưởng và nội dung của mình, Hexo và Github page trở thành một công cụ tuyệt vời cho bạn. Với sự đơn giản và cộng đồng của nó, việc thiết lập rất dễ dàng, cho phép bạn chỉ tập trung vào điều quan trọng: Sự chia sẻ của bạn.Tôi hy vọng bạn thấy bài viết này hữu ích.","link":"/vi/posts/Building-your-personal-page-with-Hexo/index.html"},{"title":"Bảo mật giao tiếp Bluetooth: Triển khai luồng xác thực và mã hóa","text":"Bluetooth đã trở thành sợi dây vô hình kết nối các thiết bị của chúng ta, từ đồng hồ thông minh và thiết bị theo dõi sức khỏe đến khóa thông minh và hệ thống IoT công nghiệp. Nhưng sự tiện lợi đi kèm với rủi ro: giao tiếp Bluetooth là không dây và dễ bị chặn bắt, khiến nó dễ bị nghe lén, truy cập trái phép và tấn công phát lại.Để chống lại những mối đe dọa này, xác thực và mã hóa là thiết yếu. Trong bài viết này, tôi sẽ giới thiệu một luồng bảo mật Bluetooth mạnh mẽ, giải thích cách xác thực, trao đổi khóa và truyền dữ liệu mã hóa hoạt động cùng nhau. Chúng ta cũng sẽ so sánh nó với TLS/HTTPS vì cả hai đều chia sẻ cách tiếp cận bảo mật phân lớp tương tự. Ôn lại: Cách HTTPS hoạt độngTrước khi đi sâu hơn vào xác thực Bluetooth, việc hiểu cách HTTPS (Hypertext Transfer Protocol Secure) bảo vệ giao tiếp trên web sẽ rất hữu ích, vì cả hai đều chia sẻ các nguyên tắc bảo mật tương tự.Khi bạn truy cập một trang web an toàn (https://), trình duyệt và máy chủ thực hiện một quy trình gọi là TLS handshake để thiết lập sự tin cậy và mã hóa. Quá trình bắt tay này diễn ra qua một vài bước chính: Client Hello – Trình duyệt gửi một thông điệp đến máy chủ để giới thiệu bản thân, liệt kê các phương thức mã hóa được hỗ trợ và một số ngẫu nhiên (được sử dụng sau trong quá trình tạo khóa). Server Hello – Máy chủ phản hồi với số ngẫu nhiên của riêng nó, chọn một phương thức mã hóa và gửi chứng chỉ SSL/TLS của nó — bao gồm khóa công khai và được xác minh bởi Certificate Authority (CA). Xác thực – Trình duyệt xác minh rằng chứng chỉ hợp lệ và đáng tin cậy (không hết hạn, bị thu hồi hoặc cấp cho tên miền khác). Bước này đảm bảo trang web là hợp pháp. Trao đổi khóa – Sử dụng khóa công khai từ chứng chỉ (hoặc thông qua ECDHE — Elliptic Curve Diffie-Hellman Ephemeral), cả hai bên tạo ra một khóa phiên chung một cách an toàn mà chỉ họ có thể tính toán. Giao tiếp mã hóa – Khi khóa phiên được thiết lập, tất cả dữ liệu trao đổi giữa trình duyệt và máy chủ được mã hóa bằng mã hóa đối xứng (thường là AES hoặc ChaCha20). Tính toàn vẹn &amp; Xác thực – Mỗi thông điệp bao gồm một checksum mật mã (MAC hoặc AEAD tag) để ngăn chặn giả mạo hoặc tấn công phát lại. Từ thời điểm đó trở đi, kết nối của bạn vừa được mã hóa (không ai có thể đọc dữ liệu của bạn) vừa được xác thực (bạn biết bạn đang nói chuyện với máy chủ thực). Tóm lại, HTTPS bảo mật giao tiếp bằng cách sử dụng: Chứng chỉ để thiết lập danh tính. Trao đổi khóa để tạo ra các khóa phiên duy nhất. Mã hóa đối xứng cho hiệu suất và tính bảo mật. Kiểm tra tính toàn vẹn để phát hiện bất kỳ sửa đổi nào. Luồng xác thực Bluetooth an toànBây giờ hãy chuyển các khái niệm này thành một luồng bảo mật Bluetooth thực tế. Không giống như HTTPS, Bluetooth không có cơ sở hạ tầng certificate authority tích hợp sẵn. Thay vào đó, chúng ta thường dựa vào Pre-Shared Keys (PSK) hoặc cơ chế ghép nối ngoài băng tần để thiết lập sự tin cậy ban đầu. Đây là một luồng xác thực và mã hóa mạnh mẽ cho giao tiếp BLE: Giai đoạn 1: Xác thực Challenge-ResponseTrước khi bất kỳ dữ liệu nhạy cảm nào được trao đổi, cả ứng dụng di động (Central) và thiết bị BLE (Peripheral) phải chứng minh họ chia sẻ một bí mật chung — PSK. 1234567891011121314151617181920┌──────────────┐ ┌──────────────┐│ Central │ │ Peripheral ││ (Mobile) │ │ (Device) │└──────┬───────┘ └──────┬───────┘ │ │ │ 1. Generate Random Challenge (Nc) │ │ 2. Send Challenge ─────────────────────▶ │ │ │ 3. Device generates Nd │ │ 4. Response = HMAC(PSK, Nc||Nd) │ │ │ │ ◀───────────── 5. Send (Nd, Response) │ │ │ │ 6. Verify Response │ │ 7. Generate own Response for Device │ │ ─────────────────────────────────────▶ │ │ │ │ 8. Device verifies │ ▼ ▼ [Mutual Authentication Complete] Cách hoạt động: Central tạo một nonce (Nc) — một số ngẫu nhiên chỉ được sử dụng một lần — và gửi nó đến Peripheral. Peripheral tạo nonce riêng của nó (Nd) và tính toán phản hồi bằng HMAC-SHA256:1Response = HMAC-SHA256(PSK, Nc || Nd) Peripheral gửi lại (Nd, Response) cho Central. Central xác minh bằng cách tính toán cùng HMAC với PSK được chia sẻ. Nếu khớp, thiết bị được xác thực. Xác thực hai chiều — Central sau đó gửi phản hồi của riêng nó để Peripheral cũng có thể xác minh danh tính của Central. Cơ chế challenge-response này đảm bảo: Không có tấn công phát lại — Mỗi phiên sử dụng nonce mới. Không truyền PSK — Bí mật không bao giờ được truyền qua sóng vô tuyến. Xác thực hai chiều — Cả hai bên chứng minh danh tính của họ. Giai đoạn 2: Trao đổi khóa với ECDHSau khi xác thực, chúng ta cần thiết lập một khóa phiên để mã hóa. Chúng ta sử dụng Elliptic Curve Diffie-Hellman (ECDH) để tạo ra một bí mật chung mà không cần truyền trực tiếp. 1234567891011121314151617181920// Generate ephemeral key pair on each sidelet privateKey = P256.KeyAgreement.PrivateKey()let publicKey = privateKey.publicKey// Exchange public keys over BLE// Central sends its public key to Peripheral// Peripheral sends its public key to Central// Both sides compute the shared secretlet sharedSecret = try privateKey.sharedSecretFromKeyAgreement( with: peerPublicKey)// Derive the session key using HKDFlet sessionKey = sharedSecret.hkdfDerivedSymmetricKey( using: SHA256.self, salt: salt, sharedInfo: \"BLE-Session-Key\".data(using: .utf8)!, outputByteCount: 32) Tại sao ECDH? Forward secrecy — Ngay cả khi PSK bị xâm phạm sau này, các phiên trước đó vẫn an toàn vì mỗi phiên sử dụng khóa tạm thời. Không truyền bí mật chung — Chỉ khóa công khai được trao đổi; bí mật chung được tính toán độc lập. Hiệu quả — ECC cung cấp bảo mật mạnh với kích thước khóa nhỏ hơn, lý tưởng cho các thiết bị BLE có tài nguyên hạn chế. Giai đoạn 3: Truyền dữ liệu mã hóaVới khóa phiên được thiết lập, tất cả giao tiếp tiếp theo được mã hóa bằng AES-GCM (Galois/Counter Mode): 1234567891011121314151617181920212223// Encrypting data before sendingfunc encrypt(data: Data, using key: SymmetricKey) throws -&gt; Data { let nonce = AES.GCM.Nonce() let sealedBox = try AES.GCM.seal(data, using: key, nonce: nonce) // Combine nonce + ciphertext + tag for transmission return nonce + sealedBox.ciphertext + sealedBox.tag}// Decrypting received datafunc decrypt(data: Data, using key: SymmetricKey) throws -&gt; Data { let nonce = try AES.GCM.Nonce(data: data.prefix(12)) let ciphertext = data.dropFirst(12).dropLast(16) let tag = data.suffix(16) let sealedBox = try AES.GCM.SealedBox( nonce: nonce, ciphertext: ciphertext, tag: tag ) return try AES.GCM.open(sealedBox, using: key)} AES-GCM cung cấp: Tính bảo mật — Dữ liệu được mã hóa và không thể đọc được nếu không có khóa. Tính toàn vẹn — Tag xác thực phát hiện bất kỳ sự giả mạo nào. Xác thực — Chỉ các bên có khóa phiên mới có thể giải mã. Bộ đếm tuần tự: Ngăn chặn tấn công phát lạiNgay cả với mã hóa, kẻ tấn công có thể bắt và phát lại các gói tin đã mã hóa. Để ngăn chặn điều này, chúng ta bao gồm một bộ đếm tuần tự: 12345678910111213141516struct SecureMessage { let sequenceNumber: UInt32 let encryptedPayload: Data}class SequenceValidator { private var expectedSequence: UInt32 = 0 func validate(_ message: SecureMessage) -&gt; Bool { guard message.sequenceNumber == expectedSequence else { return false // Replay or out-of-order attack detected } expectedSequence += 1 return true }} Số tuần tự được bao gồm trong dữ liệu xác thực bổ sung (AAD) của AES-GCM, vì vậy bất kỳ sửa đổi nào cũng được phát hiện. So sánh: HTTPS với Luồng bảo mật BLE Khía cạnh HTTPS/TLS Luồng bảo mật BLE Nguồn tin cậy Certificate Authority (CA) Pre-Shared Key (PSK) Xác thực Xác minh chứng chỉ Challenge-response với HMAC Trao đổi khóa ECDHE hoặc RSA ECDH Mã hóa AES-GCM, ChaCha20-Poly1305 AES-GCM Forward Secrecy Có (với ECDHE) Có (khóa ECDH tạm thời) Bảo vệ phát lại Số tuần tự trong bản ghi TLS Bộ đếm tuần tự trong payload Cả hai cách tiếp cận đều chia sẻ các nguyên tắc cơ bản giống nhau: Xác thực trước — Xác minh danh tính trước khi tin tưởng. Tạo khóa phiên — Không bao giờ tái sử dụng khóa qua các phiên. Mã hóa mọi thứ — Bảo vệ tính bảo mật dữ liệu. Xác minh tính toàn vẹn — Phát hiện giả mạo. Các cân nhắc triển khaiPhía di động (iOS/Swift)Framework CryptoKit của Apple cung cấp tất cả các primitive cần thiết: 1234567891011121314151617181920212223242526272829import CryptoKitclass BLESecurityManager { private let psk: SymmetricKey private var sessionKey: SymmetricKey? private var sequenceNumber: UInt32 = 0 init(psk: Data) { self.psk = SymmetricKey(data: psk) } // Challenge-response authentication func generateChallenge() -&gt; Data { var bytes = [UInt8](repeating: 0, count: 16) _ = SecRandomCopyBytes(kSecRandomDefault, bytes.count, &amp;amp;bytes) return Data(bytes) } func computeResponse(challenge: Data, nonce: Data) -&gt; Data { let message = challenge + nonce let hmac = HMAC&lt;SHA256&gt;.authenticationCode(for: message, using: psk) return Data(hmac) } func verifyResponse(_ response: Data, challenge: Data, nonce: Data) -&gt; Bool { let expected = computeResponse(challenge: challenge, nonce: nonce) return response == expected }} Phía thiết bị (Embedded)Đối với các thiết bị có tài nguyên hạn chế, các thư viện như mbed TLS hoặc wolfSSL cung cấp các triển khai nhẹ: 12345678910111213141516171819202122232425// Pseudo-code for embedded device#include \"mbedtls/gcm.h\"#include \"mbedtls/ecdh.h\"int verify_challenge_response( const uint8_t *psk, size_t psk_len, const uint8_t *challenge, size_t challenge_len, const uint8_t *nonce, size_t nonce_len, const uint8_t *response, size_t response_len) { uint8_t computed[32]; uint8_t message[challenge_len + nonce_len]; memcpy(message, challenge, challenge_len); memcpy(message + challenge_len, nonce, nonce_len); mbedtls_md_hmac( mbedtls_md_info_from_type(MBEDTLS_MD_SHA256), psk, psk_len, message, sizeof(message), computed ); return memcmp(computed, response, 32) == 0 ? 0 : -1;} Các thực hành bảo mật tốt nhất Xoay vòng PSK định kỳ — Không dựa vào một PSK duy nhất mãi mãi. Triển khai một cơ chế an toàn để cập nhật nó. Sử dụng sinh số ngẫu nhiên an toàn — Tính ngẫu nhiên yếu làm suy yếu toàn bộ mô hình bảo mật. Triển khai cơ chế timeout — Hủy bỏ xác thực nếu mất quá nhiều thời gian (tấn công DoS tiềm ẩn). Xác thực tất cả đầu vào — Kiểm tra độ dài, định dạng và giới hạn trước khi xử lý. Xử lý lỗi một cách an toàn — Không rò rỉ thông tin qua thông báo lỗi hoặc sự khác biệt về thời gian. Cân nhắc BLE 4.2+ Secure Connections — Đặc tả BLE bao gồm LE Secure Connections với ECDH. Sử dụng nó như một lớp bổ sung khi có sẵn. Ứng dụng thực tếLuồng bảo mật này lý tưởng cho các tình huống mà tính bảo mật dữ liệu và xác thực thiết bị là quan trọng: Thiết bị đeo — Đồng hồ thông minh và thiết bị theo dõi sức khỏe truyền dữ liệu sức khỏe thuộc các quy định về quyền riêng tư (HIPAA, GDPR). Thiết bị nhà thông minh — Khóa, bộ mở cửa garage và camera an ninh nơi truy cập trái phép có thể có hậu quả vật lý. Thiết bị y tế — Bơm insulin, máy tạo nhịp tim và máy theo dõi đường huyết liên tục nơi giả mạo có thể đe dọa tính mạng. IoT công nghiệp — Cảm biến và bộ điều khiển trong môi trường sản xuất nơi tính toàn vẹn dữ liệu ảnh hưởng đến hoạt động và an toàn. Thiết bị thanh toán — Hệ thống điểm bán hàng di động phải bảo vệ các giao dịch tài chính. Ô tô — Chìa khóa thông minh, công cụ chẩn đoán và hệ thống giải trí trên xe kết nối với điện thoại. Kết luậnBảo mật trong giao tiếp Bluetooth không chỉ là ghép nối một lần và tin tưởng mãi mãi — mà là về xác thực liên tục, khóa mới và truyền dữ liệu mã hóa. Bằng cách phân lớp: Xác thực challenge-response dựa trên PSK — Chứng minh cả hai bên chia sẻ một bí mật. Trao đổi khóa ECDH — Thiết lập khóa phiên có forward-secret. Mã hóa AES-GCM — Bảo vệ tính bảo mật và toàn vẹn. Bộ đếm tuần tự — Ngăn chặn tấn công phát lại. Chúng ta tạo ra một luồng bảo mật có khả năng chống lại nghe lén, mạo danh và tấn công phát lại. Giống như HTTPS đã biến đổi bảo mật web bằng cách biến giao tiếp mã hóa thành mặc định, việc triển khai các luồng bảo mật Bluetooth mạnh mẽ mang lại sự tin cậy và khả năng phục hồi tương tự cho các thiết bị chúng ta sử dụng hàng ngày. Sự tiện lợi không dây của Bluetooth không nhất thiết phải đánh đổi bằng bảo mật — với kiến trúc phù hợp, chúng ta có thể có cả hai. Các ví dụ code trong bài viết này sử dụng CryptoKit của Apple cho iOS. Các triển khai tương tự có thể thực hiện trên Android bằng Java Cryptography Architecture (JCA) hoặc BouncyCastle, và trên các thiết bị embedded sử dụng mbed TLS hoặc wolfSSL.","link":"/vi/posts/Bluetooth-security-Implement-authentication/index.html"},{"title":"Core Bluetooth trên WatchOS","text":"Bạn đã bao giờ nghĩ đến việc thêm Watch App vào sản phẩm của mình chưa? Thắc mắc làm thế nào để CoreBluetooth hoạt động trên Watch App của bạn? Bạn đã đến đúng nơi! Hướng dẫn này là cẩm nang dành cho bạn. Trong bài viết này, chúng tôi sẽ hướng dẫn bạn từng bước qua quy trình tích hợp mượt mà dữ liệu từ các thiết bị Bluetooth vào ứng dụng Apple Watch của bạn. Khám phá cách khai thác tiềm năng của các thiết bị Bluetooth để nâng cao trải nghiệm người dùng Apple Watch của bạn. Chúng tôi cũng sẽ cung cấp những hiểu biết về cách vượt qua các thách thức phổ biến khi làm việc với Core Bluetooth trên watchOS. Dù bạn là chuyên gia dày dạn hay người mới bắt đầu, hướng dẫn này đơn giản hóa quy trình cho bạn. Môi trường: XCode 15.0.1, iOS 17.0.3, WatchOS 10.1.1, Swift 5. Thiết lập projectBắt đầu bằng cách vào cài đặt project của bạn, sau đó chọn File &gt; New Target &gt; Watch OS &gt; App, và điền các trường bắt buộc. Sau khi hoàn tất, Xcode sẽ tích hợp mượt mà một project watch app mới vào workspace hiện tại của bạn. Cấu hình BluetoothVề cơ bản, tất cả các method và sự kiện Bluetooth trên WatchOS rất giống với iOS. Nếu bạn đã có một class BluetoothManager xử lý các chức năng Bluetooth khác nhau, như khởi tạo scanning hoặc kết nối đến peripheral, và quản lý các delegate Bluetooth, bạn đã sẵn sàng. 123456789101112131415161718192021class BluetoothManager : NSObject, CBCentralManagerDelegate { private var central: CBCentralManager! override init() { super.init() central = CBCentralManager( delegate: self, queue: nil, options: [:] ) } func startScanning() { central.scanForPeripherals(withServices: nil, options: [CBCentralManagerScanOptionAllowDuplicatesKey: true]) } func connect(periperal: CBPeripheral) { central.connect(periperal) } // Phần còn lại được lược bỏ} Để tiết kiệm thời gian và tránh duplicate code, bạn có thể dễ dàng chia sẻ file chứa class BluetoothManager với cả iOS và watch app target. Với thiết lập này, bạn có thể sử dụng class BluetoothManager trong watch app giống như cách bạn làm trong iOS app. 1234567891011121314struct ContentView: View { var body: some View { VStack { Image(systemName: \"globe\") .imageScale(.large) .foregroundStyle(.tint) Text(\"Hello, world!\") } .padding() .onAppear(perform: { BluetoothManager.shared.startScanning() }) }} Lưu ý quan trọng Để kiểm tra chức năng Bluetooth của project, điều cần thiết là chạy nó trên Apple Watch thật vì simulator không hỗ trợ Bluetooth. Hãy nhớ rằng thời gian kết nối trên Apple Watch có thể bị ảnh hưởng bởi tình trạng pin của thiết bị, ngay cả khi chế độ tiết kiệm pin không được bật. Đảm bảo rằng bạn thêm thủ công capability cần thiết vào file plist của Watch App. Bước này rất quan trọng; nếu không, ứng dụng của bạn sẽ không thể scan, kết nối, hoặc thực hiện bất kỳ lệnh Bluetooth nào khi nó ở background. 1234&lt;key&gt;UIBackgroundModes&lt;/key&gt;&lt;array&gt; &lt;string&gt;bluetooth-central&lt;/string&gt;&lt;/array&gt; Không giống như Bluetooth trên iOS, nơi bạn có thể tận dụng State preservation và restoration để đánh thức ứng dụng nếu nó đã bị hệ thống terminate do các sự kiện Bluetooth (xem Best practice: Best practice: How to deal with Bluetooth Low Energy in background), điều quan trọng cần lưu ý là không có cơ chế State preservation và restoration tương đương trên watchOS. Thời gian kết nối trên iOS và WatchOS khá tương đương. Tôi đã đo API Connect bằng cách thực hiện 200 lần gọi (cùng thiết bị, cùng môi trường kiểm thử). Trung bình trên iOS là khoảng 0.69 giây, trong khi trên WatchOS là 0.78 giây. Kết luậnTóm lại, bằng cách học cách kết nối Apple Watch với các thiết bị Bluetooth, bạn đã nâng cao các tính năng của đồng hồ. Hướng dẫn này đã hướng dẫn bạn cách sử dụng Core Bluetooth trên watchOS, xử lý các vấn đề phổ biến trong quá trình đó. Dù bạn là chuyên gia hay người mới bắt đầu, chúng tôi đã phân tích cho bạn. Giờ đây, Watch App của bạn không chỉ hoạt động tốt mà còn gây ấn tượng với người dùng. Khi bạn tiếp tục phát triển ứng dụng, hãy sử dụng những kỹ năng này để tạo ra những trải nghiệm tuyệt vời và mượt mà. Happy coding! Tham khảo[1] WWDC 2021[2] WWDC 2022[3] Core Bluetooth in watchOS Tutorial","link":"/vi/posts/Core-Bluetooth-on-WatchOS/index.html"},{"title":"Tạo và Phân phối Private Libraries với Cocoapods","text":"CocoaPods là một dependency manager cho các dự án Swift và Objective-C. Công cụ này không chỉ cho phép chúng ta dễ dàng tích hợp các dependencies mà còn cho phép chúng ta tạo các thư viện của riêng mình. Trong bài viết này, tôi sẽ hướng dẫn bạn cách tạo một private library và phân phối nó cho private team của bạn mà không cần publish thư viện. Khởi tạo repositoriesTruy cập Github hoặc Bitbucket, sau đó tạo hai repositories. Một cho source code của chúng ta được chia sẻ giữa team, cái còn lại cho Podspec, định nghĩa tất cả thông tin về Pod đó. Hình 1. Tạo Github repo để lưu trữ source code Hình 2. Tạo Github repo để lưu trữ các file Podspec Theo hướng dẫn trên trang Github, nó hướng dẫn bạn cách thêm project của bạn vào các repositories này. 123456$ echo \"# MyAwesomeKit-Spec\" &gt;&gt; README.md$ git init$ git add README.md$ git commit -m \"first commit\"$ git remote add origin git@github.com:uynguyen/MyAwesomeKit-Spec.git$ git push -u origin master Tạo thư viện của riêng chúng taMở XCode và tạo một Cocoa Touch Framework mới có tên MyAwesomeKit. Sau đó, tạo một class đơn giản tên là HaHaHaManager, class này định nghĩa các public methods cho clients. Để đơn giản hơn, tôi định nghĩa một method đơn giản, nhận 2 số làm tham số rồi trả về tổng của chúng: 123456public class HaHaHaManager { public init() { } public func awesomeFunction(a: Int, b: Int) -&gt; Int { return a + b }} Lưu ý: Vì chúng ta đang tạo một public Framework, chúng ta phải override default constructor của class HaHaHaManager, làm cho nó trở thành public. Nếu không, clients sử dụng Framework này không thể tạo instance của class này vì scope mặc định của classes trong Swift là internal. Sau đó, push code của chúng ta lên repository mà chúng ta đã tạo ở bước đầu tiên. Đảm bảo bạn thêm một tag làm version cho commit này. 1234$ git add .$ git commit -m \"Our first commit\"$ git tag MyAwesomeKit_1.0.0$ git push -u origin master --tags Thêm Private Repository vào cài đặt CocoaPods của bạnSử dụng lệnh sau để tạo private repository mới vào CocoaPods của bạn 1$ pod repo add REPO_NAME SOURCE_URL 1$ pod repo add MyAwesomeKit https://github.com/uynguyen/MyAwesomeKit Đảm bảo bạn có quyền truy cập đúng vào repository. Bạn có thể cấu hình ssh để truy cập repo qua ssh key. Xem thêm: Tạo SSH key mới và thêm vào ssh-agentĐể kiểm tra cài đặt của bạn có thành công không, sử dụng các lệnh sau: 12$ cd ~/.cocoapods/repos/MyAwesomeKit$ pod spec lint . --allow-warnings Lệnh này được sử dụng để validate specifications. Flag --allow-warnings chỉ ra rằng chúng ta bỏ qua tất cả warnings khi validate file Pod. (Thiếu một số options như license, author hoặc description). Tạo file Podspec của chúng taGõ lệnh để tạo file Podspec. File này chứa tất cả thông tin về code của chúng ta, bao gồm git repository, version của thư viện, dependencies, v.v. 1$ pod spec create MyAwesomeKit Bạn sẽ thấy kết quả như sau 123456789101112131415Pod::Spec.new do |s| s.name = \"MyAwesomeKit\" s.version = \"1.0.0\" s.summary = \"An awesome KIT can do anything for you\" s.homepage = \"https://github.com/uynguyen/MyAwesomeKit\" s.author = { \"Uy Nguyen\" =&gt; \"uynguyen.itus@gmail.com\" } s.source = { :git =&gt; \"git@github.com:uynguyen/MyAwesomeKit.git\", :tag =&gt; \"MyAwesomeKit_#{s.version}\" } s.platform = :ios, '8.0' s.requires_arc = true s.dependency 'AFNetworking', '~&gt; 3.1.0' [1] s.source_files = \"MyAwesomeKit/**/*.{swift}\" [2] s.frameworks = 'UIKit', 'CoreText' [3] s.library = 'z', 'c++' s.module_name = 'MyAwesomeKit'end Đây là giải thích: 1: Các Podspecs dependencies khác của bạn. Để thêm nhiều dependency, thêm dòng mới để định nghĩa nó. 2: Các source files sẽ được bao gồm. (Thay thế bằng .m, .mm, .c hoặc .cpp nếu bạn cần) 3: Các frameworks được liên kết với thư viện của bạn. Để biết các options khác, vui lòng tham khảo Podspec Syntax Reference Push lên Spec Repo 1$ pod repo push MyAwesomeKit MyAwesomeKit.podspec --allow-warnings Cấu trúc thư mục của bạn sẽ như sau 12345.├── MyAwesomeKit-Spec └── MyAwesomeKit └── 1.0.0 └── MyAwesomeKit.podspec Bất cứ khi nào bạn cập nhật thư viện, bạn phải chạy lệnh update để cập nhật Pod repos của bạn 1$ pod repo update Sử dụng Kit tuyệt vời của chúng taĐã đến lúc sử dụng Kit mạnh mẽ của chúng ta. Mở XCode và tạo project mới có tên MyAwesomeApp. Sau đó, gõ lệnh dưới đây để init file Pod 1$ Pod init Mở file Pod, thêm code sau để cài đặt thư viện của chúng ta. 123456789101112131415161718# Uncomment the next line to define a global platform for your projectsource 'git@github.com:uynguyen/MyAwesomeKit-Spec.git'source 'https://github.com/CocoaPods/Specs.git'platform :ios, :deployment_target =&gt; '8.0'target 'MyAwesomeApp' do # Comment the next line if you're not using Swift and don't want to use dynamic frameworks use_frameworks! pod 'MyAwesomeKit', '1.0.0' # Pods for MyAwesomeApp target 'MyAwesomeAppTests' do inherit! :search_paths # Pods for testing end target 'MyAwesomeAppUITests' do inherit! :search_paths # Pods for testing endend Hãy xem kết quả của chúng ta (Cầu nguyện và hy vọng nó hoạt động tốt) Kết luậnChúng ta vừa publish private Pod đầu tiên cho team của mình. Từ giờ trở đi, team của chúng ta có thể sử dụng thư viện này một cách riêng tư. Hơn nữa, việc cập nhật và phân phối thư viện khi nó được nâng cấp rất dễ dàng. Cảm ơn CocoaPod!Nếu bạn có bất kỳ câu hỏi hoặc bình luận nào về bài viết, hãy gửi email cho tôi. Tài liệu tham khảo[1] Private Pods","link":"/vi/posts/Create-and-Distribute-Private-Libraries-with-Cocoapods/index.html"},{"title":"Bảo mật Bluetooth: Pairing và Bonding","text":"Trong thời đại hiện đại, Bluetooth đóng vai trò quan trọng trong việc kết nối các thiết bị một cách liền mạch. Từ thiết bị theo dõi thể dục đến thiết bị nhà thông minh, Bluetooth Low Energy (BLE) cho phép các thiết bị giao tiếp hiệu quả trong khi giảm tiêu thụ năng lượng. Tuy nhiên, với sự gia tăng của truyền thông không dây, đảm bảo bảo mật đã trở thành mối quan tâm chính. Hai khái niệm cốt lõi của bảo mật Bluetooth là Pairing và Bonding, thường bị hiểu nhầm trong bối cảnh BLE. Đảm bảo rằng các thiết bị pair và bond một cách an toàn là rất quan trọng để bảo vệ dữ liệu nhạy cảm. Việc triển khai không đúng các quy trình này có thể dẫn đến nhiều loại tấn công. Ví dụ, kẻ tấn công có thể chặn các giao tiếp và đánh cắp thông tin có giá trị. Trong bài blog này, chúng ta sẽ khám phá pairing và bonding là gì, tại sao chúng quan trọng cho bảo mật, và cách chúng hoạt động trong thực tế, đặc biệt đối với các ứng dụng di động. Cấp thấp: Security Manager (SM)Ở cốt lõi của bảo mật BLE là Security Manager (SM), một thành phần quan trọng quản lý các chức năng bảo mật khác nhau. SM xử lý việc trao đổi các khóa bảo mật và đảm bảo rằng tất cả dữ liệu truyền giữa các thiết bị được mã hóa và bảo vệ khỏi truy cập trái phép. Các trách nhiệm chính của SM bao gồm quản lý pairing, bonding, mã hóa và xác thực, và quản lý khóa. SM cung cấp các phương pháp xác thực khác nhau cho các mức độ bảo mật khác nhau: Just Works: Không có xác thực liên quan. Được sử dụng cho các ứng dụng bảo mật thấp. Passkey Entry: Một passkey (PIN) được nhập trên một hoặc cả hai thiết bị để xác thực. Numeric Comparison: Cả hai thiết bị hiển thị một số, và người dùng phải xác nhận rằng chúng khớp nhau. Out-of-Band (OOB): Một công nghệ không dây khác, như NFC, được sử dụng để trao đổi thông tin, cung cấp bảo mật nâng cao. Thiết lập trình tự pairing và bondingPairing là quá trình thiết lập một liên kết giao tiếp an toàn giữa hai thiết bị Bluetooth. Bước này rất cần thiết để đảm bảo rằng các thiết bị có thể chia sẻ dữ liệu một cách an toàn. Trong quá trình pairing, các thiết bị trao đổi thông tin, xác thực lẫn nhau, và tạo các khóa mã hóa để bảo vệ dữ liệu được truyền. Bonding là bước tiếp theo sau pairing. Khi hai thiết bị pair thành công, chúng có thể lưu trữ các khóa mã hóa và thông tin bảo mật liên quan để sử dụng trong tương lai. Nó đảm bảo rằng các thiết bị không cần phải pair lại lần sau khi kết nối. Bằng cách lưu trữ các khóa này, các thiết bị có thể kết nối lại nhanh hơn và an toàn hơn trong tương lai. Ở cấp độ cao, các bước trong quy trình pairing và bonding bao gồm: PAIRING Khởi tạo: Một thiết bị gửi yêu cầu pairing đến thiết bị kia. Trao đổi tham số bảo mật: Các thiết bị chia sẻ khả năng của chúng, bao gồm các phương pháp xác thực có sẵn. Xác thực: Tùy thuộc vào các phương pháp có sẵn (Just Works, Passkey Entry, Numeric Comparison, hoặc Out-of-Band), các thiết bị tự xác thực. Tạo khóa: Các khóa mã hóa được tạo và sử dụng để bảo mật giao tiếp. Thiết lập mã hóa: Các thiết bị bắt đầu giao tiếp được mã hóa sau khi các khóa được trao đổi thành công. BONDING Lưu trữ thông tin bảo mật: Sau khi pairing, cả hai thiết bị lưu các khóa mã hóa cho các kết nối trong tương lai. Kết nối lại: Trong các tương tác tương lai, các thiết bị có thể sử dụng các khóa đã lưu để thiết lập lại liên kết an toàn, được mã hóa mà không cần lặp lại quy trình pairing. Dưới đây là tóm tắt của luồng trong ví dụ về thiết bị di động (central) và peripheral (ví dụ: đồng hồ thông minh, màn hình theo dõi, v.v.). Phía ứng dụng di độngiOS không cung cấp API bonding rõ ràng. Tuy nhiên, quy trình bonding xảy ra một cách trong suốt khi bạn kết nối với thiết bị BLE yêu cầu nó, và hệ điều hành sẽ nhắc người dùng xác thực cần thiết. Yêu cầu pairing thường được kích hoạt bằng cách truy cập các characteristic được bảo mật. Ngược lại, bạn có nhiều quyền kiểm soát hơn đối với quy trình pairing và bonding trên Android. 1234567891011121314151617181920212223242526272829BluetoothDevice device = bluetoothAdapter.getRemoteDevice(deviceAddress);// Checking bond stateint bondState = device.getBondState();if (bondState == BluetoothDevice.BOND_BONDED) { // Already bonded} else { // Create bond device.createBond();}...// Moniroting updatesBroadcastReceiver receiver = new BroadcastReceiver() { @Override public void onReceive(Context context, Intent intent) { final String action = intent.getAction(); if (BluetoothDevice.ACTION_BOND_STATE_CHANGED.equals(action)) { int bondState = intent.getIntExtra(BluetoothDevice.EXTRA_BOND_STATE, BluetoothDevice.ERROR); if (bondState == BluetoothDevice.BOND_BONDED) { // Device is bonded } else if (bondState == BluetoothDevice.BOND_BONDING) { // Bonding in progress } else if (bondState == BluetoothDevice.BOND_NONE) { // Bonding failed } } }}; Trên Android, không có API công khai để xóa thiết bị đã bond theo chương trình. Tuy nhiên, có một phương thức API riêng có sẵn có thể được truy cập bằng reflection để xóa bond. Xin lưu ý rằng, vì đây là API riêng, nó không được Google hỗ trợ, và việc sử dụng nó trong mã production có thể dẫn đến hành vi không thể đoán trước trên một số thiết bị hoặc ứng dụng của bạn có thể bị từ chối trong quá trình đánh giá của Google. 123456789public static boolean removeBond(BluetoothDevice device) { try { Method removeBondMethod = BluetoothDevice.class.getMethod(\"removeBond\"); return (boolean) removeBondMethod.invoke(device); } catch (Exception e) { e.printStackTrace(); } return false;} Thực hành tốt nhấtKhi làm việc với các thiết bị cần dữ liệu được mã hóa, tôi đã gặp một số vấn đề. Dưới đây là những điểm chính tôi đã học được, có thể giúp bạn tiết kiệm thời gian: Để hỗ trợ tự động kết nối từ hệ thống iOS, thiết bị phải chứa HID profile hoặc được đăng ký vào ANCS profile của điện thoại. Trên Android, hệ điều hành không tự động kết nối lại với thiết bị khi bonding; đó là công việc của các service của bạn. Hệ thống iOS tự động hiển thị popup pairing ngay lập tức sau khi gọi connect thành công với thiết bị nếu nó chứa HID profile. Việc xóa tất cả các characteristic được mã hóa của HID profile khỏi thiết bị của bạn ngăn hệ thống tự động hiển thị popup pairing. Khi đọc một characteristic được mã hóa tùy chỉnh của GATT profile, popup yêu cầu pairing sẽ xuất hiện. Hệ điều hành vẫn sẽ tự động kết nối với thiết bị sau khi pair nó với characteristic được mã hóa của chúng ta, ngay cả khi thiết bị HID không được mã hóa. Sử dụng các phương pháp xác thực mạnh: Ưu tiên Numeric Comparison hoặc Passkey Entry hơn Just Works. Cập nhật các giao thức mã hóa: Đảm bảo rằng các thiết bị của bạn sử dụng các giao thức mã hóa hiện đại, mạnh mẽ. Kết luậnBluetooth pairing và bonding là các quy trình nền tảng cho phép giao tiếp an toàn giữa các thiết bị. Bằng cách hiểu các cơ chế này, các nhà phát triển có thể tăng cường đáng kể bảo mật cho các kết nối Bluetooth của họ. Khi số lượng thiết bị được kết nối tăng lên, việc đảm bảo bảo mật Bluetooth mạnh mẽ sẽ tiếp tục là ưu tiên để bảo vệ dữ liệu nhạy cảm cá nhân. Tài liệu tham khảo Kevin Townsend, Carles Cufí, Akiba, Robert Davidson - Getting Started with Bluetooth Low Energy_ Tools and Techniques for Low-Power Networking-O’Reilly Media (2014) How iOS and Android Handle Connections with BLE Human Interface Devices, Punch Through BLE Pairing and Bonding","link":"/vi/posts/Bluetooth-security-Pairing-and-Bonding/index.html"},{"title":"Chuyện ở Đại Học (Phần 1)","text":"Tối hôm qua vô tình lướt Facebook thì trang Confession của trường mình hiện lên bài post của một bạn k17, bạn tâm sự về chuyện học ở Đại Học.Bạn tâm sự rằng bạn đang stress và căng thẳng vì lượng kiến thức ở Đại Học quá nhiều làm bạn không theo kịp, trong khi đó các bạn cùng khoá lại có vẻ như tiếp thu nhanh hơn bạn. Điều đó làm bạn thêm tự ti và muốn bỏ cuộc.Trước giờ mình không có thói quen comment lên các Fan page hay Confession, mà vì đọc được bài post của bạn mình thấy sao giống với mình 5 năm về trước quá, vì vậy mình muốn viết một bài chia sẻ ngắn để chia sẻ với các bạn về con đường mình đã đi qua cách đây 5 năm, cũng là con đường mà các bạn sẽ đi, dù ít hay nhiều. 1. “Học Công Nghệ Thông Tin mà Visual Basic là cái gì mà cũng không biết thì nghỉ cha cho rồi!”Đó là câu trả lời của thằng bạn học Quốc Phòng với mình khi mình hỏi quyển sách dày cui nó cầm trên tay là sách gì. Lúc đó buồn lắm chứ, cảm giác như mình là sinh vật ngoài hành tinh khác rớt xuống chỗ này vậy.Sau đó vào kí túc xá, (Lúc này gặp thím Trương - Thằng này giỏi từ cấp 3, thi Tin trường quận huyện tỉnh gì đó nó thi hết rồi), nó hỏi mình chứ “Ông biết con trỏ hem, ông biết đệ quy hem, ông biết thuật toán Dijktra, chu trình Hamilton hem” (WTH !!!). Chả hiểu nó nói gì, mình chỉ biết nhe răng cười. :))Vào lớp học, (Lúc này gặp thím Tú), mình còn đang loay hoay debug cái Hello World thì thím Tú đã bay lên bảng code một cách thần thánh: i++, j++ (WTF !!!).“Ê mày, i++ là sao mày” - Uy said =]].Đó, background lập trình của mình là vậy đó :). Rồi mình cũng lê lết qua được 4 năm Đại Học đấy thôi, nên tin vui cho các bạn là dù biết hay không biết nên tảng lập trình, vào Đại Học thì mọi người sẽ cùng một điểm xuất phát lại hết nhé, chỉ là mấy bạn biết trước sẽ có nhiều lợi thế hơn thôi. Mà cũng phải thôi, tại những năm cấp 3 người ta đã bớt thời gian đi chơi, xem phim, la cà để chuyên tâm nghiên cứu rồi còn gì.Mình có một người bạn từng nói là mình giống như mục tiêu của nó vậy đó, nó sẽ cố gắn phấn đấu cho đến khi qua được mặt mình, để xem thử ai là người đạt được ước mơ của mình sớm hơn. Mình trả lời lại là *”Mình không lấy người khác ra để làm mục tiêu cho mình, mình có những mục tiêu riêng. Mặt khác, mỗi người sinh ra đã có những xuất phát điểm, những nỗ lực khác nhau rồi, tôi không biết con đường bạn đã đi như thế nào và bạn cũng vậy. Vậy sao lại so sánh được?”* 2. Những kiến thức nền ở Đại HọcSau đây là list những môn học đại cương trong 3 kì đầu. Toán đại cương: Toán rời rạc: Các bạn sẽ học về Vector, các phép toán trên Vector, đại số Bool, các bảng chân trị, bảng logic, khái niệm cơ bản về đồ thị … Xác suất thống kê: Các bạn sẽ được học về các phép toán tính xác suất, các phép đếm, thống kê … Đại Số B1, B2: Học về cách phép toán xử lý trên ma trận, định thức, không gian vector … Giải tích B1, B2: Học về vi phân, tích phân, đạo hàm … Những môn này cực kì quan trọng cho những môn khoa học máy tính sau này nên tập trung học cho chắc nhé. Toán rời rạc quan trọng nếu sau này bạn chuyên về thuật toán, giải thuật, lý thuyết đồ thị, automata, trình biên dịch, xử lý ngôn ngữ tự nhiên. Xác suất thống kê cần nếu bạn làm nhiều về trí tuệ nhân tạo, Data Science, Machine Learning. Đại số tuyến tính ma trận, vector etc. có ứng dụng trong Cryptography, phân tích độ phức tạp thuật toán. Tin học đại cương: Điện Tử Căn Bản: Môn này học cái gì mình quên rồi, và cũng không biết tại sao mình lại qua môn. Lý Thuyết Mạch Số: Môn này học về các cổng logic AND, OR, XOR, NOT. Các hệ cơ số đếm, các phép toán xử lý trên bit bla bla. Nhập Môn Lập Trình: Môn này nhẹ nhàng thôi, học về mấy cái cực cơ bản như viết “Hế lô bà con”, học các syntax cơ bản: lặp, điều khiển, rẽ nhánh … Lý Thuyết Đồ Thị: Môn này là môn mình thích nhất trong 4 năm Đại Học vì được học với Cô Vân dễ thương. Các bạn sẽ được học về các phép duyệt đồ thị (BFS, DFS), các thuật toán tìm đường đi ngắn nhất (Dijkstra, Floyd + Bellman), các khái niệm về đồ thị (Liên thông, đẳng cấu bla bla), chu trình Euler và Hamilton … Bạn nên đọc thêm quyển: Introduction To Algorithm [THOMAS H. CORMEN, CHARLES E. LEISERSON, RONALD L. RIVEST, CLIFFORD STEIN] Nhập Môn Công Nghệ Thông Tin 1,2: Hai môn này chủ yếu “Cưỡi ngựa xem hoa” cho vui thôi, sẽ giới thiệu cho các bạn về ngành Công Nghệ Thông Tin, các chuyên ngành và các hướng nghiên cứu. Hai môn này nhẹ nhàng, đừng tạo áp lực làm gì. Cơ Sở Dữ Liệu: Học về các khái niệm cơ bản trong hệ thống thôn tin và cơ sở dữ liệu, các hệ thống CSDL và mô hình dữ liệu quan hệ, sử dụng SQL để truy vấn cơ sở dữ liệu, thiết kế cơ sở dữ liệu, phân tích chất lượng của một lược đồ cơ sở dữ liệu. Kiến Trúc Máy Tính và Hợp Ngữ: Học về các cách thiết kế kiến trúc của máy tính, tổng quan về máy tính, kiến trúc MIPS, x86, x32, cách thiết kế CPU của máy tính, các hệ cơ số và cách lưu trữ trên máy tính … Bạn nên tìm đọc thêm quyển Computer Architecture: A Quantitative Approach [John L.Hennessy and David A.Patterson] Hệ Điều Hành: Môn này quan trọng, các bạn cần học thật tốt môn này. Môn này các bạn sẽ được học về cách hệ điều hành làm việc, học về Kernel của OS, hệ thống tập tin FAT32 và FAT64, cách mà OS quản lý và điều phối các tiến trình, đồng bộ hoá giữa các tiến trình, quản lý bộ nhớ trên OS … Bạn nên tìm đọc thêm quyển Operating System Concepts [Silberschatz, Galvin, Gagne]. Mạng Máy Tính: Môn này quan trọng, nên đầu tư nhiều thời gian tìm hiểu. Môn này các bạn học về mạng máy tính, cách mà các hệ thống máy tính làm việc với nhau, cách một gói tin được truyền đi trong hệ thống mạng, các khái niệm về mạng máy tính (IP, subnet mark, …), mô hình 7 tầng OSI, sau đó học vào chi tiết từng tầng trong mô hình mạng. Bạn nên tìm đọc thêm quyển Computer Networking: A Top-Down Approach [7th Edition, Kurose &amp; Ross] Lập Trình Hướng Đối Tượng: Môn này các bạn bắt buộc phải nắm vững, học tốt môn này thì bạn có thể học nhanh bất kì ngôn ngữ lập trình nào. Và nên nhớ, sau cùng thì ngôn ngữ cũng chỉ là cái để hiện thực hoá cái ý tưởng của mình thôi. Không nên đặt nặng vấn đề ngôn ngữ lập trình lên hàng đầu mà bỏ qua cơ sở để xây dựng ngôn ngữ đó. Bạn nên tìm đọc thêm Head First Design Pattern [Head First],Design Patterns [Gang Of Four] Kỹ Thuật Lập Trình: Môn này sẽ dạy bạn các khái niệm trong lập trình (Con trỏ, vùng nhớ, ma trận, stack, heap …) và các chiêu thức lập trình rất hay (Quy hoạch động (Dynamic Programming), quay lui (Backtracking), mà cái mình thích nhất là vét cạn (Greedy)) Ahihi. Cấu Trúc Dữ liệu &amp; Giải Thuật: Môn này sẽ dạy bạn các loại cấu trúc dữ liệu trong lập trình (Tree, Stack, Heap, Queue …). Cách sử dụng từng loại dữ liệu trong từng trường hợp cụ thế. Đồng thời còn dạy bạn các giải thuật cơ bản (Sort, Search …), đánh giá độ phức tạp giữa các giải thuật. Khi nào dùng cái này, khi nào dùng cái kia, cái nào tốt hơn, phải đánh đổi cái gì bla bla. Để học tốt môn này thì ngoài giáo trình trên trường, mình nghĩ các bạn nên đọc thêm quyển Introduction To Algorithm [Steven S.Skiena] hoặc Introduction To Algorithm [THOMAS H. CORMEN, CHARLES E. LEISERSON, RONALD L. RIVEST, CLIFFORD STEIN] để tăng nội công. Ngoài ra để trở thành một lập trình viên có tâm, code ít bug, người khác đọc code của bạn không bị ức chế thì nên đọc thêm những quyển sau: Clean Code [Robert C.Martin], Code Complete [Steve McConnell], Refactoring [Martin Fowler, Steve McConnell], Pragmatic Programmer [Andrew Hunt, David Thomas]. 3. Việc chọn chuyên ngành:Sau 3 học kì đầu các bạn sẽ được chọn chuyên ngành phù hợp với nguyện vọng của mình.Các bạn sẽ ĐƯỢC CHỌN chuyên ngành chứ không bị ép buộc hay sợ hết slot gì hết nhé, vì có một số bạn inbox hỏi mình chỗ này nên nhân đây mình nói luôn.Khoa mình hiện có 6 chuyên ngành: Công Nghệ Phần Mềm (Software Engineering): Học về quy trình phát triển phần mềm; Học về cách phân tích yêu cầu phần mềm, thiết kế phần mềm, hiện thực hoá phần mềm và kiểm thử phần mềm. Hệ Thống Thông Tin (Information System): Học cách phát triển, xây dựng các hệ thống thông tin phức tạp, thông minh, tối ưu; Nghiên cứu bảo mật thông tin, rút trích thông tin đa ngôn ngữ. Mạng Máy Tính và Viễn Thông (Computer Networks and Telecommunication): Phát triển các ứng dụng mạng, hệ điều hành cho các thiết bị mạng, phát triển hệ thống. Khoa Học Máy Tính (Computer Science): Khai thác dữ liệu, phân tích và thiết kế thuật toán để tối ưu bài toán, phát triển các hệ thống trí tuệ nhân tạo (AI)… Công Nghệ Tri Thức (Knowledge Engineering): Nghiên cứu về xử lý ngôn ngữ tự nhiên (Giọng nói á) hoặc đa phương tiện (File âm thanh); nghiên cứu về mật mã và an ninh thông tin. Thị Giác Máy Tính và Khoa Học Robot (Computer Vision and Robotics): Tích hợp kỹ thuật trong đồ hoạ máy tính và xử lý ảnh số vào thiết bị di động và robot. Hỗ trợ phát hiện, nhận dạng, truy vấn, tái tạo các đối tượng trong các môi trường khác nhau. Đến giai đoạn này thì các bạn sẽ tự đăng kí môn học cho phù hợp với chuyên ngành của mình. Ví dụ bạn chọn chuyên ngành “Công Nghệ Phần Mềm” thì bạn phải tích luỹ đủ N tín chỉ thuộc các môn phần mềm và phải hoàn thành N môn học bắt buộc trong công nghệ phần mềm.Một lời khuyên cho các bạn là không nên chỉ chọn học những môn trong phạm vi chuyên ngành của mình, nên chọn học thêm những môn học ở những chuyên ngành khác mà nó hay, nó bổ ích, nó hỗ trợ cho chuyên ngành chính của mình. Ví dụ như bạn chọn Công nghệ Phần mềm thì có thể học thêm các môn khác của Khoa Học Máy Tính như “Phân Tích Độ Phức Tạp Thuận Toán”, “Phân Tích và Thiết Kế Giải Thuật” hay “Chuyên Đề Hệ Điều Hành Linux” hay “Bảo Mật Cơ Sở Dữ Liệu” hay “Khai Thác Dữ Liêu và Ứng Dụng” hay “Máy Học” … Chung quy lại là phải biết lựa môn mà học.Để tìm hiểu thêm về các chuyên ngành, các bạn tham khảo tại đây Chuyên ngành CNTT 4. Điểm số có thực sự quan trọng?*”Xuỳ, học là học kiến thức thôi chứ điểm thì có quan trọng gì.”*Mình nói thẳng luôn là câu này chỉ là câu nguỵ biện của mấy bạn lười làm bài thôi, nếu các bạn làm bài đầy đủ thì điểm của các bạn cũng sẽ xứng đáng với những gì bạn bỏ ra thôi.Quay lại vấn đề, điểm số ở Đại Học có thật sự quan trọng? Quan điểm của mình là nó không quá quan trọng, nhưng cũng không phải là thứ có thể phớt lờ.Điểm số, trong Đại Học, một mặt là để bạn khỏi bị đóng tiền học ngu rớt môn, mặt khác nó lại có ý nghĩa quan trọng hơn đối với những bạn cần học bổng để chi trả học phí hay sinh hoạt hàng tháng. Xa xôi hơn là để sau này các bạn có thể Apply các học bổng du học nước ngoài.Điểm số, ngoài Đại Học, là cái mà nhà tuyển dụng sẽ nhìn vào đầu tiên (Đối với người mới ra trường) để xem xét xem bạn có qua được vòng gởi xe không. Thử đặt mình vào vị trí nhà tuyển dụng, bạn mới ra trường, họ không biết gì về bạn, họ lấy gì để đánh giá năng lực và con người bạn? Mình không biết thật sự các nhà tuyển dụng sẽ đánh giá như thế nào, nhưng mình nghĩ điểm GPA sẽ phần nào nói lên con người bạn, rằng bạn có phải là một người có trách nhiệm (Với việc học) của mình không? Rằng bạn có đủ điều kiện để tới vòng test kỹ thuật, vòng phỏng vấn không? Điểm số giống như là tấm vé để bạn đi vào một hội trường, lúc đó năng lực thật sự của bạn sẽ được thể hiện. Mà ngay cả tấm vé mời bạn còn chưa có thì lấy cơ hội đâu để thể hiện bản thân?Vậy điểm số có quan trọng không? 5. Hoạt động ngoại khoá, có ăn được không?Nói về hoạt động ngoại khoá, mình nói thẳng là mình không tham gia quá nhiều hoạt động Đoàn - Hội. Mình chỉ lọc ra một vài hoạt động thật sự có ý nghĩa (Cho mình và cho người khác) để tham gia. Ví dụ như hiến máu nhân đạo, vui hội trăng rằm, về với ngoại thành … Đi mấy cái này vừa bổ ích, vừa có trải nghiệm lại giúp đỡ được người khác.Các hoạt động ngoại khoá này sẽ là điểm nhấn quan trọng trong hồ sơ xin học bổng học tập hoặc học bổng du học.Ngoài các hoạt đông trong trường, các bạn có thể tìm thêm các hoạt động khác từ các tổ chức từ thiện. Mình đã từng tham gia hoạt động từ thiện của tổ chức phi chính phủ Habitat kết hợp với ĐHQG TP.Hồ Chí Minh, tập đoàn POSCO Hàn Quốc và sinh viên Hàn Quốc để xây nhà tình thương cho người nghèo ở Vũng Tàu. Các hoạt động này rất ý nghĩa và còn giúp bạn có thêm bạn bè, các mối quan hệ sau này.Các bạn tham khảo thêm tại đây: Habitat for Humanity Vietnam. 6. Học bổng, kiếm ở đâu?Mỗi kì trường mình đều có rất nhiều học bổng hỗ trợ các bạn: Học bổng khuyến khích học tập dành cho những bạn có điểm học tập cao (Lấy từ trên lấy xuống đến khi hết chỉ tiêu). Hồi lúc năm nhất mình nhận thì giá trị của nó là 2tr5 thì phải, sau đó đến năm tư thì nó tăng lên được gần 4tr 1 kì (Chắc do lạm phát :))). Khoảng tiền này cũng đủ để các bạn chi trả (Phần nào) học phí.Thật ra để lấy được suất học bổng này mình nghĩ là không quá khó. Điểm trung bình của các bạn chỉ cần trên 8.0 là đã có cơ hội nhận rồi. Về vấn đề điểm rèn luyện. Mình nghĩ cũng không cần thiết phải dành quá nhiều thời gian để tham gia các hoạt động Đoàn - Hội làm gì, chỉ cần tham gia một vài hoạt động chính (Xem lại mục hoạt động ngoại khoá) và không vi phạm gì đến các ‘giới răng’ của trường (Vắng sinh hoạt công dân, xác nhận lưu trú bla bla gì đó) là đủ điều kiện rồi. Ngoài ra khoa mình cũng có liên kết với các doanh nghiệp để có các suất học bổng khác. Các công ty lớn như KMS, ELCA, CSC, Global Cybersoft, NTTData, GameLoft, VNG… đều có liên kết với khoa mình để trao học bổng hằng kì (Hàng năm) cho sinh viên khoa mình. Giá trị các suất học bổng dao động từ 3tr - 5tr tuỳ công ty.Để được các suất học bổng này thì điểm trung bình của các bạn không cần quá cao (Chỉ cần từ 7.5+). Thường thì các suất học bổng này nhắm tới các bạn sinh viên khó khăn trong khoa nên sẽ có yêu cầu (Optional) nộp thêm một giấy xác nhận gia đình có hoàn cảnh khó khăn ở địa phương. Giấy này thì bạn về UBND quê của bạn xin tờ giấy xác nhận nhé.Các suất học bổng này ngoài giá trị vất chất (Tiền đó), một số công ty còn offer cho bạn các cơ hội thực tập (KMS, theo mình biết), hoặc sẽ có thư mời bạn làm việc ngay sau khi tốt nghiệp. Quá sướng phải hem? Thêm thông tin cho các bạn là khoa mình cũng có Quỹ học bổng từ các cựu sinh viên trong khoa dành cho các bạn có hoàn cảnh thực sự khó khăn (Cái này hình như không yêu cầu điểm cao, 7.0+).Các bạn sẽ được phỏng vấn với các Thầy/Cô chủ nhiệm Quỹ học bổng, Thầy/Cô sẽ quyết định số phận của bạn :). Theo mình biết thì học bổng này được cấp hàng tháng trong suốt 4 năm học với yêu cầu là bạn phải hoàn thành tốt chương trình học hay sao đó.Để thêm thông tin thì bạn vào đây: Quỹ học bổng cựu sinh viên khoa CNTT. Phía sau là những suất học bổng lớn hơn, đòi hỏi bạn phải có nhiều thành tích hơn (GPA phải thật cao: 8.5+, English tốt: Essay, một số học bổng đòi hỏi bạn phải test kỹ thuật, cống hiến cho xã hội: hoạt động ngoại khoá, bonus thêm: Công trình nghiên cứu, bài báo khoa học, giải thưởng quốc tế bla bla).Lúc này những hoạt động ngoại khoá của bạn mới thực sự phát huy tác dụng, những hoạt động phục vụ xã hội, nhắm đến cộng đồng sẽ được ban điều hành đánh giá cao, phần nào biét được nhân cách con người bạn. Các học bổng lớn người ta nhìn nhận con người ở nhiều khía cạnh chứ không chỉ học không, kiểu giống như Tài và Đức phải đi với nhau vậy đó.Mình list dưới đây chỉ là những học bổng mình đã đạt được thôi nhé, trường mình còn rất nhiều các học bổng khác tương đương, bạn có thể tìm thêm trên trang web của trường: Odon Vallet Scholarship 2016 from Recontres du Vietnam – Vallet Foundation for students with outstanding achievements. (Giá trị 15tr) Sunflower Mission Engineering and Technology Scholarship from eSilicon Corporation and Sunflower Mission foundation. (Giá trị 300$) Pony Chung scholarship is sponsored by Pony Chung foundation, Hyundai Development Company and Vietnam National University. (Giá trị 500$ + Cơ hội được học bổng sau Đại Học ở Hàn Quốc) Lawrence S.Ting scholarship from Lawrence S.Ting Memorial Fund for students with outstanding achievements. (Giá trị 10tr)Phần Essay xin học bổng, để hôm nào rảnh mình viết về kinh nghiệm với Essay sau, giờ làm biếng rồi =]].3s quảng cáo bằng khen của Sunflower (Cái bằng khen này đẹp nên khoe :))): 7. Học như thế nào?Quan trọng nhất vẫn là chính bạn, sẽ không có một phương pháp học tập nào phù hợp với bạn hết. Bạn phải tự tìm ra nó.Nhưng lời khuyên của mình dành cho các bạn là nên có một nhóm học tập, đối với mình thì nhóm này không cần phải là những super trong lớp, chỉ cần các bạn chịu khó học chung với nhau (Nhớ nhé, học nhiều hơn chơi), chia sẻ kiến thức với nhau, lâu lâu cho copy code xí =]], vì lượng kiến thức ở Đại Học rất nhiều, đặc biệt là ngành của mình, nên bạn phải có đồng bọn để học chung, với rủ rê cúp học đi xem phim, đi hát Karaoke chẳng hạn. Hồi đó mình ở chung kí túc xá với thím Trương, nó cũng chịu học nên mình đu bám nó để nó chỉ bài cho; hai đứa cắm đầu chạy deadline ngày đêm, nhờ vậy mà cũng khá lên được. (y)Trong Software Engineering có một khải niệm gọi là Trade-off, nghĩa là bạn phải biết đánh đổi giữa được và mất, giữa chi phí bộ nhớ và thời gian, giữa môn này và môn kia, trong những hoàn cảnh cụ thể, bạn lựa chọn cái nào thì đó là quyết định của bạn :).*”You can not write perfect softwares. Because a perfect software does not exist. No one in the brief history of computing has ever written a piece of perfect software. It’s unlike that you’ll be the first. And unless you accept this as a fact, you’ll end up wasting time and energy chasing an impossible dream”* (Pragmatic Programmer).Các bạn cũng tập tư duy phản biện, tức là khi người ta đưa ra một bài toán hay một solution cho bài toán, các bạn phải biết đặt lại câu hỏi, “Tại sao phải làm cách này mà không phải làm cách kia?”, “Cách này có ưu, nhược điểm gì so với cách kia?”, “Làm như thế này sau này có dễ mở rộng hay dễ bảo trì không?”, “Có cách nào thông minh hơn không?” … đại loại là những câu hỏi như vậy.Việc đặt câu hỏi sẽ giúp bạn hiểu rõ hơn về vấn đề, người nói chuyện với bạn cũng biết là bạn đã hiểu rõ vấn đề nên mới có thể đặt câu hỏi ngược lại, chứ cứ ngồi dạ dạ rồi làm theo mà không biết đúng sai thì lúc đó bạn chưa có cái gọi là Critical thinking.Một vấn đề nữa là trước khi đặt câu hỏi, các bạn nên tự tìm hiểu thật kỹ về vấn đề này, khi nào tìm không ra hoặc không biết keyword để tìm thì mình mới nên đi hỏi người khác. Mình vừa tiết kiệm thời gian cho người khác (Nhiều khi hỏi ngu quá bị chửi thì cũng đừng trẻ trâu mà gân cổ lên cãi), vừa giúp mình tập tính tự nghiên cứu. Sau này ra đời, sếp giao cho cái task, không biết đường tìm hiểu thì đi hỏi ai? Quay lại hỏi thằng hồi đó học chung à? =]]Sau đây là một số kênh các bạn có thể tham khảo: Medium, Stack overflow, Quora. Ngoài ra còn có các group học tập trên facebook của khoa, các bạn nên follow các trang này để cập nhập thông tin.Phương pháp tiếp thu kiến thức trong 1 môn học: cố gắng học kiến thức cơ bản (thuật toán chạy như thế nào, giao thức chạy thế nào, ưu nhược điểm của từng loại cơ sở dữ liệu, …) thay vì tập trung nhiều vào syntax và thư viện.Và, phải dành thời gian đọc thêm sách, học trên trường kiến thức cho mọi người là như nhau. Vậy cái gì để phân biệt bạn với những người còn lại? Là kiến thức bạn tự lượm nhặt riêng ở ngoài lớp học. Đọc thêm sách sẽ giúp bạn có cái nhìn sâu hơn về vấn đề đã học trên lớp. Nhiều khi thầy trên lớp nói cũng chưa hẳn là đúng hết. Đọc sách thì chưa bao giờ là vô bổ cả :). Sách thì mình có list ra một vài cuốn nổi tiêng ở mục 2.Kiến thức nền ở Đại Học rồi.Nên nhớ mình là một Engineer chứ không phải là một Coder. 8. “Lương anh có đủ sống hem?”Câu này là câu hỏi cuối cùng sau khi các bạn đã moi hết các kinh nghiệm học tập của mình. Mình đều trả lời là “Hem” =]]Như thế nào là đủ? Đủ sống thôi hả? Vậy thì chắc đủ sống rồi vì mình vẫn còn sống mà viết cái bài này này.Có một câu nói mình thấy rất đúng đó là Theo đuổi đam mê, con nợ sẽ theo đuổi bạn “Theo đuổi đam mê, thành công sẽ theo đuổi bạn“. Khi bạn làm việc hết mình với năng lực của mình thì người khác sẽ nhận thấy nó, sẽ đánh giá đúng những gì bạn đã bỏ ra, và bạn sẽ nhận lại được những gì xứng đáng thôi.Lại thêm một câu chuyện từ một cuộc phỏng vấn, sau khi hỏi mình mức lương mình mong muốn nhận, chị nhân sự dễ thương mới chia sẻ với mình rằng: 1234Sự nghiệp mỗi người sẽ trải qua 3 giai đoạn:Mởi tốt nghiệp: Lúc này bạn hoàn toàn trắng tay, hãy tập trung lượm nhặt kiến thức, nâng cao trình độ, theo chân người giỏi để học cái trí, cái tài của người ấy. Tạo thương hiệu cá nhân riêng của mình, cái tên của bạn.Kiếm tiền: Khi đã có trong tay kiến thức, bạn bắt đầu lao mình vào kiếm tiền.Sống với đam mê: Lúc này tiền đối với bạn không còn quan trọng nữa, cái quan trọng hơn cả là được làm cái bạn thích, làm cái bạn đam mê, làm cái bạn sinh ra để làm. Sau cùng thì chị trả lời là “Mức lương em đưa ra cao quá công ty chị hem trả nổi” =]].Mình kể câu chuyện trên với đám bạn thân, chúng nó nói đấy là thuyết âm mưu để tẩy não sinh viên đó =]].Riêng mình thì thấy chị nói cũng đúng mà, “Follow your passion and success will follow you.”Vào ngày tốt nghiệp các bạn sẽ được thầy trưởng Khoa cam kết 100% sẽ tìm được việc sau khi tốt nghiệp nhé, nên các bạn khỏi lo thất nghiệp hay lương bổng nhé (Việc đó cũng có thể là đánh văn bản dạo không chừng :3) 9. KếtNói chung, quãng đường Đại Học mà mình đã đi qua, và các bạn sẽ đi qua có lẽ là quãng thời gian đẹp nhất của đời người.Lúc trước mình vẫn hay nghe các anh khoá trên nói “Đi làm buồn hơn đi học” hay “Giờ ước gì được quay lại 1 tháng lúc học Quốc Phòng, chắc lúc đó quẩy banh cái TT. Quốc Phòng”. Lúc đó mình cũng “Dạ, em cũng thấy vậy”, mà lúc đó đã có trải nghiệm gì đâu mà Dạ như đúng rồi =]].Bây giờ, đã qua rồi cái thời sinh viên đó, giờ mới thật sự hiểu được tâm trạng của người nói.Nói dài nói dai, nói tóm lại là 4 năm sẽ trôi qua rất mau, nên các bạn cứ sống chậm lại thôi, từ từ mà tận hưởng deadline với bạn bè. Sau cùng nhìn lại thì nó cũng chẳng là gì cả. NOT A BIG DEAL !!! Cái mà các bạn có được là kỉ niệm thời sinh viên đầy nhiệt huyết :).By the way, một phút mặc niệm cho sự đóng góp của các thanh niên: Đạp Xích Lô (DevOps &amp; Security Engineer), Cảnh Nguyễn (Back-end Engineer) đã góp ý chỉnh sửa bài viết.","link":"/vi/posts/Chuyen-o-Dai-Hoc-Phan-1/index.html"},{"title":"Crash Sớm trong Swift","text":"Tối qua, tôi đọc một chương của một cuốn sách là một trong những cuốn sách yêu thích của tôi: &quot;The pragmatic programmer&quot; (Của Andrew Hunt và David Thomas). Chương này thảo luận về cách sử dụng assertion để làm code dễ debug hơn. Chúng ta đều biết rằng assertion là một công cụ thiết yếu để viết test, nhưng nó làm được nhiều hơn thế. Hãy cùng tôi gặp gỡ anh chàng này: Assertion. Crash, đừng phá hỏngBạn có bao giờ tự nói với mình hoặc với đồng nghiệp trong một cuộc thảo luận kỹ thuật những điều sau không? “Trường hợp này sẽ không bao giờ xảy ra nên chúng ta không cần xử lý cái này.” “Class này phải là “Dog”, nó không bao giờ có thể là “Cat”, hãy force unwrap đối tượng này.” “Lỗi này sẽ không bao giờ xảy ra, cứ bỏ qua nó.” “Đồ ngốc! tại sao chúng ta xử lý trường hợp này khi code của bạn không bao giờ đến được dòng này?” Nhưng nếu “trường hợp này” xảy ra bằng cách nào đó thì sao? Ứng dụng có còn phản hồi theo cách chúng ta mong đợi không? Có khả năng nào tình huống không mong đợi sẽ làm hỏng database quan trọng của chúng ta không?Ngay từ đầu chương này, tác giả giới thiệu một số tình huống mà tôi có thể thấy mình trong những ví dụ đó: “Code này sẽ không được sử dụng 30 năm nữa, nên ngày hai chữ số là ổn.” “Ứng dụng này sẽ không bao giờ được sử dụng ở nước ngoài, vậy tại sao phải quốc tế hóa nó?” “count không thể âm.” “printf này không thể thất bại.” 1NẾU NÓ KHÔNG THỂ XẢY RA, SỬ DỤNG ASSERTION ĐỂ ĐẢM BẢO RẰNG NÓ SẼ KHÔNG Nếu chúng ta tin rằng điều gì đó không thể xảy ra, hoặc điều gì đó đúng, hãy sử dụng assertion để đảm bảo niềm tin của bạn là đúng! Nếu điều kiện của assertion không được đáp ứng, nó sẽ ngay lập tức crash ứng dụng. Nó rất hữu ích trong quá trình phát triển vì nó dẫn chúng ta trực tiếp đến vấn đề. Trước khi tiếp tục, hãy nói về các mức tối ưu hóa của SwiftTùy thuộc vào việc build ở chế độ Release hay Debug, trình biên dịch Swift sẽ bật hoặc tắt các assertion (Các dòng có câu lệnh assert được bỏ qua), tốt để biết các mức tối ưu hóa của Swift trước khi chúng ta tiếp tục.Có 3 loại mức tối ưu hóa cho một build trong Xcode None (Onone): Mặc định cho debug build. Biên dịch mà không có tối ưu hóa nào. Fast (O): Mặc định cho release build. Biên dịch với các tối ưu hóa. Unchecked (Ounchecked): Biên dịch với các tối ưu hóa và loại bỏ các kiểm tra an toàn runtime, bao gồm kiểm tra mảng vượt giới hạn, unwrap nil, precondition và preconditionFailure. Đó là lý do tại sao chúng ta không nên sử dụng chế độ Ounchecked trong release build vì nó có thể dẫn đến hỏng bộ nhớ và ứng dụng có thể hoạt động không đúng. Cập nhật: Như bạn thấy không còn chế độ -Ounchecked trong Xcode10, thay vào đó một tùy chọn mới được giới thiệu Optimize for Size. Sự khác biệt chính giữa chế độ O và chế độ Osize là “Khi biên dịch với -O, trình biên dịch cố gắng chuyển đổi code để nó thực thi với hiệu suất tối đa. Tuy nhiên, sự cải thiện hiệu suất runtime này đôi khi có thể đi kèm với sự đánh đổi về kích thước code tăng lên. Với chế độ tối ưu hóa -Osize mới, người dùng có thể chọn biên dịch cho kích thước code tối thiểu thay vì tốc độ tối đa” (swift.org) Áp dụng Assertion vào SwiftThành thật mà nói, trước khi đọc chương này của cuốn sách, tôi nghĩ “Assertion” chỉ được sử dụng khi viết unit test. Thực tế là các developer sử dụng Assertion trong phát triển để làm quá trình phát triển an toàn hơn và dễ dàng hơn để truy vết bug.Swift cung cấp 5 loại hàm assertion khác nhau về cách chúng ảnh hưởng đến luồng code: assert() &amp; assertionFailure(): Sử dụng chúng khi chúng ta muốn xác minh code, nhưng nếu nó thực sự là một vấn đề, nó không nhất thiết phải thoát ứng dụng. Trình biên dịch sẽ bỏ qua các câu lệnh assert() và assertionFailure() cho phiên bản release (Trong chế độ -O). Ví dụ, tôi sử dụng assert để đảm bảo không có request không mong đợi trong luồng nghiệp vụ của tôi. Bằng cách đó, tôi đảm bảo rằng nếu có “kẻ lạ” xuất hiện trong luồng của tôi, luồng sẽ bị phá vỡ và ứng dụng sẽ bị kết thúc. Ngoài ra, debugger sẽ dẫn tôi trực tiếp đến vấn đề để tôi có thể xác định vấn đề logic và loại bỏ bug càng sớm càng tốt. precondition() &amp; preconditionFailure(): Sử dụng các hàm này để phát hiện điều kiện phải được đáp ứng trước khi tiếp tục xử lý, ngay cả trong phiên bản release (chế độ -O). Ví dụ, giả sử chúng ta cần tải file config khi ứng dụng khởi chạy. Nếu không có file config, thì chúng ta nên dừng ứng dụng ngay lập tức thay vì tiếp tục thực thi.123guard let fileConfig = Bundle.main.path(forResource: \"config\", ofType: \"json\") else { preconditionFailure(\"Unable to load config file.\")} fatalError(): Giống như các hàm precondition() và preconditionFailure(), ngoại trừ fatalError() hoạt động cho tất cả các mức tối ưu hóa trong tất cả các cấu hình, có nghĩa là ứng dụng của bạn LUÔN bị kết thúc nếu đạt đến dòng fatalError. Trong ví dụ sau, tôi sử dụng fatalError() để buộc mọi class kế thừa phải override parseData(files:) từ class cha của nó. Lời khuyên nổi bật từ tác giả &quot;Tất cả các lỗi đều cung cấp thông tin cho bạn. Bạn có thể tự thuyết phục mình rằng lỗi không thể xảy ra, và chọn bỏ qua nó. Thay vào đó, Pragmatic Programmer tự nói với mình rằng nếu có lỗi, điều gì đó rất, rất tệ đã xảy ra.&quot; Nếu lỗi xảy ra, chúng ta có thể khôi phục nó không? Nếu chúng ta không thể xử lý một số vấn đề không mong đợi, thì hãy crash sớm để bảo vệ dữ liệu quan trọng của chúng ta (Đặc biệt trong các ứng dụng ngân hàng yêu cầu bảo mật cao cho database). &quot;Đừng đặt assertion trong code xử lý lỗi thực sự.&quot; Đây là một sự hiểu lầm nếu chúng ta đặt assertion ở khắp nơi trong code, đặc biệt trong code xử lý lỗi thực sự. Assertion không được sử dụng theo cách này. Nếu chúng ta chỉ đơn giản kết thúc một chương trình đang chạy, nó sẽ ảnh hưởng đến trải nghiệm người dùng, dẫn đến người dùng sẽ không còn mở ứng dụng của bạn nữa. Nguyên tắc đơn giản nhất để kiểm tra xem chúng ta có nên thoát chương trình khi có lỗi xảy ra là Khi code của bạn phát hiện ra điều gì đó được cho là không thể xảy ra vừa xảy ra, chương trình của bạn không còn khả thi. Bất cứ điều gì nó làm từ thời điểm này trở đi đều trở nên đáng ngờ, vì vậy hãy kết thúc nó càng sớm càng tốt. Một chương trình chết thường gây ít thiệt hại hơn một chương trình tàn tật. &quot;Điều kiện được truyền vào assertion không nên có tác dụng phụ&quot;. Sẽ thật xấu hổ nếu chúng ta đặt code để kiểm tra lỗi mà thực sự gây ra lỗi khác. Ví dụ, đoạn code sau (Trong Java) được thêm assert để đảm bảo phần tử tiếp theo không phải nil, nhưng nó thực sự tạo ra lỗi mới. Bạn có thể tìm ra nó không?12345while (iter.hasmoreElements () { Test.ASSERT(iter.nextElements() != null); object obj = iter.nextElement(); // ....} Kết luậnTrong bài viết này, chúng ta đã đi qua năm phương thức để thoát sớm trong Swift. Nói chung, cách đúng để chọn cái nào sử dụng phụ thuộc vào ngữ cảnh của lỗi: Liệu lỗi có thể khôi phục được hay không? Nếu câu trả lời là không, thì crash là cách tốt nhất chúng ta có thể làm để bảo vệ ứng dụng khỏi các hành vi không thể đoán trước. Đôi khi, ứng dụng ở trong tình huống sẽ quá nguy hiểm để tiếp tục.Hy vọng bạn thấy bài viết này hữu ích và có thể áp dụng ý tưởng này vào dự án tiếp theo của bạn.Cảm ơn bạn đã đọc!","link":"/vi/posts/Crash-early-in-Swift/index.html"},{"title":"Dark Hat - Phiên bản 1.0 đã được phát hành","text":"Sau nhiều năm làm việc với công nghệ BLE, tôi nhận thấy rằng mặc dù có nhiều ứng dụng giúp kiểm tra thiết bị BLE nhưng không có ứng dụng nào thực hiện tốt vai trò của mình. Đó là lý do tại sao tôi quyết định xây dựng một ứng dụng BLE của riêng mình - Dark Hat. Mục tiêu cốt lõi của ứng dụng này là chia sẻ một công cụ tốt hơn với bạn - một kỹ sư làm việc trong lĩnh vực BLE. Tính năng chínhKhám phá các thiết bị gần đó với nhiều bộ lọc được hỗ trợ để chỉ hiển thị các thiết bị mà người dùng quan tâm. Lọc theo RSSI. Lọc theo tên thiết bị. Lọc theo service UUID: Chỉ truy xuất và quét các thiết bị có service UUID của bạn. Hỗ trợ nhiều tùy chọn trong cài đặt cho phép người dùng tùy chỉnh ứng dụng theo yêu cầu của họ. Quản lý trạng thái: Tự động kết nối lại khi mất kết nối. Preservation and Restoration: Người dùng hiện có thể chọn tham gia kiểm tra “Preservation and Restoration”. Để biết thêm chi tiết về kỹ thuật này, vui lòng tham khảo Thực hành tốt nhất: Cách xử lý Bluetooth Low Energy trong nền Các bước trong quy trình kết nối hiện được điều khiển bởi người dùng: thời gian chờ kết nối, thiết lập trạng thái notification và nhiều hơn nữa. Màn hình chính hiển thị tất cả thông tin và service thực sự quan trọng với bạn.Chế độ xem log inline giúp bạn quan sát tốt hơn những gì đang xảy ra trên thiết bị của bạn.Ứng dụng cũng cung cấp tùy chọn cho phép người dùng đặt tên riêng cho các characteristic để hiển thị tốt hơn, bật | tắt notification, sao chép UUID vào clipboard, và nhiều hơn nữa. Ứng dụng hỗ trợ trình soạn thảo thông minh tự động gợi ý tất cả các lệnh gần đây - một cải tiến nhỏ nhưng giúp giảm thời gian kiểm tra của bạn.Màn hình chi tiết characteristic hiện cung cấp tùy chọn cho phép hiển thị tất cả phản hồi từ nhiều characteristic giúp bạn nắm bắt toàn bộ quy trình khi kiểm tra. Dễ dàng chia sẻ: Chia sẻ kết quả của bạn chỉ với 1 lần nhấp. Kiến trúcTrung tâm của ứng dụng này là một SDK có tên BLEFramework - được tôi xây dựng - bao gồm tất cả logic làm việc với framework BLE của Apple và cung cấp các giao diện đơn giản cho các layer cấp cao hơn - ứng dụng. Bằng cách này, chúng ta có thể tách logic phức tạp khỏi ứng dụng UI, giúp dễ dàng phát triển và bảo trì.Ngoài ra, tôi có kế hoạch chuyển tất cả các view UI sang một công nghệ cross-platform (có thể là React Native) để hỗ trợ Android trong một layer view duy nhất. Tất cả những gì tôi cần làm là tạo một SDK khác hỗ trợ cho nền tảng Android. Các bước tiếp theoTôi có một lộ trình để thêm nhiều tính năng tuyệt vời hơn cho ứng dụng, kể đến một vài: streaming dữ liệu realtime, đo tốc độ, nhiều kết nối, điều khiển bằng script, iBeacons.Không thể chờ đợi để cung cấp tất cả các tính năng thú vị này cho người dùng.Nếu bạn có bất kỳ ý tưởng hoặc phản hồi nào, hãy gửi email đến uynguyen.itus@gmail.com hoặc dark.hat.ble@gmail.com, tôi rất muốn nghe từ bạn.","link":"/vi/posts/Dark-Hat-v1-0-has-been-released-yay/index.html"},{"title":"Design patterns","text":"","link":"/vi/posts/Design-patterns/index.html"},{"title":"Kéo và Thả","text":"","link":"/vi/posts/Drag-and-Drop/index.html"},{"title":"Fork và publish thư viện tùy chỉnh của bạn lên npm - React Native Wheel Picker","text":"Khi phát triển một tính năng mới cho phần mềm của chúng ta, chúng ta có xu hướng tìm kiếm xem có thư viện hoặc framework “tương tự” nào có sẵn trong cộng đồng để tái sử dụng hay không. Không ai muốn phát minh lại bánh xe, phải không? Tuy nhiên, thư viện phù hợp nhất với yêu cầu của chúng ta đôi khi không hỗ trợ một tính năng bạn cần hoặc chỉ là một property tùy chỉnh. Bạn có thể mở một pull request đến repo gốc, nhưng có thể mất thời gian và phụ thuộc vào tác giả xem họ có chấp nhận thay đổi của bạn hay không. Trong trường hợp đó, bạn có thể tạo thư viện của riêng mình từ thư viện gốc, chúng ta gọi đó là quá trình “Fork”.Trong bài viết này, tôi sẽ tóm tắt ngắn gọn các bước để publish một thư viện lên npm, và kể cho bạn nghe về một câu chuyện mà tôi gặp phải khi sử dụng thư viện React Native Wheel Picker. Việc publish một lib lên npm khá đơn giản. Chỉ cần làm theo các bước sau: Đảm bảo bạn có tài khoản npm. Truy cập https://www.npmjs.com để đăng ký tài khoản nếu bạn chưa có. Tiếp theo, đăng nhập vào tài khoản của bạn trên máy tính qua command line npm login. Để kiểm tra người dùng nào đang đăng nhập, sử dụng npm whoami. Thư viện tôi sử dụng cho project của mình hỗ trợ component Wheel Picker, nhưng nó đã bị deprecated, và nó không hỗ trợ thiết lập màu của item được chọn trên Android. Bên cạnh đó, tôi muốn tạo thư viện của riêng mình để có thể dễ dàng thêm nhiều tính năng hơn sau này. Vì vậy tôi quyết định fork và tùy chỉnh wheel picker của riêng mình. Để fork một lib, hãy vào repo của lib bạn muốn chỉnh sửa, sau đó nhấn nút fork ở góc trên bên phải. Sau khi fork thành công, bạn sẽ thấy repo trên dashboard của mình. Tiếp theo, clone code về máy tính của bạn, và thêm các tính năng mới của bạn.Trong trường hợp của tôi, tôi cần thêm một tính năng mới hỗ trợ thiết lập màu cho item được chọn (Tham khảo PR này) Khi hoàn thành việc chỉnh sửa, commit các thay đổi của bạn. Cập nhật thông tin repo tại file package.json nếu cần (Author, version, description, v.v.). Cuối cùng, chạy npm publish --access public để phát hành thư viện tuyệt vời của bạn. Đã đến lúc kiểm tra thư viện mới. Nếu bạn cài đặt thư viện mới @uynguyen505/react-native-wheel-picker và thử sử dụng nó, bạn sẽ thấy kết quả như dưới đây. Chúc cuối tuần vui vẻ! Refs Creating and publishing scoped public packages Forking, Modifying, and Publishing NPM Packages — For those almost-perfect packages","link":"/vi/posts/Fork-and-publish-your-custom-lib-to-npm/index.html"},{"title":"Tài liệu hóa Kiến trúc Phần mềm","text":"Rõ ràng là việc tài liệu hóa kiến trúc là một trong những công việc nhàm chán quan trọng nhất của Kỹ thuật Phần mềm. Một hoạt động hai mặtCó nhiều lý do tốt để chúng ta phải tài liệu hóa các dự án phần mềm của mình: Các thành viên khác có thể hiểu và đánh giá thiết kế của phần mềm này. Chúng ta có thể hiểu những gì đã triển khai khi quay lại sau một khoảng thời gian nhất định. Chúng ta có thể phân tích thiết kế để đánh giá hiệu năng của hệ thống, ngăn ngừa lỗi xảy ra trước khi bắt đầu giai đoạn triển khai. Việc tài liệu hóa kiến trúc cũng có một số nhược điểm, như: Tài liệu sẽ dần trở nên lỗi thời so với code. Việc giữ cho tài liệu kiến trúc cập nhật thường là một hoạt động bị bỏ qua, đặc biệt dưới áp lực trong một dự án. Tài liệu hóa tốn thời gian và tốn kém. Vậy khi nào chúng ta nên tài liệu hóa kiến trúc phần mềm?Có rất nhiều yếu tố cần xem xét để quyết định có cần tài liệu hóa hay không. Các dự án ít có triển vọng tồn tại lâu dài có lẽ không cần nhiều tài liệu. Yếu tố khác cần xem xét khi tài liệu hóa là nhu cầu của các bên liên quan trong dự án, bao gồm các vai trò khác nhau như developer, tester, manager, v.v. Trong một team nhỏ, tài liệu có thể ở mức tối thiểu và có thể được thay thế bằng giao tiếp trực tiếp, giúp tiết kiệm thời gian. Tuy nhiên, trong một team lớn, tài liệu trở nên quan trọng hơn để mô tả hệ thống, đặc biệt là các công ty hoạt động ở nhiều quốc gia và nhiều văn phòng. Do đó, điều quan trọng là phải suy nghĩ kỹ trước khi tài liệu hóa vì nó tốn thời gian để phát triển và duy trì cùng với các dự án.Trong bài viết này, tôi sẽ giới thiệu cho bạn ngôn ngữ phổ biến nhất để tài liệu hóa kiến trúc phần mềm: Unified Modeling Language. Unified Modeling Language (UML)UML là một ngôn ngữ mô hình hóa của Kỹ thuật Phần mềm. Nó cung cấp một cách tiêu chuẩn để trực quan hóa thiết kế của một hệ thống hoặc ứng dụng. UML bao gồm cả biểu đồ cấu trúc và biểu đồ hành vi để biểu diễn một hệ thống phần mềm: Biểu đồ cấu trúc mô tả kiến trúc tĩnh của hệ thống. Biểu đồ hành vi hiển thị các tương tác giữa các thực thể bên trong hệ thống. Lưu ý rằng tôi chưa bao giờ sử dụng Component diagrams, Package diagram, Deployment diagrams, Profile Diagram, Composite Structure diagrams, Communication diagrams, Interaction Overview diagrams và Timing diagrams nên tôi sẽ bỏ qua các biểu đồ này trong bài viết này. Biểu đồ cấu trúcClass diagramsClass diagram mô tả cấu trúc của một hệ thống bằng cách hiển thị các mối quan hệ giữa các class. Nó cũng hiển thị các thuộc tính và phương thức của mỗi class. Mục đích chính của class diagrams là để có cái nhìn tổng quan về hệ thống. Trong đó vis = visibility Cú pháp Loại visibility + Public Nếu một biến hoặc phương thức là static, nó phải được gạch chân. # Protected - Private ~ Package Các dòng sau giới thiệu một số mối quan hệ chính trong Class diagrams. Ký hiệu Ý nghĩa Implementation Class B triển khai các hành vi được định nghĩa trong Class A. Inheritance Class B có mối quan hệ IS-A với Class A, hay chúng ta có thể nói Class B là một loại của Class A. Dependency Nó tồn tại giữa hai phần tử nếu thay đổi định nghĩa của một phần tử có thể gây ra thay đổi cho phần tử kia. Association Một association nhị phân (với hai đầu) thường được biểu diễn dưới dạng một đường thẳng. Nó chỉ ra rằng Class A chứa một hoặc nhiều thuộc tính thuộc về Class B, hoặc ngược lại. Aggregation Nó là một trường hợp đặc biệt của Association. Chúng ta có thể nói Class A được aggregation với Class B nếu Object X là một instance của Class A bị hủy nhưng Object Y là một instance của Class B vẫn tồn tại. Ở đây, vòng đời của cả Employee và Department độc lập với nhau. Employees có thể tồn tại mà không cần department. Composition Nó là một trường hợp đặc biệt của Aggregation nhưng mạnh hơn mối quan hệ Aggregation. Nếu Object X là một instance của Class A bị hủy, Object Y là một instance của Class B cũng sẽ bị hủy. Chúng ta cũng nói Composition là mối quan hệ HAS-A. Ở đây, nếu chúng ta xóa đối tượng vehicle thì tất cả các engine sẽ tự động bị xóa. Các engine không có vòng đời độc lập, nó phụ thuộc vào vòng đời của đối tượng vehicle. Một ví dụ về class diagram. Instance diagrams (Object diagrams)Về cơ bản, instance diagram tương tự như class diagram mà nó phụ thuộc vào. Tuy nhiên, instance diagram chỉ là một snapshot của hệ thống tại một thời điểm nào đó, và nó hiển thị những giá trị mà các object đó chứa tại thời điểm được chỉ định. Instance diagrams thường được sử dụng để tạo prototype của một hệ thống, và để hiểu hệ thống rõ hơn từ góc nhìn thực tế.Các ký hiệu và notation của instance diagrams có thể được sử dụng trong class diagrams. Ví dụ Chuyển đổi từ class diagram sang instance diagram. Biểu đồ hành viActivity diagramsActivity diagram hiển thị luồng từ một activity này sang activity khác (Một activity là một chức năng được thực hiện bởi hệ thống). Lưu ý rằng các message không được bao gồm trong activity diagrams.Activity diagram thường được sử dụng để mô tả mức cao của hệ thống, chủ yếu cho người dùng kinh doanh hoặc người không có chuyên môn kỹ thuật. Nó cũng có thể mô tả các bước trong một use case diagram.Các ký hiệu và thành phần cơ bản: Ký hiệu cơ bản Ý nghĩa Start point Nó đại diện cho trạng thái hành động ban đầu. Activity Nó đại diện cho một activity của quy trình. Condition Sử dụng ký hiệu này khi một activity yêu cầu một quyết định trước khi chuyển sang activity tiếp theo Synchronization Nó chỉ ra rằng nhiều activity được thực hiện đồng thời. Time event Điều này đề cập đến một sự kiện dừng luồng trong một khoảng thời gian. Interrupting Edge Một sự kiện làm gián đoạn luồng. End Point Nó đại diện cho trạng thái hành động cuối cùng. Sequence diagramsSequence diagram hiển thị cách các object và component tương tác với nhau để hoàn thành một chức năng.Các ký hiệu và thành phần cơ bản: Ký hiệu cơ bản Ý nghĩa Actor Nó hiển thị các thực thể tương tác với hệ thống. Object Nó đại diện cho một object trong UML. Activation box Nó đại diện cho thời gian cần thiết để hoàn thành một tác vụ. Loop Nó chỉ ra các câu lệnh lặp. Alternative Nó chỉ ra các câu lệnh điều kiện. Parallel Mỗi tác vụ trong frame đại diện cho một thread thực thi được thực hiện song song. Synchronous message Người gửi phải đợi phản hồi cho một message trước khi tiếp tục. Biểu đồ nên hiển thị cả lời gọi và phản hồi. Asynchronous message Người gửi không cần đợi phản hồi cho một message trước khi tiếp tục. Return message Các message được trả lời cho các lời gọi. Delete object Nó chỉ ra rằng object sẽ bị hủy. State Machine diagramsMục đích chính của state machine diagrams là hiển thị sự thay đổi trạng thái của một object trong suốt vòng đời của nó. Ký hiệu cơ bản Ý nghĩa State Một state đại diện cho một tình huống trong vòng đời của một object. Initial State Trạng thái ban đầu của object. Final State Trạng thái cuối cùng của object. Ví dụ sau đây cho thấy sự chuyển đổi trạng thái của một đơn hàng. Use Case diagramsUse-case diagram hiển thị cách người dùng hoặc các ứng dụng bên ngoài khác tương tác với hệ thống. Nó cũng hiển thị phạm vi của hệ thống. Ký hiệu cơ bản Ý nghĩa Actors Họ đại diện cho người dùng hoặc hệ thống bên ngoài tương tác với hệ thống của chúng ta. Use cases Họ đại diện cho các cách sử dụng khác nhau mà người dùng có thể có. Associations Có hai loại association: Actor-use case và use case - use case. Một Actor - use case association chỉ ra actor nào được liên kết với use case nào. Một Use case - Use case association hiển thị mối quan hệ của hai use case: - Include: Một use case “include” một use case khác nếu đó là một hành động bắt buộc của use case đó. - Extend: Một use case “extend” một use case khác nếu đó là một cách sử dụng tùy chọn của use case đó. - Generalization: Use case kế thừa cấu trúc, hành vi và các mối quan hệ của một use case khác. Bạn đã từng nghe về Business Process Model and Notation (hay BPMN) chưa?“Business Process Model and Notation (BPMN) là một tiêu chuẩn cho việc mô hình hóa quy trình kinh doanh, cung cấp một ký hiệu đồ họa để chỉ định các quy trình kinh doanh trong Business Process Diagram (BPD).” (Wiki).Các mục tiêu chính của BPMN là: Cung cấp một bộ ký hiệu tiêu chuẩn mà các bên liên quan kinh doanh có thể hiểu được. Thường được sử dụng để định nghĩa logic kinh doanh vì nó có các khái niệm về sự kiện hoàn chỉnh hơn và hỗ trợ trao đổi message bất đồng bộ, điều quan trọng trong xử lý kinh doanh. BPMN tương tự như activity diagram từ UML. Một ví dụ về BPMN. Một quy trình mua sắm được mô tả bằng BPMN (Nguồn từ Google image) ## Sự khác biệt giữa UML và BPMN, nên sử dụng cái nào? Chúng ta sử dụng BPMN để mô tả hệ thống ở mức cao, không quan tâm nhiều đến chi tiết tính toán. Ngược lại, UML được sử dụng để định nghĩa chi tiết của hệ thống này, nó được xây dựng như thế nào? nó được tổ chức như thế nào? nó tương tác với các component khác như thế nào? dữ liệu được xử lý như thế nào? v.v. Kết luậnTrong bài viết này, tôi đã cho bạn thấy các ý tưởng chung về một số UML diagram phổ biến, và cho bạn thấy sự khác biệt chính giữa UML và BPMN. Tất nhiên, vẫn còn rất nhiều mục đích và notation của các biểu đồ đó mà tôi không thể liệt kê hết ở đây vì phạm vi của bài viết này.Nếu bạn quan tâm đến UML, bạn có thể tải tài liệu đầy đủ của UML tại đây (Phiên bản mới nhất của UML là 2.5.1).Cảm ơn bạn đã đọc. Tài liệu tham khảo[1] Essential Software Architecture (2011, Springer-Verlag Berlin Heidelberg)Ian Gorton (auth.), Chapter 8 Documenting a Software Architecture.","link":"/vi/posts/Documenting-a-Software-Architecture/index.html"},{"title":"Tích hợp Google Drive vào ứng dụng iOS","text":"Tại Fossil, tôi đã có cơ hội thử nghiệm tích hợp Google Drive như một nền tảng lưu trữ đám mây. Ưu điểm chính của việc sử dụng Google Drive là dễ dàng chia sẻ với các thành viên khác, với giao diện web tốt để chỉnh sửa nội dung các thư mục, và nó miễn phí. Tuy nhiên, tôi đã gặp khó khăn khi cố gắng làm cho Google Drive hoạt động do thiếu tài liệu và bài viết liên quan đến Google Drive APIs, đặc biệt là trong Swift. Ngoài ra, code và ví dụ trên trang web của Google đã lỗi thời. Do đó, tôi quyết định viết bài viết này với hy vọng tiết kiệm thời gian của bạn khi bạn muốn tích hợp Google Drive vào ứng dụng của mình. Hãy bắt đầu. Tạo ứng dụng và quyền truy cập Google APIĐể sử dụng Google APIs, trước tiên chúng ta phải vào Google Console Dashboard để tạo một project. Vì vậy hãy truy cập Google cloud console, nhấp vào menu dropdown để tạo một project mới.Google Drive API của bạn bị tắt theo mặc định khi bạn tạo project mới. Để bật Google Drive API thủ công, nhấp vào mục “APIs &amp; Services” ở thanh bên trái, nó sẽ đưa bạn đến một trang khác nơi bạn có thể bật các dịch vụ Google cho ứng dụng của mình.Nhấp vào nút “Enable APIs and services”, sau đó gõ để tìm kiếm “Google drive”, tiếp theo chọn Google Drive từ kết quả, cuối cùng nhấp “Enable” để kích hoạt ứng dụng.Đó là tất cả những gì bạn cần để tạo một ứng dụng sử dụng Google API. Thêm credential cho ứng dụng iOS của bạnCredentials cho phép ứng dụng iOS của bạn truy cập các API đã được bật. Nhấp vào nút “Credentials” ở thanh bên trái để thêm ứng dụng iOS của bạn. Tiếp theo, nhập thông tin ứng dụng của bạn bao gồm tên ứng dụng và bundle id, xin lưu ý rằng bạn cần nhập chính xác bundle id, nếu không nó sẽ không hoạt động.Sau khi tạo credential mới thành công, bạn sẽ có thể tải xuống file plist chứa các key cần thiết để thiết lập project Xcode của bạn. Giữ file này ở nơi an toàn, chúng ta sẽ sử dụng nó ở bước tiếp theo. 1234567891011121314&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\"&gt;&lt;plist version=\"1.0\"&gt;&lt;dict&gt; &lt;key&gt;CLIENT_ID&lt;/key&gt; &lt;string&gt;YOUR_CLIENT_ID&lt;/string&gt; &lt;key&gt;REVERSED_CLIENT_ID&lt;/key&gt; &lt;string&gt;YOUR_REVERSED_CLIENT_ID&lt;/string&gt; &lt;key&gt;PLIST_VERSION&lt;/key&gt; &lt;string&gt;1&lt;/string&gt; &lt;key&gt;BUNDLE_ID&lt;/key&gt; &lt;string&gt;com.example&lt;/string&gt;&lt;/dict&gt;&lt;/plist&gt; Cấu hình ProjectGoogle APIs Client Library là một thư viện được Google viết để truy cập Google APIs. Hãy thêm thư viện sau vào Pod file của bạn. 12pod 'GoogleAPIClientForREST/Drive', '~&gt; 1.2.1'pod 'GoogleSignIn', '~&gt; 4.1.1' Bạn sẽ tìm thấy YOUR_REVERSED_CLIENT_ID và YOUR_CLIENT_ID trong file plist cấu hình client mà bạn đã tải xuống trước đó. Chọn target project của bạn, vào tab “Info”, thêm một mục mới tại phần “URL Types”, sau đó nhập YOUR_REVERSED_CLIENT_ID vào ô “URL Schemes”.Trong trường hợp bạn không biết URL Schemes dùng để làm gì, mỗi mục trong phần URL Schemes cho phép bạn định nghĩa một custom URL scheme cho ứng dụng của mình. Ví dụ, ứng dụng của bạn có thể cho phép người dùng chạm vào một custom URL trong email để khởi chạy ứng dụng của bạn trong một ngữ cảnh cụ thể. Theo mặc định, Apple hỗ trợ các scheme phổ biến liên kết với các ứng dụng hệ thống như mail, sms, facetime, v.v. Để biết thêm thông tin, vui lòng tham khảo Defining a Custom URL Scheme for Your AppNếu bạn không thêm YOUR_REVERSED_CLIENT_ID làm custom URL scheme, ứng dụng của bạn sẽ bị crash khi cố gắng xác thực với Google API. Vì vậy hãy đảm bảo bạn không bỏ lỡ bước quan trọng này.Tiếp theo, mở file AppDelegate.swift, thêm client id của bạn vào instance Google Sign In. 1234func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -&gt; Bool { GIDSignIn.sharedInstance().clientID = \"YOUR_CLIENT_ID\" return true} Sau đó, mở ViewController nơi bạn cho phép người dùng đăng nhập bằng tài khoản Google của họ và triển khai hai delegate GIDSignInUIDelegate và GIDSignInDelegate từ Google Sign in. 123456789101112131415extension ViewController: GIDSignInDelegate { func sign(_ signIn: GIDSignIn!, didSignInFor user: GIDGoogleUser!, withError error: Error!) { if let _ = error { } else { print(\"Authenticate successfully\") } } func sign(_ signIn: GIDSignIn!, didDisconnectWith user: GIDGoogleUser!, withError error: Error!) { print(\"Did disconnect to user\") }}extension ViewController: GIDSignInUIDelegate {} Cuối cùng, gán delegate Google sign in cho view controller của bạn. 123456private func setupGoogleSignIn() { GIDSignIn.sharedInstance().delegate = self GIDSignIn.sharedInstance().uiDelegate = self GIDSignIn.sharedInstance().scopes = [kGTLRAuthScopeDrive] GIDSignIn.sharedInstance()?.signInSilently()} Bạn có thể nhận thấy dòng code GIDSignIn.sharedInstance().scopes. Dòng code này định nghĩa những quyền mà người dùng cấp cho ứng dụng của bạn để truy cập dữ liệu của họ khi xác thực. Trong trường hợp này, chúng ta sử dụng scope kGTLRAuthScopeDrive cho phép ứng dụng của chúng ta xem và quản lý tất cả các file trong Google Drive của người dùng, bao gồm cả team drive. Phương thức signInSilently sẽ cố gắng đăng nhập một cách im lặng cho người dùng đã được xác thực trước đó. Nếu bạn thực hiện đúng tất cả các bước trên, bạn sẽ có thể xác thực ứng dụng của mình với Google API. ![](/Post-Resources/GoogleDrive/GoogleSignIn.png \"Google Sign in\") ![](/Post-Resources/GoogleDrive/GrantPermission.png \"Grant permission\") Các API phổ biếnLàm việc với “My Drive”Tìm kiếm12345678public func search(_ name: String, onCompleted: @escaping (GTLRDrive_File?, Error?) -&gt; ()) { let query = GTLRDriveQuery_FilesList.query() query.pageSize = 1 query.q = \"name contains '\\(name)'\" self.service.executeQuery(query) { (ticket, results, error) in onCompleted((results as? GTLRDrive_FileList)?.files?.first, error) }} Liệt kê12345678 public func listFiles(_ folderID: String, onCompleted: @escaping (GTLRDrive_FileList?, Error?) -&gt; ()) { let query = GTLRDriveQuery_FilesList.query() query.pageSize = 100 query.q = \"'\\(folderID)' in parents and mimeType != 'application/vnd.google-apps.folder'\" self.service.executeQuery(query) { (ticket, result, error) in onCompleted(result as? GTLRDrive_FileList, error) }} Tải lên123456789101112131415private func upload(_ folderID: String, fileName: String, data: Data, MIMEType: String, onCompleted: ((String?, Error?) -&gt; ())?) { let file = GTLRDrive_File() file.name = fileName file.parents = [folderID] let params = GTLRUploadParameters(data: data, mimeType: MIMEType) params.shouldUploadWithSingleRequest = true let query = GTLRDriveQuery_FilesCreate.query(withObject: file, uploadParameters: params) query.fields = \"id\" self.service.executeQuery(query, completionHandler: { (ticket, file, error) in onCompleted?((file as? GTLRDrive_File)?.identifier, error) })} Tải xuống12345678910111213public func download(_ fileItem: GTLRDrive_File, onCompleted: @escaping (Data?, Error?) -&gt; ()) { guard let fileID = fileItem.identifier else { return onCompleted(nil, nil) } self.service.executeQuery(GTLRDriveQuery_FilesGet.queryForMedia(withFileId: fileID)) { (ticket, file, error) in guard let data = (file as? GTLRDataObject)?.data else { return onCompleted(nil, nil) } onCompleted(data, nil) }} Xóa123456789public func delete(_ fileItem: GTLRDrive_File, onCompleted: @escaping ((Error?) -&gt; ())) { guard let fileID = fileItem.identifier else { return onCompleted(nil) } self.service.executeQuery(GTLRDriveQuery_FilesDelete.query(withFileId: fileID)) { (ticket, nilFile, error) in onCompleted(error) }} Làm việc với “Team Drive”Điều duy nhất chúng ta cần làm để làm việc với “Team Drive” là đặt param corpora của query thành teamDrive. Theo mặc định, corpora user được áp dụng. Điều đó có nghĩa là query chỉ áp dụng cho các thư mục thuộc sở hữu của người dùng. Bằng cách đặt thành teamDrive, chúng ta chỉ ra rằng query sẽ ảnh hưởng đến team drive của người dùng. Chúng ta có thể kết hợp nhiều corpora trong một query duy nhất nếu bạn cần làm như vậy. Suy nghĩ cuối cùngGoogle Drive là một nơi lưu trữ lý tưởng để tích hợp với các ứng dụng của chúng ta. Trong bài viết này, chúng ta đã đề cập đến cách cấu hình Google Drive API và cách thực thi các API phổ biến. Tôi hy vọng bạn đã học được điều gì đó hôm nay.Bạn có thể tìm thấy tất cả source code demo trên Github của tôi. Tài liệu tham khảo[1] Google Developer https://developers.google.com/drive/api/v3/about-sdk","link":"/vi/posts/Integrate-Google-Drive-to-iOS-app/index.html"},{"title":"Grand Central Dispatch trong Swift","text":"Grand Central Dispatch, hay viết tắt là GCD, là một tập API C cấp thấp để quản lý các tác vụ đồng thời. Nó giúp chúng ta cải thiện hiệu suất ứng dụng bằng cách thực thi một khối code trên các thread phù hợp, như thực hiện các tác vụ tính toán nặng ở background. GCD cung cấp nhiều tùy chọn để chạy các tác vụ như đồng bộ, bất đồng bộ, sau một khoảng delay nhất định, v.v.Trong bài viết này, tôi sẽ giải thích chi tiết hơn về GCD và cách nó hoạt động, cũng như cung cấp một số điểm thú vị khi làm việc với GCD. Hãy bắt đầu. Giới thiệuTrung tâm của GCD là các dispatch queue - những pool của các thread được quản lý bởi GCD. Apple tạo ra GCD để các developer không cần quan tâm quá nhiều đến các queue này, họ chỉ đơn giản dispatch một khối code đến một queue nhất định mà không cần quan tâm thread nào được sử dụng. Các khái niệm GCDConcurrencyConcurrency đạt được khi có nhiều hơn hai tác vụ được thực thi cùng một lúc. Thực tế, từ “Concurrency” không chính xác có nghĩa là “cùng một lúc” hay “xảy ra song song”. Bên trong, CPU cung cấp cho mỗi tác vụ một khoảng thời gian nhất định để thực hiện công việc. Ví dụ, nếu có 5 tác vụ cần được thực thi trong một giây, với cùng độ ưu tiên, hệ điều hành sẽ chia 1.000 mili giây cho 5 (tác vụ) và sẽ cung cấp cho mỗi tác vụ 200 mili giây thời gian CPU. Kết quả là, chúng sẽ có vẻ như được thực thi đồng thời. Serial queue và concurrent queueMột serial queue sẽ thực thi các tác vụ theo kiểu first-in-first-out (FIFO). Điều này có nghĩa là chúng chỉ có thể thực thi một khối code tại một thời điểm. Chúng không chạy trên main thread, do đó, chúng không block UI.Ngược lại, một concurrent queue cho phép thực thi nhiều tác vụ song song. Điều này có nghĩa là các tác vụ có thể hoàn thành theo bất kỳ thứ tự nào và bạn sẽ không biết thời gian nó sẽ mất. Phương thức đồng bộ (sync) và bất đồng bộ (async)Khi bạn dispatch một tác vụ đến một queue, bạn xác định xem khối đó chạy đồng bộ hay bất đồng bộ. Có một số khác biệt chính giữa hai kỹ thuật: Phương thức đồng bộ trả quyền điều khiển cho caller chỉ sau khi tác vụ hoàn thành trong khi phương thức bất đồng bộ trả quyền điều khiển cho caller ngay lập tức. Vì các phương thức bất đồng bộ trả quyền điều khiển ngay lập tức nên chúng không block thread hiện tại. Lưu ý rằng từ “đồng bộ” không có nghĩa là chương trình phải đợi code hoàn thành trước khi tiếp tục. Nó chỉ có nghĩa là concurrent queue sẽ đợi cho đến khi tác vụ hoàn thành trước khi nó thực thi khối code tiếp theo trên queue.Code dưới đây minh họa cách sử dụng thực thi async và sync.1234567891011121314151617DispatchQueue.global().sync { [1] print(\"A\") DispatchQueue.global().async { for i in 0...5 { print(i) } }}DispatchQueue.global().sync { [2] print(\"B\") DispatchQueue.global().async { for i in 6...10 { print(i) } }} Nói chung, chúng ta không thể dự đoán output khi chạy code trên vì mỗi lần chạy chương trình, nhiều output khác nhau sẽ được in ra. Chúng ta chỉ có thể nói rằng “B” sẽ luôn được in sau “A” vì caller cần đợi khối [1] trả quyền điều khiển để có thể thực thi khối tiếp theo [2].Nếu chúng ta sửa các khối bên trong thành sync, chúng ta đảm bảo rằng output sẽ luôn là A 0 1 2 3 4 5 B 6 7 8 9 10.Ba loại queue chínhCó ba loại queue chính trong GCD: Main queue: Các tác vụ được dispatch đến queue này sẽ được thực hiện trên main thread, nơi các công việc liên quan đến UI được gọi. Main queue là một serial queue. Lưu ý quan trọng, phương thức sync không thể được gọi trên main thread vì nó sẽ block thread hoàn toàn và dẫn ứng dụng đến deadlock. Do đó, tất cả các tác vụ gửi đến main queue phải được gửi bất đồng bộ. 1234567override func viewDidLoad() { super.viewDidLoad() let mainQueue = DispatchQueue.main mainQueue.sync { // -&gt; Code này sẽ dẫn đến Deadlock print(\"Inner block called\") }} Global queues: Chúng là các concurrent queue và được chia sẻ bởi hệ thống. Chúng ta sử dụng global queue cho bất kỳ tác vụ nào không liên quan đến UI. Ví dụ, tải một hình ảnh từ internet sau đó hiển thị nó cho người dùng sau khi tải xong, lấy database từ server, v.v.Khi làm việc với global queue, chúng ta không chỉ định độ ưu tiên mà sử dụng Quality of Service (QoS) để giúp GCD xác định độ ưu tiên của các tác vụ. Điều quan trọng cần lưu ý là các ứng dụng sử dụng nhiều tài nguyên khác nhau như CPU, bộ nhớ, giao diện mạng, v.v. Do đó, chúng ta nên chọn QoS phù hợp của queue để duy trì khả năng phản hồi và hiệu quả của ứng dụng. Hệ điều hành sẽ dựa trên QoS đã cho để đưa ra quyết định thông minh về thời điểm và nơi thực thi chúng.Có bốn loại QoS: User-interactive: Điều này chỉ ra rằng các tác vụ cần được thực thi ngay lập tức để duy trì khả năng phản hồi trên UI. Chúng ta sử dụng nó cho cập nhật UI hoặc thực hiện animation. User-initiated: Công việc mà người dùng đã khởi tạo và yêu cầu kết quả ngay lập tức (Trong vài giây hoặc ít hơn). Chúng ta sử dụng nó để thực hiện một hành động khi người dùng click vào thứ gì đó trong UI. Utility: Các tác vụ có thể mất một thời gian để hoàn thành và không yêu cầu kết quả ngay lập tức (Mất vài giây đến vài phút) như tải dữ liệu. Background: Điều này đại diện cho các tác vụ mà người dùng không trực tiếp nhận biết. Thông thường, chúng ta sử dụng nó để lấy dữ liệu hoặc bất kỳ tác vụ nào không yêu cầu tương tác người dùng. Custom queues: Khi bạn tạo một custom queue, bạn có thể chỉ định loại queue đó là gì (Serial hoặc concurrent). Mặc định, chúng là serial queue. DeadlockTừ Deadlock đề cập đến một tình huống trong đó một tập các thread khác nhau chia sẻ cùng một tài nguyên đang đợi nhau giải phóng tài nguyên để hoàn thành các tác vụ của mình.Khi làm việc với GCD, nếu chúng ta không hiểu đầy đủ các khái niệm của GCD, chúng ta có thể tạo ra deadlock trong code. Ví dụ, code dưới đây đang tạo ra một deadlock. 123456789func deadLock() { let myQueue = DispatchQueue(label: \"myLabel\") myQueue.async { myQueue.sync { print(\"Inner block called\") } print(\"Outer block called\") }} Đầu tiên, chúng ta tạo một custom queue với một label nhất định. Sau đó, chúng ta dispatch bất đồng bộ một khối code gọi một khối code khác đồng bộ. Rõ ràng là khối bên trong và khối bên ngoài đang thực thi trên cùng một queue. Mặc định, một custom queue là serial nên khối bên trong sẽ không bắt đầu trước khi khối bên ngoài hoàn thành. Mặt khác, khối bên ngoài không thể hoàn thành vì khối bên trong đang giữ quyền điều khiển của thread hiện tại (Đồng bộ). Do đó, deadlock xảy ra.Có hai cách để khắc phục vấn đề. Cách thứ nhất là thay đổi loại queue thành concurrent. Bằng cách này, chúng ta đảm bảo rằng khối bên trong không phải đợi khối bên ngoài hoàn thành để có thể bắt đầu. 1let myQueue = DispatchQueue(label: \"myLabel\", attributes: .concurrent) Cách thứ hai là thay đổi khối bên trong thành async. Lần này, khối bên ngoài sẽ không đợi khối bên trong hoàn thành để có thể bắt đầu. 123456myQueue.async { myQueue.async { print(\"Inner block called\") } print(\"outer block called\")} Có một khuyến nghị trên tài liệu Apple về Deadlock tại chương Dispatch queues and thread safety&quot;Không gọi hàm dispatch_sync từ một tác vụ đang thực thi trên cùng queue mà bạn truyền vào lời gọi hàm của bạn. Làm như vậy sẽ gây deadlock cho queue. Nếu bạn cần dispatch đến queue hiện tại, hãy làm như vậy bất đồng bộ bằng cách sử dụng hàm dispatch_async.&quot; LivelockCó một khái niệm lock khác ngoài deadlock gọi là Livelock. Không giống như deadlock, livelock không block thread hiện tại. Chúng chỉ không thể tiến triển thêm. Hoặc chính xác hơn, livelock là “một tình huống trong đó hai hoặc nhiều process liên tục thay đổi trạng thái của chúng để phản hồi các thay đổi trong (các) process khác mà không thực hiện bất kỳ công việc hữu ích nào”.Có một ví dụ thực tế hay về livelock trên StackOverflowMột cặp vợ chồng đang cố ăn súp, nhưng chỉ có một chiếc thìa giữa họ. Mỗi người đều quá lịch sự, và sẽ đưa thìa nếu người kia chưa ăn.Có các loại lock khác khi chúng ta làm việc với concurrency như bound resources, mutual exclusion, starvation. Vì phạm vi của bài viết này, tôi sẽ không giải thích tất cả ở đây. Vui lòng tham khảo các nguồn khác để biết thêm chi tiết. Lưu ý quan trọng Trên iPhone, các hoạt động discretionary và background, bao gồm networking, bị tạm dừng khi bật Low Power Mode. Khi sử dụng Xcode 9 với iOS 11, một cảnh báo sẽ được phát ra khi một đối tượng giao diện người dùng được truy cập từ một thread không phải main. Độ ưu tiên user interactive nên hiếm trong chương trình của bạn. Nếu mọi thứ đều có độ ưu tiên cao, thì không có gì là cao cả. Kết luậnTrong bài viết này, tôi đã cho bạn thấy một số điểm thú vị về GCD trong Swift. Trong bài viết tiếp theo, chúng ta sẽ thảo luận thêm về các khái niệm nâng cao khác của lập trình đồng thời như DispatchGroup, Operation Queue, Group Tasks, v.v. Sau đó chúng ta sẽ triển khai một dự án nhỏ để kết hợp chúng lại với nhau.Nếu bạn có bất kỳ ý kiến nào, đừng ngần ngại liên hệ với tôi. Tài liệu tham khảo[1] Tài liệu Apple: Concurrency Programming Guide[2] iOS 8 Swift Programming Cookbook của O’Reilly, Chương 7: Concurrency and Multitasking.","link":"/vi/posts/Grand-Central-Dispatch-in-Swift/index.html"},{"title":"Protobuf trong thực tế","text":"Tôi đã làm việc với các sản phẩm Bluetooth, bao gồm thiết bị đeo và khóa thông minh, trong nhiều năm. Việc tạo điều kiện cho việc truyền message giữa các thành phần hệ thống là một khía cạnh quan trọng do sự khác biệt về ngôn ngữ lập trình, yêu cầu về tính nhất quán và giới hạn về kích thước truyền dữ liệu. Để giải quyết những thách thức này, chúng tôi sử dụng Protocol Buffers.Protocol Buffers, còn được gọi là Protobuf, là một định dạng dữ liệu đa nền tảng mã nguồn mở và miễn phí được sử dụng để serialize dữ liệu có cấu trúc, được phát triển bởi Google. Nó được thiết kế để hiệu quả, có thể mở rộng và thân thiện với người dùng. Trong bài hướng dẫn này, chúng ta sẽ tìm hiểu những kiến thức cơ bản về việc tạo một Protocol Buffers message đơn giản, định nghĩa schema và generate code trong các ngôn ngữ lập trình khác nhau. Cài đặtĐể cài đặt protobuf compiler, hãy làm theo hướng dẫn được nêu trong protobuf-compiler-installation.Cách sử dụng cơ bản có thể được tóm tắt bằng hình ảnh dưới đây. Các bước để thiết lập: Cài đặt protobuf compiler. Trên Mac, sử dụng brew: brew install protobuf Xác nhận việc cài đặt đã hoàn tất thành công: protoc --version. Cài đặt Code Generator Plugin: Protobuf hỗ trợ nhiều ngôn ngữ lập trình khác nhau. Bạn cần tìm và cài đặt code generator cho ngôn ngữ cụ thể tùy thuộc vào ngôn ngữ lập trình nào được sử dụng trong dự án của bạn. Ví dụ, cho Swift, sử dụng swift-protobuf: brew install swift-protobuf. Cho JavaScript, sử dụng npm install -g protoc-gen-js. Định nghĩa các scheme của bạn: Truy cập Programming Guides để tìm hiểu cách sử dụng ngôn ngữ protocol buffer để cấu trúc dữ liệu protocol buffer của bạn example.proto12345message Person { optional string name = 1; optional int32 id = 2; optional string email = 3;} Compile các file .proto để generate code cho các ngôn ngữ cụ thể. 1234nguyenuy@192 ~/Desktop/protobuf protoc --js_out=. example.protonguyenuy@192 ~/Desktop/protobuf protoc --java_out=. example.protonguyenuy@192 ~/Desktop/protobuf protoc --cpp_out=. example.protonguyenuy@192 ~/Desktop/protobuf protoc --dart_out=. example.proto Phân phối (import) các file đã generate vào các dự án của bạn. Cài đặt runtime plugin. Ví dụ, trong dự án iOS, include framework SwiftProtobuf trong Podfile. Cho các dự án Flutter, thêm protobuf vào file pubspec.yaml. Cho các dự án ReactJS, include google-protobuf trong file package.json. Triển khai serialization và deserialization:Ví dụ trong Python 12345678910111213person = example_pb2.Person()# Set valuesperson.name = \"Uy Nguyen\"person.id = 1person.email = \"uynguyen.itus@gmail.com\"# Serialize the message to bytesserialized_data = person.SerializeToString()# Parse the bytes back into a messagenew_person = example_pb2.Person()new_person.ParseFromString(serialized_data) Ví dụ trong Java 1234567891011Person person = Person.newBuilder() .setName(\"Uy Nguyen\") .setId(1) .setEmail(\"uynguyen@gmail.com\") .build();// Serialize the message to bytesbyte[] serializedData = person.toByteArray();// Parse the bytes back into a messagePerson newPerson = Person.parseFrom(serializedData); Ví dụ trong Swift 12345678910var p = Person()p.id = 1p.email = \"uynguyen.itus@gmail.com\"p.name = \"Uy Nguyen\"// Serialize the message to byteslet data = try? p.serializedData()// Parse the bytes back into a messagelet converted = try? Person(serializedData: data!) Dưới đây là cách các file được generate trông như thế nào trong các ngôn ngữ khác nhau. Ưu điểm Định dạng nhị phân: Protobuf sử dụng định dạng nhị phân để serialization, nhỏ gọn hơn so với định dạng dựa trên văn bản của JSON. Điều này dẫn đến kích thước message nhỏ hơn, làm cho nó hiệu quả hơn về cả băng thông và lưu trữ. Hiệu suất: Do định dạng nhị phân và encoding hiệu quả, quá trình serialization và deserialization của Protobuf thường nhanh hơn JSON. Điều này có thể đặc biệt quan trọng trong các tình huống yêu cầu throughput cao hoặc độ trễ thấp, chẳng hạn như các hệ thống sử dụng BLE. Code Generation: Protobuf dựa vào code generation để tạo các data class trong các ngôn ngữ lập trình khác nhau dựa trên schema đã định nghĩa. Điều này có thể dẫn đến code type-safe và hiệu quả, giảm khả năng xảy ra lỗi runtime liên quan đến sự không khớp cấu trúc dữ liệu. Hỗ trợ nhiều ngôn ngữ: Protobuf hỗ trợ code generation trong nhiều ngôn ngữ lập trình, phù hợp cho các dự án với các công nghệ khác nhau. Điều này cho phép các service khác nhau được viết bằng các ngôn ngữ khác nhau dễ dàng giao tiếp bằng cách sử dụng cùng các cấu trúc dữ liệu. Nhược điểm Khả năng đọc: Định dạng nhị phân của Protobuf không thể đọc được bởi con người, điều này có thể làm cho việc debug và khắc phục sự cố khó khăn hơn so với JSON. Định dạng văn bản thuần túy của JSON cho phép các nhà phát triển dễ dàng kiểm tra dữ liệu. Độ phức tạp khi debug: Do tính chất nhị phân của protobuf, việc debug có thể phức tạp hơn khi so sánh với JSON. Thường cần các công cụ chuyên dụng để kiểm tra nội dung của các message được encode bằng protobuf. Ít phổ biến trong công nghệ Web: JSON phổ biến hơn trong phát triển web và được hỗ trợ natively bởi nhiều web API. Nếu khả năng tương tác với các công nghệ web là ưu tiên hàng đầu, JSON có thể là một lựa chọn tự nhiên hơn. Phức tạp với cấu trúc lồng nhau: Việc xử lý các cấu trúc lồng nhau trong protobuf message đôi khi có thể ít trực quan hơn so với trong JSON. Cần chú ý khi thiết kế các cấu trúc lồng nhau để tránh sự phức tạp không cần thiết. Tổng kếtTóm lại, trong khi protobuf mang lại những lợi thế đáng kể về hiệu quả và hiệu suất, việc áp dụng nó nên được xem xét dựa trên các yêu cầu và ràng buộc cụ thể của dự án. Điều cần thiết là xem xét các ưu và nhược điểm và chọn định dạng serialization phù hợp nhất với mục tiêu và ràng buộc của dự án. Tài liệu tham khảo Protocol Buffers Documentation","link":"/vi/posts/Protobuf/index.html"},{"title":"Chơi với Android Things","text":"","link":"/vi/posts/Play-with-Android-Things/index.html"},{"title":"React Native trong thế giới thực của tôi","text":"React Native được giới thiệu vào tháng 1 năm 2015 tại React.js Con: Bản xem trước công khai đầu tiên. Vào tháng 3 năm 2015, React Native được mở và có sẵn trên Github. Sau khi phát hành, React Native nhanh chóng trở nên phổ biến và được cập nhật liên tục bởi hàng ngàn lập trình viên trên thế giới. Hiện tại, React Native là một trong những repository có nhiều star nhất trên Github. ThreadsHiệu năngNative modules123$ react-native run-ios --simulator 'iPad Pro (9.7 inch)'$ react-native run-ios --device 'qa'$ react-native run-ios --configuration Release --device 'qa' 123456789#import &lt;React/RCTBridgeModule.h&gt;@interface RCT_EXTERN_MODULE(SDKWrapper, NSObject)RCT_EXTERN_METHOD(supportedEvents)RCT_EXTERN_METHOD(startScanning)RCT_EXTERN_METHOD(stopScanning)RCT_EXTERN_METHOD(playAnimation)RCT_EXTERN_METHOD(connectToDevice:(NSString *)serialNumber:(RCTPromiseResolveBlock)resolve:(RCTPromiseRejectBlock)reject) //PromiseRCT_EXTERN_METHOD(disConnectToDevice:(RCTPromiseResolveBlock)resolve:(RCTPromiseRejectBlock)reject) //Promise@end 123456789101112public class SDKWrapper extends ReactContextBaseJavaModule{ public SDKWrapper(ReactApplicationContext reactContext) { super(reactContext); } @Override public String getName() { return \"SDKWrapper\"; } @ReactMethod public void startScanning() {. . .}} 123456import {NativeModules} from 'react-native';const {SDKWrapper} = NativeModules;....SDKWrapper.doSomething();SDKWrapper.saySomething();.... Ưu điểm và nhược điểmƯu điểm Hiệu năng native Học một lần, chạy mọi nơi Flex box Hot reloading Phát hiện platform trong code Nhược điểm Không ổn định, khó theo kịp Thiếu tài liệu Single dedicated device thread Gọi callback Kết luận","link":"/vi/posts/React-Native-In-My-Real-World/index.html"},{"title":"Tích hợp Google Sign In trên ứng dụng MacOS bằng Swift","text":"Là một iOS developer, bạn có thể có cơ hội viết ứng dụng trên Mac OS. Và đôi khi, ứng dụng của bạn yêu cầu người dùng xác thực trước khi họ có thể sử dụng ứng dụng của bạn. Việc bật Google Sign in giúp bạn tiết kiệm rất nhiều thời gian để triển khai luồng xác thực. Đáng tiếc, thiếu tài liệu về cách tích hợp Google Sign in trên ứng dụng MacOS, đặc biệt là trong Swift. Tôi đã từng có cơ hội triển khai tính năng này cho ứng dụng của mình. Bây giờ tôi muốn chia sẻ với bạn cách chúng ta có thể làm điều đó. Hãy bắt đầu. Thiết lậpTrước tiên hãy tạo ứng dụng Mac OS của bạn, đặt tên tùy thích. Sau đó, chạy lệnh pod init để khởi tạo Pod workspace.Tiếp theo, thêm các dòng sau vào Pod file của bạn. 123456use_frameworks!pod 'GTMAppAuth' # GTMAppAuth is an alternative authorizer to GTMOAuth2, supports for authorizing requests with AppAuth.pod 'SwiftyJSON' # JSON parserpod 'PromiseKit' # Make async requestspod 'Kingfisher' # Cached imagepod 'SnapKit' # Autolayout Sau đó chạy pod install để tải xuống tất cả các dependency này. Lấy OAuth client IDTrước khi bắt đầu ví dụ, trước tiên hãy truy cập Google Console và tạo một project mới. Sau đó nhấn “Create credentials” &gt; “OAuth client ID” &gt; loại ứng dụng “Other” &gt; Làm theo hướng dẫn để lấy credentials của bạn.Sau khi bạn tạo OAuth client ID, hãy ghi lại client ID và client secret, bạn sẽ cần chúng để cấu hình Google Sign-in trong ứng dụng của bạn. Bạn có thể tùy chọn tải xuống file cấu hình chứa thông tin project của bạn để tham khảo sau này. Cấu hình projectĐảm bảo rằng bạn cấu hình ứng dụng của mình để cho phép network vào và ra bằng cách vào Signing &amp; Capabilities &gt; App Sandbox &gt; Check cả Incoming Connections &amp; Outcoming Connections. Nếu bạn không làm điều đó, bạn sẽ gặp lỗi sau vì ứng dụng của bạn không có quyền thực hiện request. 122019-12-11 22:22:49.472046+0700 GoogleSignInDemo[3955:65750] Metal API Validation Enabled2019-12-11 22:22:51.444494+0700 GoogleSignInDemo[3955:66166] dnssd_clientstub ConnectToServer: connect() failed path:/var/run/mDNSResponder Socket:11 Err:-1 Errno:1 Operation not permitted Tiếp theo, mở Info.plist và thêm một giá trị mới cho CFBundleURLTypes, đó là dạng reverse DNS notation của client ID của bạn. Safari sẽ sử dụng DNS notation này để mở ứng dụng của bạn sau khi quá trình xác thực được thực hiện thành công. 1234567891011&lt;key&gt;CFBundleURLTypes&lt;/key&gt;&lt;array&gt; &lt;dict&gt; &lt;key&gt;CFBundleTypeRole&lt;/key&gt; &lt;string&gt;Editor&lt;/string&gt; &lt;key&gt;CFBundleURLSchemes&lt;/key&gt; &lt;array&gt; &lt;string&gt;com.googleusercontent.apps.REPLACE_BY_YOUR_CLIENT_ID&lt;/string&gt; &lt;/array&gt; &lt;/dict&gt;&lt;/array&gt; Thực hiện authorizationTrước tiên hãy tạo service object của chúng ta, class GoogleSignInService, xử lý tất cả các request liên quan đến Google Sign in. Nó cũng chứa tất cả các credentials của project của bạn. 123456789class GoogleSignInService: NSObject, OIDExternalUserAgent { static let kYourClientNumer = \"REPLACE_BY_YOUR_CLIENT_ID\" static let kIssuer = \"https://accounts.google.com\" static let kClientID = \"\\(Self.kYourClientNumer).apps.googleusercontent.com\" static let kClientSecret = \"REPLACE_BY_YOUR_CLIENT_SECRET\" static let kRedirectURI = \"com.googleusercontent.apps.\\(Self.kYourClientNumer):/oauthredirect\" static let kExampleAuthorizerKey = \"REPLACE_BY_YOUR_AUTHORIZATION_KEY\" // The rest omitted} Discover endpoint của dịch vụ Google và định nghĩa một request. 1234567891011OIDAuthorizationService.discoverConfiguration(forIssuer: URL(string: Self.kIssuer)!) { // The rest omitted let request = OIDAuthorizationRequest(configuration: config, clientId: Self.kClientID, clientSecret: Self.kClientSecret, scopes: [OIDScopeOpenID, OIDScopeProfile, OIDScopeEmail], redirectURL: URL(string: Self.kRedirectURI)!, responseType: OIDResponseTypeCode, additionalParameters: nil) // The rest omitted} Hãy xem param scopes, param này định nghĩa thông tin nào của người dùng mà ứng dụng của bạn có thể truy cập. Google Sign In cung cấp 5 scope khác nhau, bao gồm: NSString *const OIDScopeOpenID = @”openid”; NSString *const OIDScopeProfile = @”profile”; NSString *const OIDScopeEmail = @”email”; NSString *const OIDScopeAddress = @”address”; NSString *const OIDScopePhone = @”phone”; Bạn có thể chọn những scope phù hợp với yêu cầu của ứng dụng.Cuối cùng, bắt đầu quá trình xác thực. 1234567OIDAuthState.authState(byPresenting: request, externalUserAgent: self, callback: { (state, error) in guard error == nil else { seal.reject(error!) return } // You got the OIDAuthState object here}) Sau khi quá trình xác thực thực hiện thành công, bạn sẽ nhận được một object OIDAuthState sẽ được sử dụng như một param để khởi tạo object GTMAppAuthFetcherAuthorization.Thông thường, bạn nên lưu object GTMAppAuthFetcherAuthorization này vào keychain và tái sử dụng nó cho các REST API call tiếp theo. 123456private func saveState() { // The rest omitted if auth.canAuthorize() { GTMAppAuthFetcherAuthorization.save(auth, toKeychainForName: Self.kExampleAuthorizerKey) }} Thực hiện requestSau khi lưu service object vào keychain, bây giờ bạn có thể lấy nó để thực hiện bất kỳ request nào. Tôi sẽ thực hiện một request để lấy thông tin profile người dùng hiện tại. 12345678910111213func loadProfile() -&gt; Promise&lt;GoogleSignInProfile&gt; { return Promise { (seal) in // The rest omitted if let url = URL(string: \"https://www.googleapis.com/oauth2/v3/userinfo\") { let service = GTMSessionFetcherService() service.authorizer = auth service.fetcher(with: url).beginFetch { (data, error) in // Process the data here // data = [\"locale\", \"family_name\", \"given_name\", \"picture\", \"sub\", \"name\", emai] } } }} Xử lý sự cố Sau khi đăng nhập, nếu Safari của bạn không thể redirect về ứng dụng của bạn. Chỉ cần clean project của bạn (Shift + Cmd + K) sau đó chạy lại. Các trình duyệt web khác (Chrome, Firefox, v.v.) không thể mở ứng dụng của bạn vì vậy hãy đảm bảo bạn khởi chạy trang đăng nhập trên Safari.1NSWorkspace.shared.open([url], withAppBundleIdentifier: \"com.apple.Safari\", options: .default, additionalEventParamDescriptor: nil, launchIdentifiers: nil) { Suy nghĩ cuối cùngBạn có thể tìm thấy demo hoàn chỉnh ở đâyBây giờ bạn có thể sử dụng Google Sign in bên trong macOS của mình để giảm công sức cho việc xác thực. Để lấy full source code, vui lòng tải xuống qua link Github.Trong trường hợp bạn có bất kỳ vấn đề gì, đừng ngần ngại liên hệ với tôi.","link":"/vi/posts/Integrate-Google-Sign-In-on-MacOS-App-in-Swift/index.html"},{"title":"Memory Leak","text":"Là một Software Engineer, bạn chắc chắn đã nghe về khái niệm Memory leak. Memory leak là tình huống các khối bộ nhớ được cấp phát bởi chương trình vẫn còn trong bộ nhớ mặc dù chúng không còn được tham chiếu nữa. Leak lãng phí không gian bằng cách lấp đầy các trang bộ nhớ với dữ liệu không thể truy cập. Kết quả là, kích thước bộ nhớ sử dụng trong ứng dụng của bạn tiếp tục tăng, ảnh hưởng đến trải nghiệm người dùng và hiệu suất của ứng dụng. Tệ hơn nữa, ứng dụng của bạn sẽ bị crash ngẫu nhiên vì một tiến trình sẽ bị hệ thống kết thúc nếu nó tiêu thụ quá nhiều bộ nhớ.Trong chủ đề này, chúng ta sẽ thảo luận cách bộ nhớ được quản lý trong iOS và cách sử dụng bộ nhớ hiệu quả. Đọc tiếp nào. Automatic Reference CountingARCHầu hết các ngôn ngữ lập trình hiện đại (như Java, C#, Go, v.v.) đều có một quy trình tích hợp tự động tìm các đối tượng không sử dụng và xóa chúng để giải phóng bộ nhớ. Mục đích chính của công nghệ này là giảm memory leak và cho phép lập trình viên tập trung vào logic nghiệp vụ mà không phải lo lắng quá nhiều về quản lý bộ nhớ.Là một ngôn ngữ lập trình cấp cao, Swift cũng có Automatic Reference Counting (ARC) để quản lý bộ nhớ sử dụng trong ứng dụng của chúng ta. Cách ARC hoạt độngBất cứ khi nào chúng ta tạo một instance mới của một class, ARC sẽ cấp phát một không gian bộ nhớ để lưu trữ thông tin về instance đó. Bộ nhớ này chứa thông tin về kiểu của instance, bất kỳ thuộc tính lưu trữ nào liên kết với instance đó. Đặc biệt, bộ nhớ này chứa thông tin về có bao nhiêu thuộc tính, hằng số và biến đang tham chiếu đến instance đó. ARC sẽ không bao giờ giải phóng instance đó miễn là còn ít nhất một tham chiếu hoạt động đến instance đó còn tồn tại.Khi số lượng đối tượng tham chiếu đến instance đó về không, ARC sẽ giải phóng instance đó và giải phóng bộ nhớ được giữ bởi instance đó.Bằng cách áp dụng kỹ thuật này, Apple đảm bảo rằng các instance của class không tiếp tục chiếm không gian trong bộ nhớ khi chúng không còn cần thiết, nói chung tránh được vấn đề memory leak. Memory leakTrong hầu hết các trường hợp, ARC làm tốt công việc của mình. Chúng ta thường không lo lắng về quản lý bộ nhớ. Tuy nhiên, leak vẫn xảy ra trong iOS do vô tình. Đây là khi hai đối tượng giữ tham chiếu mạnh đến nhau khiến mỗi đối tượng giữ đối tượng kia không bị giải phóng. Hãy lấy một ví dụ, có hai class tên là Person và Car. 1234567891011121314151617181920212223242526272829class Person { let name: String var car: Car? lazy var greeting: () -&gt; String = { return \"Hello, my name is \\(self.name). I have \\(self.car?.name ?? \"no cars\")\" } init(name: String) { self.name = name } deinit { print(\"Person \\(self.name) is being destroyed.\") }}class Car { let name: String var owner: Person? init(name: String) { self.name = name } deinit { print(\"car \\(self.name) is being destroyed.\") }} Mỗi instance Person có thuộc tính name kiểu String và thuộc tính Car optional ban đầu là nil vì một người có thể không phải lúc nào cũng có xe.Tương tự, mỗi instance Car có thuộc tính name kiểu String và thuộc tính Person optional ban đầu là nil vì một chiếc xe có thể không phải lúc nào cũng có chủ.Tiếp theo, hãy định nghĩa hai biến gọi là Foo và BMW của class Person và Car, tương ứng. Bây giờ, chúng ta liên kết hai instance với nhau để người có xe, và xe có chủ. 123456# Khối chínhvar foo: Person? = Person(name: \"Foo\")var car: Car? = Car(name: \"BMW\")foo!.car = carseat!.owner = fooprint(foo!.greeting()) Đoạn code tiếp theo sẽ giải phóng hai instance này bằng cách đặt chúng thành nil. 12foo = nilseat = nil Như bạn có thể biết, khi đặt một biến thành nil, có nghĩa là không còn tham chiếu đến instance class này, ARC sẽ giải phóng không gian của đối tượng này để giải phóng bộ nhớ. Như mong đợi, chúng ta nên thấy các phương thức deinit của Student và Car được gọi. Tuy nhiên, hai phương thức đó không bao giờ được gọi, không có thông báo nào, chỉ ra đối tượng được giải phóng, được in ra console. Điều này có nghĩa là foo và car không bao giờ được giải phóng.Lý do tại sao hai đối tượng này không được giải phóng là vì hai đối tượng này giữ tham chiếu mạnh đến nhau khiến mỗi đối tượng giữ đối tượng kia không bị giải phóng, dẫn đến chúng không bao giờ được giải phóng. Tình huống này được gọi là strong reference cycle trong lập trình. Phá vỡ strong reference cycleCó hai cách để phá vỡ strong reference cycle trong Swift. Tùy thuộc vào tình huống chúng ta đang gặp, chúng ta sẽ chọn cách tiếp cận hợp lý để giải quyết vấn đề. Cả hai phương pháp đều cho phép một instance tham chiếu đến instance khác mà không giữ chặt nó. Weak referenceWeak reference nên được sử dụng khi đối tượng nó tham chiếu có thể trở thành nil trong tương lai. Do đó, các đối tượng được capture là kiểu optional.Trong ví dụ trên, việc một chiếc xe không có chủ tại một thời điểm nào đó trong vòng đời của nó là phù hợp, vì vậy weak reference là cách thích hợp để phá vỡ reference cycle trong trường hợp này.Hãy thực hiện một số thay đổi để điều kỳ diệu xảy ra 123456789101112class Car { let name: String weak var owner: Person? init(name: String) { self.name = name } deinit { print(\"Car \\(self.name) is being destroyed.\") }} Hãy chạy code, vẫn không có thông báo nào được in ra console, có nghĩa là hai đối tượng không được giải phóng. Cái quái gì vậy!Hãy truy ngược lại code của chúng ta để kiểm tra có gì sai với nó.Bạn có thấy không? Có một vấn đề khác với code: Closure. Unowned referenceTrong ví dụ trên, class Person không chỉ tạo strong reference cycle với class Car mà còn giữa chính nó và closure greeting. Đây là cách cycle trông như thế:Để giải quyết vấn đề này, chúng ta sẽ sử dụng “Unowned reference”. Unowned reference nên được sử dụng khi closure và đối tượng nó tham chiếu sẽ luôn có cùng thời gian sống với nhau. Điều này có nghĩa là hai đối tượng sẽ được giải phóng cùng một lúc. Kết quả là, unowned reference không bao giờ có thể trở thành nil.Hãy thực hiện một số thay đổi để điều kỳ diệu xảy ra (Một lần nữa). 12345678910111213141516class Person { let name: String var car: Car? lazy var greeting: () -&gt; String = { [unowned self] in return \"Hello, my name is \\(self.name). I have \\(self.car?.name ?? \"no cars\")\" } init(name: String) { self.name = name } deinit { print(\"Person \\(self.name) is being destroyed.\") }} Hãy chạy code, bạn sẽ thấy các thông báo sau được in ra console. 123Hello, my name is Foo. I have BMWPerson Foo is being destroyed.Car BMW is being destroyed. Hai đối tượng foo và car đã được giải phóng và leak đã được giải quyết.Đây là cách cycle trông như thế cho đến nay: Công cụ để phát hiện strong reference cycleGặp phải memory leak thường là cơn ác mộng đối với iOS developer vì quá khó để tìm ra nguyên nhân gốc rễ. May mắn thay, chúng ta có nhiều công cụ được Apple hỗ trợ để theo dõi memory leak. Allocations và Leaks InstrumentTừ thanh công cụ của XCode, chọn Product &gt; Profile &gt; Allocations để bắt đầu một profile instrument mới để theo dõi cấp phát bộ nhớ. Allocations instrument theo dõi tất cả các đối tượng mà ứng dụng cấp phát trong suốt vòng đời của nó.Bây giờ, nhấn nút đỏ ở phía trên bên trái trong panel để bắt đầu ghi.Có rất nhiều thông tin liên quan đến memory mapping được hiển thị trong công cụ. Để xác định memory leak, chúng ta chỉ cần tập trung vào hai cột chính: #Persident và #Transident. Cột Persident: giữ số lượng đối tượng của mỗi kiểu hiện đang tồn tại trong bộ nhớ. Cột Transident: hiển thị số lượng đối tượng đã tồn tại nhưng đã được giải phóng. Như bạn thấy, cột #Persident tiếp tục tăng bất cứ khi nào bạn nhấn nút “Create a leak” để thực thi khối chính. Khi bạn thấy điều gì đó như thế này xảy ra với ứng dụng của bạn, đã đến lúc xem xét lại các class của bạn để tìm ra leak ở đâu. Debug Memory GraphDebug Memory Graph là một công cụ lần đầu được giới thiệu trong Xcode 8. Nó có thể bắt được các leak như retain cycle.Từ debug navigator, click debug mode &gt; View Memory Graph Hierarchy để trực quan hóa memory mappingBạn sẽ thấy một cái gì đó như thế này.Từ hình trực quan, chúng ta có thể thấy có hai strong reference cycle đến từ mối quan hệ Person-Car và từ bên trong chính Person. Kết luậnMỗi iOS developer nên có hiểu biết sâu sắc về cách ARC hoạt động để tránh memory leak. Không thể phủ nhận, quản lý bộ nhớ tốt góp phần vào hiệu suất ứng dụng và trải nghiệm người dùng. Hy vọng, tất cả các khái niệm chúng ta đi qua trong bài viết này sẽ giúp bạn xây dựng các ứng dụng có hiệu suất tốt nhất. Hãy để lại bình luận của bạn ở đây. Tài liệu tham khảo[1] The Swift Programming Language (Swift 4.0.3), App Inc., chương Automatic Reference Counting.","link":"/vi/posts/Memory-leak/index.html"},{"title":"Đóng Vai Trò Central Và Peripheral Với CoreBluetooth","text":"Giới thiệuNhư tôi đã đề cập trong bài viết trước, CoreBluetooth cho phép chúng ta tạo các ứng dụng có thể giao tiếp với các thiết bị BLE như máy đo nhịp tim, cảm biến cơ thể, thiết bị theo dõi hoặc các thiết bị hybrid.Có hai vai trò trong các khái niệm CoreBluetooth: Central và peripheral. Central: Lấy dữ liệu từ các peripheral. Peripheral: Phát hành dữ liệu để được truy cập bởi central. Chúng ta có thể làm cho một thiết bị Bluetooth đóng vai trò peripheral từ phía firmware hoặc phía software. Trong bài viết này, tôi sẽ hướng dẫn bạn cách tạo một peripheral bằng cách sử dụng các identifier của riêng chúng ta. Cũng như sử dụng một thiết bị khác, làm central, để kết nối và khám phá các service của chúng ta. Hãy bắt đầu. Thiết lập PeripheralĐể tạo một service, bạn cần có một identifier duy nhất gọi là UUID. Một service tiêu chuẩn có UUID 16-bit và một service tùy chỉnh có UUID 128-bit. Hãy gõ lệnh sau để tạo một uuid duy nhất từ terminal của bạn. 1$ uuidgen Như bạn thấy, lệnh trả về một uuid ở định dạng hexa (128 bit): A56E51F3-AFFE-4E14-87A2-54927B22354C. Chúng ta sẽ sử dụng chuỗi này để thiết lập service của riêng mình. 123456789101112131415161718192021class ViewController: UIViewController, CBPeripheralManagerDelegate { let kServiceUUID = \"A56E51F3-AFFE-4E14-87A2-54927B22354C\" // Other properties ... override func viewDidAppear(_ animated: Bool) { super.viewDidAppear(animated) peripheralManager = CBPeripheralManager(delegate: self, queue: nil) [1] } func peripheralManagerDidUpdateState(_ peripheral: CBPeripheralManager) { print(\"peripheralManagerDidUpdateState \\(peripheral.state.rawValue)\") if peripheral.state == .poweredOn { let serviceUUID = CBUUID(string: kServiceUUID) [2] self.service = CBMutableService(type: serviceUUID, primary: true) [3] } // Other code }} Đây là những gì các phương thức này làm: [1] Bạn tạo một instance của class PeripheralManager, sẽ đóng vai trò peripheral trong ví dụ của chúng ta. Lưu ý rằng có một tham số queue trong constructor. Các event của vai trò peripheral sẽ được dispatch trên queue được cung cấp. Nếu chúng ta truyền nil, main queue sẽ được sử dụng. [2] Để thiết lập một service, chúng ta cần tạo một instance của class CBUUID. Constructor nhận một uuid duy nhất làm tham số, để phân biệt service của chúng ta với các service khác. [3] Chúng ta tạo một instance của class CBMutableService. Constructor nhận hai tham số: Tham số đầu tiên là uuid duy nhất của chúng ta, được định nghĩa tại [2]; tham số thứ hai chỉ ra rằng service của chúng ta có phải là primary hay không. Nếu không, service của chúng ta sẽ không được tìm thấy khi ứng dụng ở background. Lưu ý rằng bạn có thể thêm bao nhiêu service tùy thích. Để đơn giản, tôi chỉ tạo một service trong bài viết này.OK, hãy chuyển sang bước tiếp theo. Chúng ta sẽ định nghĩa các characteristic cho service bằng code dưới đây. 12345let characteristic = CBMutableCharacteristic.init( type: CBUUID(string: kCharacteristicUUID), [1] properties: [.read, .write, .notify], [2] value: nil, [3] permissions: [CBAttributePermissions.readable, CBAttributePermissions.writeable]) [4] Đây là những gì đang xảy ra: [1] Giống như service, một characteristic cũng cần một uuid duy nhất để được phân biệt với các characteristic khác. [2] Chúng ta thiết lập các thuộc tính cho char. Có nhiều loại permission cho characteristic, nhưng tôi thường sử dụng một số trong số chúng: Read: Được sử dụng cho các characteristic không thay đổi thường xuyên, ví dụ số phiên bản. Write: Sửa đổi giá trị của characteristic. Indicate và notify: Peripheral liên tục thông báo giá trị cập nhật của characteristic cho central. Central không phải liên tục yêu cầu nó. IndicateEncryptionRequired: Chỉ các thiết bị đáng tin cậy mới có thể bật indication của giá trị characteristic.Đối với các thuộc tính khác, vui lòng tham khảo tài liệu Apple [3] Giá trị của characteristic. Lưu ý quan trọng: Nếu bạn cung cấp một giá trị cho characteristic, characteristic phải là read-only. Nếu không, bạn sẽ gặp exception run-time như sau.2018-03-03 12:48:32.938615+0700 Peripheral[4238:3046876] *** Terminating app due to uncaught exception 'NSInternalInconsistencyException', reason: 'Characteristics with cached values must be read-only'Do đó, bạn phải chỉ định giá trị là nil nếu bạn mong đợi giá trị thay đổi trong suốt thời gian tồn tại của service đã publish (write). [4] Tất cả characteristic nên bao gồm permission “readable” để các central có thể đọc giá trị của nó. Nếu chúng ta muốn central có thể gửi lệnh đến peripheral, chúng ta cần đặt permission “writeable” cho characteristic. Bây giờ chúng ta có một service và một characteristic. Hãy publish nó. 1234self.service?.characteristics = []self.service?.characteristics?.append(characteristic)self.peripheralManager.add(self.service!) Sau khi thêm một service vào peripheral manager, delegate method peripheralManager(_ peripheral: CBPeripheralManager, didAdd service: CBService, error: Error?) sẽ được gọi. 1234567func peripheralManager(_ peripheral: CBPeripheralManager, didAdd service: CBService, error: Error?) { if let error = error { print(\"Add service failed: \\(error.localizedDescription)\") return } print(\"Add service succeeded\")} Chúng ta gần xong rồi, chỉ còn một bước nữa: Bắt đầu advertising peripheral để nó có thể được tìm thấy bởi các central khác. 12peripheralManager.startAdvertising([CBAdvertisementDataLocalNameKey: \"TiTan\", CBAdvertisementDataServiceUUIDsKey : [self.service!.uuid]]) Sau khi advertising, delegate method peripheralManagerDidStartAdvertising sẽ được kích hoạt để chỉ ra liệu peripheral đã advertising thành công hay chưa. 1234567func peripheralManagerDidStartAdvertising(_ peripheral: CBPeripheralManager, error: Error?) { if let error = error { print(\"Start advertising failed: \\(error.localizedDescription)\") return } print(\"Start advertising succeeded\")} Tại thời điểm này, chúng ta đã định nghĩa và publish các service của mình. Từ bây giờ, peripheral có thể được khám phá bởi các central thông qua CoreBluetooth. Thiết lập CentralĐầu tiên, chúng ta cần tạo một instance của class CBCentralManager. 12345678class ViewController: UIViewController, CBCentralManagerDelegate, UITableViewDelegate, UITableViewDataSource, CBPeripheralDelegate { override func viewDidLoad() { super.viewDidLoad() // Do any additional setup after loading the view, typically from a nib. centralManager = CBCentralManager(delegate: self, queue: nil) ... }} Giống như peripheral manager, có một tham số queue trong constructor. Các event của vai trò central sẽ được dispatch trên queue được cung cấp. Nếu chúng ta truyền nil, main queue sẽ được sử dụng.Chúng ta cần đợi central manager sẵn sàng, sau đó chúng ta sẽ bắt đầu scan các thiết bị gần đó. 1234567func centralManagerDidUpdateState(_ central: CBCentralManager) { print(\"peripheralManagerDidUpdateState \\(central.state.rawValue)\") if central.state == .poweredOn { self.centralManager.scanForPeripherals(withServices: nil, options: nil) }} Nếu nó tìm thấy một peripheral, delegate method func centralManager(_ central: CBCentralManager, didDiscover peripheral: CBPeripheral, advertisementData: [String : Any], rssi RSSI: NSNumber) sẽ được gọi. 123456789101112func centralManager(_ central: CBCentralManager, didDiscover peripheral: CBPeripheral, advertisementData: [String : Any], rssi RSSI: NSNumber) { if let name = peripheral.name { if (!checkIfExisted(name)) { let tupleDeviceInfo = (device: peripheral, rssi: RSSI) self.scannedDevices.append(tupleDeviceInfo) } DispatchQueue.main.async { self.tbvScannedDevices.reloadData() } }} Bên trong method, chúng ta sẽ kiểm tra xem peripheral có hợp lệ không, sau đó chúng ta sẽ thêm nó vào danh sách hiện tại, rồi reload table view. Lưu ý rằng giá trị RSSI đại diện cho cường độ của tín hiệu truyền. Chúng ta có thể ước tính khoảng cách hiện tại giữa central và peripheral dựa trên giá trị này. Giá trị càng lớn, thiết bị càng gần.Build và chạy project, bạn sẽ thấy danh sách các thiết bị được phát hiện như thế này. Bây giờ, hãy kết nối với peripheral của chúng ta (Thiết bị “Titan”) bằng cách click vào hàng tương ứng.Khi một kết nối được thực hiện thành công, delegate method func centralManager(_ central: CBCentralManager, didConnect peripheral: CBPeripheral) sẽ được gọi. Nếu không, method centralManager(_ central: CBCentralManager, didFailToConnect peripheral: CBPeripheral, error: Error?) sẽ được kích hoạt. 123456func centralManager(_ central: CBCentralManager, didConnect peripheral: CBPeripheral) { self.centralManager.stopScan() peripheral.delegate = self self.peripheral = peripheral self.peripheral?.discoverServices(nil) [1]} 123centralManager(_ central: CBCentralManager, didFailToConnect peripheral: CBPeripheral, error: Error?) { // Fail to connect peripheral} Lưu ý rằng sau khi kết nối với peripheral, chúng ta cần discover các service của peripheral để sử dụng nó ([1]).Delegate method func peripheral(_ peripheral: CBPeripheral, didDiscoverServices error: Error?) sẽ được gọi sau khi discovering services. 1234567891011func peripheral(_ peripheral: CBPeripheral, didDiscoverServices error: Error?) { if let err = error { print(\"didDiscoverServices fail \\(err.localizedDescription)\") return } // [1] Start discovering all chars for service in (peripheral.services)! { peripheral.discoverCharacteristics(nil, for: service) }} Chúng ta vẫn chưa xong =.= Sau khi discovering services, chúng ta cũng cần discover tất cả các characteristic của các service tại [1].Giống như các method khác, method func peripheral(_ peripheral: CBPeripheral, didDiscoverCharacteristicsFor service: CBService, error: Error?) sẽ được gọi sau khi discovering characteristics cho một service. 123456789101112func peripheral(_ peripheral: CBPeripheral, didDiscoverCharacteristicsFor service: CBService, error: Error?) { if let error = error { print(\"didDiscoverCharacteristicsFor Error \\(error.localizedDescription)\") return } for char in service.characteristics! { if char.properties.contains(.notify) { peripheral.setNotifyValue(true, for: char) [1] } ... }} Như bạn thấy, chúng ta cần đặt notify cho characteristic chứa thuộc tính notify để nhận cập nhật từ nó. [1]Cuối cùng, chúng ta đã hoàn thành việc thiết lập kết nối giữa peripheral và central. Bây giờ hãy khám phá dữ liệu. Đọc và ghi dữ liệu từ peripheralBạn phải chỉ định characteristic nào bạn muốn đọc. 1self.peripheral?.readValue(for: discovererChars[kCharacteristicUUID]!) Từ phía peripheral, bạn sẽ nhận được một read request bên trong method 12345func peripheralManager(_ peripheral: CBPeripheralManager, didReceiveRead request: CBATTRequest) { print(\"Read request\") request.value = myValue.data(using: .utf8) peripheral.respond(to: request, withResult: .success)} Sau khi peripheral phản hồi các read request, delegate method func peripheral(_ peripheral: CBPeripheral, didUpdateValueFor characteristic: CBCharacteristic, error: Error?) sẽ được gọi từ phía central. 1234 func peripheral(_ peripheral: CBPeripheral, didUpdateValueFor characteristic: CBCharacteristic, error: Error?) { let value = String.init(data: characteristic.value!, encoding: .utf8)! ...} Nếu giá trị được lấy thành công, bạn có thể truy cập nó thông qua thuộc tính value của characteristic, như trên.Đôi khi chúng ta muốn ghi giá trị của một characteristic có thể ghi được. Chúng ta có thể ghi giá trị vào nó bằng cách gọi method writeValue của peripheral như thế này. 1self.peripheral?.writeValue(data, for: discovererChars[kCharacteristicUUID]!, type: .withResponse) Có một argument gọi là type, bạn chỉ định loại write bạn muốn thực hiện. Trong ví dụ trên, loại write là .withResponse, yêu cầu peripheral cho ứng dụng của bạn biết liệu việc write có thành công hay không.Từ phía peripheral, bạn sẽ nhận được một write request bên trong method 1234func peripheralManager(_ peripheral: CBPeripheralManager, didReceiveWrite requests: [CBATTRequest]) { print(\"Write request\") peripheral.respond(to: requests[0], withResult: .success)} Sau khi write request nhận được phản hồi, method peripheral(_ peripheral: CBPeripheral, didWriteValueFor characteristic: CBCharacteristic, error: Error?) sẽ được gọi. 12345func peripheral(_ peripheral: CBPeripheral, didWriteValueFor characteristic: CBCharacteristic, error: Error?) { if let err = error { print(\"Did write value with error \\(err.localizedDescription)\") }} Giá trị characteristic được mã hóaĐôi khi chúng ta muốn bảo mật dữ liệu nhạy cảm. Chúng ta có thể cấu hình các thuộc tính và permission characteristic phù hợp. Như thế này 12345let encryptedChar = CBMutableCharacteristic.init( type: CBUUID(string: kCharacteristicUUID), properties: [.read, .notify, .notifyEncryptionRequired], value: nil, permissions: [.readable]) Bằng cách này, chúng ta đảm bảo rằng chỉ các thiết bị đáng tin cậy mới có quyền truy cập vào các dữ liệu này.Trong ví dụ của tôi, một khi kết nối được thực hiện, CoreBluetooth cố gắng ghép nối peripheral (iPad) với central (iPhone) để tạo kết nối an toàn. Cả hai thiết bị sẽ nhận được một cảnh báo chỉ ra rằng thiết bị kia muốn ghép nối. Sau khi ghép nối, central có thể truy cập các giá trị characteristic được mã hóa của peripheral. Một số lưu ý quan trọng Mô hình client-server của BLE được gọi là mô hình publish và subscribe. Peripheral chỉ tiêu thụ năng lượng khi nó đang advertising các service của mình, hoặc nhận hoặc phản hồi yêu cầu của central. Bạn có thể truyền một danh sách các service UUID bên trong method scanForPeripherals. Khi bạn chỉ định một danh sách các service UUID, central manager chỉ trả về các peripheral advertising những service đó, cho phép bạn chỉ scan các thiết bị mà bạn có thể quan tâm. Bạn cần cấp quyền để cho phép ứng dụng của bạn sử dụng phụ kiện Bluetooth LE, và hoạt động như một phụ kiện Bluetooth LE cho phía peripheral. (Đi đến project -&gt; Capabilities để thiết lập). Bạn cũng cần thêm một thuộc tính thông tin nữa vào info.plist của bạn, hãy thêm một entry với key Privacy - Bluetooth Peripheral Usage Description và value App communicates using CoreBluetooth (Hoặc bất cứ điều gì bạn muốn mô tả). Xem nhanh ứng dụng của tôiHãy thử một số bài tập nhẹ từ ví dụ của tôi. Tóm tắt luồng lập trình cho BLEĐể tóm tắt quy trình lập trình chung của CoreBluetooth trên iOS, vui lòng xem hình ảnh dưới đây. Suy nghĩ cuối cùngTrong bài viết này, tôi đã hướng dẫn bạn cách sử dụng CoreBluetooth để tạo một peripheral cũng như cách tạo một central để kết nối và lấy dữ liệu từ peripheral. Trong tương lai, chúng ta có thể thấy rằng tất cả các thiết bị xung quanh chúng ta được kết nối với nhau thông qua Bluetooth, hướng tới thế giới IoT.Bạn có thể tải project hoàn chỉnh của central tại đây hoặc peripheral tại đây.Nếu bạn có bất kỳ câu hỏi hoặc bình luận nào, hãy thoải mái để lại trên bài viết của tôi. Mọi bình luận đều được chào đón. Tài liệu tham khảo[1] Core Bluetooth Programming Guide từ Apple","link":"/vi/posts/Play-Central-And-Peripheral-Roles-With-CoreBluetooth/index.html"},{"title":"Remote Notification","text":"Push notification cho phép ứng dụng của bạn tiếp cận người dùng thường xuyên hơn, và cũng có thể thực hiện một số tác vụ. Trong hướng dẫn này, chúng ta sẽ học cách cấu hình ứng dụng để nhận remote notifications, hiển thị nội dung và sau đó thực hiện một số hành động khi người dùng nhấn vào.Hãy bắt đầu. APNsAPNs, viết tắt của Apple Push Notification service, là một dịch vụ gửi messages đến ứng dụng của bạn. Thông tin notification được gửi có thể bao gồm badges, sounds, nội dung tùy chỉnh, hoặc text alerts tùy chỉnh. Lưu ý rằng bạn cần một tài khoản developer trả phí để có thể cấu hình ứng dụng với Push Notification capability. Bạn cũng cần một thiết bị vật lý để testing nếu bạn muốn khởi chạy remote notifications vì push notifications không khả dụng trong simulator. Bạn chỉ có thể simulate notifications trên simulators. Cấu hìnhĐầu tiên, bạn cần thêm push notifications entitlement vào project của bạn,Đi đến Project Setting &gt; Signing Capabilities &gt; + Capability &gt; Thêm Push Notification Nếu bạn muốn gửi notifications đến thiết bị thật, bạn cần làm một số bước bổ sung để có notification key: Đăng nhập vào Apple developer Dưới phần Keys &gt; Thêm keys mới &gt; Nhập tên key của bạn &gt; Chọn Apple Push Notifications service (APNs) &gt; Tiếp tục. Download key và lưu nó vào bất kỳ vị trí nào bạn muốn lưu key này. Lưu ý tên file của key file có pattern AuthKey_[Key ID].p8 Yêu cầu quyền từ người dùngTiếp theo, ứng dụng cần xin quyền từ người dùng để hiển thị notifications.Mở AppDelegate.swift và thêm code sau 123456789101112131415161718192021222324func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -&gt; Bool { // The rest omitted self.registerPushNotifications() ...}func registerPushNotifications() { UNUserNotificationCenter.current() .requestAuthorization(options: [.alert, .sound, .badge]) { granted, error in guard granted else { return } // If the user allows showing notification, then register the device to receive a push notification self.registerForRemoteNotification() }}func registerForRemoteNotification() { UNUserNotificationCenter.current().getNotificationSettings { settings in guard settings.authorizationStatus == .authorized else { return } DispatchQueue.main.async { UIApplication.shared.registerForRemoteNotifications() } }} Nếu quá trình hoàn thành thành công, callback didRegisterForRemoteNotificationsWithDeviceToken: sẽ được gọi bao gồm device token của bạn (Một giá trị duy nhất để xác định thiết bị của bạn, lưu ý rằng nó khác nhau mỗi khi bạn cài đặt lại ứng dụng).Nếu có lỗi xảy ra, didFailToRegisterForRemoteNotificationsWithError: sẽ được kích hoạt. 12345678func application(_ application: UIApplication, didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data) { print(\"Did register remote notification successfully \\(deviceToken.hexadecimalString)\")}func application(_ application: UIApplication, didFailToRegisterForRemoteNotificationsWithError error: Error) { print(\"Did failed register remote notification \\(error.localizedDescription)\") // e.g Did failed register remote notification no valid \"aps-environment\" entitlement string found for application} Lưu ý Alert, sound, và badge là tổ hợp phổ biến khi yêu cầu authorization.Có các options khác bạn có thể tìm thấy trên Apple doc.Một cảnh báo khác là nếu bạn chạy ứng dụng trên simulator, bạn sẽ nhận được sự kiện didFailToRegisterForRemoteNotificationsWithError vì remote notification không được hỗ trợ trên simulators. Xử lý notifications khi ứng dụng ở foregroundSau khi đăng ký remote notification thành công, nếu bạn muốn xử lý notifications khi ứng dụng của bạn ở foreground, bạn cần implement userNotificationCenter:willPresent:withCompletionHandler trong class của bạn. 1234public func userNotificationCenter(_ center: UNUserNotificationCenter, willPresent notification: UNNotification, withCompletionHandler completionHandler: @escaping (UNNotificationPresentationOptions) -&gt; Void) { ... completionHandler([.alert, .sound, .badge])} Nếu bạn không implement function này, notifications sẽ không hiển thị nếu ứng dụng của bạn ở foreground. Đã đến lúc gửi notificationCó 2 cách để test implementation của bạn. Nếu bạn không có thiết bị vật lý, đừng lo, bạn vẫn có thể simulate notifications một cách đơn giản, hoặc bạn có thể gửi notifications thật đến thiết bị thật. Simulate APNsTạo một file với ext .apns. ví dụ SimulateNoti.apns, sau đó copy nội dung của bạn vào file này 1234567891011{ \"Simulator Target Bundle\": \"YOUR_APP_BUNDLE_ID\", &lt;--- THAY ĐỔI THÀNH APP BUNDLE ID CỦA BẠN \"aps\": { \"alert\": { \"title\" : \"Your title\", \"subtitle\" : \"Your subtitle\", \"body\" : \"Your body\" }, \"sound\": \"default\" }} Kéo và thả file này vào simulator mục tiêu sẽ hiển thị notification Push đến thiết bị thậtĐầu tiên, bạn cần một công cụ remote notification client giúp bạn push notification. Một công cụ tuyệt vời để test là Push notification tester. Hãy điều hướng đến website này để download và khởi chạy ứng dụng. Sau khi khởi chạy ứng dụng thành công, Chuyển sang tab TOKEN trong phần Authentication. Nhấn SELECT P8 và chọn file P8 của bạn đã được download từ bước trước, sau đó điền thông tin còn lại KEY ID, TEAM ID. KEY ID là một phần của tên file P8 AuthKey_[Key ID].p8. Đối với TEAM ID, bạn có thể tìm thấy nó trên trang membership của bạn. Trong phần Body, điền app bundle Id của bạn (ví dụ com.example.yourapp) và device token được tạo từ callback didRegisterForRemoteNotificationsWithDeviceToken:. Soạn nội dung của bạn. Đây là body phổ biến cho push notification.ví dụ 12345678910{ \"aps\": { \"alert\": { \"title\" : \"Your title\", \"subtitle\" : \"Your subtitle\", \"body\" : \"Your body\" }, \"sound\": \"default\" }} Để biết tất cả các options có sẵn trong notification, vui lòng tham khảo Apple doc: generating_a_remote_notification Nhấn nút Send để gửi notification đến thiết bị đã chọn. Một message sẽ xuất hiện ở phía trên nút để hiển thị kết quả. Silent notificationTừ góc nhìn của tôi, tính năng thú vị nhất của Push notification là “Silent notification”, có thể đánh thức ứng dụng của bạn để thực hiện một số tác vụ trong khi ứng dụng của bạn ở trong nền, ngay cả khi ứng dụng của bạn đã bị người dùng tắt. Nhiều kỹ sư ngoài kia đang tìm cách giữ cho ứng dụng của họ sống trong nền càng nhiều càng tốt. Có một số cách để đạt được điều đó bằng cách sử dụng restoration và preservation, core location, iBeacon. Silent push notification là một trong số đó. Tôi sẽ có một bài viết khác nói về silent notification và thí nghiệm của tôi để chúng ta có thêm chi tiết và thông tin. Để gửi silent notification, chỉ cần thay đổi nội dung JSON thành 12345{ \"aps\": { \"content-available\": 1 }} Sau khi nhấn nút Send, không có notification nào hiển thị trên ứng dụng của bạn. Suy nghĩ cuối cùngBằng cách sử dụng push notifications một cách khôn ngoan, bạn có thể thu hút người dùng quay lại ứng dụng của bạn. Tuy nhiên, nếu bạn lạm dụng notifications, nó có thể dẫn đến các tác dụng tiêu cực như người dùng tắt quyền cho ứng dụng của bạn hoặc đánh giá ứng dụng 1* với các phàn nàn trên store (Giống như câu chuyện của chúng tôi trong quá khứ :)).Notifications không chỉ giúp gửi messages của bạn đến người dùng mà còn có thể được sử dụng cho các mục đích nâng cao khác như đánh thức ứng dụng của bạn bằng cách sử dụng silent notifications. Trong bài viết tiếp theo, chúng ta sẽ có cái nhìn sâu hơn về tính năng tuyệt vời này.Nếu bạn có bất kỳ thắc mắc hoặc bình luận nào, hãy cho tôi biết.Happy sharing! Tài liệu tham khảo Apple doc: Generating a remote notification Raywenderlich: Push notification tutorial","link":"/vi/posts/Remote-Notification/index.html"},{"title":"Review Sach: Clean Code","text":"Day la cuon sach toi duoc tang tu lau boi mot dong nghiep cu, nguoi cung la mot trong nhung nguoi ban than cua toi. Day la mot trong nhung cuon sach ve phan mem ma toi thich nhat nhung khong co co hoi mua khi con la sinh vien. Gioi thieuVe tac gia, Robert C. Martin, ong duoc coi la mot trong nhung ky su lau nam nhat trong nganh cong nghiep phan mem. Ong co nhieu nam kinh nghiem lam viec trong linh vuc phan mem tu nhieu vi tri khac nhau, tu lap trinh vien, quan ly, den CEO. Ong duoc biet den nhieu nhat voi viec viet cac huong dan phan mem mo ta cac nguyen tac, mau thiet ke, va cac thuc hanh phan mem. Ong da xuat ban nhieu cuon sach nhu Clean Coder, Clean Code, Clean Architecture, v.v. Clean Code la mot trong nhung cuon sach phan mem ma nhieu ky su phan mem tren the gioi khuyen doc.Tac gia noi rang *”Theo thoi gian, su lon xon tro nen qua lon, qua sau va qua cao, ho khong the don dep no”*. Chung ta can doc, suy nghi nhieu truoc khi viet code. Chung ta nen tranh viet code voi vang. Voi vang viet code te se dan den viec ton nhieu thoi gian hon cho viec bao tri sau nay. Clean Code tap trung vao cac khia canh ky thuat: huong dan lap trinh vien cach to chuc code va viet code sach. Ban se khong hoc bat ky framework moi nao, nhung no se cung cap cho ban mot bo quy tac ve phong cach lap trinh co ban. Cuon sach dang de doc. Noi dung sachNoi dung cua cuon sach duoc chia thanh ba phan: Cac chuong dau tien se giai thich cac nguyen tac, mau thiet ke, va cac thuc hanh viet code sach. Phan thu hai bao gom nhieu case study, moi case study la mot bai tap chuyen doi code co mot so van de thanh code it van de hon. Phan cuoi cung la phan tong ket. Tai sao can code sach?Bjarne Stroustrup (Nguoi sang tao C++): Elegant, Efficiency.Grady Booch (Tac gia Object Oriented Analysis): Readability.David Thomas (Nguoi sang lap OTI): De cho nguoi khac cai tien.Warn Cunningham (Nguoi sang tao Wiki): Lam cho ngon ngu trong don gian.Toi: De co the nho nhung gi ban viet mot thang truoc. Tieu chi danh gia code sachTong quat Khong lap lai chinh minh: Su trung lap co the la goc re cua moi dieu xau trong phan mem. Nhieu nguyen tac va thuc hanh da duoc tao ra voi muc dich kiem soat hoac loai bo no. Doi khi chung ta co the su dung mau Template method de loai bo su trung lap o cap cao hon. Dat ten bien, phuong thuc, tham so, lop, tap tin Ten cua mot bien, ham hoac lop nen tra loi cau hoi tai sao no ton tai, no lam gi va no duoc su dung nhu the nao. Su dung ten co the tim kiem. Lop va doi tuong nen co ten danh tu hoac cum danh tu. Phuong thuc nen la dong tu hoac cum dong tu. Su khong nhat quan: Can than voi cac quy uoc ban chon, va mot khi da chon, tiep tuc tuan thu chung. Comment Comment nen noi nhung dieu ma code khong the tu noi: Giai thich y tuong trong code, neu khong the, thi viet comment. Comment nen duoc danh rieng cho cac ghi chu ky thuat ve code va thiet ke. Su dung ngu phap va dau cau dung. Dung comment-out code, hay xoa no. Ham Ham nen nho: It hon 100 dong. No lam cho ham de doc va hieu hon. Ham chi nen lam mot viec. Ham nen co it tham so (It hon 4 tham so). Dung truyen gia tri boolean lam tham so. Ham khong bao gio duoc goi nen duoc xoa. Tach xu ly loi ra khoi xu ly binh thuong. Dong goi cac dieu kien. Xu ly loi Xu ly loi la quan trong, nhung neu no che khuat logic, thi no sai. Dung tra ve Null: Hay xem xet nem exception hoac tra ve mot doi tuong SPECIAL CASE thay the. Neu ban code theo cach nay, ban se giam thieu co hoi gap NullPointerException va code cua ban se sach hon. Dung truyen Null lam tham so. Ranh gioi Boc cac API cua ben thu ba: Giam thieu su phu thuoc cua ban vao no. Khi co ban phat hanh moi cua goi thu ba, chung ta nen chay test de xem co su khac biet ve hanh vi khong. Tranh de qua nhieu code cua chung ta biet ve cac chi tiet cu the cua ben thu ba: Hay su dung Adapter de xu ly no. Lop Mot lop nen nho: Chung ta do no bang trach nhiem. (Chung ta biet no nhu nguyen tac SRP) Code nen duoc dat o noi ma nguoi doc tu nhien mong doi no o do. (Hang so PI nen o dau? No nen o trong lop Math? Hay co le trong lop Circle?). Can than khi tao cac phuong thuc static. Mot phuong thuc static khong hoat dong tren mot instance don le. Tat ca du lieu ma phuong thuc su dung den tu cac tham so cua no, va khong tu bat ky instance nao cua lop nay. Ngoai ra, hay dam bao rang khong co co hoi ban muon no hoat dong da hinh. Dong thoi Co mot so dinh nghia co ban chung ta nen biet khi noi ve dong thoi va thread: Bound resources, mutual exclusion, starvation, deadlock, va livelock. Dong thoi khong phai luc nao cung cai thien hieu suat. No doi khi phat sinh chi phi va loi tu no khong thuong lap lai. Gioi han quyen truy cap cua du lieu duoc chia se giua hon hai thread. Su dung ban sao cua du lieu neu co co hoi. Giu cac phan dong bo hoa cang nho cang tot vi Lock tao ra do tre va them chi phi. Chung la dat. Code da luong hoat dong khac nhau trong cac moi truong khac nhau: Chay test trong moi moi truong trien khai tiem nang. Nhung gi toi thich Kien thuc trong cuon sach nay huu ich. No hoan toan co the ap dung vao thuc te. Sau khi doc cuon sach, phong cach lap trinh cua toi da thay doi rat nhieu. Cuon sach de hieu va theo doi. Ban se doc nhieu code, ban se co thach thuc de suy nghi ve dieu gi dung ve code do va dieu gi sai voi no. Sau moi chuong, tac gia tom tat cac y chinh. No giup toi nho cac diem chinh lau hon. Nhung gi toi khong thich Tac gia su dung code Java lam vi du trong sach. Doi khi de hieu y tuong cua tac gia, chung ta phai tim hieu them ve cac khai niem Java. (Spring framework, JUnit framework, cac loai exception, v.v.) Y tuong cua tac gia bi trung lap trong mot so chuong. Tong quatTat nhien, trong pham vi bai viet, toi khong the mo ta day du cac y tuong cua tac gia. Day la mot cuon sach tot ma toi khuyen doc, dac biet cho cac lap trinh vien junior moi tot nghiep. Vi o truong, giao vien co the khong day chung ta code nhu the nao duoc goi la sach, phong cach lap trinh cua ban khong duoc danh gia. Tren thuc te, code cua ban co the chay dung nhung khong sach.Neu ban co kha nang mua cuon sach nay de co the tham khao khi can, no se rat huu ich.“Ban dang doc cuon sach nay vi hai ly do. Thu nhat, ban la mot lap trinh vien. Thu hai, ban muon tro thanh mot lap trinh vien gioi hon.”","link":"/vi/posts/Review-Book-Clean-Code/index.html"},{"title":"Review sach: Building Applications With iBeacon","text":"Trong bai viet truoc, toi da gioi thieu so luoc ve iBeacon - Mot giao thuc Bluetooth duoc xay dung tren nen tang BLE boi Apple, va tao mot demo don gian ve cach iBeacon co the danh thuc mot ung dung sau khi bi nguoi dung tat. Tuy nhien, toi chua de cap den cac khai niem nen tang khac trong Beacon, no cung khong cho ban cai nhin sau ve cac uu diem va nhuoc diem cua cong nghe manh me nay.Hom nay, toi muon gioi thieu cho ban mot cuon sach tot cung cap kien thuc vung chac trong linh vuc Beacon, dac biet la iBeacon: Building Applications With iBeacon xuat ban boi O’Reilly.Sau khi doc cuon sach nay, toi dam bao rang ban se co duoc kien thuc tot trong linh vuc iBeacon va tam tri cua ban se coi mo hon voi cac y tuong sap toi.Bat dau thoi! Noi dung chinhCuon sach tap trung chu yeu vao cac lap trinh vien dang tim kiem cach hieu qua de tich hop giao thuc beacon vao ung dung cua ho. De su dung sach hieu qua, toi khuyen ban nen co mot so kien thuc nen tang ve BLE vi iBeacon duoc xay dung tren BLE.Trong phan dau, cuon sach mo ta mot lich su ngan gon cua cac cong nghe proximity noi rieng. No cung giai thich tai sao va khi nao su dung trong mot so tinh huong cu the.Hai ly do chinh tai sao su dung iBeacon la, truoc het, cong nghe GPS kho co the lam tot hon vai met, va GPS thuong bi han che trong nha. iBeacons co the cho phep xac dinh trong pham vi centimet. Ly do thu hai la iBeacons cung cap vi tri vi mo co do chinh xac cao, cung voi kha nang hanh dong dua tren nhung gi thiet bi di dong o gan. Chua co cong nghe nao khac cung cap su ket hop do.De thuyet phuc nguoi doc, cuon sach so sanh GPS voi Beacon, noi cach khac la vi tri so voi su gan gui; dua ra mot so han che cua cong nghe GPS hien tai, tac gia chi ra mot so linh vuc ma Beacon vuot troi hon nhieu so voi GPS.Tiep theo, cuon sach giai thich cach giao thuc Beacon hoat dong ben duoi; gioi thieu cho ban cac thuat ngu nen tang, va cach chung tuong tac voi nhau.Cuoi cung, trong mot so chuong, cuon sach huong dan ban cach thiet lap beacon cua rieng ban tren Mac OS, thiet bi di dong, hoac cac may tinh nho nhu Ras. Pi hoac Arduino. Cac khai niem chinh Moi quan he giua iBeacons, generic beacons, BLE beacons, va BLE devices duoc mo ta nhu ben duoi iBeacons la mot tap con cua dac ta BLE beacon, Tat ca iBeacons la BLE beacons, va tat ca BLE beacons la BLE devices. Tuy nhien, co cac beacon khong dua tren Bluetooth, va co cac BLE devices khong phat beacon. Mot iBeacon can duoc cau hinh voi bo so dinh danh cua no (UUID, major number, va minor number).Beacon identifier = UUID + Major + Minor. Trong Core Location, mot region la khong gian nhan duoc su ket hop cu the cua UUID, major number, va minor number. Core Location ho tro ba loai loc region: Chi UUID: bat ky iBeacon nao da cai dat khop voi uuid. UUID cong major number: Giong nhu tuy chon chi UUID, no co the khop voi nhieu iBeacons, rat co the duoc cai dat tai mot vi tri cu the. UUID cong major va minor numbers: Tuy chon nay se chi khop voi mot iBeacon cu the. Code sau minh hoa cach dinh nghia ba region do trong Swift, tuong ung.123let region1 = CLBeaconRegion(uuid: \"uuid1\", identifier: \"Your region's name 1\")let region2 = CLBeaconRegion(proximityUUID: \"uuid2\", major: 1, identifier: \"Your region's name 2\")let region3 = CLBeaconRegion(proximityUUID: \"uuid3\", major: 1, minor: 0, identifier: \"Your region's name 3\") iOS va iBeacon: Apple cung cap hai hanh dong chinh khi lam viec voi iBeaconMonitoringMonitoring cung cap kha nang dang ky theo doi su xuat hien cua mot region, duoc ket hop voi mot hoac nhieu beacon.Mot su kien in va out se duoc kich hoat khi thiet bi vao hoac ra khoi region, tuong ung. Duoc thuc hien o ca foreground va background tren iOS, duoc su dung de xac dinh khi nao thiet bi da vao hoac roi khoi vung phu song cua iBeacon. Mot trong nhung loi ich lon nhat cua viec su dung beacon la cac region duoc theo doi boi he dieu hanh, khong phai ung dung. Ngay ca khi ung dung khong chay (bi OS tat hoac nguoi dung buoc dung), OS co the khoi dong lai ung dung de xu ly cac su kien. Sau khi duoc dua tro lai background, ung dung co vai giay de thuc thi cac tac vu (Khoang 10 giay). Location manager dinh nghia mot phuong thuc cho didEnterRegion, duoc goi khi thiet bi vuot qua ranh gioi de vao mot region Location manager dinh nghia mot phuong thuc cho didExitRegion, duoc goi khi thiet bi vuot qua ranh gioi de roi khoi mot region. Han che cua Monitoring iOS chi co the theo doi toi da 20 region trong mot ung dung don le nhu mo ta trong tai lieu Apple Regions la tai nguyen he thong duoc chia se, va tong so region co san tren toan he thong bi gioi han. Vi ly do nay, Core Location gioi han 20 so luong region co the duoc theo doi dong thoi boi mot ung dung don le” Apple doc. He thong cung mat mot thoi gian de kich hoat su kien exit, trong thuc te khoang 30 ~ 40 giay. RangingSu dung cac tin hieu truyen de uoc tinh khoang cach tu thiet bi di dong den beacon. Mot cach su dung pho bien cua hoat dong ranging la xac dinh iBeacon nao gan nhat voi khu vuc nay.Location manager se kich hoat phuong thuc didRangeBeacons sau khi ranging thanh cong, mot danh sach cac iBeacons co du lieu ranging se duoc truyen vao phuong thuc delegate, cung voi region ma chung duoc phat hien. No cung cung cap chi so cuong do tin hieu nhan duoc (RSSI) de uoc tinh pham vi tinh bang met (No la mot thuoc tinh cua doi tuong CLBeacon). Han che cua Ranging: Mot nhuoc diem chinh cua hoat dong ranging yeu cau nhieu hoat dong hon trong phan cung Bluetooth va tieu thu nhieu nang luong, vi giao dien Bluetooth hoat dong nhieu hon khi ranging Nhung gi toi thich Toi khong bao gio nghi chu de iBeacon se duoc viet thanh mot cuon sach hoan chinh nhung tac gia da lam rat tot: Cuon sach mo ta iBeacon voi giai thich sau sac. Lam ro cac thuat ngu nen tang thuong duoc su dung trong cong nghe beacon. Phan tich uu va nhuoc diem cua iBeacon voi cac vi du. Gioi thieu cac ung dung khac cua beacon ma toi chua bao gio nghi den truoc day, dieu nay mo rong tam tri toi rat nhieu: Indoor Location va Proximity: Thay the ban do, ho tro giao thong cong cong, tim duong trong nha, xe cua toi dau?, huong dan bao tang, nang cao cua hang ban le. Proximity-Triggered Actions: Quang cao di dong, xac nhan ve, tim kho bau, tich hop thong tin benh nhan. Quan ly hang doi: Do luong hang doi, may goi ban nha hang, hoan thanh giao dich ban le. De hieu: noi dung duoc to chuc tot, de theo doi dong noi dung. Nhung gi toi khong thichKhong co gi de phan nan ve cuon sach, tu noi dung den hinh thuc. Tong quatNhieu cong nghe ton tai de giup dien thoai tuong tac voi the gioi xung quanh chung. Cuon sach nay gioi thieu cho ban iBeacons, mot cong nghe Bluetooth cho phep thiet bi phat hien cac doi tuong gan do voi do chinh xac tuong doi cao. Khong con nghi ngo gi rang cac ung dung cua beacon ngay cang duoc ap dung rong rai trong nhieu linh vuc, dac biet la trong marketing va quang cao.Tu quan diem cua toi, ban nen doc cuon sach de co the mo rong tam tri ve iBeacon. Co the startup tiep theo cua ban duoc xay dung tren Beacon, ai biet?Trong bai huong dan tiep theo, toi se dua ban vao thuc hanh voi iBeacon tren iOS, cung se gioi thieu cho ban mot so ky thuat de xu ly iBeacon trong phan tich sau.Neu ban co bat ky cau hoi hoac nhan xet nao ve bai viet nay, hay lien he voi toi!","link":"/vi/posts/Review-book-Building-Applications-With-iBeacon/index.html"},{"title":"Review sach: RxSwift Reactive Programming with Swift","text":"Trong the gioi phat trien iOS lien tuc phat trien, viec thao tac thuan thuc reactive programming co the giup ban noi bat nhu mot lap trinh vien. Mot trong nhung tai nguyen tot nhat de di sau vao reactive programming voi Swift la cuon sach “RxSwift: Reactive Programming with Swift.” Huong dan toan dien nay cung cap moi thu ban can de hieu va tan dung RxSwift trong cac ung dung cua ban. Hay cung kham pha dieu gi lam cho cuon sach nay tro thanh tai lieu can doc cho cac lap trinh vien Swift. Reactive Programming la gi?Reactive programming la mot mo hinh cho phep ban lam viec voi cac luong du lieu bat dong bo va cac su kien theo cach khai bao. Thay vi quan ly thu cong cac callback va thay doi trang thai, reactive programming cho phep ban khai bao cach du lieu nen chay va phan hoi cac su kien. Dieu nay mang lai code sach hon, de bao tri hon, dac biet cho cac ung dung phuc tap. Bat dau voi RxSwiftCuon sach bat dau voi cac kien thuc co ban cua reactive programming, gioi thieu cac khai niem cot loi nhu Observables, Subscribers, va Observer Pattern. No huong dan ban thiet lap RxSwift trong du an cua ban su dung cac dependency managers pho bien nhu CocoaPods va Swift Package Manager. Cac khai niem cot loiCuon sach di sau vao cac khai niem cot loi cua RxSwift: Observables va Observers: Hoc cach Observables phat ra cac item va cach Observers subscribe vao cac luong nay. Day la xuong song cua reactive programming. Operators: RxSwift cung cap mot bo operators phong phu de chuyen doi va ket hop cac luong. Cuon sach bao gom cac operators khac nhau, bao gom: Creation Operators: create, just, from Transformation Operators: map, flatMap, concatMap Filtering Operators: filter, distinctUntilChanged, throttle Combination Operators: merge, combineLatest, zip Subjects: Hieu cac loai Subjects khac nhau nhu PublishSubject, BehaviorSubject, ReplaySubject, va AsyncSubject va cac truong hop su dung cua chung. Cac chu de nang cao va Thuc hanh tot nhat: Khi ban da thoai mai voi cac kien thuc co ban, cuon sach gioi thieu cac chu de nang cao hon: Schedulers: Quan ly dong thoi va quan ly thread voi cac schedulers cua RxSwift, bao gom MainScheduler va ConcurrentDispatchQueueScheduler. Xu ly loi: Kham pha cac chien luoc xu ly loi trong cac luong reactive su dung cac operators nhu catchError va retry. Quan ly bo nho: Hoc cac thuc hanh tot nhat de quan ly subscriptions va tranh ro ri bo nho voi cac cong cu nhu DisposeBag. Tich hop RxSwift voi UIKit: Mot trong nhung diem manh cua RxSwift la kha nang tich hop lien mach voi UIKit. Cuon sach trinh bay cach bind RxSwift Observables vao cac thanh phan UIKit nhu UITableView va UICollectionView. No cung bao gom xu ly dau vao nguoi dung theo cach reactive, lam cho code UI cua ban phan hoi nhanh hon va de quan ly hon. Test va Debug: Test va debug code reactive co the la thach thuc. “RxSwift: Reactive Programming with Swift” cung cap loi khuyen thuc te ve viec viet unit tests cho code RxSwift va su dung cac cong cu nhu TestScheduler. No cung cung cap cac meo de debug cac luong reactive, giup ban dam bao ung dung cua ban chay tron tru. Ung dung thuc te: Cuon sach day cac vi du thuc te va case studies. Ban se thay cach RxSwift co the duoc ap dung vao cac van de thuc te nhu network requests, form validation, va quan ly cac tuong tac UI phuc tap. Nhung vi du nay giup cung co su hieu biet cua ban va chi ra cach su dung RxSwift hieu qua trong cac du an cua ban. Uu diem Giai thich ro rang: Cuon sach duoc khen ngoi vi cac giai thich ro rang va co cau truc, lam cho cac khai niem reactive programming phuc tap tro nen de tiep can hon. Vi du thuc te: No cung cap mot loat cac vi du thuc te giup hieu cach su dung RxSwift hieu qua. Bao quat toan dien: Bao gom ca cac chu de co ban va nang cao, phuc vu nguoi doc voi cac cap do kinh nghiem khac nhau. Nhuoc diem Phien ban Swift: Tuy thuoc vao ngay xuat ban, mot so noi dung co the dua tren cac phien ban Swift hoac RxSwift cu hon, dieu nay co the yeu cau mot so dieu chinh neu ban dang su dung cac phien ban moi nhat. Do sau bao quat: Mot so nguoi doc co the thay rang mac du cuon sach bao quat nhieu noi dung, mot so chu de nang cao co the yeu cau tai nguyen bo sung de thao tac day du. Ket luanDay la mot tai nguyen vo gia cho cac lap trinh vien iOS muon thao tac thuan thuc reactive programming. Voi cac giai thich ro rang, vi du thuc te, va bao quat toan dien ca cac chu de co ban va nang cao, day la cuon sach can doc cho bat ky ai nghiem tuc ve viec su dung RxSwift trong cac ung dung cua ho. Du ban moi lam quen voi reactive programming hay dang muon nang cao kien thuc, cuon sach nay se huong dan ban tung buoc tren duong di.","link":"/vi/posts/Review-book-RxSwift-Reactive-Programming-with-Swift/index.html"},{"title":"Chuỗi bài React Native và BLE: Phần 1 - Xây dựng BLE framework cho iOS","text":"Tôi đã làm việc trong lĩnh vực phát triển di động trên cả các dự án native và cross platform (React Native, Flutter), và tôi cũng có kinh nghiệm làm việc với BLE. Đôi khi tôi nhận được email hỏi về việc giao tiếp giữa RN/Flutter và BLE. Vì vậy, tôi quyết định giới thiệu chuỗi bài React Native và BLE này để hướng dẫn bạn cách phát triển một BLE framework native và kết nối nó với React Native.Tất nhiên, sẽ có một chuỗi bài khác cho Flutter và BLE sau khi hoàn thành chuỗi bài React Native.Trong chuỗi bài này, tôi sẽ hướng dẫn bạn qua một quy trình hoàn chỉnh từ phát triển đến phân phối. Tạo iOS / Android framework. Script để build và phân phối framework của bạn. Import các framework vào dự án React Native của bạn. Sử dụng framework native của bạn trong React Native. Phân phối ứng dụng của bạn. Và những điều thú vị khác tôi muốn chia sẻ với bạn … Nếu bạn thích những gì tôi làm, hãy cân nhắc ủng hộ tôi tại buy a coffee for Uy Nguyen :)Bắt đầu thôi. Xcode 13, iOS 15, Swift 5, React 17.0.1, React Native 0.64.1. Chuẩn bị iOS frameworkBước đầu tiên là tạo một BLE framework. Bạn cũng không nhất thiết phải tạo framework, bạn có thể include source code của mình trực tiếp bên trong dự án iOS nếu bạn muốn.Tuy nhiên, lý do tại sao tôi khuyên nên chuyển tất cả logic BLE vào một framework là vì nó có thể tái sử dụng, bạn có thể chia sẻ framework của mình cho các dự án khác như Flutter hoặc các dự án Native mà không cần phải duplicate logic.Một lý do khác là nó sẽ cải thiện thời gian compile của Xcode, chia ứng dụng của bạn thành nhiều framework có thể tăng tốc thời gian build. Điều này là do hệ thống build Xcode không cần phải recompile các framework mà các file Swift không thay đổi. Từ thanh trên cùng bên trái của Xcode, chọn File &gt; New &gt; Project &gt; From the &quot;Framework &amp; Library&quot; section, select &quot;Framework&quot; &gt; Enter your framework name (I use &quot;BLEFramework&quot;) Bây giờ, bạn có thể phát triển logic BLE của mình trong dự án bạn vừa tạo. Tôi sẽ không chi tiết việc triển khai tất cả các method đơn lẻ của framework vì nó phụ thuộc vào logic kinh doanh và kiến trúc của bạn. Bạn có thể tìm các tutorial trước đây của tôi để có ý tưởng về cách triển khai BLE framework. Bluetooth Low Energy OniOS, Play Central And Peripheral Roles With CoreBluetoothTôi sẽ lấy một method đơn giản trong BLE framework của tôi làm ví dụ: method startScanning. 12345678910/**Class: CentralManager*//*** @discussion Start scanning nearby peripherals and returns to the `ScanningDelegate`*/public func startScanningFor(delegate: ScanningDelegate, filter: DeviceFilter = DeviceFilter()) throws { //... BLE implementation.} OK bây giờ chúng ta có một BLE framework, hãy chuyển sang bước tiếp theo: Build và phân phối framework của bạn. Build và phân phốiCó nhiều cách để phân phối framework như sử dụng CocoaPod, hoặc thủ công bằng cách gửi file đã compiled, v.v. Trong bài viết này, tôi sẽ cung cấp cho bạn một script để biến framework của bạn thành một universal framework ẩn tất cả logic của bạn, và có thể được sử dụng cho cả thiết bị vật lý và simulator. Đảm bảo bạn bật cờ “Build Libraries for Distribution” trong “Build Settings” thành YES. Cờ này chỉ ra rằng compiler nên tạo một trong những interface ổn định để framework có thể được sử dụng khi các phiên bản mới hơn của Xcode hoặc Swift compiler được phát hành. Tiếp theo, tạo một file bash, đặt nó ở root của thư mục ios, và copy các lệnh sau vào file. Sau đó thực thi script. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546### SCRIPT TO BUILD A SWIFT UNIVERSAL FRAMEWORKPRODUCT_NAME=\"REPLACE_BY_YOUR_TARGET_NAME\"BUILD_CONFIGURATION=\"Release\"DERIVED_DATA_PATH=\"$(pwd)/build\"RELEASE_DIR=\"$(pwd)/RELEASE\"BUILD_SCHEME=\"${PRODUCT_NAME}\"FRAMEWORK_NAME=\"${PRODUCT_NAME}.framework\"RELEASE_DEVICE_PATH=\"${RELEASE_DIR}/device/${FRAMEWORK_NAME}\"RELEASE_SIMULATOR_PATH=\"${RELEASE_DIR}/simulator/${FRAMEWORK_NAME}\"rm -rf \"${DERIVED_DATA_PATH}\"rm -rf \"${RELEASE_DIR}\"mkdir -p \"${DERIVED_DATA_PATH}\"mkdir -p \"${RELEASE_DIR}\"mkdir -p \"${RELEASE_DIR}/simulator\"mkdir -p \"${RELEASE_DIR}/device\"# Build library for simulatorfastlane ios build scheme:\"${BUILD_SCHEME}\" \\ configuration:\"${BUILD_CONFIGURATION}\" \\ sdk:iphonesimulator \\ build_dir:\"${DERIVED_DATA_PATH}\" \\ --verboseSIMULATOR_FRAMEWORK_PATH=\"${DERIVED_DATA_PATH}/Build/Products/${BUILD_CONFIGURATION}-iphonesimulator/${FRAMEWORK_NAME}\"mv \"${SIMULATOR_FRAMEWORK_PATH}\" \"${RELEASE_SIMULATOR_PATH}\"# Build library for iphoneosfastlane ios build scheme:\"${BUILD_SCHEME}\" \\ configuration:\"${BUILD_CONFIGURATION}\" \\ sdk:iphoneos \\ build_dir:\"$DERIVED_DATA_PATH\" \\ --verboseDEVICE_FRAMEWORK_PATH=\"${DERIVED_DATA_PATH}/Build/Products/${BUILD_CONFIGURATION}-iphoneos/${FRAMEWORK_NAME}\"mv \"${DEVICE_FRAMEWORK_PATH}\" \"${RELEASE_DEVICE_PATH}\"# Merge SDKsxcodebuild -create-xcframework -output \"${RELEASE_DIR}/${PRODUCT_NAME}.xcframework\" \\ -framework \"${RELEASE_DEVICE_PATH}\" \\ -framework \"${RELEASE_SIMULATOR_PATH}\"open \"${RELEASE_DIR}\" Khi bạn chạy script thành công, bạn sẽ thấy kết quả như bên dưới Trong đó: YOUR_TARGET_NAME.xcframework: Universal framework có thể được sử dụng cho cả thiết bị vật lý và simulator. thư mục device: chứa YOUR_TARGET_NAME.framework chỉ có thể được sử dụng trên thiết bị vật lý. thư mục simulator: chứa YOUR_TARGET_NAME.framework chỉ có thể được sử dụng trên simulator. Bây giờ chúng ta có một BLE framework cho ứng dụng của mình, hãy chuyển sang bước tiếp theo - Tạo một dự án React Native mới. Khởi tạo dự án React NativeĐể tạo một dự án React Native mà không sử dụng Expo (tôi khuyên không nên sử dụng Expo vì chúng ta sẽ thêm nhiều Native code cho Android và iOS vào dự án của mình, để biết thêm chi tiết bạn có thể tham khảo what is the difference between expo and react native), mở terminal và gõ 1react-native init projectName Đợi một lúc để thiết lập dự án của bạn. Sau khi chạy thành công, bạn sẽ thấy cấu trúc thư mục như bên dưới: 12345|---projectName |---ios |---projectName.xcworkspace |---android |---...Other files, folders Mở file projectName.xcworkspace, chúng ta sẽ cấu hình native code trong bước tiếp theo. Kết nối chúng lại với nhauĐầu tiên, kéo và thả YOUR_TARGET_NAME.xcframework vào Xcode workspace của bạn.Vì SDK của tôi được build bằng Swift, tôi sẽ tạo một class Swift làm cầu nối để chúng ta có thể giao tiếp từ SDK đến React Native.Từ dự án Xcode, chọn File &gt; New &gt; File &gt; Swift File &gt; Enter your file name (e.g BLEManager) &gt; Add. Một hộp thoại sẽ xuất hiện hỏi bạn có muốn tạo bridging header không, chọn yes. Đối với những ai không biết bridging header được sử dụng để làm gì, bridging header là nơi bạn định nghĩa tất cả các class Objective-C được expose cho Swift. Để sử dụng các class RCT, đảm bảo bạn #import tất cả các header liên quan vào ...-Bridging-Header.h của bạn. Nếu không, bạn sẽ gặp lỗi compile. 1234#import &lt;React/RCTBridgeModule.h&gt;#import \"React/RCTEventEmitter.h\"#import \"React/RCTViewManager.h\"#import &lt;React/RCTLog.h&gt; Tiếp theo, thêm interface RCTEventEmitter vào class BLEManager chúng ta vừa tạo ở bước trước. 1234567891011121314151617181920212223242526272829@objc(BLEManager) &lt;--- Remember to add this [1]public class BLEManager: RCTEventEmitter, ScanningDelegate { static let didFoundDeviceEvent = \"didFoundDevice\" @objc &lt;--- Remember to add this public static let shared = BLEManager() override init() { super.init() _ = BLEWrapper.shared } @objc(startScanning) &lt;--- Remember to add this func startScanning() { BLEWrapper.shared.startScanning(self) } public func managerDidFoundDevice(_ manager: CentralManager, device: Device, rssi: Int) { self.sendEvent(withName: Self.didFoundDeviceEvent, body: [\"name\": device.localName, \"rssi\": rssi]) [2] } public override static func requiresMainQueueSetup() -&gt; Bool { return true } override public func supportedEvents() -&gt; [String]! { return [Self.didFoundDeviceEvent] [3] }} [1] Đảm bảo bạn decorate class và function của mình bằng keyword @objc để đảm bảo class và function được export đúng cách sang Objective-C runtime.[2] Khi một peripheral được phát hiện, gửi một event đến Javascript.[3] Đăng ký hỗ trợ event từ native module. Cuối cùng, để expose các method của native module của bạn, tạo một file mới BLEManager.m và thêm code sau. 12345@interface RCT_EXTERN_MODULE(BLEManager, RCTViewManager)RCT_EXTERN_METHOD(startScanning)@end Vậy là xong. Javascript bây giờ có thể gọi function startScanning và lắng nghe event didFoundDeviceEvent. Kiểm thửĐã đến lúc kiểm tra triển khai của chúng ta, React Native cung cấp các instance NativeEventEmitter và NativeModules cho phép bạn làm việc với các native module.từ thư mục root, mở App.js và import các thứ cần thiết. 12345import { NativeEventEmitter, NativeModules,} from 'react-native';const {BLEManager} = NativeModules; &lt;-- You can then access the BLEManager native module Trong method componentDidMount, thêm code sau vào đó 123456789101112componentDidMount() { let beaconManagerEmitter = new NativeEventEmitter(BLEManager); [1] this.didFoundDevice = beaconManagerEmitter.addListener( [2] 'didFoundDevice', data =&gt; { console.log(data); }, ); setTimeout(() =&gt; { BLEManager.startScanning(); [3] }, 3000); // Just to make sure the Bluetooth is on, we will improve it later} [1] Tạo một instance NativeEventEmitter mới và lắng nghe event didFoundDevice [2][3] Vì chúng ta chưa hỗ trợ event thay đổi trạng thái Bluetooth, nên chúng ta tạm thời delay 3s trước khi gọi scanning chỉ để đảm bảo Bluetooth đang bật. Chúng ta sẽ cải thiện nó sau bằng cách hỗ trợ thêm các event và method. OK, hãy build và chạy dự án của bạn. Nếu bạn thấy console log in ra kết quả từ quá trình scanning, xin chúc mừng, bạn đã làm đúng! Bước tiếp theoTrong bài viết này, tôi đã chỉ cho bạn cách tạo một BLE framework và cách sử dụng một BLE native module trong dự án React Native như gọi một method từ Javascript đến Swift và xử lý một event từ Swift đến Javascript. Trong tutorial tiếp theo, chúng ta sẽ làm điều tương tự trên nền tảng Android.Nếu bạn gặp bất kỳ khó khăn nào, hãy liên hệ với tôi. Tôi rất vui lòng giúp đỡ.Chúc ngày nghỉ vui vẻ. Tài liệu tham khảo[1] React Native - Native module ios","link":"/vi/posts/Series-React-Native-and-BLE-Part-1-Building-BLE-framework-for-iOS/index.html"},{"title":"Review sach: Swift Apprentice - Raywenderlich","text":"Khi toi dang tim kiem mot cuon sach de nang cao ky nang phat trien iOS, toi tim thay cuon Swift Apprentice nay tren cua hang sach cua Raywenderlich. Xem qua noi dung cua cuon sach, toi quyet dinh them cuon sach vao thu vien cua minh.Noi chung, neu ky nang iOS cua ban la mid-level hoac senior, ban rat tu tin voi ky nang lap trinh bac thay cua minh, cuon sach nay khong danh cho ban. Nhung neu ban dang tim kiem mot cuon sach de cung co kien thuc, hoac ban chi muon dam bao moi thu ban hieu ve ngon ngu Swift la dung - nhu muc dich cua toi, thi hay mang cuon sach nay theo.Ban se hoc ve nhung thu rat co ban nhu function, method, constants, control statement, v.v. Ban cung se co co hoi co duoc kien thuc sau ve Stack/Heap allocation, protocol-oriented programming, va generic programming, dieu nay lam cho cong viec hang ngay cua ban thuan tien hon, va ban se thay minh nhu mot bac thay trong ngon ngu Swift.Bat dau thoi! Ve tac giaVoi nhung ai khong biet Raywenderlich la gi, day la mot trang web cong dong tap trung vao viec tao cac bai huong dan va sach lap trinh (Chu yeu tap trung vao phat trien di dong tren Android va iOS). Noi dung cua ho bao gom tat ca cac cap do tu co ban den cac chu de nang cao.Toi thuong truy cap trang web Raywenderlich de lay code mau va cap nhat kien thuc. Cac bai huong dan cua ho cuc ky tuyet voi, chinh xac ve mat ky thuat va duoc cap nhat voi cac cong nghe moi nhat.Swift Apprentice la mot trong nhung bo suu tap lap trinh iOS cua ho. Cac diem chinh Lazy property: Neu ban co mot thuoc tinh co the mat thoi gian de tinh toan, ban khong muon lam cham moi thu cho den khi ban thuc su can thuoc tinh do, hay su dung lazy stored property. No huu ich cho nhung thu nhu tai anh dai dien nguoi dung hoac thuc hien tinh toan phuc tap. Heap vs. Stack:Stack duoc su dung de luu tru bat ky thu gi tren thread thuc thi ngay lap tuc; no duoc quan ly va toi uu hoa boi CPU. Khi mot function tao mot bien, stack luu tru bien do va sau do huy no khi function ket thuc. Vi stack duoc to chuc nghiem ngat, no rat hieu qua, va do do kha nhanh.Heap, o phia ben kia, duoc su dung de luu tru cac instance cua reference types. Heap noi chung la mot vung nho lon ma he thong co the yeu cau va cap phat dong cac khoi bo nho. Thoi gian song linh hoat va dong. No khong tu dong huy du lieu cua no (stack lam dieu do). Can cong viec bo sung de giai phong bo nho tren Heap, dieu nay lam cho viec tao va xoa du lieu tren heap la mot qua trinh cham hon, so voi tren stack.Khi mot instance cua class duoc tao, code cua ban yeu cau mot khoi bo nho tren heap de luu tru chinh instance do.Khi mot instance cua struct duoc tao (khong phai la mot phan cua instance cua class), chinh instance do duoc luu tru tren stack, va heap khong lien quan. Khi nao su dung class so voi struct: Values vs. objects: Su dung structures nhu values va classes nhu objects co identity. De don gian, chi can nho rang khong co hai objects nao duoc coi la bang nhau chi vi chung giu cung state. Nguoc lai, cac instance cua value types, la values, duoc coi la bang nhau neu chung la cung gia tri. v.d, khong co hai sinh vien nao duoc coi la bang nhau, ngay ca khi ho co cung ten; Hai diem (x, y) bang nhau neu x1 va y1 giong voi x2 va y2, tuong ung, nen chung ta implement Point nhu mot struct.Speed: Neu nhung instances nay chi ton tai trong bo nho trong mot thoi gian ngan — nen su dung struct. Neu instance cua ban se co lifecycle dai hon trong bo nho, hay nghi den class.Mot cach tiep can khac la chi su dung nhung gi ban can. Neu du lieu cua ban se khong bao gio thay doi hoac ban can mot noi luu tru du lieu don gian, thi su dung structures. Neu ban can cap nhat du lieu cua ban va ban can no chua logic de cap nhat trang thai cua chinh no, thi su dung classes. Thuong thi, tot nhat la bat dau voi mot struct. Neu ban can cac kha nang them cua class sau nay, thi ban chi can chuyen doi struct thanh class. Two-Phase initialization:• Giai doan mot: Khoi tao tat ca cac stored properties trong class instance, tu duoi len tren cua class hierarchy. Neu ban su dung properties va methods truoc khi giai doan mot hoan thanh, compiler se nem loi.• Giai doan hai: Bay gio chung ta co the su dung properties va methods cua object. Protocols trong Standard Library: Equatable, Comparable, Hashable, CustomStringConvertible. Generic function parameters:123func swapped&lt;T, U&gt;(_ x: T, _ y: U) -&gt; (U, T) { (y, x)} Wildcard pattern:1234if case (_, 0, 0) = coordinate { // x co the la bat ky gia tri nao. y va z phai chinh xac la 0. print(\"On the x-axis\") // Printed!} Value-binding pattern:123if case let (x, y, 0) = coordinate { print(\"On the x-y plane at (\\(x), \\(y))\") // Printed: 1, 0} “Is” type-casting pattern”:12345switch element { case is String: print(\"Found a string\") default: break} Rethrows: Bang viec su dung rethrows thay vi throws, cac function chi ra rang chung se chi rethrow cac loi duoc nem boi cac function duoc goi ben trong chinh no nhung khong bao gio la cac loi cua rieng no. Loi ich cua Protocol-oriented:Bang viec su dung protocols thay vi implementations, chung ta tap trung vao nhung gi object co the lam thay vi cach object lam, dieu nay lam cho ung dung co the mo rong va test duoc hon.Multiple inheritances: Mot trong nhung loi ich thuc su cua protocols la chung cho phep mot hinh thuc da ke thua. Swift la ngon ngu protocol-oriented. Nhung gi toi thich To chuc tot. Vi du thuc te: Co cac vi du cho moi chu de de dam bao nguoi doc hieu sau nhung gi vua de cap. De hieu: Vi noi dung duoc to chuc tot, de theo doi dong noi dung. Dung lai va suy nghi: Co cac bai tap ngan va thach thuc xuyen suot cuon sach de cho ban mot so thuc hanh lap trinh va kiem tra kien thuc cua ban theo cach. Keypoints: Ho tom tat cac diem chinh o cuoi moi chuong. Nhung gi toi khong thichToi da co xem qua cuon sach nhieu lan de tim mot diem ma toi khong thich nhung khong co gi de phan nan, tu noi dung den hinh thuc. Tong quatSwift thi vui va day cac mo hinh lap trinh. Sau khi doc cuon sach nay, toi hy vong bay gio ban cam thay du thoai mai voi ngon ngu de chuyen sang xay dung nhung thu lon hon. Voi cac kien thuc nen tang ve ngon ngu chung ta da co duoc, chung ta san sang kham pha cac framework nang cao nhu Animation, UIKit, v.v. de xay dung cac ung dung iOS, cac ung dung macOS va hon the nua.Toi hy vong ban thay cuon sach nay thu vi.Cuoi tuan vui ve!","link":"/vi/posts/Review-book-Swift-Apprentice-Raywenderlich/index.html"},{"title":"Silent notification","text":"Trong thế giới phát triển ứng dụng di động không ngừng phát triển, việc giữ cho người dùng tương tác và được cập nhật thông tin là điều then chốt. Đối với các nhà phát triển iOS, background notification là một công cụ mạnh mẽ giúp nâng cao trải nghiệm người dùng mà không làm gián đoạn các hoạt động hiện tại của họ. Nhưng chính xác thì background notification là gì và chúng hoạt động như thế nào? Hãy cùng tìm hiểu chi tiết. Background Notification là gì?Background notification, hay silent notification, là một loại thông báo trong iOS cho phép ứng dụng thức dậy và thực hiện các tác vụ ở chế độ nền mà không cần cảnh báo người dùng bằng thông báo hiển thị. Không giống như các thông báo tiêu chuẩn xuất hiện trên màn hình và yêu cầu tương tác của người dùng, background notification được thiết kế để âm thầm cập nhật nội dung của ứng dụng hoặc thực hiện các hoạt động nền. Các thông báo này đặc biệt hữu ích cho các ứng dụng cần giữ dữ liệu luôn mới hoặc thực hiện các tác vụ định kỳ mà không làm phiền người dùng. Ví dụ, một ứng dụng thời tiết có thể sử dụng background notification để cập nhật thông tin thời tiết, hoặc một ứng dụng tin tức có thể lấy các bài viết mới nhất ở chế độ nền. Background Notification hoạt động như thế nào?Background notification dựa vào Apple Push Notification Service (APNs), đây là dịch vụ do Apple cung cấp để gửi thông báo đến các thiết bị iOS. Dưới đây là tổng quan đơn giản về cách chúng hoạt động: Đăng ký ứng dụng: Ứng dụng đăng ký với APNs và nhận được một device token duy nhất. Yêu cầu từ Server: Server của ứng dụng gửi yêu cầu push notification đến APNs, chỉ định device token và bao gồm payload của thông báo. Gửi thông báo: APNs gửi thông báo đến thiết bị. Đối với background notification, payload này bao gồm key content-available được đặt thành 1, cho biết thông báo nhằm mục đích đánh thức ứng dụng ở chế độ nền. Đánh thức ứng dụng: Khi nhận được background notification, iOS đánh thức ứng dụng để xử lý dữ liệu hoặc thực hiện các tác vụ nền. Điều này được thực hiện mà không hiển thị bất kỳ cảnh báo trực quan nào cho người dùng. Xử lý thông báo: Code của ứng dụng xử lý thông báo ở chế độ nền, cập nhật nội dung hoặc thực hiện các hành động cần thiết. Những điều cần lưu ý Hiệu quả và Giới hạn: Background notification nên được sử dụng hiệu quả để tránh sử dụng không cần thiết tài nguyên pin và mạng. iOS có thể giới hạn tần suất và kích thước của background notification để bảo vệ hiệu suất hệ thống và tuổi thọ pin. Quyền riêng tư và Quyền của người dùng: Mặc dù background notification không hiển thị cảnh báo, chúng vẫn yêu cầu quyền của người dùng để nhận thông báo. Đảm bảo rằng ứng dụng của bạn truyền đạt rõ ràng lý do tại sao cần quyền này. Xử lý tác vụ nền: Khi xử lý background notification, việc quản lý tác vụ hiệu quả là rất quan trọng. iOS cung cấp các API cụ thể cho các tác vụ nền để đảm bảo các hoạt động được hoàn thành kịp thời. Kiểm thử và Debug: Việc kiểm thử background notification có thể khó khăn. Sử dụng các công cụ debug và simulator để kiểm tra các kịch bản khác nhau và đảm bảo ứng dụng của bạn xử lý thông báo như mong đợi. Các trường hợp sử dụng thực tế Ứng dụng tin tức: Giữ cho người dùng được cập nhật với các tiêu đề mới nhất mà không cần nhắc họ bằng cảnh báo. Ứng dụng mạng xã hội: Cập nhật nội dung feed hoặc thông báo âm thầm cho ứng dụng về tin nhắn mới hoặc yêu cầu kết bạn. Ứng dụng năng suất: Đồng bộ dữ liệu hoặc làm mới nội dung ở chế độ nền để đảm bảo người dùng luôn có thông tin mới nhất khi họ mở ứng dụng. Kết luậnBackground notification trong iOS là một tính năng mạnh mẽ giúp nâng cao chức năng và trải nghiệm người dùng của các ứng dụng di động. Bằng cách cho phép ứng dụng thực hiện các tác vụ ở chế độ nền mà không làm gián đoạn người dùng, chúng tạo ra các tương tác liền mạch và hiệu quả hơn. Tuy nhiên, chúng nên được sử dụng một cách cẩn thận để cân bằng hiệu suất, tuổi thọ pin và trải nghiệm người dùng.Nếu bạn đang phát triển một ứng dụng iOS, hãy cân nhắc tích hợp background notification để cung cấp trải nghiệm năng động và phản hồi tốt hơn. Với việc triển khai đúng cách, bạn có thể giữ cho nội dung của ứng dụng luôn mới và người dùng luôn tương tác, đồng thời duy trì trải nghiệm người dùng mượt mà và không bị gián đoạn.","link":"/vi/posts/Silent-notification/index.html"},{"title":"Chuỗi bài React Native và BLE: Phần 2 - Xây dựng BLE framework cho Android","text":"Khi nói đến công nghệ di động, iOS và Android là hai hệ điều hành thống trị cung cấp năng lượng cho phần lớn điện thoại thông minh và máy tính bảng trên toàn thế giới. Là các nhà phát triển, điều cần thiết là chúng ta phải có kiến thức và công cụ để làm việc hiệu quả với cả hai nền tảng. Điều này đặc biệt đúng khi nói đến việc sử dụng công nghệ Bluetooth, là một thành phần quan trọng của nhiều ứng dụng di động hiện đại.Trong phần 1 của chuỗi bài tutorial này, chúng ta đã tạo một BLE (Bluetooth Low Energy) framework có thể được kết nối với UI sử dụng React Native. Tuy nhiên, framework này chỉ hoạt động trên iOS, điều đó có nghĩa là chúng ta cần phát triển một giải pháp riêng cho Android.Trong phần 2 của chuỗi bài tutorial này, chúng ta sẽ tập trung vào việc định nghĩa một SDK mới cho Android và liên kết nó với UI, giống như chúng ta đã làm trên iOS. Điều này sẽ cho phép chúng ta hỗ trợ đầy đủ cả hai hệ điều hành và cung cấp trải nghiệm Bluetooth liền mạch cho tất cả người dùng, bất kể thiết bị họ chọn. Tạo Android SDK mớiBước đầu tiên là tạo thư viện Bluetooth của riêng bạn. Thông thường, các kỹ sư có xu hướng sử dụng thư viện mã nguồn mở như RxAndroidBle hoặc Android-BLE-Library powered by Nordic. Tuy nhiên, mục tiêu chính của tutorial này là hướng dẫn bạn cách tạo một Android module mới và liên kết nó với React Native. Điều này không chỉ áp dụng cho Bluetooth mà còn cho bất kỳ thư viện nào bạn cần sử dụng trong ứng dụng của mình. Mục tiêu khác là đạt được kiến thức nền tảng về Android BLE trong trường hợp bạn cần sửa đổi điều gì đó hoặc tạo tính năng riêng chưa được hỗ trợ trên thị trường. Bằng cách tạo thư viện Bluetooth của riêng mình, bạn có tự do tùy chỉnh và điều chỉnh thư viện theo nhu cầu cụ thể của bạn. Điều này có thể mang lại lợi thế đáng kể so với việc sử dụng các thư viện có sẵn, vì bạn có thể tối ưu hóa thư viện cho trường hợp sử dụng cụ thể của mình và tránh các vấn đề tương thích tiềm ẩn. Từ dự án của bạn, đi đến File &gt; New &gt; New Module &gt; Fill in the information.Một thư viện mới sẽ được thêm vào dự án của bạn. Một điều khác biệt lớn giữa Android và iOS là từ Android 6.0, Google yêu cầu Location Permission phải được bật để quét Bluetooth Low Energy (Xem thêm Android 6.0 Changes). Tiếp theo, thêm các permission sau vào AndroidManifest.xml của bạn tại android/app/src/main/AndroidManifest.xml 123&lt;uses-permission android:name=\"android.permission.BLUETOOTH\" /&gt;&lt;uses-permission android:name=\"android.permission.BLUETOOTH_ADMIN\" /&gt;&lt;uses-permission android:name=\"android.permission.ACCESS_FINE_LOCATION\" /&gt; note:123456Android 12 update:From Android 12 (API level 31+):- Google requires new permission for scanning nearby devices: + If your app looks for Bluetooth devices, such as BLE peripherals, declare the BLUETOOTH_SCAN permission. + If your app communicates with already-paired Bluetooth devices, declare the BLUETOOTH_CONNECT permission.- If your app does not use Bluetooth scan results for physical location, you can skip declaring location permission by adding `android:usesPermissionFlags` Với mục đích demo, SDK chỉ expose 2 API đơn giản startScan để bắt đầu quét các thiết bị gần đó và isBluetoothOn để kiểm tra xem Bluetooth có được bật không. 12345/*Start scanning nearby devices.Accept `callback` as param and return found devices via `callback`*/fun startScan(callback: (device: Device) -&gt; Unit) 1234/*Check if BLE is ready for scanning*/fun isBluetoothOn() : Boolean Để yêu cầu permission trên React Native, chúng ta sẽ sử dụng module này https://github.com/zoontek/react-native-permissions để lấy các permission mà ứng dụng cần. Build và release Android SDK moduleTiếp theo, hãy phân phối module để các ứng dụng khác có thể sử dụng nó.Từ thư mục root, chạy ./gradlew kTrackingSDK:assembleRelease để tạo file .aar.File output sẽ nằm tại ./KTrackingSDK/build/outputs/aar, sau đó bạn có thể import file .aar vào dự án android. Kết nối với phần React NativeBây giờ, chúng ta đã có thư viện Bluetooth. Bước tiếp theo là liên kết module với phần React Native. Đầu tiên, phần React Native cần hiểu Native module. Thêm cấu hình sau vào /src/main/java của bạn 1234567891011121314151617181920212223242526272829class BLEManager(context: ReactApplicationContext) : ReactContextBaseJavaModule(context) { init { Log.d(\"BLEManager\", \"Init package\") BLEManagerLib.shared.config(context) } override fun getName(): String { return \"BLEManager\" } @ReactMethod fun isBluetoothOn(promise: Promise) { promise.resolve(BLEManagerLib.shared.isBluetoothOn()) } @ReactMethod fun startScanning() { Log.d(\"BLEManager\", \"Start scanning\") BLEManagerLib.shared.startScan { val params: WritableMap = Arguments.createMap() params.putString(\"name\", it.name) params.putInt(\"rssi\", it.rssi) params.putString(\"address\", it.address) this.reactApplicationContext .getJSModule(RCTDeviceEventEmitter::class.java) .emit(\"didFoundDevice\", params) } }} Tạo file mới để định nghĩa BLEManagerPackage 1234567891011class BLEManagerPackage: ReactPackage { override fun createNativeModules(reactContext: ReactApplicationContext): MutableList&lt;NativeModule&gt; { val modules = ArrayList&lt;NativeModule&gt;() modules.add(BLEManager(reactContext)) return modules } override fun createViewManagers(reactContext: ReactApplicationContext): MutableList&lt;ViewManager&lt;View, ReactShadowNode&lt;*&gt;&gt;&gt; { return ArrayList() }} Tiếp theo, thêm nó vào danh sách package trong MainApplication.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class MainApplication extends Application implements ReactApplication { ... @Override protected List&lt;ReactPackage&gt; getPackages() { Log.d(\"BLEManager\", \"Running\"); @SuppressWarnings(\"UnnecessaryLocalVariable\") List&lt;ReactPackage&gt; packages = new PackageList(this).getPackages(); /* Add your custom modules here */ packages.add(new BLEManagerPackage()); /* */ return packages; } ...}Cuối cùng, ứng dụng cần yêu cầu người dùng cấp permission.```js// somewhere in your codeimport { check, PERMISSIONS, request, RESULTS } from 'react-native-permissions';checkPermission = () =&gt; { check(PERMISSIONS.ANDROID.ACCESS_FINE_LOCATION) .then((result) =&gt; { if (result !== RESULTS.GRANTED) { requestLocation(() =&gt; { // On granted }, () =&gt; { // On denied }); } }) .catch((error) =&gt; { // … });}requestLocation = (grantedCallback, deniedCallback) =&gt; { request(PERMISSIONS.ANDROID.ACCESS_FINE_LOCATION).then(result =&gt; { switch (result) { case RESULTS.DENIED: console.log('User denied permission',); deniedCallback(); break; case RESULTS.GRANTED: console.log('The permission is granted'); grantedCallback(); break; } });} Kết quảVì chúng ta sử dụng cùng code cho cả Android và iOS trong phần React Native, không cần sửa đổi code React Native từ tutorial trước. Miễn là bạn tuân theo protocol chúng ta đã định nghĩa, mọi thứ sẽ hoạt động như dự định. Bằng cách duy trì một protocol nhất quán trên cả hai nền tảng, chúng ta có thể đảm bảo rằng code dễ dàng portable và bất kỳ thay đổi nào được thực hiện trên một nền tảng sẽ không ảnh hưởng đến nền tảng kia. Điều này có thể đơn giản hóa đáng kể quá trình phát triển và giảm rủi ro lỗi hoặc vấn đề tương thích. Kết luậnSau khi dành vô số giờ nghiên cứu và thử nghiệm, chúng ta cuối cùng đã học được cách tạo thư viện Bluetooth của riêng mình và sử dụng nó trong dự án React Native. Với kiến thức mới này, quá trình thêm các tính năng mới đã trở nên dễ dàng và hiệu quả hơn đáng kể. Chúng ta chỉ cần triển khai logic trong Native Code thay vì phải phát triển phần UI hai lần. Điều này không chỉ tiết kiệm cho chúng ta một lượng lớn thời gian và công sức mà còn cho phép chúng ta tập trung hơn vào việc nâng cao chức năng của ứng dụng. Giờ đây chúng ta có thể dành nhiều tài nguyên hơn cho việc phát triển các tính năng mới, tối ưu hóa các tính năng hiện có, và cải thiện trải nghiệm người dùng tổng thể. Hơn nữa, khả năng mới của chúng ta trong việc tạo các thư viện tùy chỉnh đã mở ra một thế giới hoàn toàn mới về khả năng cho đội ngũ phát triển của chúng ta. Giờ đây chúng ta có thể tận dụng kiến thức về React Native để tạo ra các tính năng tiên tiến và sáng tạo hơn nữa, trong khi vẫn duy trì quy trình phát triển được đơn giản hóa. Chúc viết code vui vẻ! Tài liệu tham khảo Android Native Modules. Android Bluetooth permissions.","link":"/vi/posts/Series-React-Native-and-BLE-Part-2-Building-BLE-framework-for-Android/index.html"},{"title":"Lên lịch tác vụ ở chế độ nền từ foreground service","text":"Nếu bạn đang chạy service trên Android, hãy lưu ý rằng Android đã giới thiệu các hạn chế thực thi nền nghiêm ngặt hơn trong các phiên bản gần đây. Bắt đầu từ Android 8.0 (API level 26) trở lên, background service có giới hạn về thời gian thực thi, đặc biệt khi ứng dụng ở chế độ nền. Hãy đảm bảo bạn nhận thức được các hạn chế này và điều chỉnh service của mình cho phù hợp. TimerKhi sử dụng Timer để lên lịch tác vụ, nó dựa vào một background thread duy nhất. Nếu màn hình tắt, thiết bị có thể vào trạng thái tiết kiệm năng lượng hoặc chế độ ngủ, và điều này có thể ảnh hưởng đến việc thực thi các tác vụ được lên lịch với Timer. Trong những trường hợp như vậy, các tính năng tiết kiệm năng lượng của thiết bị có thể tạm dừng hoặc trì hoãn việc thực thi tác vụ, dẫn đến hành vi không mong đợi. 1234567private final Timer syncTimer = new Timer();syncTimer.scheduleAtFixedRate(new TimerTask() { @Override public void run() { // Do your task }}); Trong trường hợp của tôi, ứng dụng cần lên lịch một tác vụ lặp lại ở chế độ nền để đồng bộ dữ liệu và kiểm tra xem người dùng còn quyền truy cập thiết bị Bluetooth hay không. Trong lần thử đầu tiên, chúng tôi sử dụng Timer, và nó không hoạt động như mong đợi vì Timer không chạy khi thiết bị vào chế độ doze (Doze mode là tính năng tiết kiệm năng lượng được giới thiệu trong Android 6.0 (Marshmallow) giúp kéo dài tuổi thọ pin bằng cách giảm mức tiêu thụ năng lượng của thiết bị khi nó ở chế độ rảnh và không được sử dụng. Nó tối ưu hóa hành vi của ứng dụng để giảm thiểu hoạt động nền, truy cập mạng và sử dụng CPU trong các khoảng thời gian không hoạt động. Khi thiết bị ở chế độ Doze, nó hạn chế xử lý nền, truy cập mạng và wake lock để tiết kiệm pin.).Do đó, chúng tôi cần tìm một giải pháp thay thế, và có hai ứng cử viên khác tôi muốn chia sẻ với bạn: AlarmManager và WorkManager. Alarm managerNếu bạn cần lên lịch các tác vụ cần chạy ngay cả khi ứng dụng không đang chạy, bạn có thể sử dụng class AlarmManager. Nó cho phép bạn lên lịch các tác vụ vào thời điểm hoặc khoảng thời gian cụ thể, ngay cả khi ứng dụng của bạn ở chế độ nền hoặc không chạy. Class AlarmManager trong Android là một system service cho phép bạn lên lịch các tác vụ hoặc sự kiện để thực thi vào thời điểm hoặc khoảng thời gian cụ thể, ngay cả khi ứng dụng của bạn không đang chạy. Nó cung cấp một cách để thực hiện các hành động hoặc kích hoạt thực thi code vào những thời điểm được chỉ định, chẳng hạn như đặt báo thức, lên lịch các tác vụ định kỳ hoặc thực hiện các hoạt động nền. Các tính năng chính của AlarmManager bao gồm: Độ chính xác thời gian: AlarmManager cung cấp thời gian chính xác để lên lịch tác vụ. Nó sử dụng đồng hồ hệ thống của thiết bị để xác định khi nào thời gian hoặc khoảng thời gian được chỉ định đã trôi qua. Linh hoạt trong việc lên lịch: Bạn có thể lên lịch các tác vụ chạy một lần (set()), lặp lại theo khoảng thời gian cố định (setRepeating()), hoặc lặp lại theo khoảng thời gian cụ thể với độ linh hoạt (setInexactRepeating()). Sự linh hoạt này cho phép bạn lên lịch các tác vụ theo yêu cầu cụ thể của mình. Bền vững khi thực thi: Các tác vụ đã lên lịch được đăng ký với AlarmManager vẫn tồn tại ngay cả khi thiết bị được khởi động lại. Điều này đảm bảo rằng các tác vụ sẽ được thực thi theo lịch trình ngay cả sau khi hệ thống khởi động lại. Khả năng đánh thức thiết bị: AlarmManager có thể đánh thức thiết bị từ chế độ ngủ để thực thi các tác vụ đã lên lịch. Điều này hữu ích cho các tình huống mà bạn cần thực hiện các hoạt động nền yêu cầu thiết bị phải thức. Tương thích và hỗ trợ ngược: AlarmManager đã có sẵn từ các phiên bản đầu tiên của Android và cung cấp khả năng tương thích ngược với các phiên bản Android cũ hơn. Điều này đảm bảo rằng các tác vụ đã lên lịch của bạn có thể chạy trên nhiều loại thiết bị. Dưới đây là ví dụ cơ bản về việc sử dụng AlarmManager để lên lịch một tác vụ: Đầu tiên, bạn cần thiết lập các quyền cần thiết trong file AndroidManifest.xml: 1&lt;uses-permission android:name=\"android.permission.WAKE_LOCK\"/&gt; Tiếp theo, tạo một class để xử lý tác vụ sẽ được thực thi khi alarm kích hoạt, và sử dụng nó 123456789101112131415161718192021public class MyAlarmReceiver extends BroadcastReceiver { @Override public void onReceive(Context context, Intent intent) { // Do your task }}Intent intent = new Intent(this, MyAlarmReceiver.class);PendingIntent pendingIntent = PendingIntent.getBroadcast(this, 0, intent, 0);// Get the AlarmManager serviceAlarmManager alarmManager = (AlarmManager) getSystemService(Context.ALARM_SERVICE);// Set the repeating alarmalarmManager.setRepeating( AlarmManager.RTC_WAKEUP, System.currentTimeMillis() + ALARM_INTERVAL_MS, ALARM_INTERVAL_MS, pendingIntent); Work managerWorkManager là một thư viện Android Jetpack được Google giới thiệu để đơn giản hóa và quản lý các tác vụ nền trong các ứng dụng Android. Nó được thiết kế để giúp các nhà phát triển dễ dàng lên lịch các tác vụ có thể hoãn lại, định kỳ và một lần cần được thực thi ngay cả khi ứng dụng không chạy hoặc thiết bị ở trạng thái tiết kiệm năng lượng. Sử dụng WorkManager, bạn có thể thực hiện các tác vụ như tải dữ liệu lên server, đồng bộ dữ liệu từ server từ xa, làm mới dữ liệu định kỳ, dọn dẹp database và hơn thế nữa, đồng thời đảm bảo thực thi nền hiệu quả và tiết kiệm pin. Nó che giấu sự phức tạp của việc xử lý các phiên bản Android khác nhau và các tính năng tiết kiệm năng lượng, khiến nó trở thành một giải pháp mạnh mẽ và được khuyến nghị cho xử lý nền trong các ứng dụng Android hiện đại. Đầu tiên, mở file build.gradle của ứng dụng và thêm dependency Guava vào khối dependencies: 12implementation \"androidx.work:work-runtime:2.8.1\"implementation 'com.google.guava:guava:30.1-android' Tiếp theo, tạo một class để xử lý tác vụ sẽ được thực thi và sử dụng nó 123456789101112131415161718192021222324class SyncDataWorker extends Worker { public SyncDataWorker( @NonNull Context context, @NonNull WorkerParameters params) { super(context, params); } @Override public Result doWork() { // Do your task return Result.success(); }}// somewhere in your codePeriodicWorkRequest periodicWorkRequest = new PeriodicWorkRequest.Builder( SyncDataWorker.class, TIME_IN_MILLISECONDS, TimeUnit.MILLISECONDS) .setConstraints(new Constraints.Builder() .setRequiredNetworkType(NetworkType.CONNECTED) // Set it if your task requires network to be completed .build()) .build();WorkManager.getInstance(context).enqueue(periodicWorkRequest); Khi sử dụng WorkManager và màn hình thiết bị tắt, có một số giới hạn và lưu ý cần nhớ: Thực thi bị trì hoãn: Khi màn hình thiết bị tắt, Android có thể vào các trạng thái tiết kiệm năng lượng như Doze mode hoặc app standby mode để tiết kiệm pin. Trong các trạng thái này, các tác vụ nền, bao gồm những tác vụ được lên lịch bởi WorkManager, có thể bị trì hoãn. WorkManager cố gắng thực thi các tác vụ trong các cửa sổ bảo trì, nhưng vẫn có thể có sự chậm trễ trong việc thực thi tác vụ. Hạn chế truy cập mạng: Android có thể hạn chế truy cập mạng cho các tác vụ nền khi màn hình tắt. Nếu tác vụ của bạn phụ thuộc vào kết nối mạng, nó có thể gặp sự chậm trễ hoặc có quyền truy cập hạn chế vào tài nguyên mạng. Bạn có thể sử dụng các constraint như setRequiredNetworkType() trong WorkManager để chỉ định yêu cầu mạng cho các tác vụ của bạn. Giới hạn thực thi nền: Bắt đầu từ Android 8.0 (API level 26), Android đã giới thiệu các giới hạn thực thi nền nghiêm ngặt hơn. Các ứng dụng nền, bao gồm những ứng dụng chạy các tác vụ nền được lên lịch bởi WorkManager, có hạn chế về khả năng chạy các tác vụ tốn CPU hoặc truy cập một số tài nguyên nhất định. Mặc dù WorkManager được thiết kế để xử lý các giới hạn này và đảm bảo thực thi tác vụ hiệu quả, nó vẫn có thể phải tuân theo các hạn chế do hệ điều hành áp đặt. Hành vi theo thiết bị cụ thể: Các thiết bị Android và nhà sản xuất khác nhau có thể có các tính năng tiết kiệm năng lượng hoặc tối ưu hóa riêng có thể ảnh hưởng đến việc thực thi tác vụ nền khi màn hình tắt. Các tối ưu hóa này có thể khác nhau, dẫn đến các hành vi và giới hạn khác nhau. Điều quan trọng là kiểm thử ứng dụng của bạn trên nhiều thiết bị khác nhau để đảm bảo hành vi nhất quán. Để tối ưu hóa việc thực thi các tác vụ nền khi màn hình thiết bị tắt, hãy xem xét các điều sau: Sử dụng các constraint phù hợp: Chỉ định các constraint như yêu cầu mạng (setRequiredNetworkType()), trạng thái sạc (setRequiresCharging()), và hơn thế nữa để đảm bảo các tác vụ được thực thi trong các điều kiện mong muốn. Tôn trọng tối ưu hóa pin: Khuyến khích người dùng loại trừ ứng dụng của bạn khỏi tối ưu hóa pin hoặc đưa vào whitelist trong bất kỳ cài đặt tiết kiệm năng lượng nào trên thiết bị của họ. Điều này có thể giúp đảm bảo rằng ứng dụng của bạn và các tác vụ nền của nó không bị hạn chế quá mức. Tối ưu hóa thực thi tác vụ: Cấu trúc các tác vụ của bạn để hiệu quả nhất có thể, giảm thiểu tác động lên tuổi thọ pin và tài nguyên. Chia nhỏ các tác vụ lớn thành các đơn vị nhỏ hơn, dễ quản lý và cân nhắc sử dụng ListenableWorker hoặc CoroutineWorker của WorkManager để có hiệu suất tốt hơn. Bằng cách xem xét các yếu tố này và thiết kế các tác vụ nền và chiến lược lên lịch của bạn cho phù hợp, bạn có thể tối ưu hóa việc thực thi của chúng ngay cả khi màn hình thiết bị tắt và làm việc trong các giới hạn do hệ thống Android áp đặt. Nên sử dụng cái nào?Việc lựa chọn giữa AlarmManager và WorkManager phụ thuộc vào trường hợp sử dụng và yêu cầu cụ thể của bạn. Dưới đây là một số yếu tố cần xem xét khi quyết định cái nào phù hợp hơn với nhu cầu của bạn: Thời gian và Tính linh hoạt AlarmManager: Nó cung cấp thời gian chính xác để thực thi các tác vụ vào thời điểm hoặc khoảng thời gian cụ thể, ngay cả khi ứng dụng không đang chạy. AlarmManager phù hợp cho các tác vụ yêu cầu thời gian quan trọng đòi hỏi thời gian thực thi chính xác. WorkManager: Nó cung cấp nhiều sự linh hoạt và tối ưu hóa hơn cho các tác vụ nền. WorkManager xem xét các yếu tố như tối ưu hóa pin, khả năng mạng và trạng thái rảnh của thiết bị để thực thi các tác vụ một cách hiệu quả. Nó phù hợp cho các tác vụ không yêu cầu độ chính xác thời gian nghiêm ngặt, chẳng hạn như đồng bộ dữ liệu hoặc cập nhật định kỳ có thể chấp nhận một số độ trễ. Hiệu quả năng lượng và Tối ưu hóa pin AlarmManager: Nó cho phép thực thi ngay lập tức hơn và có thể đánh thức thiết bị từ chế độ ngủ. Tuy nhiên, nếu sử dụng không đúng cách, nó có thể ảnh hưởng đáng kể đến tuổi thọ pin. WorkManager: Nó tận dụng các tối ưu hóa hệ thống để giảm thiểu sử dụng pin. WorkManager gom nhóm các tác vụ, tôn trọng trạng thái rảnh của thiết bị và thích ứng với các tính năng tiết kiệm năng lượng. Nó cung cấp cách tiếp cận hiệu quả năng lượng hơn để thực thi các tác vụ nền. Tương thích và Hỗ trợ ngược AlarmManager: Nó đã có sẵn từ các phiên bản đầu tiên của Android và cung cấp khả năng tương thích ngược với các phiên bản Android cũ hơn. Nó có thể được sử dụng trên nhiều loại thiết bị Android. WorkManager: Nó là một phần của thư viện Android Jetpack và tương thích ngược đến Android API level 14 (Ice Cream Sandwich). WorkManager được thiết kế để hoạt động nhất quán trên các phiên bản và thiết bị Android khác nhau. Xử lý lỗi và Cơ chế thử lại AlarmManager: Nó không cung cấp các cơ chế tích hợp để xử lý lỗi tác vụ hoặc thử lại tự động. WorkManager: WorkManager có thể tự động thử lại các tác vụ thất bại với các constraint có thể cấu hình. Nói chung, nếu bạn cần thời gian chính xác, thực thi ngay lập tức hoặc khả năng đánh thức thiết bị từ chế độ ngủ, AlarmManager có thể là lựa chọn tốt hơn. Mặt khác, nếu bạn yêu cầu hiệu quả năng lượng, lên lịch tác vụ linh hoạt, xử lý lỗi và tương thích trên các phiên bản Android khác nhau, WorkManager là một lựa chọn phù hợp hơn.Trong một số trường hợp, bạn thậm chí có thể sử dụng cả AlarmManager và WorkManager cùng nhau, tùy thuộc vào yêu cầu cụ thể của ứng dụng. Ví dụ, bạn có thể sử dụng AlarmManager cho các tác vụ nhạy cảm về thời gian và WorkManager cho xử lý nền hiệu quả năng lượng. Kết luậnTóm lại, trong khi sử dụng Timer có thể dẫn đến hành vi không thể đoán trước khi màn hình tắt do thực thi đơn luồng và thiếu tối ưu hóa tiết kiệm năng lượng, WorkManager và AlarmManager có thể xử lý việc thực thi tác vụ hiệu quả và đáng tin cậy hơn, ngay cả khi màn hình tắt hoặc thiết bị ở trạng thái tiết kiệm năng lượng. Để lên lịch các tác vụ nền, thường được khuyến nghị sử dụng WorkManager hoặc AlarmManager hơn là sử dụng Timer.","link":"/vi/posts/Schedule-task-in-background-from-foreground-service/index.html"},{"title":"Đưa ứng dụng iOS của bạn lên Store","text":"Gửi ứng dụng của bạn lên Apple Store không đơn giản như việc nhấn một nút “thần kỳ” rồi mọi thứ tự động hoàn thành, nhưng cũng không phức tạp như bạn nghĩ. Có thể đây là lần đầu tiên bạn phát hành ứng dụng đầu tiên của mình, và bạn chưa có cơ hội làm quen với quy trình gửi ứng dụng trước đó. Hướng dẫn từng bước này sẽ chỉ cho bạn quy trình chính để gửi ứng dụng từ con số không đến thành công. Lưu ý rằng bạn cần có Tài khoản Developer trả phí để hoàn thành việc này.Bắt đầu thôi! Certificates, app IDs và provisioning profilesĐể gửi ứng dụng của bạn lên App Store, bạn cần hiểu certificates, app IDs và provisioning profiles là gì. Về cơ bản, một distribution certificate xác định team/tổ chức của bạn trong một distribution provisioning profile và cho phép bạn gửi ứng dụng lên Apple App Store. Hình ảnh sau đây mô tả mối quan hệ giữa chúng. Tạo Distribution Certificate Trên Mac của bạn, mở ứng dụng Key Chain Access. Vào Certificate Assistant &gt; Request a Certificate From a Certificate Authority. Điền email của bạn vào ô email. Keychain Access sẽ tạo một private key, được lưu trữ trong keychain, và một file .certSigningRequest sẽ được tải lên Apple. Apple sẽ cấp một certificate cho bạn dựa trên file .certSigningRequest. Certificate chứa public key. Sau đó, bạn có thể tải file về và mở nó. Public key sẽ được đẩy vào Keychain và ghép cặp với private key để tạo thành “Code Signing Identity”. Để bạn biết CSR là gì CSR hay Certificate Signing Request là một khối văn bản được mã hóa được cung cấp cho Certificate Authority khi đăng ký SSL Certificate. Nó thường được tạo trên server nơi certificate sẽ được cài đặt và chứa thông tin sẽ được đưa vào certificate như tên tổ chức, common name (tên miền), địa phương và quốc gia. Nó cũng chứa public key sẽ được đưa vào certificate. Private key thường được tạo cùng lúc khi bạn tạo CSR, tạo thành một cặp key. Sau khi có file .certSigningRequest, vào trang Apple developer, đăng nhập vào Apple Account của bạn &gt; Certificates, Identifiers &amp; Profiles &gt; Nhấn nút “+” để tạo certification mới &gt; Nhớ chọn tùy chọn “iOS Distribution (App Store and Ad Hoc)”. Tiếp theo, chọn để tải lên file .certSigningRequest bạn vừa tạo ở bước 3. Cuối cùng, bạn có thể tải file Certificate về Mac của mình, mở nó và key sẽ được đẩy vào keychain tự động. Đó là tất cả cho việc tạo Distribution Certificate, hãy chuyển sang bước tiếp theo, tạo app id của bạn. Tạo App Id Nhấn nút “+” trên trang “All Identifiers” Điền thông tin ứng dụng của bạn, bao gồm bundle Id. Xin lưu ý rằng bundle id này phải khớp với bundle id trong XCode của bạn. Bạn cũng có thể sử dụng wildcard pattern để định nghĩa bundle Id cho nhiều app Ids. Tạo Provisioning Profile Nhấn nút “+” trên trang “Profiles”, sau đó chọn tùy chọn “App Store”. Chọn app Id mà bạn vừa tạo ở bước trước, Tạo App Id. Chọn Certificate mà bạn vừa tạo ở bước trước, Tạo Distribution Certificate Bây giờ bạn có một profile liên kết Certificate và app Ids của bạn. Tải file này về và mở nó. Provisioning Profiles sẽ được đẩy vào XCode tự động. Tải lênĐã đến lúc tải ứng dụng của bạn lên Store.Quay lại project của bạn, từ Top Tool Bar &gt; Product &gt; Archive, XCode sẽ rebuild project của bạn. Sau đó, XCode Organizer sẽ khởi chạy và hiển thị tất cả các archives bạn đã tạo trong quá khứ.Chọn build hiện tại, sau đó click vào “Distribute App” ở bảng bên phải. Cửa sổ tiếp theo cho phép bạn chọn credentials bao gồm Distribution Certificate và Provisioning Profiles bạn đã tạo ở phần đầu. Cuối cùng, nhấn nút upload, XCode sẽ làm phần còn lại cho bạn. Một email sẽ được gửi để thông báo cho bạn ngay sau khi Apple hoàn tất quá trình xử lý, thường mất vài phút.Ứng dụng của bạn đã được tải lên thành công vào iTunes Profile của bạn, hãy đến bước cuối cùng. Gửi duyệtĐiều hướng đến App Store Connect, chọn “My Apps”. bạn sẽ thấy ứng dụng của mình xuất hiện trên trang. Bạn cần chuẩn bị các thông tin sau để điền vào các trang này: Tên ứng dụng, Privacy Policy URL, Age Rating, Category. Screenshot ở các kích thước khác nhau: Điều này có thể tốn nhiều thời gian nhất của bạn, screenshots của bạn cần đáp ứng yêu cầu của Apple tại Screenshot specifications. Lưu ý rằng người dùng sẽ thấy các screenshots này liên quan đến thiết bị hiện tại của họ, vì vậy hãy đảm bảo ảnh của bạn đẹp và hấp dẫn nhất có thể. Fastlane cũng hỗ trợ chụp screenshots tự động, bạn có thể tìm tài liệu nếu bạn quan tâm. Fastlane tools có thể tự động hóa quy trình này giúp nó nhanh chóng và nhất quán trong khi mang lại kết quả đẹp mắt! Mô tả version, keywords, support URL. Nếu ứng dụng của bạn yêu cầu đăng nhập, điền thông tin tài khoản với username và password. Ghi chú ứng dụng: Một số ghi chú quan trọng bạn muốn gửi cho người review để đảm bảo nó hoạt động đúng. (ví dụ: chúng tôi khuyên dùng dịch vụ với kết nối Wifi để có chất lượng tốt nhất) Tệp đính kèm: Tốt nhất nên có một video demo ngắn về ứng dụng của bạn. Thông tin liên hệ: Nếu có bất kỳ vấn đề gì, Apple sẽ liên hệ với bạn qua thông tin này. Bạn đã hoàn tất. Bây giờ nhấn nút “Submit” để bắt đầu quá trình review. Quá trình reviewQuá trình review của bạn mất một thời gian để hoàn thành, có thể từ vài ngày đến vài tuần tùy thuộc vào danh mục ứng dụng, tính năng và… người review.Nếu ứng dụng của bạn vi phạm các quy tắc của Apple như sử dụng private APIs không được phê duyệt, thiếu mô tả quyền, crash hoặc hiệu suất kém, nó sẽ bị từ chối. Cuối cùng, chúng ta phải chấp nhận rằng Apple có quyền quyết định cuối cùng về việc cho phép bất cứ thứ gì vào App Store. Chỉ vì bạn nghĩ ứng dụng của mình tuyệt vời không có nghĩa là Apple sẽ cho phép nó vào App Store. Bản thân tôi đã trải nghiệm quy trình nghiêm ngặt-ngẫu nhiên-cảm xúc này khi gửi ứng dụng của mình. Lần gửi đầu tiên diễn ra suôn sẻ không có rắc rối gì. Lần thứ hai, chỉ cập nhật một số UI, bị từ chối vì Apple cho rằng ứng dụng của tôi chứa tính năng không được phép trong App Store. Với nhiều email và cuộc gọi điện thoại, cuối cùng tôi phải xóa tính năng này khỏi ứng dụng của mình. (?!) Lời kếtTrong bài viết này, tôi đã hướng dẫn bạn cách gửi ứng dụng lên Store một cách rất chi tiết. Hy vọng bài viết này tiết kiệm thời gian của bạn trong việc đưa các ứng dụng tuyệt vời đến người dùng. Không thể chờ đợi được nữa.Trong bài viết tiếp theo, tôi sẽ chỉ cho bạn các bước để tải ứng dụng lên Google Play.Happy coding.","link":"/vi/posts/Shipping-your-iOS-app-to-Store/index.html"},{"title":"Hội nghị Swift Summit tại San Francisco 2017","text":"Hội nghị Swift Summit 2017 được tổ chức tại Palace Of Fine Arts, San Francisco, một trong mười cung điện nằm ở trung tâm của Triển lãm Panama-Pacific. Tại hội nghị, các lập trình viên Swift từ khắp nơi trên thế giới đã chia sẻ kiến thức mới, công cụ và ý tưởng về nền tảng iOS và ngôn ngữ Swift. Hình 1. Tôi đã có mặt tại hội nghị Swift Summit 2017 Hội nghị tổ chức hơn 20 phiên kỹ thuật và phòng thí nghiệm dành cho lập trình viên. Đặc biệt, có một khu triển lãm với các công ty công nghệ hàng đầu như Facebook, IBM, Lyft, Capital One, v.v. Tại đó, tôi đã gặp gỡ các lập trình viên khác, thảo luận về các công nghệ mới và nhận quà tặng từ các nhà tài trợ. Hình 2. Túi của tôi (và một túi khác của bạn tôi) đầy ắp quà tặng từ hội nghị :)). Mười ngày tận hưởng nước Mỹ, hai ngày tận hưởng hội nghịVì đây là lần đầu tiên tôi đến San Francisco, tôi không quen với thời tiết ở đây. Tôi nhớ rằng vào buổi sáng đầu tiên khi tôi đến Palace of Fine Arts, thời tiết lúc đó là 13 độ C. Tôi lạnh cóng!Khi bước vào hội trường chính, tôi cảm thấy dễ chịu hơn nhờ ánh sáng ấm áp. Ban tổ chức đã chuẩn bị rất nhiều đồ ăn và trái cây trên một chiếc bàn ở giữa hội trường. Tôi và bạn bè đi quanh thăm các công ty công nghệ, thử nghiệm các công nghệ mới của họ và nhận quà tặng.Quy mô của hội nghị không như tôi mong đợi. Nó khá nhỏ, khoảng một trăm người, tôi đoán vậy. Nhưng ban tổ chức và các diễn giả đã chuẩn bị nội dung rất tốt. Dưới đây là một số phiên chính mà tôi đánh giá cao nhất trong hai ngày hội nghị. Lập trình bất đồng bộCác phương thức bất đồng bộ (gọi tắt là Async) là các phương thức không trả về kết quả ngay lập tức như hầu hết các phương thức, các phương thức async cần một khoảng thời gian để tạo ra kết quả.Trước khi tham dự phiên này, tôi thường sử dụng callback để xử lý các phương thức bất đồng bộ như quét thiết bị bluetooth hoặc truy xuất tài nguyên từ internet. Thực tế, callback là một kỹ thuật lập trình tồi. Callback sẽ làm code của chúng ta khó đọc, khó debug và mất nhiều thời gian hơn để bảo trì sau này. Cuối cùng, code của chúng ta sẽ trở thành thứ mà chúng ta gọi là callback hell.Trong phiên này, diễn giả đã giới thiệu một framework giúp chúng ta đơn giản hóa lập trình bất đồng bộ, PromiseKit. Nó dễ học, dễ sử dụng và tạo ra code rõ ràng, dễ đọc hơn.Để biết thêm chi tiết về phiên này, vui lòng tham khảo bài viết khác của tôi: Lập trình bất đồng bộ trong Swift BuglifeBugLife là một framework mã nguồn mở giúp người dùng của chúng ta gửi báo cáo lỗi từ điện thoại của họ, và nó ngay lập tức hiển thị trên bảng điều khiển vấn đề của chúng ta. Lợi ích tốt nhất mà tôi thấy khi sử dụng BugLife là nó miễn phí và dễ dàng tích hợp vào ứng dụng của chúng ta mà không cần tốn nhiều công sức.Để biết thêm chi tiết về cách sử dụng framework này, vui lòng tham khảo bài viết khác của tôi: BugLife trong thực tế MixpanelMixpanel là một thư viện giúp chúng ta theo dõi hành vi người dùng và các sự kiện khác xảy ra trên ứng dụng của chúng ta. Nhiều công ty công nghệ sử dụng Mixpanel để phân tích dữ liệu của họ để hiểu rõ hơn về người dùng. Từ kết quả, họ có thể đưa ra quyết định để cải thiện ứng dụng nhằm làm hài lòng người dùng. Hình 3. Các lập trình viên đang tham dự một phòng thí nghiệm. Swift trên Server: Tình hình hiện tạiPhiên này mô tả tình trạng hiện tại của Swift trên server và đưa ra một số dự đoán về những gì năm tới sẽ mang lại. Đáng tiếc, tôi đã ngủ gật trong phiên này nên không nắm bắt được nhiều ý tưởng từ diễn giả.Để biết thêm chi tiết về cách sử dụng framework này, vui lòng tham khảo bài viết khác của tôi: Swift phía server Kiến trúc iOS trong bối cảnhTại sao chúng ta phải quan tâm đến việc chọn kiến trúc?Ngày nay, chúng ta có rất nhiều kiến trúc phần mềm để lựa chọn, nếu chúng ta không chọn một kiến trúc phù hợp cho ứng dụng của mình, một ngày nào đó chúng ta sẽ thấy mình không thể tìm và sửa bất kỳ lỗi nào trong ứng dụng. Trong phiên này, diễn giả đã thảo luận về một số kiến trúc iOS như MVC, MVP, MVVM, VIPER, v.v. Với nhiều năm kinh nghiệm làm việc về kiến trúc phần mềm, ông đã đánh giá cả ưu điểm và nhược điểm của từng loại.Đối với tôi, phiên này khá khó để nắm bắt tất cả ý tưởng của diễn giả vì tôi không có nhiều kinh nghiệm trong việc thiết kế kiến trúc phần mềm. Sau đó, tôi phải dành thêm thời gian để đọc các tài liệu và blog kỹ thuật khác để hiểu những gì ông nói. Hình 4. Cảnh xung quanh hội nghị Sau cùng …Cuối ngày thứ hai, chúng tôi có một bữa tiệc Halloween trong hội trường của cung điện. Đây là lần đầu tiên tôi tham dự một hội nghị công nghệ tại một quốc gia dẫn đầu về công nghệ, nước Mỹ. Sau hai ngày tham dự hội nghị, tôi đã cập nhật một số công nghệ mới và cũng áp dụng một số công nghệ vào các dự án tại công ty của tôi. Thành thật mà nói, có một số phiên hơi nhàm chán và chỉ mang tính giới thiệu. Ngoài ra, jet lag khiến tôi cảm thấy mệt mỏi nên tôi đã không tập trung hoàn toàn vào một số phiên. Đó là một điều đáng tiếc.Cuối cùng, đây vẫn là chuyến đi tuyệt vời nhất! Hình 5. Một chuyến đi không thể nào quên","link":"/vi/posts/Swift-Summit-conference-in-San-Francisco-2017/index.html"},{"title":"WWDC 2020 - Những lý do hàng đầu khiến ứng dụng bị kill ở chế độ nền","text":"Bạn có bao giờ thắc mắc tại sao ứng dụng của bạn bị hệ thống kill khi nó chuyển sang chế độ nền? Bài viết này sẽ tóm tắt những lý do hàng đầu được Apple giới thiệu trong WWDC 2020, và những gì bạn có thể làm để ngăn ứng dụng của mình bị kill ở chế độ nền. Bằng cách áp dụng những mẹo này, chúng ta có thể cải thiện trải nghiệm ứng dụng vì ứng dụng của bạn không phải khởi động lại từ đầu.Hãy bắt đầu! Những lý do hàng đầuDưới đây mô tả 6 lý do hàng đầu khiến ứng dụng của bạn bị kill khi nó ở chế độ nền: Crash: Segmentation fault, illegal instruction, assert và uncaught exception. Watchdog:Treo lâu trong quá trình chuyển đổi trạng thái ứng dụng như deadlock, vòng lặp vô hạn hoặc các tác vụ đồng bộ không kết thúc trên main thread. Trong khoảng 20 giây, ứng dụng của bạn phải chuyển từ trạng thái này sang trạng thái khác. Nếu không, nó sẽ bị kill. 123+ application(_:didFinishLaunchingWithOptions)+ applicationDidEnterBackground(_:)+ applicationWillEnterForeground(_:) Sử dụng CPU quá mức:Tải CPU cao liên tục ở chế độ nền. Nếu ứng dụng của bạn thực sự cần thực hiện các công việc nặng ở chế độ nền, bạn nên cân nhắc chuyển tác vụ vào background processing task, cho phép ứng dụng của bạn chạy trong vài phút khi đang sạc mà không có giới hạn tài nguyên CPU. Vượt quá giới hạn bộ nhớ:Ứng dụng của bạn đang sử dụng quá nhiều bộ nhớ (giống nhau ở cả chế độ nền và foreground). Hãy nhớ rằng giới hạn khác nhau tùy theo thiết bị. Trước iPhone6s, 200M là giới hạn bộ nhớ (Thiết bị càng cũ, giới hạn càng nhỏ). Memory pressure exit (hay còn gọi là Jetsam):Điều này xảy ra khi hệ thống cần giải phóng bộ nhớ của các ứng dụng nền cho các ứng dụng foreground (và các ứng dụng đang chạy khác như ứng dụng nhạc hoặc điều hướng). Để ngăn chặn điều này, hãy cố gắng giảm bộ nhớ càng nhỏ càng tốt, ít hơn 50M (ví dụ: xóa các image view). Tuy nhiên, chúng ta không thể loại bỏ hoàn toàn rủi ro jetsam. Lời khuyên tốt nhất để khắc phục là tận dụng State Restoration có sẵn của UI để khôi phục trạng thái ứng dụng ngay trước khi nó bị kill ở chế độ nền. Video sau đây mô tả cách Jetsam xảy ra trên các thiết bị iOS. Giả sử chúng ta mở ứng dụng Amazon để mua sắm, sau đó chọn một mặt hàng yêu thích để xem chi tiết. Giả sử chúng ta phải rời khỏi ứng dụng một lúc để vào chế độ nền, sau đó bắt đầu mở các ứng dụng khác (Google Maps, Music, Photos, Spotify, v.v.). Tại một thời điểm nào đó, chúng ta mở lại ứng dụng Amazon. Như chúng ta thấy, ứng dụng khởi động lại từ đầu. Điều này là do ứng dụng đã bị hệ thống kết thúc. Rõ ràng, ứng dụng Amazon không làm gì sai, chỉ là hệ thống cần giải phóng bộ nhớ cho các ứng dụng khác đang chạy ở foreground. Background task timeout:Lý do phổ biến cuối cùng là sử dụng background task không đúng cách. 12UIApplication.beginBackgroundTask(exprirationHandler:)UIApplication.endBackgroundTask(_:) Khi ứng dụng của bạn chuyển từ foreground sang background, và bạn muốn hoàn thành một số tác vụ quan trọng, iOS cung cấp cho bạn thêm thời gian chạy (chỉ vài giây) bằng cách gọi phương thức UIApplication.beginBackgroundTask. Khi tác vụ hoàn thành, hãy nhớ gọi UIApplication.endBackgroundTask để thông báo cho hệ thống rằng tác vụ đã xong. Nếu bạn quên gọi endBackgroundTask một cách rõ ràng, timeout sẽ được kích hoạt 30 giây sau khi tạm dừng ứng dụng, và việc kết thúc ứng dụng sẽ xảy ra. Vì vậy, bạn nên xử lý cẩn thận các background task và không bắt đầu bất kỳ công việc tốn kém nào khi ứng dụng của bạn vào chế độ nền vì chúng ta chỉ có vài giây thời gian chạy. Trong khi debug, XCode sẽ tạo ra một thông báo log để thông báo nếu có một tác vụ đã được giữ quá lâu mà không kết thúc. Khi thấy thông báo này, bạn nên kiểm tra để xem có vấn đề gì với các lệnh gọi background task. 12345678Background task still not ended after expiration handlers were called: &lt;_UIBackgroundTaskInfo: 0x28190d140&gt;: taskID = 8, taskName = Called by AppGetKilled,from $s12AppGetKilled13SceneDelegateC23sceneDidEnterBackgroundyySo7UISceneCF, creationTime = 70784 (elapsed = 26).This app will likely be terminated by the system. Call UIApplication.endBackgroundTask(_:) to avoid this.Background Task 5 (\"Called by AppGetKilled, from $s12AppGetKilled13SceneDelegateC23sceneDidEnterBackgroundyySo7UISceneCF\"),was created over 30 seconds ago.In applications running in the background, this creates a risk of termination.Remember to call UIApplication.endBackgroundTask(_:) for your task in a timely manner to avoid this. Kết luậnTrong bài viết này, tôi đã tóm tắt 6 lý do hàng đầu khiến ứng dụng có thể bị kết thúc ở chế độ nền, cách chúng ta có thể làm để ngăn chặn các vấn đề, và cách khôi phục ứng dụng một cách mượt mà từ các vấn đề không thể đoán trước như Jetsam.Bạn có thể tìm tài liệu và video đầy đủ tại WWDC 2020 - Why is my app getting killed","link":"/vi/posts/WWDC-2020-Top-reasons-why-app-get-killed-in-background/index.html"},{"title":"Web Bluetooth","text":"Bạn đã bao giờ muốn tạo một ứng dụng web cho phép người dùng giao tiếp với thiết bị của bạn bằng Bluetooth chưa? Cho đến khi Web Bluetooth được giới thiệu, điều này chỉ có thể thực hiện được thông qua các ứng dụng di động native. Tuy nhiên, với sự ra đời của Web Bluetooth, bạn giờ đây có thể biến ý tưởng của mình thành hiện thực.Web Bluetooth là một công nghệ mang tính đột phá cho phép các nhà phát triển web kết nối ứng dụng của họ trực tiếp với các thiết bị Bluetooth, mở ra một loạt các khả năng cho IoT, thiết bị đeo, và các thiết bị hỗ trợ Bluetooth khác. Bằng cách tận dụng sức mạnh của Web Bluetooth, bạn có thể tạo các ứng dụng web có thể giao tiếp với thiết bị mà không cần một ứng dụng native riêng biệt.Vì vậy, nếu bạn đã mơ ước tạo một ứng dụng web có thể tương tác với các thiết bị Bluetooth, bây giờ là lúc để khám phá các khả năng của Web Bluetooth và nâng cao kỹ năng phát triển của bạn lên tầm cao mới. Web Bluetooth là gì?Web Bluetooth là một tập hợp các API cung cấp khả năng kết nối và thực hiện các hành động như đọc giá trị, ghi dữ liệu, lắng nghe notification, v.v. với các peripheral BLE sử dụng Generic Attribute Profile (GATT). Điều này có thể cho phép nhiều trường hợp sử dụng, chẳng hạn như điều khiển thiết bị IoT, đồng bộ dữ liệu thể dục từ đồng hồ thông minh, hoặc truyền dữ liệu giữa điện thoại thông minh và máy tính.Web Bluetooth được hỗ trợ bởi một số trình duyệt web lớn, bao gồm Chrome, Firefox và Opera, và nó cũng bao gồm một tập hợp các giao thức tiêu chuẩn công nghiệp cho giao tiếp an toàn và hiệu quả. Tuy nhiên, điều quan trọng cần lưu ý là không phải tất cả các thiết bị Bluetooth đều tương thích với Web Bluetooth, vì sự hỗ trợ cho công nghệ này khác nhau giữa các thiết bị và nhà sản xuất khác nhau. Ưu điểm của Web Bluetooth Đa nền tảng: Web Bluetooth cho phép các nhà phát triển tạo các ứng dụng web có thể giao tiếp với các thiết bị Bluetooth trên nhiều nền tảng, bao gồm cả máy tính để bàn và thiết bị di động. Dễ sử dụng: Web Bluetooth đơn giản hóa quy trình kết nối với các thiết bị Bluetooth, giảm nhu cầu cho các ứng dụng native hoặc phần mềm phức tạp. Khả năng tiếp cận: Web Bluetooth cho phép các nhà phát triển web tạo các ứng dụng có thể giao tiếp với thiết bị Bluetooth mà không yêu cầu người dùng cài đặt các ứng dụng hoặc plugin riêng biệt. Linh hoạt: Web Bluetooth có thể được sử dụng để kết nối với nhiều loại thiết bị Bluetooth, bao gồm thiết bị IoT, thiết bị đeo và thiết bị nhà thông minh. Nhược điểm của Web Bluetooth Hỗ trợ trình duyệt: Trong khi hầu hết các trình duyệt hiện đại hỗ trợ Web Bluetooth, một số trình duyệt cũ hơn có thể không tương thích. Bảo mật: Web Bluetooth có thể gây ra rủi ro bảo mật nếu không được triển khai đúng cách. Ví dụ, nếu một ứng dụng có quyền truy cập vào thiết bị Bluetooth của người dùng, nó có thể truy cập các thông tin nhạy cảm khác trên thiết bị. Chức năng hạn chế: Web Bluetooth có thể không cung cấp cùng mức độ chức năng như các ứng dụng Bluetooth native. Điều này có thể hạn chế các loại ứng dụng có thể được phát triển bằng công nghệ này. Tuổi thọ pin: Bluetooth có thể là một công nghệ tiêu thụ năng lượng cao, có thể làm cạn tuổi thọ pin của thiết bị di động. Các nhà phát triển cần lưu ý điều này khi thiết kế các ứng dụng dựa vào kết nối Bluetooth. Các API được hỗ trợCác API được Web Bluetooth hỗ trợ tương tự như những API có sẵn trên iOS và Android, điều này làm cho việc làm việc trở nên đơn giản cho các nhà phát triển đã quen thuộc với công nghệ Bluetooth trên thiết bị di động.Bạn có thể xem lại luồng để thiết lập kết nối với peripheral tại Play Central And Peripheral Roles With CoreBluetooth navigator.bluetooth.requestDevice(): API này được sử dụng để yêu cầu quyền truy cập vào thiết bị BLE gần đó. Khi người dùng nhấp vào nút “Connect” trên ứng dụng web của bạn, API này được gọi để quét các thiết bị khả dụng và hiển thị hộp thoại cho người dùng. 123456789101112131415161718192021222324/**// Discovery options match any devices advertising:// . The standard heart rate service. OR// . Service uuid0, and devices with name \"ExampleName1\", and devices with name starting with \"Prefix1\" OR// . Both service uuid1 and uuid2. OR// . Devices with name \"ExampleName2\". OR// . Devices with name starting with \"Prefix2\". OR//// And enables access to the battery service if devices// include it, even if devices do not advertise that service.**/const device = await navigator.bluetooth.requestDevice({ acceptAllDevices: true, filters: [ { services: [\"heart_rate\"] }, { services: [uuid0], name: \"ExampleName1\", namePrefix: \"Prefix1\" }, { services: [uuid1, uuid2] }, { name: \"ExampleName2\" }, { namePrefix: \"Prefix2\" } ], optionalServices: [ \"battery_service\", ],}); BluetoothDevice.gatt.connect(): API này được sử dụng để thiết lập kết nối với GATT server trên thiết bị BLE đã chọn. Khi kết nối được thiết lập, ứng dụng web của bạn có thể tương tác với các service và characteristic của thiết bị. 1const server = await device.gatt.connect(); BluetoothDevice.gatt.disconnect(): API này được sử dụng để ngắt kết nối khỏi thiết bị BLE khi tương tác hoàn tất. 1const server = await device.gatt.disconnect(); Lấy service &amp; characteristic:BluetoothDevice.gatt.getPrimaryService(serviceUuid): API này được sử dụng để lấy primary service từ GATT server trên thiết bị BLE đã chọn.BluetoothRemoteGATTService.getCharacteristic(characteristicUuid): API này được sử dụng để lấy một characteristic cụ thể từ một service. 12345const services = await server.getPrimaryServices();services.forEach(async (e) =&gt; { const chars = await e.getCharacteristics(); // Doing your logic}); Đọc &amp; ghi giá trị:BluetoothRemoteGATTCharacteristic.readValue(): API này được sử dụng để đọc giá trị của một characteristic.BluetoothRemoteGATTCharacteristic.writeValue(value): API này được sử dụng để ghi một giá trị vào characteristic. 1234await char.writeValue( fromHexString(value));await char.readValue(); Lắng nghe sự kiện disconnected: Event listener này được kích hoạt khi thiết bị ngắt kết nối khỏi GATT server. 123device.addEventListener('gattserverdisconnected', () =&gt; { // Your callback}); Lắng nghe thay đổi giá trị: Event listener này được kích hoạt khi giá trị của một characteristic thay đổi. Điều này có thể được sử dụng để nhận cập nhật thời gian thực từ thiết bị. 123device.addEventListener('characteristicvaluechanged', () =&gt; { // Your callback}); Lắng nghe notification 12await char.stopNotifications();await char.startNotifications(); Một ví dụ đơn giảnTại Web Bluetooth example, tôi đã tạo một website đơn giản trình bày một tập hợp các API. Website demo này cung cấp cho các nhà phát triển một giao diện dễ sử dụng để kiểm tra và hiểu chức năng của các API. Bằng cách truy cập website demo này, các nhà phát triển có thể nhanh chóng có được cái nhìn sâu sắc về cách các API có thể được tích hợp vào ứng dụng của họ. Theo mặc định, web quét tất cả các thiết bị gần đó. Để quét các thiết bị được chỉ định với uuid được định nghĩa trước, chọn Filters và nhập service uuid của bạn vào hộp filter. Đây là giao diện sau khi kết nối đã được thiết lập thành công. Thêm các mẫuBạn có thể tìm thêm các ví dụ và ý tưởng qua video này WebBluetooth demos for Bluetooth.rocks from Niels Leenheer on Vimeo. Hạn chế Vì mục đích bảo mật, chúng ta không thể tự động quét và kết nối với một thiết bị được chỉ định. Người dùng quyết định liệu ứng dụng web có được phép kết nối hay không, và được phép kết nối với thiết bị nào. Kết nối HTTPS: Web Bluetooth yêu cầu kết nối HTTPS an toàn để hoạt động đúng cách. Điều này có nghĩa là ứng dụng web phải được host trên một server an toàn với chứng chỉ SSL hợp lệ. Nếu ứng dụng không được host trên server an toàn, người dùng sẽ không thể kết nối với các thiết bị Bluetooth. Nền tảng: Web Bluetooth được hỗ trợ trong Chrome trên desktop và mobile (Yêu cầu Android 6+, không hỗ trợ iOS), Opera, và một số phiên bản Microsoft Edge. Điều quan trọng cần lưu ý là Web Bluetooth có thể không hoạt động trên các trình duyệt cũ hơn hoặc lỗi thời. Tùy chỉnh: Thật không may, không thể tùy chỉnh hộp thoại quét của Web Bluetooth để hiển thị thông tin bổ sung ngoài các tùy chọn mặc định. Web Bluetooth API được thiết kế để cung cấp một giao diện đơn giản và nhất quán cho các nhà phát triển, và hộp thoại quét được cố ý giữ đơn giản để duy trì sự đơn giản này. Hiệu suất: Người ta công nhận rộng rãi rằng sự ổn định của kết nối Bluetooth trên các ứng dụng Android native thường không đáng tin cậy như trên iOS, và có thể bị ảnh hưởng bởi các yếu tố như model điện thoại, nhà sản xuất, và phiên bản Android đang sử dụng. Do đó, điều quan trọng cần lưu ý là Web Bluetooth không hoạt động tốt như các ứng dụng native, đặc biệt trên các thiết bị Android. Mẹo &amp; thực hành tốt nhấtDưới đây là một số mẹo và thực hành tốt nhất để tối ưu hóa hiệu suất của các ứng dụng Web Bluetooth: Giảm thiểu truyền dữ liệu: Giao tiếp Bluetooth chậm so với các kênh giao tiếp khác. Do đó, điều quan trọng là giảm thiểu lượng dữ liệu mà ứng dụng của bạn gửi và nhận qua Bluetooth. Ví dụ, bạn có thể giảm số lượng thao tác đọc và ghi và chỉ truyền dữ liệu cần thiết cho ứng dụng của bạn. Sử dụng notification thay vì polling: Thay vì liên tục polling giá trị của một characteristic, hãy sử dụng notification để nhận cập nhật khi giá trị thay đổi. Cách tiếp cận này có thể giảm số lượng thao tác đọc và cải thiện hiệu suất của ứng dụng của bạn. Ngắt kết nối khi không sử dụng: Ngắt kết nối khỏi GATT server khi bạn không chủ động giao tiếp với thiết bị. Điều này có thể giảm tiêu thụ năng lượng và cải thiện tuổi thọ pin của thiết bị. Sử dụng caching: Caching có thể được sử dụng để lưu trữ dữ liệu thường xuyên được ứng dụng của bạn truy cập. Điều này có thể giảm số lượng thao tác đọc và cải thiện hiệu suất của ứng dụng của bạn. Tối ưu hóa quy trình quét: Quét thiết bị có thể là một thao tác tốn nhiều tài nguyên. Do đó, điều quan trọng là tối ưu hóa quy trình quét bằng cách giảm thời gian quét và lọc kết quả để chỉ bao gồm các thiết bị liên quan. Kiểm tra ứng dụng của bạn trên các thiết bị khác nhau: Kiểm tra ứng dụng của bạn trên các thiết bị khác nhau để đảm bảo rằng nó hoạt động tốt trên các nền tảng và cấu hình phần cứng khác nhau. Suy nghĩ cuối cùngBất chấp những hạn chế này, Web Bluetooth vẫn là một công nghệ đầy hứa hẹn với nhiều trường hợp sử dụng tiềm năng. Các nhà phát triển quan tâm đến việc sử dụng Web Bluetooth nên xem xét cẩn thận những hạn chế này và thiết kế ứng dụng của họ cho phù hợp. Tài liệu tham khảo https://www.smashingmagazine.com/2019/02/introduction-to-webbluetooth/ https://googlechrome.github.io/samples/web-bluetooth/","link":"/vi/posts/Web-Bluetooth/index.html"},{"title":"Hai tuần tại Fossil Group ở Mỹ","text":"Tuần trước, tôi đã có cơ hội đến thăm nước Mỹ một lần nữa.","link":"/vi/posts/Two-weeks-at-Fossil-Group-in-the-US/index.html"},{"title":"Refactoring la gi?","text":"","link":"/vi/posts/What-is-refactoring/index.html"},{"title":"Co gi moi trong iPad OS 14?","text":"Xem #5 cap nhat hang dau trong iPadOS 14.","link":"/vi/posts/What-s-new-in-iPad-OS-14/index.html"},{"title":"Co gi moi cua App Clip tren iOS 17?","text":"Voi su ra mat cua iOS 17, cac ung dung gio day co kha nang khoi chay App Clips tu cac ung dung khac bang cach su dung invocation URL cua App Clip. Chuc nang nay mo ra nhieu kha nang khac nhau. Vi du, neu ban da phat trien mot bo cac ung dung, ban co the cho phep chung khoi chay App Clips tu nhau, cung cap cho nguoi dung quyen truy cap vao cac chuc nang cu the ma khong can cai dat ung dung day du. Hon nua, ung dung cua ban co the mo rong de cung cap khoi chay App Clips tu cac nha phat trien khac neu quy trinh lam viec cua ban lien quan den tuong tac voi nhung ung dung do. Cach tiep can hop tac nay nang cao su tien loi cho nguoi dung, cho phep ho di chuyen lien mach giua cac ung dung va tan dung cac chuc nang da dang. Su ket noi duoc thuc day boi tinh nang nay thuc day mot trai nghiem tich hop hon va lay nguoi dung lam trung tam trong he sinh thai iOS. https://developer.apple.com/videos/play/wwdc2023/10178/","link":"/vi/posts/What-s-new-of-Appclip-on-iOS-17/index.html"},{"title":"Xin Chào","text":"Chào mừng bạn đến với blog của Uy Nguyen!Tôi yêu thích viết lách, vì vậy tôi xây dựng trang web này để viết về bất kỳ điều gì trong cuộc sống, công việc hoặc bất cứ thứ gì liên quan đến Software Engineering. Bằng cách này, tôi có thể ghi nhớ các chủ đề này lâu hơn. Tôi cũng muốn chia sẻ những gì tôi đã học được với bất kỳ ai cần đến nó.Hãy thoải mái gửi email nếu bạn cần liên hệ với tôi. “Hãy là một Software Engineer, không phải một Coder.” - Uy Nguyen","link":"/vi/posts/hello-world/index.html"},{"title":"iOS 18: Có gì mới trong CoreBluetooth?","text":"AccessorySetupKit, được giới thiệu trong iOS 18, cách mạng hóa cách các phụ kiện Bluetooth và Wi-Fi của bên thứ ba tích hợp với các thiết bị iOS. Framework này mang lại trải nghiệm thiết lập liền mạch, tăng cường sự tiện lợi cho người dùng và mở rộng khả năng cho các nhà phát triển.Trong khi AccessorySetupKit hỗ trợ khám phá cho các thiết bị Bluetooth, Wi-Fi và Local Network, bài viết này sẽ tập trung cụ thể vào BLE (Bluetooth Low Energy). Quy trình thiết lập cho các thiết bị Wi-Fi và Local Network tuân theo cách tiếp cận tương tự. Các tính năng chínhDưới đây, chúng ta sẽ khám phá các chức năng chính làm cho AccessorySetupKit trở thành một thay đổi lớn cho việc quản lý phụ kiện. Quy trình Pairing được đơn giản hóa: Người dùng giờ đây có thể pair hoặc unpair phụ kiện và bật/tắt Bluetooth trực tiếp trong ứng dụng, loại bỏ nhu cầu phải vào cài đặt hệ thống. Cách tiếp cận được đơn giản hóa này nâng cao trải nghiệm người dùng và giảm thời gian thiết lập. Quản lý truy cập thống nhất: Khi một phụ kiện được pair, nó xuất hiện trong phần “Accessories” mới trong cài đặt Privacy. Tại đây, người dùng có thể quản lý quyền và xem các thiết bị đã kết nối, cung cấp một vị trí tập trung cho việc quản lý phụ kiện. Kiểm soát nâng cao cho nhà phát triển: Các nhà phát triển có thể định nghĩa các bộ lọc quét và cung cấp hình ảnh và tên tùy chỉnh cho thiết bị, đảm bảo trải nghiệm thiết lập có thương hiệu. Luồng thiết lậpBạn có thể tìm thấy dự án mẫu được cung cấp bởi Apple tại WWWDC24.Để mô phỏng các phụ kiện, tôi đã sử dụng CoreBluetooth và định nghĩa Bluetooth profile của mình với hai UUID khác nhau: 1FA2FD8A-17E0-4D3B-AF45-305DA6130E39 và 1FA2FD8A-17E0-4D3B-AF45-305DA6130E38, sau đó bắt đầu advertising chúng.Tiếp theo, bạn cần sửa đổi scanning UUID service trong file Info.plist của bạn để khớp với các Bluetooth profile của bạn. Điều này thông báo cho hệ thống về các loại phụ kiện mà ứng dụng của bạn hỗ trợ.Apple hỗ trợ các loại filter khác nhau, như: 123456789101112131415161718&lt;dict&gt; &lt;key&gt;NSAccessorySetupBluetoothCompanyIdentifiers&lt;/key&gt; &lt;array&gt; #Matches the key of an advertised manufacturing data field &lt;/array&gt; &lt;key&gt;NSAccessorySetupBluetoothServices&lt;/key&gt; &lt;array&gt; #Matches either an advertised service UUID field or the key (service UUID) of an advertised service data field &lt;/array&gt; &lt;key&gt;NSAccessorySetupBluetoothNames&lt;/key&gt; &lt;array&gt; #Match any substring within the advertised name &lt;/array&gt; &lt;key&gt;NSAccessorySetupKitSupports&lt;/key&gt; &lt;array&gt; &lt;string&gt;Bluetooth&lt;/string&gt; &lt;/array&gt;&lt;/dict&gt; Tiếp theo, tạo một ASAccessorySession. Session này rất cần thiết để quản lý quy trình thiết lập phụ kiện, cho phép bạn hiển thị accessory picker cho người dùng và xử lý các sự kiện liên quan đến phụ kiện một cách hiệu quả. 1private var session = ASAccessorySession() Sau đó, hiển thị Accessory Picker. Điều này cho phép bạn hiển thị giao diện picker, cho phép người dùng dễ dàng chọn và pair phụ kiện của họ với ứng dụng. 123456789101112131415161718192021222324252627let pickerDevice1: ASPickerDisplayItem = { let descriptor = ASDiscoveryDescriptor() descriptor.bluetoothServiceUUID = ### return ASPickerDisplayItem( name: ###, productImage: UIImage(named: ###)!, descriptor: descriptor )}()let pickerDevice2: ASPickerDisplayItem = { let descriptor = ASDiscoveryDescriptor() descriptor.bluetoothServiceUUID = ### return ASPickerDisplayItem( name: ###, productImage: UIImage(named: ###)!, descriptor: descriptor )}()session.showPicker(for: [pickerDevice1, pickerDevice2]) { error in if let error { print(\"Failed to show picker due to: \\(error.localizedDescription)\") }} Người dùng bây giờ sẽ thấy danh sách các thiết bị được khám phá và có thể chọn một để bắt đầu quy trình pairing, theo luồng tiêu chuẩn. 1234567891011121314151617private func handleSessionEvent(event: ASAccessoryEvent) { switch event.eventType { case .accessoryAdded, .accessoryChanged: guard let device = event.accessory else { return } # Save your device case .activated: guard let device = session.accessories.first else { return } # Save your device case .accessoryRemoved: # Clean up case .pickerDidPresent: # Your logic case .pickerDidDismiss: # Your logic default: ### }} Điều gì quan trọng?AccessorySetupKit đơn giản hóa quy trình thiết lập cho người dùng, làm cho nó trực quan và hiệu quả hơn trong khi loại bỏ sự phức tạp thường liên quan đến việc kết nối phụ kiện của bên thứ ba.Đối với các nhà phát triển, nó cung cấp một framework tích hợp được tiêu chuẩn hóa, đảm bảo trải nghiệm người dùng nhất quán và codebase đơn giản hóa. Bằng cách áp dụng AccessorySetupKit, các nhà phát triển có thể mang lại trải nghiệm liền mạch và gắn kết, đưa các phụ kiện của bên thứ ba phù hợp với các tiêu chuẩn cao mà người dùng liên kết với các sản phẩm Apple. Tài liệu tham khảoMeet AccessorySetupKit, WWWDC 2024iOS 18 AccessorySetupKit: Everything BLE Developers Need To Know","link":"/vi/posts/iOS-18-What-s-news-in-CoreBluetooth/index.html"},{"title":"Làm việc với Thread Safe trên iOS","text":"Như bạn có thể biết, từ “Thread safe” đề cập đến một khái niệm khoa học máy tính trong ngữ cảnh của các chương trình đa luồng. Một đoạn code được gọi là “Thread safe” nếu bất kỳ dữ liệu chia sẻ nào chỉ được truy cập bởi một thread tại bất kỳ thời điểm nào. Lưu ý rằng các dữ liệu chia sẻ này được gọi là critical section trong hệ điều hành.Điểm quan trọng là các kiểu collection trong Swift như Array và Dictionary không phải thread-safe khi được khai báo mutable (với từ khóa var).Trong bài viết này, chúng ta sẽ thảo luận một số kỹ thuật để làm cho code của chúng ta thread safe trong iOS. Nghiên cứu tình huốngGiả sử chúng ta có một array chứa dữ liệu quan trọng. Trong thực tế, nó có thể là số tiền trong thẻ tín dụng, trạng thái giao dịch, v.v. Chúng thực sự quan trọng nên nếu chúng ta không bảo vệ các giá trị này một cách chính xác, chúng ta sẽ gặp phải các lỗi nghiêm trọng khi runtime.Để mô phỏng một race condition, tôi sẽ sử dụng DispatchQueue.concurrentPerform để tạo 10 thread đồng thời chạy cùng một lúc. 12345678910111213class ViewController: UIViewController { var array = [Int]() override func viewDidAppear(_ animated: Bool) { super.viewDidAppear(animated) // Thực hiện bất kỳ thiết lập bổ sung nào sau khi load view, thường từ nib. DispatchQueue.concurrentPerform(iterations: 10) { index in self.array.append(index) } } // Phần còn lại của code} Kết quả của code trên là không thể dự đoán được. Bạn sẽ rơi vào 2 trường hợp: Hầu hết các lần bạn chạy code này, bạn sẽ gặp crash runtime như thế nàyVấn đề cơ bản là vì các collection trong Swift như Array và Dictionary không phải thread-safe nhưng chúng ta cho phép nhiều thread sửa đổi array cùng một lúc. Stackoverflow Nếu bạn may mắn không gặp crash này, các phần tử của array sẽ trông ngẫu nhiên như thế này:Element count 5Element count 9Element count 10Điểm quan trọng là chúng ta không phải lúc nào cũng nhận được 10 phần tử như mong đợi. Nó xảy ra như thế nào?Không an toàn khi để một thread sửa đổi giá trị trong khi thread khác đang đọc nó. Giải phápCách để tránh race condition là đồng bộ hóa dữ liệu, hoặc các critical section. Đồng bộ hóa dữ liệu thường có nghĩa là “khóa” nó để chỉ một thread có thể truy cập phần code đó tại một thời điểm.Vì Swift không hỗ trợ các giải pháp concurrency tích hợp sẵn, chúng ta sẽ sử dụng Grand Central Dispatch để triển khai thread safe thay thế. Sử dụng serial queueBằng cách tận dụng serial queue, chúng ta có thể ngăn chặn race condition trên một tài nguyên. Như tôi đã giới thiệu cách serial queue hoạt động trong bài viết trước, Grand-Central-Dispatch-in-Swift, một serial queue chỉ cho phép một process chạy tại một thời điểm nên array an toàn khỏi các process đồng thời. 123456789101112131415161718class SafetyArray&lt;T&gt; { var array = [T]() let serialQueue = DispatchQueue(label: \"com.uynguyen.queue\") var last: T? { var result: T? self.serialQueue.sync { result = self.array.last } return result } func append(_ newElement: T) { self.serialQueue.async() { self.array.append(newElement) } } } Mặc dù chúng ta bảo vệ array khỏi việc bị truy cập bởi nhiều thread, việc sử dụng serial queue không phải là giải pháp tốt nhất. Đọc giá trị cuối cùng không được tối ưu vì nhiều yêu cầu đọc phải đợi lẫn nhau vì nó nằm trong một serial queue. Các thao tác đọc nên có thể xảy ra đồng thời, miễn là chúng ta không thực hiện ghi cùng một lúc. Sử dụng concurrent queue với cờ barrierÝ tưởng chính của giải pháp này là sử dụng một concurrent queue thay vì serial queue.Swift hỗ trợ chúng ta dispatch một khối code đến một concurrent queue với một cờ gọi là barrier. Cờ barrier đảm bảo rằng concurrent queue không thực thi bất kỳ tác vụ nào khác trong khi thực thi process barrier. Một khi process barrier hoàn thành, queue sẽ cho phép chạy các tác vụ khác đồng thời theo triển khai mặc định. 123456789101112131415161718class SafeArray&lt;T&gt; { var array = [T]() let concurrentQueue = DispatchQueue(label: \"com.uynguyen.queue\", attributes: .concurrent) var last: T? { var result: T? self.concurrentQueue.sync { result = self.array.last } return result } func append(_ newElement: T) { self.concurrentQueue.async(flags: .barrier) { self.array.append(newElement) } } } Chúng ta tiếp tục sử dụng phương thức sync để đọc phần tử cuối cùng, nhưng tất cả các reader sẽ chạy song song lần này vì chúng ta đang sử dụng concurrent queue. Sự đánh đổiLàm việc với nhiều thread là phần khó của việc code. Mặc dù chúng ta phải bảo vệ các critical section khỏi nhiều truy cập, chúng ta nên ghi nhớ rằng *”Giữ các phần đồng bộ hóa càng nhỏ càng tốt vì Lock tạo ra độ trễ và thêm overhead. Chúng tốn kém”*. Clean code.Một số mẹo để xử lý concurrency: Concurrency không phải lúc nào cũng cải thiện hiệu suất. Đôi khi nó phát sinh một số overhead và các bug từ nó thường không lặp lại được. Giới hạn quyền truy cập của dữ liệu được chia sẻ giữa nhiều hơn hai thread. Sử dụng bản sao của dữ liệu nếu có cơ hội. Code đa luồng hoạt động khác nhau trong các môi trường khác nhau: Chạy test trong mọi môi trường triển khai tiềm năng. Suy nghĩ cuối cùngThread safe là một trong những khái niệm quan trọng nhất trong khoa học máy tính, đặc biệt trong một hệ thống cho phép truy cập dữ liệu đồng thời. Hiểu cách làm cho code thread safe, chúng ta có thể tránh các lỗi nghiêm trọng xảy ra khi runtime.Happy coding.","link":"/vi/posts/Working-In-Thread-Safe-on-iOS/index.html"},{"title":"iOS: Giới thiệu Stack Views Lập trình","text":"Khi kỹ năng phát triển iOS của bạn đang phát triển, tôi tin rằng bạn sử dụng UIScrollView, UICollectionView, UITableView, và các view native khác thường xuyên và thành thạo trong các ứng dụng của mình. Tuy nhiên, một số iOS developer vẫn không biết chính xác UIStackView là gì, nó được sử dụng cho mục đích gì hoặc trong tình huống nào chúng ta nên sử dụng UIStackView.Trong tutorial này, tôi sẽ giới thiệu cho bạn UIStackView - Một view giúp chúng ta đơn giản hóa các layout iOS. Hãy tưởng tượng bạn đang xây dựng một ứng dụng cho phép người dùng thêm hoặc xóa các view trong runtime. Nhớ cách chúng ta sẽ hoàn thành tác vụ này? Đầu tiên chúng ta phải xóa tất cả các constraint trong vùng liên quan và cập nhật lại tất cả. Hoặc nhớ trường hợp bạn triển khai view đăng nhập / đăng ký, bạn thêm nhiều text field và thiết lập constraint thủ công giữa các view đó. Trong những tình huống như vậy, UIStackView tỏ ra hữu ích hơn các view khác. Để minh họa cách áp dụng UIStackView vào các project của bạn, chúng ta sẽ xây dựng một ứng dụng đơn giản cho phép người dùng điều khiển các thiết bị thông minh trong nhà của họ; Người dùng có thể thêm hoặc xóa phòng nào họ muốn hiển thị trong danh sách điều khiển của họ. Điểm chính ở đây là tất cả các hành động của người dùng được thực thi trong runtime một cách động. Ngoài ra, thay vì sử dụng Storyboard trong project này, tôi sẽ sử dụng code động cùng với sự trợ giúp của framework AutoLayout (SnapKit - đây chỉ là sở thích cá nhân). Hãy bỏ qua các triển khai phức tạp khác, ứng dụng chỉ chứa hai view: Một view đăng nhập và một trang chủ. Ngoài ra, sẽ không có code logic nào cả. Các thuộc tính chínhĐể hiểu cách Stack View hoạt động, trước tiên chúng ta cần xem xét các thuộc tính của nó. Bất kể loại Stack View là gì (Ngang hay Dọc), có bốn thuộc tính chính: Axis, Spacing, Alignment, và Distribution. Hình ảnh sau đây tóm tắt mối quan hệ giữa các thuộc tính đó. Axis: xác định hướng của stack, bao gồm Horizontal và Vertical. Spacing: xác định khoảng cách tối thiểu giữa các view của stack. Alignment: xác định layout của các view của stack vuông góc với trục của nó.Cả stack view ngang và dọc đều có các tùy chọn Fill và Center. Fill: Các view được sắp xếp của Stack sẽ được thay đổi kích thước sao cho chúng vừa với stack view vuông góc với trục của nó. Các cạnh leading và trailing của các item xếp dọc hoặc các cạnh top và bottom của item xếp ngang, tương ứng. Center: Như tên gọi, căn giữa các view của stack theo chiều ngang (Stack dọc) hoặc theo chiều dọc (Stack ngang). Fill Center Có một số tùy chọn alignment chỉ áp dụng cho stack view ngang: Top: Như tên gọi, căn giữa các view của stack theo chiều ngang (Stack dọc) hoặc theo chiều dọc (Stack ngang). Bottom: Như tên gọi, căn giữa các view của stack theo chiều ngang (Stack dọc) hoặc theo chiều dọc (Stack ngang). First baseline: Một layout trong đó stack view căn chỉnh các view được sắp xếp của nó dựa trên baseline đầu tiên của chúng. Last baseline: Một layout trong đó stack view căn chỉnh các view được sắp xếp của nó dựa trên baseline cuối cùng của chúng. Top Bottom First baseline Last baseline Tương tự, có một số tùy chọn alignment chỉ hoạt động cho stack view dọc: Leading: Stack view căn chỉnh cạnh leading (Trái) của các view được sắp xếp dọc theo cạnh leading của nó. Tương tự như alignment top cho stack ngang. Trailing: Stack view căn chỉnh cạnh trailing (Phải) của các view được sắp xếp dọc theo cạnh leading của nó. Tương tự như alignment bottom cho stack ngang. Leading Trailing Distribution: xác định layout của các view của stack dọc theo trục của nó. Các subview đều được thay đổi kích thước dựa trên cài đặt này. Fill: Đây được đặt làm distribution mặc định khi một Stack View được tạo. Khi chúng ta đặt các view bên trong một UIStackView với Fill được đặt làm distribution, nó sẽ tiếp tục cố gắng kéo dãn kích thước của một trong các view để lấp đầy không gian.Vậy câu hỏi là, nó sẽ dựa trên tiêu chí nào để chọn view để thay đổi kích thước? Content Hugging Priority (CHP) sẽ là tiêu chí. Để xác định view nào sẽ được kéo dãn, stack view sẽ dựa vào CHP để đánh giá, priority càng thấp, view càng có khả năng được chọn. Nếu tất cả các view có cùng CHP, view đầu tiên sẽ được chọn. Fill Equally: Mỗi control trong UIStackView sẽ có kích thước bằng nhau. Fill Proportionally: Tất cả các control cần có intrinsic content size, Stack view sẽ đảm bảo các control duy trì cùng tỷ lệ. Equal Spacing: Loại distribution này sẽ duy trì khoảng cách bằng nhau giữa các subview. Equal Centering: Loại distribution này sẽ duy trì khoảng cách bằng nhau giữa tâm của các subview. Fill Fill Equally Fill Proportionally Equal Spacing Equal Centering Lưu ý: UIStackView là một view không render, có nghĩa là bạn không thể đặt thuộc tính background-color, hoặc override method draw, v.v. Thực hànhBây giờ, với kiến thức đó trong tâm trí, chúng ta sẽ áp dụng nó vào một project hiện có mà hiện tại không sử dụng UIStackView để sắp xếp view của nó. Bằng cách áp dụng UIStackView vào thực tế, chúng ta sẽ thực sự hiểu cách UIStackView hoạt động và những vấn đề nào nó có thể giải quyết. Tự động sắp xếp các viewĐiều đầu tiên UIStackView mang lại cho chúng ta là sự tự do khỏi việc thiết lập constraint cho tất cả các view.View đăng nhập khá đơn giản, nó chứa hai text field, một nút đăng nhập và một số text label. Nếu không sử dụng UIStackView, chúng ta phải thiết lập constraint thủ công cho tất cả các text field đó. 12345678910111213141516171819view.addSubview(lblLogin)lblLogin.snp.makeConstraints { (make) in make.centerX.equalToSuperview() make.centerY.equalToSuperview().offset(-250) make.left.equalToSuperview().offset(20) make.right.equalToSuperview().offset(-20) make.height.equalTo(30)}view.addSubview(lblUsername)lblUsername.snp.makeConstraints { (make) in make.centerX.left.right.equalTo(lblLogin) make.top.equalTo(lblLogin.snp.bottom).offset(30) make.height.equalTo(30)}view.addSubView(btnLogin)//...// Phần còn lại được bỏ qua Nhưng nó vẫn chưa phải là cơn ác mộng. Tưởng tượng bây giờ bạn muốn thêm một số view khác, chẳng hạn như một label và một switch view để cho phép người dùng nhớ phiên đăng nhập. Bây giờ chúng ta phải thay đổi tất cả các view khác để chèn những view mới đó vào đúng vị trí trên màn hình! Tác vụ sẽ dễ dàng và đơn giản hơn nếu chúng ta sử dụng StackView. Bây giờ hãy xem cách chúng ta có thể làm điều đó.Đầu tiên, hãy thêm một thuộc tính mới vào view controller Đăng nhập. 12345678910111213lazy var stackView: UIStackView = { let stack = UIStackView() stack.axis = .vertical stack.spacing = 20.0 stack.alignment = .fill stack.distribution = .fillEqually [self.lblUsername, self.txtUserName, self.lblPassword, self.txtPassword, self.btnLogin].forEach { stack.addArrangedSubview($0) } [1] return stack}() Lưu ý tại [1], đây là cách chúng ta thêm các view được sắp xếp vào một stack view. Sau đó, chúng ta chỉ cần thiết lập constraint cho stackView. 12345678910override func viewDidLoad() { super.viewDidLoad() // ... view.addSubview(stackView) stackView.snp.makeConstraints { (make) in make.centerX.left.right.equalTo(lblLogin) make.top.equalTo(lblLogin.snp.bottom).offset(30) make.height.equalTo(280) }} Trong tương lai, nếu chúng ta muốn thêm các view mới, chúng ta chỉ cần đặt nó vào mảng các view được sắp xếp. Như bên dưới. 123456789lazy var keepLoginStackView: UIStackView = { let stackView = UIStackView() stackView.axis = .horizontal stackView.alignment = .trailing stackView.distribution = .fill [self.lblRememberMe, self.swKeepLogin].forEach { stackView.addArrangedSubview($0) } return stackView}() 12345// ...self.txtPassword,self.keepLoginStackView,self.btnLogin].forEach { stack.addArrangedSubview($0) }// ... Bạn có thể thấy sự khác biệt không? Codebase bây giờ sạch hơn và dễ bảo trì hơn cái cũ, phải không? Các view độngBây giờ chuyển sang trường hợp chúng ta sẽ triển khai trang Chủ của ứng dụng.Khi người dùng nhấn nút bên phải của màn hình, một view mới, đại diện cho một phòng được điều khiển trong trường hợp này, sẽ được đặt trên trang chính. Người dùng cũng có thể xóa bất kỳ phòng nào trong danh sách bằng cách nhấn nút “Remove”. Bên trong mỗi phòng, có một nút “Hide” / “Show” cho phép ẩn và hiện hình ảnh phòng. Nhớ trong quá khứ khi bạn phải triển khai một tính năng tương tự trong ứng dụng của bạn mà không sử dụng UIStackView, bạn sẽ làm gì? Hơi đau đớn! Đầu tiên chúng ta cần xóa tất cả các constraint trong vùng liên quan và cập nhật lại tất cả. Đây là những gì chúng ta sẽ làm với UIStackView, trang chính chứa một stack view dọc được nhúng bên trong một scroll view. Bất cứ khi nào nút Add được nhấn, một view TaskView mới sẽ được thêm vào stack view này. 1234567func addMoreView() { let view = TaskView(delegate: self, data: room[Int.random(in: 0..&lt;room.count)]) let constraint1 = view.heightAnchor.constraint(lessThanOrEqualToConstant: 400.0) constraint1.isActive = true self.taskStackView.addArrangedSubview(view) self.view.layoutIfNeeded()} Chúng ta cũng cần thiết lập constraint chiều cao cho view mới này. Vì chiều cao của view có thể thay đổi khi nút show/hide được nhấn, chúng ta cần định nghĩa constraint này là lessThanOrEqualToConstant:value để stack view có thể điều chỉnh constraint chiều cao này. 12345678910func onRemove(_ view: TaskView) { if let first = self.taskStackView.arrangedSubviews.first(where: { $0 === view }) { UIView.animate(withDuration: 0.3, animations: { first.isHidden = true first.removeFromSuperview() }) { (_) in self.view.layoutIfNeeded() } }} Khi nút remove trên một task view được click, view này sẽ được xóa khỏi stack view. Chúng ta có thể truy cập tất cả các view được sắp xếp của một stack view bằng cách truy cập thuộc tính arrangedSubviews. Đầu tiên chúng ta lặp qua tất cả các view được sắp xếp và tìm view thích hợp có cùng địa chỉ với sender, sau đó xóa nó khỏi super view. Ngoài ra, tôi tạo một animation nhỏ, UIView.animate(withDuration:animations:), để transition trông mượt mà và đẹp hơn cái trước.Bằng cách sử dụng cùng một cách tiếp cận, bạn có thể làm điều tương tự khi người dùng click vào nút Show / Hide để hiện/ẩn image view. Hãy tự thử. Suy nghĩ cuối cùngTrong tutorial này, tôi đã giới thiệu cho bạn UIStackView - một subclass của UIView giúp quản lý vị trí và kích thước của các view được sắp xếp của nó. Chúng ta cũng đã làm việc qua một demo đưa UIStackView vào thực tế. Bây giờ bạn đã hiểu cách UIStackView hoạt động và UIStackView được sử dụng cho mục đích gì, lần tới hãy thử sử dụng UIStackView trong ứng dụng của bạn để tận dụng sức mạnh của nó. Tôi sẽ làm, còn bạn thì sao?Bạn có thể tải demo hoàn chỉnh tại Github,Happy coding!","link":"/vi/posts/iOS-Introducing-Stack-Views/index.html"},{"title":"iOS Concurrency Nâng cao: Operations [1]","text":"Có hai kỹ thuật để xử lý Concurrency trong iOS: GCD - Grand Central Dispatch và Operations. Hầu hết thời gian, GCD cung cấp hầu hết các khả năng concurrency mà bạn cần. Tuy nhiên, đôi khi bạn sẽ muốn một số tùy chỉnh nâng cao bổ sung. Đó là lúc để sử dụng Operations. Tutorial này sẽ giới thiệu Operations trong Swift, cũng như giải thích khi nào và tại sao chúng ta sử dụng Operation thay vì GCD.Hãy chuyển số! Có một khoảng cách lớn giữa việc biết con đường và đi qua con đường. Giới thiệu OperationsOperation là một class cho phép bạn submit một khối code sẽ được chạy trên một thread khác, nó được xây dựng trên nền tảng GCD. Về cơ bản, cả GCD và operation đều có vai trò tương tự. Tuy nhiên, operation có những lợi ích khác cho chúng ta nhiều quyền kiểm soát hơn đối với tác vụ. Thiết kế OOP: vì operation là một class Swift, bạn có thể subclass nó và override các method của nó nếu cần. Nó sẽ dễ sử dụng và tái sử dụng trong tương lai. Quản lý trạng thái: Một Operation có state machine riêng được thay đổi trong suốt lifecycle của nó. Bản thân operation xử lý các thay đổi trạng thái của nó. Chúng ta không thể sửa đổi các trạng thái này của một object. Dependency giữa các operation: Nếu bạn muốn bắt đầu một tác vụ sau khi các tác vụ khác đã hoàn thành thực thi, thì operation nên là lựa chọn của bạn. Một operation sẽ không bắt đầu thực thi cho đến khi tất cả các operation mà nó phụ thuộc đã hoàn thành thành công công việc của chúng. Hủy tác vụ đã submit: Bằng cách sử dụng operation, chúng ta có khả năng hủy một operation đang chạy. Điều này rất hữu ích trong trường hợp chúng ta muốn dừng các operation không còn liên quan tại một thời điểm nhất định. Ví dụ, để hủy tải dữ liệu khi người dùng scroll table làm cho một số cell biến mất. Dependency và khả năng hủy làm cho operation có thể kiểm soát được nhiều hơn so với GCD. Thực hànhGiả sử rằng chúng ta đang xây dựng một ứng dụng sẽ fetch một số bài viết của tôi. Sau khi tải các hình ảnh cover, chúng sẽ được áp dụng một filter đơn giản, sau đó hiển thị trong một table view.Tiến hành và tạo một project. Project chỉ đơn giản chứa một màn hình chính với một table view hiển thị các bài viết với tiêu đề và hình ảnh cover. Để đơn giản hóa nguồn dữ liệu, tôi đã tạo một file JSON chứa 100 dòng mô tả một bài viết với key là tiêu đề và value là url liên kết đến hình ảnh cover. 123456789[ // input.json {\"Building your personal page with Hexo\": \"https://uynguyen.github.io/Post-Resources/Hexo/Cover.png\"}, {\"Beta Test and TestFlight\": \"https://uynguyen.github.io/Post-Resources/TestFlight/Cover.png\"}, {\"iOS: Mix and Match\": \"https://uynguyen.github.io/Post-Resources/MixMatch/mix-match-banner.png\"}, {\"Best practice: Core Data Concurrency\": \"https://uynguyen.github.io/Post-Resources/CoreDataConcurrency/banner.png\"}, {\"Two weeks at Fossil Group in the US\": \"https://uynguyen.github.io/Post-Resources/Fossil_Group/Fossil_Group.jpg\"}, ...] Bên trong MainViewController, hãy đọc file input 12345678910111213141516171819202122class ViewController: UIViewController { @IBOutlet weak var tbPosts: UITableView! var urls = [(title: String, url: String)]() override func viewDidLoad() { super.viewDidLoad() self.setup() // ... } func setup() { let inputUrl = Bundle.main.url(forResource: \"input\", withExtension: \"json\")! do { let data = try Data(contentsOf: inputUrl) if let jsonDict = try JSONSerialization.jsonObject(with: data) as? [[String: String]] { self.urls = jsonDict.map { ($0.first!.key, $0.first!.value) } } } catch { } } Bằng cách sử dụng một hàm đơn giản của CoreImage, method grayScale(input:) sẽ chuyển đổi một UIImage thành hình ảnh đen trắng với filter Tonal 12345678910111213141516171819func grayScale(input: UIImage) -&gt; UIImage? { let context = CIContext(options: nil) var inputImage = CIImage(image: input) let filters = inputImage!.autoAdjustmentFilters() for filter: CIFilter in filters { filter.setValue(inputImage, forKey: kCIInputImageKey) inputImage = filter.outputImage } let cgImage = context.createCGImage(inputImage!, from: inputImage!.extent) let currentFilter = CIFilter(name: \"CIPhotoEffectTonal\") currentFilter!.setValue(CIImage(image: UIImage(cgImage: cgImage!)), forKey: kCIInputImageKey) let output = currentFilter!.outputImage let cgimg = context.createCGImage(output!, from: output!.extent) return UIImage(cgImage: cgimg!)} Đã đến lúc thiết lập table view, chúng ta sử dụng URLSession để tải hình ảnh từ url input, sau đó hiển thị lên cell sau khi tải thành công. 1234567891011121314151617181920extension ViewController: UITableViewDataSource { // Phần còn lại được bỏ qua func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell { let cell = tableView.dequeueReusableCell(withIdentifier: \"CellId\", for: indexPath) as! PostTableViewCell let input = urls[indexPath.row] URLSession.shared.dataTask(with: URL(string: input.url)!, completionHandler: { (data, res, error) in guard error == nil, let data = data, let image = UIImage(data: data) else { return } DispatchQueue.main.async { cell.lblPostTitle.text = input.title cell.imgPostImage.image = self.grayScale(input: image) } }).resume() return cell }} Build và chạy project, bạn sẽ thấy các hình ảnh xuất hiện trên danh sách. Hãy thử scroll table. Bạn có cảm thấy giật lag không?Bạn có thể nhận thấy vấn đề đến từ đâu. Để thiết lập một cell, chúng ta đầu tiên tải hình ảnh từ internet, sau đó áp dụng filter Tonal cho hình ảnh. Hai hành động này đang thực hiện trên main thread, tạo quá nhiều áp lực lên thread chỉ nên được sử dụng cho tương tác người dùng. Sử dụng GCDChúng ta có thể dispatch code tải và filter hình ảnh sang một queue riêng biệt khác 12345678910111213DispatchQueue.global(qos: .background).async { URLSession.shared.dataTask(with: URL(string: input.url)!, completionHandler: { (data, res, error) in guard error == nil, let data = data, let image = UIImage(data: data) else { return } let filteredImage = self.grayScale(input: image) DispatchQueue.main.async { cell.lblPostTitle.text = input.title cell.imgPostImage.image = filteredImage } }).resume()} Bằng cách thực thi code trên một background queue, chúng ta giảm tải công việc cho main queue và làm cho UI phản hồi nhanh hơn nhiều.Rebuild project, bạn sẽ thấy sự khác biệt.Ngay cả khi chúng ta giải quyết vấn đề tương tác người dùng, hiệu suất của ứng dụng vẫn chưa được tối ưu.Có thể làm gì để cải thiện điều này?Khi người dùng scroll table, các cell đến và đi. Không có ý nghĩa gì trong việc tiếp tục tải và xử lý một hình ảnh của một cell không hiển thị. Tốt hơn là hủy khối code để cải thiện hiệu suất và giảm mức tiêu thụ pin của ứng dụng. Nhưng làm thế nào chúng ta có thể hủy một tác vụ đang chạy trong GCD?Đây là lúc Operation xuất hiện. Chuyển số sang OperationHãy chia tác vụ thiết lập một table view cell thành hai tác vụ: một là tải hình ảnh và một là áp dụng filter. 12345678910111213141516171819class DownloadImageOperation: Operation { let url: URL var outputImage: UIImage? init(url: URL) { self.url = url } override func main() { guard !isCancelled else { return } URLSession.shared.dataTask(with: self.url, completionHandler: { (data, res, error) in guard error == nil, let data = data else { return } self.outputImage = UIImage(data: data) }).resume() }} 123456789101112131415161718192021222324252627282930313233343536class ImageFilterOperation: Operation { let context = CIContext(options: nil) var processedImage: UIImage? func grayScale(input: UIImage) -&gt; UIImage? { var inputImage = CIImage(image: input) let filters = inputImage!.autoAdjustmentFilters() for filter: CIFilter in filters { filter.setValue(inputImage, forKey: kCIInputImageKey) inputImage = filter.outputImage } let cgImage = context.createCGImage(inputImage!, from: inputImage!.extent) let currentFilter = CIFilter(name: \"CIPhotoEffectTonal\") currentFilter!.setValue(CIImage(image: UIImage(cgImage: cgImage!)), forKey: kCIInputImageKey) let output = currentFilter!.outputImage let cgimg = context.createCGImage(output!, from: output!.extent) return UIImage(cgImage: cgimg!) } override func main() { guard !isCancelled else { return } let dependencyImage = self.dependencies .compactMap { $0 as? DownloadImageOperation } .first if let image = dependencyImage?.outputImage { guard !isCancelled else { return } self.processedImage = self.grayScale(input: image) } }} Để sử dụng Operation, chúng ta chỉ đơn giản subclass class Operation và override method main nơi tác vụ của chúng ta được đặt. Mặc định, các operation chạy ở background, vì vậy không cần lo lắng về việc block main thread.Quay lại tác vụ thiết lập table view cell, bạn có thể nhận thấy rằng có một dependency giữa hai tác vụ này, chúng ta chỉ thực hiện quá trình filter sau khi tải hình ảnh. Nói cách khác, operation ImageFilterOperation phụ thuộc vào operation DownloadImageOperation. Operation Dependencies là một trong những “tính năng sát thủ” của Operation cùng với khả năng hủy một operation đang chạy. Bằng cách liên kết hai operation, chúng ta đảm bảo rằng operation phụ thuộc không bắt đầu trước khi operation tiên quyết đã hoàn thành. Ngoài ra, việc liên kết tạo ra một cách sạch sẽ để truyền dữ liệu từ operation đầu tiên sang operation thứ hai. 1234e.glet dependencyImage = self.dependencies .compactMap { $0 as? DownloadImageOperation } .first Đã đến lúc thực hiện cải tiến.Đầu tiên hãy định nghĩa một OperationQueue cho ViewController. Class OperationQueue là thứ chúng ta sử dụng để quản lý các Operation. 123456789101112131415161718192021222324class ViewController: UIViewController { private let queue = OperationQueue() // Phần còn lại được bỏ qua // ... func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell { let cell = tableView.dequeueReusableCell(withIdentifier: \"CellId\", for: indexPath) as! PostTableViewCell let input = urls[indexPath.row] let downloadOpt = DownloadImageOperation(url: URL(string: input.url)!) let grayScaleOpt = ImageFilterOperation() grayScaleOpt.addDependency(downloadOpt) grayScaleOpt.completionBlock = { DispatchQueue.main.async { cell.lblPostTitle.text = input.title cell.imgPostImage.contentMode = .scaleToFill cell.imgPostImage.image = grayScaleOpt.processedImage } } self.queue.addOperation(downloadOpt) self.queue.addOperation(grayScaleOpt) return cell }} Ở đây, chúng ta khởi tạo hai instance mới của class DownloadImageOperation và ImageFilterOperation. Sau đó, chúng ta đặt operation grayScaleOpt phụ thuộc vào downloadOpt điều này sẽ đảm bảo grayScaleOpt chỉ được thực thi sau khi downloadOpt đã hoàn thành. Cuối cùng, chúng ta thêm hai operation này vào OperationQueue. Một khi operation được thêm vào queue, operation sẽ được lên lịch. Nếu queue tìm thấy một thread khả dụng để chạy operation, công việc sẽ được thực thi cho đến khi nó hoàn thành hoặc bị hủy. Khi operation hoàn thành, completionBlock được gọi. “Các Operation có ảnh hưởng quan trọng đến hiệu suất ứng dụng của bạn. Ví dụ, nếu bạn muốn tải nhiều nội dung từ Internet, bạn có thể muốn làm như vậy chỉ khi thực sự cần thiết. Ngoài ra, bạn có thể quyết định đảm bảo rằng chỉ một số lượng operation cụ thể có thể chạy cùng một lúc. Nếu bạn quyết định giới hạn số lượng operation đồng thời trong một queue, bạn có thể thay đổi thuộc tính maxConcurrentOperationCount của operation queue của bạn. Đây là một thuộc tính integer cho phép bạn chỉ định tối đa bao nhiêu operation có thể chạy trong một queue tại một thời điểm nhất định.” (iOS 8 Swift Programming Cookbook) Học các lý thuyết trên là đủ, bây giờ re-build project để xem kết quả. Ops! Không có gì xuất hiện, hình ảnh không được tải! Có gì đó sai ???Trong tutorial tiếp theo, chúng ta sẽ tìm hiểu điều gì đã xảy ra với code của chúng ta và tại sao Operation không hoạt động đúng như mong đợi.Cảm ơn bạn đã đọc.","link":"/vi/posts/iOS-Concurrency-Operations/index.html"},{"title":"iOS: Mix and Match","text":"Khi Swift đã trở thành ngôn ngữ chủ lực cho phát triển iOS, hầu hết các project iOS mới ngày nay đều được xây dựng bằng Swift. Tuy nhiên, có nhiều thư viện hữu ích được phát triển bằng các ngôn ngữ lập trình cấp thấp khác như Objective-C và / hoặc C++ để tăng hiệu suất. Mặt khác, không phải tất cả các vị trí kỹ sư đều mở cho các project mới, hầu hết họ được tuyển để bảo trì và phát triển các tính năng mới dựa trên codebase hiện tại được xây dựng bằng Objective-C.Có kiến thức để kết hợp hai ngôn ngữ trong một project duy nhất là tốt cho kỹ năng phát triển iOS của bạn vì bạn sẽ gặp nó một ngày nào đó trong sự nghiệp của mình. Trong bài viết này, tôi sẽ chỉ cho bạn không chỉ cách sử dụng Objective-C và Swift trong một project duy nhất mà còn cách sử dụng một tập hợp các ngôn ngữ lập trình trong một project, bao gồm C++/ Objective-C/ Swift và React Native. Hy vọng bạn sẽ thấy bài viết này thú vị.Hãy bắt đầu. C++ &lt;- Objective-C++Đối với những ai chưa nghe về Objective-C++,Objective-C++ thực sự là source code kết hợp các class Objective-C và class C++ trong một file duy nhất.Bạn chỉ cần đổi file .m thành .mm để phép màu hoạt động.Đầu tiên, tôi sẽ tạo một thư viện C++ sẽ được sử dụng bởi các class Objective-C++. 1234class CPlusPlusMath { public: int multiplyTwoNumbers(int a, int b);}; Triển khai 123int CPlusPlusMath::multiplyTwoNumbers(int a, int b) { return a * b;} Sau đó, bạn cần tạo một file bridging header cho project của bạn vì project mới của chúng ta đang sử dụng ngôn ngữ Swift. Bridging header là nơi bạn định nghĩa tất cả các class Objective-C được expose cho Swift. Khi chúng ta thêm một class Objective-C mới vào project dựa trên Swift, XCode tự động đề nghị thêm file này vào project.Tiếp theo, bạn đổi tên file .m thành .mm để chuyển nó từ code Objective-C sang Objective-C++.Từ bây giờ, bạn có thể gọi đến thư viện C++ của chúng ta (hoặc các thư viện khác) bên trong file Objective-C++ này 12345678#import \"CPlusPlusMath.hpp\"@implementation ObjMath- (long)multiplyTwoNumbers:(int) num1 num2:(int) num2 { CPlusPlusMath *a = new CPlusPlusMath(); return a-&gt;multiplyTwoNumbers(num1, num2);} Objective-C++ &lt;-&gt; SwiftĐiều thú vị là chúng ta có thể gọi code Objective-C(++) từ code Swift và ngược lại.Để sử dụng các class Objective-C từ Swift, chúng ta cần khai báo header của chúng trong file bridging header. Hãy tiến hành và include thư viện toán học của chúng ta vào file này. 12345//// Sử dụng file này để import các header public của target mà bạn muốn expose cho Swift.//#include \"ObjMath.h\" Đó là tất cả những gì bạn cần làm để xây dựng đường dẫn đầu tiên từ Objective-C sang Swift. 1234func multiply(num1: Int, num2: Int) -&gt; Int { let objMath = ObjMath() return objMath.multiplyTwoNumbers(Int32(num1), num2: Int32(num2))} Tiếp theo, chúng ta cần xây dựng đường dẫn khác từ Swift sang Objective-C.Chúng ta sử dụng từ khóa objc trước bất kỳ class và method nào chúng ta muốn expose cho các class Objective-C. Một lưu ý nhỏ là các class được expose này cần được kế thừa từ class NSObject. Nếu không, chúng ta sẽ gặp lỗi compile Only classes that inherit from NSObject can be declared @objc. 123456789@objcclass SwifthMath: NSObject { @objc func add(num1: Int, num2: Int) -&gt; Int { return num1 + num2 } // Phần còn lại được bỏ qua} Swift &lt;-&gt; React NativeVui lòng xem series của tôi tại React Native và BLE Hạn chế Các object Swift có thể có subclass của một class objective-c, như NSObject. Nhưng một class swift không thể là base class cho một class objective-c. Khắc phục sự cốKết luậnNhiều developer vẫn đang sử dụng Objective-C vì nhiều lý do, và họ chắc chắn sử dụng các thư viện C++ trong các project của họ, đặc biệt trong phát triển Game nơi C++ phát huy tối đa hiệu suất của nó.Tôi hy vọng rằng bài viết này sẽ cho bạn một cái nhìn nhanh về cách Mix and Match nhiều ngôn ngữ trong một project duy nhất.Bạn có thể tìm project demo tại GithubCảm ơn bạn đã đọc.","link":"/vi/posts/iOS-Mix-and-Match/index.html"}],"posts":[{"title":"Android Bluetooth: A Pitfall","text":"Developing BLE-enabled Android apps is fraught with challenges, especially when it comes to managing concurrent operations. One of the most common pitfalls developers face is the unexpected behavior that occurs when trying to execute BLE operations in rapid succession. In this blog post, we’ll delve into why this happens and how you can overcome it by implementing a custom queuing mechanism for BLE operations. If you’ve worked with BLE on Android, you may have encountered a frustrating issue: when you attempt to execute multiple BLE operations one after another, like reading and writing characteristics or descriptors, only the first operation succeeds, while the others seem to disappear. This is more than just a minor inconvenience; it’s a serious problem because your app logic often depends on the successful completion of these operations. Without them, your UI can’t update with the fresh data from your connected device, leading to a poor user experience. So, what’s going on under the hood? The core issue lies in how Android’s BLE stack handles operations. BLE operations are asynchronous, meaning they don’t complete instantaneously. When you execute the BLE stack with multiple requests in quick succession, the system struggles to keep up, leading to dropped operations and unpredictable behavior. The Conventional Approach: Callback-Based SolutionsOne way to mitigate this issue is by using callbacks to sequence your BLE operations.For example, you might wait for the onCharacteristicWrite() callback to trigger before starting the next operation. This works for simple use cases where your BLE interactions are limited to a single screen or Activity.However, this approach quickly becomes unmanageable as the complexity of your app grows. As you add more BLE operations—such as reading and writing descriptors, handling connections and disconnections, updating the MTU, and performing service discovery. You’ll find that a more scalable solution is needed. The Scalable Solution: Implementing a Queuing MechanismTo handle BLE operations more reliably, a custom queuing mechanism is essential. By queuing BLE operations, you ensure that each operation is executed sequentially, only after the previous operation has either succeeded or failed. This approach not only prevents operations from being dropped but also simplifies the management of BLE tasks across your app. Here’s a basic outline of how you might implement such a mechanism: Create a Queue: Start by creating a queue (such as a LinkedList or Queue) to hold your BLE operations. Each operation can be represented as a task or command object that contains the details of the operation you want to perform. Operation Handler: Implement a handler or manager class responsible for processing the operations in the queue. This class should listen for the completion of each BLE operation, whether it succeeds or fails, before dequeuing and executing the next operation. Callback Integration: Modify your existing BLE callbacks (like onCharacteristicWrite(), onCharacteristicRead(), etc.) to trigger the dequeuing and execution of the next operation in the queue. Error Handling: Implement error handling to ensure that failed operations don’t block the queue. You might also want to perform retry logic for transient errors. UI Updates: Since your UI may depend on the outcome of BLE operations, ensure that your queue manager triggers appropriate UI updates once operations complete. 1234567891011121314151617181920212223242526272829303132333435363738394041424344class BLEManager { ConcurrentLinkedQueue&lt;BLEBaseCommand&gt; commandQueue = new ConcurrentLinkedQueue&lt;&gt;(); // Note that we're using a ConcurrentLinkedQueue to prevent concurrency issues. private void terminateCommands() { commandQueue.clear(); currentCommand = null; } private void enqueueCommand(BLEBaseCommand command) { commandQueue.offer(command); if (currentCommand == null) { executeNextCommand(); } } private void signalCommandEnd() { currentCommand = null; if (!commandQueue.isEmpty()) { // Has remaining command? executeNextCommand(); } } private void executeNextCommand() { BLEBaseCommand next = commandQueue.poll(); if (next == null) { // All done return; } currentCommand = next; try { if (!currentCommand.execute()) { runOnUiThread(currentCommand.fallback); // Handle your error from `fallback` function depends on the command signalCommandEnd(); } } catch (Exception ex) { signalCommandEnd(); } } private void runOnUiThread(Runnable runnable) { new Handler(Looper.getMainLooper()).post(runnable); }} Somewhere from your BluetoothGattCallback class. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253@Override public void onConnectionStateChange(BluetoothGatt gatt, int status, int newState) { // Your logic manager.signalCommandEnd();}@Overridepublic void onServiceChanged(@NonNull BluetoothGatt gatt) { // Your logic manager.signalCommandEnd();}@Overridepublic void onServicesDiscovered(BluetoothGatt gatt, int status) { // Your logic manager.signalCommandEnd();}@Overridepublic void onCharacteristicRead(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic, int status) { // Your logic manager.signalCommandEnd();}@Overridepublic void onCharacteristicWrite(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic, int status) { // Your logic manager.signalCommandEnd();}@Overridepublic void onDescriptorRead(BluetoothGatt gatt, BluetoothGattDescriptor descriptor, int status) { // Your logic manager.signalCommandEnd();}@Overridepublic void onDescriptorWrite(BluetoothGatt gatt, BluetoothGattDescriptor descriptor, int status) { // Your logic manager.signalCommandEnd();}@Overridepublic void onReadRemoteRssi(BluetoothGatt gatt, int rssi, int status) { // Your logic manager.signalCommandEnd();}@Overridepublic void onMtuChanged(BluetoothGatt gatt, int mtu, int status) { // Your logic manager.signalCommandEnd();} Below is the basic class diagram Why This MattersImplementing a queuing mechanism for BLE operations isn’t just about avoiding dropped operations; it’s about creating a more reliable and scalable architecture for your app. As you expand your app’s BLE functionality, you’ll be thankful for the stability and predictability that a queuing system provides. It’s worth mentioning that more modern paradigms like RxJava or Kotlin framework can offer even more elegant solutions to this problem. These tools can help you manage asynchronous operations with greater flexibility and less boilerplate code. However, for many developers, a custom queuing mechanism provides a solid foundation that can be easily understood and implemented without introducing additional dependencies. We might discuss this in another thread. ConclusionBLE on Android can be challenging, but with the right strategies, you can build robust applications that reliably communicate with BLE devices. By implementing a custom queuing mechanism, you can overcome many of the concurrency-related issues. Whether you’re just starting with BLE or looking to enhance your existing apps, adopting a queuing approach will make your development process smoother and your applications more reliable.Happy Coding!","link":"/2024/08/04/Android-Bluetooth-A-Pitfall/"},{"title":"All About Alamofire","text":"If you ever have a chance to work with networking on iOS, you definately have heard about Alamofire, a networking library written in Swift for iOS and MacOS. It simplifies all of the common networking jobs in your app.If you have not meet Alamofire yet, no worries, this tutorial will introduce you all tasks that Alamofire can handle for you. If you’re familiar with it, never mind, take this post as a summarize and a centralize of your Alamofire handbook.Let’s drive in! Coming soon! Build your own serverDesign the networking layerDependencies SwiftyJSON, a library supports to deal with JSON data. [SnapKit][https://github.com/SnapKit/SnapKit], Swift based Autolayout. Advanced topicFinal thought","link":"/2020/07/12/All-About-Alamofire/"},{"title":"Asynchronous Programming in Swift","text":"Promise Kit, one of the best frameworks to deal with asynchronous programming in Swift In this post, I will use these following third parties to complete the project: Alamofire: A HTTP networking framework in Swift. SwiftyJSON: To process JSON data. SwiftGifOrigin: An UIImage extension to display Gif files. Bolts-Swift: Was designed by Parse and Facebook, I use it to create asynchronous methods. PromiseKit: A framework helps us to simplify asynchronous programming. Giphy’s APIs for searching and downloading gif images. Getting Started Asynchronous methods, (Async for short), are the methods that not immediately returning results like most method, the async methods take some time to produce results.I often use callbacks to deal with asynchronous methods like scanning Bluetooth devices or retrieving some resources from the internet. In fact, callback is a bad programming technique. Callback will make our code hard to read, hard to debug and take much more time to maintain later. In the end, our code will turn into something that we call the callback hell.In this post, I will create a project using one by one technique to explain why I said callback is bad.Firstly, go ahead and create a project, named it as whatever you like, then install these Pod frameworks to your project. You also need to edit the NSAllowsArbitraryLoads key to YES in NSAppTransportSecurity dictionary in the info.plist file to specify which domains are excepted from the rules you define for App Transport Security. In our case, this is the giphy domain. Allow HTTP requests for only giphy domain 1234567891011&lt;key&gt;NSAppTransportSecurity&lt;/key&gt; &lt;dict&gt; &lt;key&gt;NSExceptionDomains&lt;/key&gt; &lt;dict&gt; &lt;key&gt;api.giphy.com&lt;/key&gt; &lt;dict&gt; &lt;key&gt;NSExceptionAllowsInsecureHTTPLoads&lt;/key&gt; &lt;true/&gt; &lt;/dict&gt; &lt;/dict&gt;&lt;/dict&gt; Or allow HTTP requests for all domains, it is not a good idea. 12345&lt;key&gt;NSAppTransportSecurity&lt;/key&gt;&lt;dict&gt; &lt;key&gt;NSAllowsArbitraryLoads&lt;/key&gt; &lt;true/&gt;&lt;/dict&gt; Let’s create a class named ImageLoader. This class contains two methods that help us to fetch and download gif images from the Giphy server. 123456789101112//// ImageLoader.swift//class ImageLoader { func fetchImage(keyword: String) { // Searching images that matched keyword on Giphy server } func downloadImage(url: URL) { // Download the image at url }} The first version: Using callbackFirstly, we need to define two callbacks, which will be passed to the fetchImage and downloadImage methods. 12public typealias FetchImageBlock = (URL?, Error?) -&gt; Voidpublic typealias DownloadImageBlock = (URL?, Error?) -&gt; Void Then, we implement these two methods: fetchImage takes a keyword and a callback as params, sends a request to the Giphy server to query all images that match the keyword, gets the first one and finally returns the download url via the callback. downloadImage takes an url and a callback as params, then uses the Alamofire framework to download the image. Finally, returning the destination url, where the image is saved, via the callback. 123456789101112131415161718192021func fetchImage(keyword: String, callback: @escaping FetchImageBlock) { let endPoint = \"http://api.giphy.com/v1/gifs/search?q=\\(keyword)&amp;limit=1&amp;api_key=q4N1oD5jw3xvH2hIOkFAyHXWTTrh0D30\" let headers: HTTPHeaders = [ \"Content-Type\": \"application/json\" ] Alamofire.request(endPoint, headers: headers).responseData { (response) in if let error = response.error { return callback(nil, error) } let jsonData = JSON.init(data: response.data!) let dataArray = jsonData[\"data\"].array if let dataArray = dataArray, dataArray.count &gt; 0 { let imagesList = dataArray[0][\"images\"] let downsized_large = imagesList[\"downsized_large\"][\"url\"].stringValue return callback(URL.init(string: downsized_large), nil) } else { return callback(nil, nil) } }} 123456789101112131415func downloadImage(url: URL, callback: @escaping DownloadImageBlock) { let destination: DownloadRequest.DownloadFileDestination = { _, _ in let documentsURL = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)[0] let fileURL = documentsURL.appendingPathComponent(url.lastPathComponent) return (fileURL, [.removePreviousFile, .createIntermediateDirectories]) } Alamofire.download(url, to: destination).downloadProgress(closure: { (progress) in print(\"\\(progress)\") }).responseData(completionHandler: { (response) in if let error = response.error { return callback(nil, error) } callback(response.destinationURL, nil) })} Inside the main view controller, let’s define a method called searchImageWithKeyword. This method takes a keyword as a param, then pass the param to the fetchImage method of an instance of the ImageLoader class. We also need to pass a callback to handle the results.Inside the fetchImage callback, let’s check if there are any errors. If it is, then we stop calling the next method, downloadImage. Otherwise, we call the downloadImage of the imageLoader object. Then pass the url and a callback as params.Inside the downloadImage callback, let’s check if there are any errors. If it is, then we stop calling the next one. Otherwise, we update the image view on the main view by calling the updateImageAtURL method. 12345678910111213141516171819202122232425262728func searchImageWithKeyword(keyword: String) { let imageLoader = ImageLoader() imageLoader.fetchImage(keyword: keyword, callback: {downloadLink, error in if let error = error { print(\"Error \\(error)\") } else { if let downloadLink = downloadLink { imageLoader.downloadImage(url: downloadLink, callback: {downloadedURL, error in if let error = error { print(\"Error \\(error)\") } else { if let downloadedURL = downloadedURL { self.updateImageAtURL(url: downloadedURL) } else { print(\"Error: downloadedURL is nil\") } } }) } else { print(\"Error: downloadLink is nil\") } } })} 123456789101112131415func updateImageAtURL(url: URL) { guard Thread.isMainThread else { DispatchQueue.main.async { self.updateImageAtURL(url: url) } return } do { let data = try Data.init(contentsOf: url) self.imgImage.image = UIImage.gif(data: data) } catch { print(\"Error \\(error)\") }} As you can see, the searchImageWithKeyword is quite complex with many if and else statements inside the method. We have to check errors in many lines of codes. Imagine how complex it would be if we had more than three methods inside itself? A callback hell in another language, Javascript Build and run the project. Enter a keyword you want to search on the Giphy server, press search button then you will see the first result. The async programming project A better solution: Using BoltsBolts is a framework that was designed by Parse and Facebook, I use it to create asynchronous methods, without using callback. Bolts framework lets we write code as a series of actions based on events. 123456789101112131415161718192021222324func fetchImage(keyword: String) -&gt; Task&lt;URL&gt;! { let mainTask = TaskCompletionSource&lt;URL&gt;() let endPoint = \"http://api.giphy.com/v1/gifs/search?q=\\(keyword)&amp;limit=1&amp;api_key=q4N1oD5jw3xvH2hIOkFAyHXWTTrh0D30\" let headers: HTTPHeaders = [ \"Content-Type\": \"application/json\" ] Alamofire.request(endPoint, headers: headers).responseData { (response) in if let error = response.error { return mainTask.set(error: error) } let jsonData = JSON.init(data: response.data!) let dataArray = jsonData[\"data\"].array if let dataArray = dataArray, dataArray.count &gt; 0 { let imagesList = dataArray[0][\"images\"] let fixed_height_still = imagesList[\"downsized_large\"][\"url\"].stringValue return mainTask.set(result: URL.init(string: fixed_height_still)!) } else { return mainTask.set(error: NSError.init(domain: \"myDomain\", code: 0, userInfo: nil)) } } return mainTask.task} 1234567891011121314151617181920212223func downloadImage(url: URL) -&gt; Task&lt;URL&gt;! { let mainTask = TaskCompletionSource&lt;URL&gt;() let destination: DownloadRequest.DownloadFileDestination = { _, _ in let documentsURL = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)[0] let fileURL = documentsURL.appendingPathComponent(url.lastPathComponent) return (fileURL, [.removePreviousFile, .createIntermediateDirectories]) } Alamofire.download(url, to: destination).downloadProgress(closure: { (progress) in print(\"\\(progress)\") }).responseData(completionHandler: { (response) in if let error = response.error { return mainTask.set(error: error) } if let destinationURL = response.destinationURL { return mainTask.set(result: destinationURL) } else { return mainTask.set(error: NSError.init(domain: \"myDomain\", code: 0, userInfo: nil)) } }) return mainTask.task} Let’s see how simple the searchImageWithKeyword would be by using Bolts. 12345678910func searchImageWithKeyword(keyword: String) { let imageLoader = ImageLoader() imageLoader.fetchImage(keyword: keyword).continueOnSuccessWith { (linkDownload) -&gt; Void in imageLoader.downloadImage(url: linkDownload).continueOnSuccessWith(continuation: { (downloadedURL) -&gt; Void in self.updateImageAtURL(url: downloadedURL) }) }.continueOnErrorWith { (error) in print(\"Error \\(error)\") }} Build and run the project, nothing changed. But the code is more readable than the first one, isn’t it? We gather all the errors in one place, also separate error handling and success code. A much better solution: Using PromiseKitOne thing I do not like about Bolts framework is the lack of documentation and example projects. When I first use Bolts framework, I was very hard to get used to with the APIs of the Task object.At the Swift Summit conference 2017, there was one speaker introduced a Framework to deal with async methods, PromiseKit. After the conference, I replaced the code using Bolts framework by PromiseKit at the projects in my company. I realize my code now more readable. I think PromiseKit’s writing will be more familiar to developers than Bolts’s writing, especially those who have worked with Javascript like me.An async method created by using PromiseKit returns a new generic Promise, which is the primary class provided by PromiseKit. Its constructor takes a simple execution block with two parameters: fulfill: A function to call when the desired value is ready to fulfill the promise. reject: A function to call if there is an error. Let’s apply PromiseKit to our project 12345678910111213141516171819202122func fetchImage(keyword: String) -&gt; Promise&lt;URL&gt; { return Promise { fullfil, reject in let endPoint = \"http://api.giphy.com/v1/gifs/search?q=\\(keyword)&amp;limit=1&amp;api_key=q4N1oD5jw3xvH2hIOkFAyHXWTTrh0D30\" let headers: HTTPHeaders = [ \"Content-Type\": \"application/json\" ] Alamofire.request(endPoint, headers: headers).responseData { (response) in if let error = response.error { return reject(error) } let jsonData = JSON.init(data: response.data!) let dataArray = jsonData[\"data\"].array if let dataArray = dataArray, dataArray.count &gt; 0 { let imagesList = dataArray[0][\"images\"] let fixed_height_still = imagesList[\"downsized_large\"][\"url\"].stringValue return fullfil(URL.init(string: fixed_height_still)!) } return reject(NSError.init(domain: \"myDomain\", code: 0, userInfo: nil)) } }} 12345678910111213141516171819202122func downloadImage(url: URL) -&gt; Promise&lt;URL&gt; { return Promise { fullfil, reject in let destination: DownloadRequest.DownloadFileDestination = { _, _ in let documentsURL = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)[0] let fileURL = documentsURL.appendingPathComponent(url.lastPathComponent) return (fileURL, [.removePreviousFile, .createIntermediateDirectories]) } Alamofire.download(url, to: destination).downloadProgress(closure: { (progress) in print(\"\\(progress)\") }).responseData(completionHandler: { (response) in if let error = response.error { return reject(error) } if let destinationURL = response.destinationURL { return fullfil(destinationURL) } reject(NSError.init(domain: \"myDomain\", code: 0, userInfo: nil)) }) }} And the final result, what a beautiful code! :)) 123456789101112func searchImageWithKeyword(keyword: String) { let imageLoader = ImageLoader() firstly { imageLoader.fetchImage(keyword: keyword) }.then { downloadLink -&gt; Promise&lt;URL&gt; in return imageLoader.downloadImage(url: downloadLink) }.then {downloadedURL -&gt; Void in self.updateImageAtURL(url: downloadedURL) }.catch { error in print(\"Error \\(error)\") }} A feature that I find very interesting in both frameworks, Bolts and PromiseKit, is that they allow our code run on a given thread (Main thread or background thread). This is a great feature as most of the work done in the view controller has been to update the UI. Sometimes, long-running tasks are best handled on a background thread, so as not to tie up the UI. For more details about this Thread feature, please refer to their documents: #Threading ConclusionSince I am working on CoreBluetooth, I often have to work with async methods. Too many callbacks make my project more difficult to understand and difficult to debug if errors occur. Promise make my code become a more beautiful girl ;).You can download the fully finished sample project here.Feel free to leave out your comments on my post.","link":"/2018/01/16/Asynchronous-Programming-in-Swift/"},{"title":"Advanced iOS Concurrency: Async Operations [2]","text":"In the previous post, Advanced iOS Concurrency: Operations, we walked through the Operation concepts on iOS and made a demo application that fetches some posts of mine. After downloading the cover images, they will be applied to a simple filter, then be displayed in a table view. The application, however, has not been completed yet. There’s something that went wrong with our app making the app did not show downloaded images properly. In this tutorial, we will continue where we left off.Get ready! Operation life cycleTo find out why our app did not function properly, let’s review the current source code 123456789101112class DownloadImageOperation: Operation { override func main() { guard !isCancelled else { return } URLSession.shared.dataTask(with: self.url, completionHandler: { (data, res, error) in guard error == nil, let data = data else { return } self.outputImage = UIImage(data: data) }).resume() }} The following image describes the changes in states of operations. When the main method gets called, it will execute our asynchronous task and then exit immediately making the state of the operation switch to isFinish. At that point, our asynchronous task actually has not completed yet.Currently, we’re calling to download an image inside the main method of the Operation. The root cause is related to the Operation Life Cycle itself. Thus, to support asynchronous operations in our app, we need to manually manage states of operations. Key-Value ObservingBefore implementing our custom Async Operation class, we need to learn a new concept first: KVO. I assume that you’ve not heard about this concept so we will have a quick look at it first.Key-Value Observing, aka KVO, is one of the techniques for observing the state changes of an object in Objective-C and Swift. Whenever the value of the observed properties changed, the observing block of code will execute. At the heart of KVO, the main concept is based on the Observer Pattern.Swift classes that are inherited from NSObject class have methods to allow other objects to observe their properties. Key-value observing provides a mechanism that allows objects to be notified of changes to specific properties of other objects. It is particularly useful for communication between model and controller layers in an application. Let’s create a Playground to test it. 1234567891011121314151617181920212223242526272829class CreditCard: NSObject { @objc dynamic private(set) var number: Int = 1000 func increaseNumber(by value: Int) { self.number += value }}class Person: NSObject { let cretdit: CreditCard var kvoToken: NSKeyValueObservation? init(cretdit: CreditCard) { self.cretdit = cretdit kvoToken = self.cretdit.observe(\\.number, options: .new) { (credit, change) in guard let newNumber = change.newValue else { return } print(\"New number is \\(newNumber)\") } } deinit { kvoToken?.invalidate() }}let credit = CreditCard()let person = Person(cretdit: credit)credit.increaseNumber(by: 500) Here, I define two classes: CreditCard and Person. A Person object holds a CreditCard object as a property. What I want is whenever the number property of the credit card gets changed, the person will be notified. Here is KVO comes.Run the above code in the playground, you should see the log New number is \\(newNumber) print out on your console. Why should we need to know about KVO? The answer is because the Operation class uses KVO notification. Whenever the state of Operation changes, a KVO notification will be sent.Without KVO notifications, the OperationQueue won’t be able to observe the state of our operations so that it can not get updated correctly. Thus, when we manage the state of operation by ourselves, we must ensure those KVO notifications are sent properly. Async OperationLet’s create AsyncOperation class inherited from the Operation class. 12345678910class AsyncOperation: Operation { enum State: String { case ready, executing, finished var keyPath: String { return \"is\\(rawValue.capitalized)\" } } // The rest of code} Next, We declare a property to keep track the state of the object. 12345678910var state = State.ready { willSet { willChangeValue(forKey: newValue.keyPath) willChangeValue(forKey: state.keyPath) } didSet { didChangeValue(forKey: oldValue.keyPath) didChangeValue(forKey: state.keyPath) }} The Operation base class needs to know the changes of both the old state and new state.Take a specified case as an example, the state currently is ready, then we set the state to executing. There are 4 KVO notifications should be sent: Firstly, notify the willChangeValue for isReady. Then. notify the willChangeValue for executing. After that, notfiy the willChange for isReady. Finally, notfiy the willChange for executing. After that, We override the properties of states. 123456789101112131415override var isReady: Bool { return super.isReady &amp;&amp; state == .ready}override var isExecuting: Bool { return state == .executing}override var isFinished: Bool { return state == .finished}override var isAsynchronous: Bool { return true} It’s all for managing the state of Async Operation class. When adding an operation to an operation queue, the start method is what gets called first. then it will call the main method of the operation executing the main block of code you have assigned to the operation. 1234override func start() { main() state = .executing} Remember when I mentioned that Operation has killer features that make it surpass GDC? The first one is dependencies and the other one is the capability of canceling a running operation. It’s very useful in a case where we want to stop operations that are irrelevant at a certain time. For example, to cancel downloading data when the user scrolls the table making some cells disappear.Let’s add this feature to our Async Operation class.First, we need to modify the start method to check the isCancelled property before actually calling the main method. 123456789override func start() { if isCancelled { state = .finished return } main() state = .executing} And then override the cancel method to update the state to finished 123override func cancel() { state = .finished} At this point, we’ve finished implementing our Async Operation class. It’s time to mix everything together in our app. Adding this all togetherBecause the DownloadImageOperation class executes asynchronously, we can not set Operation class as its base class, we now set AsyncOperation instead. Kindly note that to support canceling in DownloadImageOperation class, we will keep the return value of creating a data task as a property of this class so that we can cancel this URLSessionDataTask later.The DownloadImageOperation class will look like below. 123456789101112131415161718192021222324252627282930class DownloadImageOperation: AsyncOperation { let url: URL var outputImage: UIImage? private var task: URLSessionDataTask? init(url: URL) { self.url = url } override func main() { self.task = URLSession.shared.dataTask(with: self.url, completionHandler: { [weak self] (data, res, error) in guard let `self` = self else { return } defer { self.state = .finished } guard !self.isCancelled else { return } guard error == nil, let data = data else { return } self.outputImage = UIImage(data: data) }) task?.resume() } override func cancel() { super.cancel() task?.cancel() }} Let’s back to our main ViewController. To cancel the running operations, we first add new dictionary as a property of ViewController which tracks all running operations for each table view cell at a corresponding index path. 1private var operations: [IndexPath: [Operation]] = [:] Inside the func tableView(_ tableView:cellForRowAt indexPath:) delegate, after adding two operations to the operation queue, we will also add them to the operations dictionary for tracking. Additionally, if there is an operation for this index path, cancel it before holding the new one. 123456if let existingOperations = operations[indexPath] { for operation in existingOperations { operation.cancel() }}operations[indexPath] = [grayScaleOpt, downloadOpt] When the user scrolls the table, some cells disappear and the delegate func tableView(_ tableView:didEndDisplaying cell:indexPath:) gets called. At that point, we’ll also cancel the running operations for that cell ensuring that only operations of visible cells are executing. 1234567func tableView(_ tableView: UITableView, didEndDisplaying cell: UITableViewCell, forRowAt indexPath: IndexPath) { if let operations = operations[indexPath] { for operation in operations { operation.cancel() } }} Now, you should see the app now works properly. Additionally, by starting and canceling the operations wisely, we’re saving the network traffic as well as reduce the battery consumption. Those things can make our app run faster. ConclusionThere are some benefits of Operation over GCD that keep our source code maintainable and reusable.The last to mention, please careful when using Operation or GCD because Concurrency sometimes introduces bugs that are not always transparent to find and fix. In Clean Code Book, Robert C. Martin states some important points when working with multiple threads There are some basic definitions we should know when we talk about concurrency and threads: Bound resources, mutual exclusion, starvation, deadlock, and livelock. Concurrency does not always improve performance. It sometimes incurs some overhead and bugs come from it are not usually repeatable. Limit the access of the data that is shared between more than two threads. Use copies of data if there is a chance. Keep the synchronized sections as small as possible because Locks create delays and add overhead. They are expensive. Multithreaded code behaves differently in different environments: Run tests in every potential deployment environment. You can find the final project via the linkThank you for reading. References Chapter 6: Operations, Concurrency By Tutorials - Multithreading in Swift with GCD and Operations, Raywenderlich, Chapter 7: Concurrency and Multitasking, iOS 8 Swift Programming Cookbook, O’Reilly.","link":"/2020/05/30/Advanced-iOS-Concurrency-Async-Operations-2/"},{"title":"Best practice: Core Data Concurrency","text":"Some applications can survive without any data storage. Most other useful applications, however, save some state such as user configurations, user profile, goals, etc. on iOS, Apple provides Core Data as a framework to persist your valuable data. One thing to keep in mind that although CoreData can store data in a relational database it’s actually not a database engine.In this tutorial, I will share with you a bad experience I faced when I work with Core Data. Hopefully, after reading my sharing, you will avoid facing the same problem in your projects.Let’s get started. Three main components of core data stackFirst of all, I will list down the three main components of core data stack, you might or might not familiar with these terms but it’s better to get a deep understand of core data stack before digging deeper.The Core Data API, also called the stack, consists of three main components: NSManagedObjectModel: The data model describes an entity (object). NSManagedObjectContext: The objects when fetched from the persistent storage are placed in managed object context. It performs validations and keeps track of the changes made to the object’s attributes so that undo and redo operations can be applied to it, if needed. In a given context, a managed object provides a representation of a record in a persistent store. Depending on a situation, there may be multiple contexts, each containing a separate managed object representing that record. All managed objects are registered with a managed object context. NSPersistentStoreCoordinator: NSManagedObjectContext does not work directly with NSPersistentStore to store and retrieve data, but NSPersistentStoreCoordinator will do so. The main roles of NSPersistentStoreCoordinator are to managed the state of managed object context and to serialize calls to NSPersistenStore to avoid redundancy. You can find the main roles of each component by the following image We have enough knowledge of Core Data and its different components. Now, let’s move forward to the main section. Core data supports concurrencyCore Data supports multi-threading in an application, which means more than one thread can be executed in parallel to increase performance. Even some tasks can be performed in the background using a separate thread.As you might know, when working with CoreData, there are two ways to define a managed object context: NSMainQueueConcurrencyType and NSPrivateQueueConcurrencyType. It depends on us to decide which type of MOC we should create in our applications. Mainly we will work on the main one, but to avoid doing data processing on the main queue, as it might affect the user experience when doing heavy tasks on the main thread, we sometimes need to create a private queue context and perform those heavy tasks on this private context.Concurrency absolutely makes the app more effective as tasks now can do in parallel, but there are some strict rules defined by Apple we must follow otherwise we will face some unexpected behaviors, including crashes and losing data. Rule 1: Managed object contexts are stuck with the thread that they are associated with upon declaration. The first rule states that do not use the main queue context in a background thread. Most of the time, there are no-fail at all if we violate the rule. When it comes to production, however, you will soon face crashes on your dashboard, resulting in bad user experiences and more importantly, leading to losing data. Rule 2: Managed objects retrieved from a context are stuck with the same queue that the context associated with. That means do not pass any objects retrived from main context to private one and vise versa. Violate this rule will lead to the same result as rule 1. Crash, crash, crash! 😱It has been the first time I use CoreData to store valuable data of users in our app. On one hand, I did not take core data concurrency seriously at that time. On the other hand, I do not know there are some strick rules when working with concurrency in Core Data. As a result, when the app comes to production, the number of crashes had been reported to the monitor dashboard. At that time, I had no idea how they come. I could not reproduce these issues to find out the root cause was. Additionally, the crash reported by Firebase did not have enough information for an investigation. I tried reviewing the flow of my app, searching on StackOverFlow and then reading deeply Apple’s document of Core Data. Finally, the root cause comes from accessing Core Data from multiple threads. As I’m working with Core Bluetooth, the key point is that Core Bluetooth dispatches Bluetooth events in the main thread by default. However, I configurated the Bluetooth queue to a background queue to avoid locking the UI queue. Here crashes come as Core Data does not allow to access NSManagedObject among different queues strictly. To simulate this issue, I created a non-stop loop to run inserting and deleting actions in a background queue continuously. The following code illustrates how I performed the test. 1234567891011121314override func viewDidLoad() { super.viewDidLoad() // Do any additional setup after loading the view. self.doSomething()}func doSomething() { self.managedContext?.insert(person: self.person) self.managedContext?.delete(person: self.person) DispatchQueue.global(qos: .background).asyncAfter(deadline: .now() + 0.1, execute: { self.doSomething() })} Sooner or later, the crash will come to us. 1232019-10-13 12:31:55.497690+0700 CoreData-Concurrency[90636:1151728] [error] error: Serious application error. Exception was caught during Core Data change processing. This is usually a bug within an observer of NSManagedObjectContextObjectsDidChangeNotification. -[__NSCFSet addObject:]: attempt to insert nil with userInfo (null)CoreData: error: Serious application error. Exception was caught during Core Data change processing. This is usually a bug within an observer of NSManagedObjectContextObjectsDidChangeNotification. -[__NSCFSet addObject:]: attempt to insert nil with userInfo (null)2019-10-13 12:31:55.569306+0700 CoreData-Concurrency[90636:1151728] *** Terminating app due to uncaught exception 'NSInvalidArgumentException', reason: '-[__NSCFSet addObject:]: attempt to insert nil' Here are some answers from the community you can find on Stackoverflow:https://stackoverflow.com/questions/36402366/core-data-crash-attempt-to-insert-nil-with-userinfo-nullhttps://stackoverflow.com/questions/55517083/ios-core-data-serious-application-error-attempt-to-insert-nil-in-less-than Avoid crashingTo avoid the crash, the are two techniques we can apply, both of them make sure that we do not violate concurrent-confinement rules. #1The first one is to ensure that the managedObjectContext is performed on the queue that it is associated with upon initialization, which is the main queue in this case. 1234567func doSomething() { self.managedContext?.insert(person: self.person) self.managedContext?.delete(person: self.person) DispatchQueue.main.asyncAfter(deadline: .now() + 0.1, execute: { // Dispatch to main queue self.doSomething() })} In case for some reason, we can not execute the actions on the main queue (e.g importing huge data to disk) we can create multiple contexts to solve this problem. Move to #2. #2Using Core data multiple context technique.A child managed object context (MOC) does not hold a reference to the persistent store coordinator (PSC). Instead, it keeps a reference to another (MOC) as its parent. Whenever a child performs saveContext, the changes will be pushed to its parent, and keep pushing to other parents (If had). It is only when the root parent MOC performs saveContext, the changes are saved to the PSC. Let’s create a private MOC inside our PersonManagedObject class. 1private let privateMOC = NSManagedObjectContext(concurrencyType: .privateQueueConcurrencyType) Then set its parent as the main MOC. 12345init?() { ... privateMOC.parent = self.managedObjectContext} From now on, all action will be performed on this privateMOC. The method performAndWait blocks the caller from returning until the block is executed.The perform(_:) method returns immediately and the context executes the block methods on its own thread. With the performAndWait(_:) method, the context still executes the block methods on its own thread, but the method doesn’t return until the block is executed. 12345678func insert(person: Person) { ... // Some code are obmitted self.privateMOC.performAndWait { self.privateMOC.insert(object) synchronize() }} Don’t forget to call saveContext method of the parent context to save the changes to PSC. 1234567891011121314private func synchronize() { do { try self.privateMOC.save() // We call save on the private context, which moves all of the changes into the main queue context without blocking the main queue. self.managedObjectContext.performAndWait { do { try self.managedObjectContext.save() } catch { print(\"Could not synchonize data. \\(error), \\(error.localizedDescription)\") } } } catch { print(\"Could not synchonize data. \\(error), \\(error.localizedDescription)\") }} After modifying the code by using either #1 or #2, I ran the program again in a long time but there were no more crashes! ConclusionCore data is a very useful framework and certainly is indispensable in most mobile applications today. To avoid the same bad situations as I just went through, make sure you dig into its components before starting your code, especially core data concurrency.You can find my completed project at Github - Core Data ConcurrencyThanks for reading. References[1] B.M. Harwani - Core Data iOS Essentials-Packt Publishing (2011)[2] Core Data, Multithreading, and the Main Thread[3] [Multiple context CoreData] https://www.cocoanetics.com/2012/07/multi-context-coredata/","link":"/2019/09/01/Best-practice-Core-Data-Concurrency/"},{"title":"Best practice: Advanced BLE scanning process on iOS","text":"iOS developers are building applications that play both roles Peripheral and Central to exchange data with other copies apps. The data can be exchange a small of information via BLE packets or the signal strength indicator (RSSI) value from one to the others. However, keeping the app last forever in the foreground is impossible. Sooner or later, the app will enter to background mode by the user and finally will be suspended by the system depending on RAM available, power consumption and other factors. Thus, understanding the procedure of advertising and scanning on iOS devices helps you to build good applications that fit your expectations.At the end of this tutorial, we will build a simple application that acts as both a scanner and an advertiser. When two applications find each other, they will write a log record for analysis. Depending on the results, we will find out how effective our application is using Core Bluetooth.Let’s switch the gear! Foundational knowledgeAccording to the Getting Started With Bluetooth Low Energy book, the two main purposes of advertising packets are: To broadcast data for applications. To discover slaves and to connect them. The maximum size of payload each advertising packet is 31 bytes, along with the header information. Every elapsed interval, which ranges from 20ms to 10.24s, advertising packets are broadcasted blindly to notify its presence to other devices or applications. There are two types of scanning approaches: Passive Scanning: Scanners simply receives advertising packets without any further actions. Active Scanning: After receiving an advertising packet, the scanner performs a Scanning Request packet to the advertiser. After receiving the Scanning Request, the advertiser responds with a Scanning Response packet which allows the advertises to send extra data (Extra 31 bytes) to the scanner. To classify advertising packet types, we rely on three properties: connectability, scannability, and directability Adv packet type Connectability: Determines if a scanner can make a connection or not Scannability: Determines if a scanner can issue a scan request or not Directability: Determines if this packet is targeted at any particular scanners or not. ADV_IND Yes Yes No ADV_DIRECT_IND Yes No Yes ADV_NONCONN_IND No No No ADV_SCAN_IND No Yes No There are a lot more advanced topics that described in more detail in the Getting Started With Bluetooth Low Energy book, such as how data is organized in BLE devices and how to communicate with existing hardware, etc. If you want to know more, please refer to the book.Because of the scope of this post, understanding of the advertising process is good enough for us to move to the next section. Scanning and advertising on iOSSetting up the advertiser - PeripheralWe’re going to reuse my previous repo allowing an ios phone advertises as a peripheral using Core Bluetooth.First, I will generate 5 UUIDs as the services of the advertiser (Peripheral). 1234let kServiceUUID1 = \"1FA2FD8A-17E0-4D3B-AF45-305DA6130E39\"...let kServiceUUID4 = \"4FA2FD8A-17E0-4D3B-AF45-305DA6130E39\"let kServiceUUID5 = \"5FA2FD8A-17E0-4D3B-AF45-305DA6130E39\" Next, I will create a list of CBMutableService and then add them to the CBPeripheralManager object. 12345678910111213141516services.forEach { (each) in let cbService = CBMutableService(type: each.uuid.cbUUID, primary: true) var charArr = [CBMutableCharacteristic]() each.characteristics.forEach { (char) in charArr.append(CBMutableCharacteristic.init( type: char.uuid.cbUUID, properties: [.read, .write, .notify], value: nil, permissions: CBAttributePermissions(char.permissions.map { $0.cbAttributePermission } ))) } cbService.characteristics = charArr self.peripheralManager.add(cbService)} Finally, we start advertising the peripheral when its state gets ready. 12self.peripheralManager.startAdvertising([CBAdvertisementDataLocalNameKey: \"uynguyen\", CBAdvertisementDataServiceUUIDsKey: self.cbServices.map { $0.uuid }]) As the above code gets executed, we will see the following log are printed. 123456789101112Add service 1FA2FD8A-17E0-4D3B-AF45-305DA6130E39 Succeeded---&gt; Chars [&lt;CBMutableCharacteristic: 0x2802d4070 UUID = 463FED20-DA93-45E7-B00F-B5CD99775150, Value = (null), Properties = 0x1A, Permissions = 0x3, Descriptors = (null), SubscribedCentrals = ()&gt;, &lt;CBMutableCharacteristic: 0x2802d4380 UUID = 463FED21-DA93-45E7-B00F-B5CD99775150, Value = (null), Properties = 0x112, Permissions = 0x1, Descriptors = (null), SubscribedCentrals = ()&gt;, &lt;CBMutableCharacteristic: 0x2802d4620 UUID = 463FED22-DA93-45E7-B00F-B5CD99775150, Value = {length = 6, bytes = 0x486168616861}, Properties = 0x2, Permissions = 0x1, Descriptors = (null), SubscribedCentrals = ()&gt;]...Add service 5FA2FD8A-17E0-4D3B-AF45-305DA6130E39 Succeeded---&gt; Chars []===&gt; Start advertising Succeeded Setting the scanner - CentralThe next step is to set up our Central Manage - the scanner. As you might know from my previous tutorial, the code to scan nearby devices is quite simple. 1234private func startScanning() { self.centralManager?.scanForPeripherals(withServices: nil, options: [CBCentralManagerScanOptionAllowDuplicatesKey: true])} The nil value we pass to withServices param indicates that we will scan all nearby devices without specifying service uuids. The CBCentralManagerScanOptionAllowDuplicatesKey option specifies the scan should run without duplicate filtering. Once the central discover a peripheral, we will print its info including the local name and the CBAdvertisementDataServiceUUIDsKey value in the advertising packet. 12345public func centralManager(_ central: CBCentralManager, didDiscover peripheral: CBPeripheral, advertisementData: [String : Any], rssi RSSI: NSNumber) { print(\"Did found per \\(peripheral.name)\") print(\"CBAdvertisementDataServiceUUIDsKey adv value \" + advertisementData[CBAdvertisementDataServiceUUIDsKey])// ...} Let’s build and run the project, 12345Did found peripheral name: Optional(\"Uy Nguyen iPad\")CBAdvertisementDataServiceUUIDsKey adv value:Optional(&lt;__NSArrayM 0x282a79350&gt;( 1FA2FD8A-17E0-4D3B-AF45-305DA6130E39)) Looking at the log, can you spot what’s going wrong? There is a problem with the advertising packet: the CBAdvertisementDataServiceUUIDsKey value contains only 1 service, where are the other services from 2 to 5? Let’s print out full advertising packet to see what it contains. 1234[\"kCBAdvDataServiceUUIDs\": &lt;__NSArrayM 0x283460630&gt;(1FA2FD8A-17E0-4D3B-AF45-305DA6130E39), \"kCBAdvDataLocalName\": uynguyen, \"kCBAdvDataTimestamp\": 620013184.4512661, \"kCBAdvDataRxPrimaryPHY\": 0, \"kCBAdvDataIsConnectable\": 1, \"kCBAdvDataRxSecondaryPHY\": 0] Still no luck, we can not find the other services from &quot;2FA2FD8A-17E0-4D3B-AF45-305DA6130E39&quot; to &quot;5FA2FD8A-17E0-4D3B-AF45-305DA6130E39&quot;. Finding problemsIt turns out the advertising packet the Central receive depends on how we call scanForPeripherals method.If we change param withServices to an array of our service from &quot;1FA2FD8A-17E0-4D3B-AF45-305DA6130E39&quot; to &quot;5FA2FD8A-17E0-4D3B-AF45-305DA6130E39&quot; explicitly, we will see the differences. 12345678private func startScanning() { self.centralManager?.scanForPeripherals(withServices: [CBUUID(string: \"1FA2FD8A-17E0-4D3B-AF45-305DA6130E39\"), CBUUID(string: \"2FA2FD8A-17E0-4D3B-AF45-305DA6130E39\"), CBUUID(string: \"3FA2FD8A-17E0-4D3B-AF45-305DA6130E39\"), CBUUID(string: \"4FA2FD8A-17E0-4D3B-AF45-305DA6130E39\"), CBUUID(string: \"5FA2FD8A-17E0-4D3B-AF45-305DA6130E39\")], options: [CBCentralManagerScanOptionAllowDuplicatesKey: true])} Here is the log that comes to. 12345678910[\"kCBAdvDataIsConnectable\": 1, \"kCBAdvDataServiceUUIDs\": &lt;__NSArrayM 0x280708750&gt;(1FA2FD8A-17E0-4D3B-AF45-305DA6130E39), \"kCBAdvDataLocalName\": uynguyen, \"kCBAdvDataRxSecondaryPHY\": 0, \"kCBAdvDataHashedServiceUUIDs\": &lt;__NSArrayM 0x280708720&gt;(2FA2FD8A-17E0-4D3B-AF45-305DA6130E39,3FA2FD8A-17E0-4D3B-AF45-305DA6130E39,4FA2FD8A-17E0-4D3B-AF45-305DA6130E39,5FA2FD8A-17E0-4D3B-AF45-305DA6130E39), \"kCBAdvDataRxPrimaryPHY\": 0, \"kCBAdvDataTimestamp\": 620013608.239601] Now, we can see the new value contained inside the advertising packet, the kCBAdvDataHashedServiceUUIDs. But what is it?Let’s back to the Peripheral side, if you look closer to the definition of the advertising method of Peripheral object, you might know what it actually is. In short, when you make an iPhone advertise as a peripheral, if there is no space for any services UUIDs contained in the value of CBAdvertisementDataServiceUUIDsKey, these services will be moved to another space called overflow area. Another term, T_T What does exactly the overflow area mean?Basically, the overflow area is placed in the scan response packet. These service uuids are hashed by Apple alg and are discovered only by an iOS device explicitly scanning for them. In our case, because we pass our service uuids from 1F to 5F when start scanning, we will get this kCBAdvDataHashedServiceUUIDs value in the advertising packets. To verify this statement, I use a tool introduced by Apple for BLE debugging - (A New Way to Debug iOS Bluetooth Applications), to grab the advertising packet from our Peripheral for analyzing.And here is the result Advertising packet type: ADV_IND, which means the scanner can make a connection to it; and a scanner can issue a scan request; and its packets do not target at any particular scanners. The yellow box is the advertising data: (Data: 02 01 1A 11 06 39 0E 13 A6 5D 30 45 AF 3B 4D E0 17 8A FD A2 1F 09 09 75 79 6E 67 75 79 65 6E), length = 31 bytes; it contains CBAdvertisementDataLocalName (75 79 6E 67 75 79 65 6E &gt; “uynguyen”) and our first service uuid 1F A2 FD 8A 17 E0 4D 3B AF 45 30 5D A6 13 0E 39 (39 0E 13 A6 5D 30 45 AF 3B 4D E0 17 8A FD A2 1F). The scan response packet (SCAN_RSP) contains the other info that the advertising packet is not enough length to carry on. In our case, it contains the other services from 2F to 5F. Understanding this packet is quite complex to put in this tutorial so I will skip explaining it for now. I have another tutorial working on this packet later. In conclusion, what we have found here is: Advertising, while the app is in background, performs differently than when it is in the foreground. CBAdvertisementDataLocalNameKey is ignored. All service UUIDs contained in the value of the CBAdvertisementDataServiceUUIDsKey advertisement key are placed in a special “overflow” area; they can be discovered only by an iOS device that is explicitly scanning for them. TestingThe table below summarizes what we have investigated. 1* YES means the Central is able to find the Peripheral. Case 1 - Both Peripheral and Central’s screens turn on \\ Peripheral Background Peripheral Foreground Central Background Yes Yes Central Foreground Yes Yes Case 2 - Peripheral’s screen turn off (locked), Central’s screen turn on \\ Peripheral Background Peripheral Foreground Central Background Yes Yes Central Foreground Yes Yes Case 3 - Central’s screen turn off (locked), Peripheral’s screen turn on \\ Peripheral Background Peripheral Foreground Central Background No No Central Foreground No No Case 4 - Both Peripheral and Central’s screens turn off (locked) \\ Peripheral Background Peripheral Foreground Central Background No No Central Foreground No No From the above experiments, regardless of the state of the device playing Peripheral role, the screen of the device playing Central mode must turn on so that it can scan nearby peripherals. In other words, if we’re building an application that allows an iOS device to discover other nearby iOS devices, we have to run both Central and Peripheral modes on each device AND the most important, if two devices want to find each other, either the screen must be turned on.There is a technique (It’s likely a trick) to get over this issue, is that scheduling periodically to push notifications to your iOS devices, which immediately turn the screen on so that the Central can discover nearby Peripherals.While the app is in background, it performs differently than when it is in the foreground. One of them is the frequency of advertising packets to be sent may decrease. As a result, a Scanner in background finds nearby peripherals is slower compared to when it is in foreground. ConclusionCongratulation! We walked through a tutorial to get a deeper view of how CoreBluetooth on iOS works in both Central and Peripheral modes. Hope you find this post interested!If you have any comments, feel free to send me an email to uynguyen.itus@gmail.com or leave your questions on the comment box. Made with love.","link":"/2020/08/23/Best-practice-Advanced-BLE-scanning-process-on-iOS/"},{"title":"Best practice: How to deal with Bluetooth Low Energy in background","text":"PrefaceWhen working with CoreBluetooth, have you ever concerned that how the BLE app on iOS can survive when it is terminated by the system? How can we bring it back to the background? Is there anything like a service on Android that can last forever? You can find the answer to all these questions in this post. Read on! Application life cycle on iOSBefore getting a deep understanding of how we can survive our app in the background, it’s good to start with the application life-cycle on iOS.As you might know, there are five main states of every iOS app.Not running The app either has not been launched or was running but was terminated by the system or the user.Inactive It is the initial state before the app actually transitions to a different state.Active The app is running in the foreground and receiving events from the user.Background The app is in the background and be invisible to the user. However, an app that requests extra execution time may remain in this state for a period of time. In addition, the app will transit into the inactive state before entering into the background mode.Suspended The app is in the background but it does not allow to execute any code. The app is moved to this state automatically by the system and it will not receive any events before the system does so. When the foreground apps need more memory, the system may terminate the suspended apps to make more space for the foreground apps. Note that we can not predict when the suspended app will be terminated by the system. After being terminated, the app returns to the not running state. BLE issues with the application life cycleAs mentioned, when the app enters to the background, the app might be terminated by the system if it need evict resources for other applications. Unlike Android OS, after being killed by the system, we can re-start a service to keep your app alive. On iOS, once the app is terminated by the system, there is no way to bring it back to the background. As a result, any Bluetooth events that dispatch from the device will never come to the app. It means your app might miss the indications that are triggered by users, such as play a track of music on their phone when pressing physical buttons from a BLE device. Apple gives out an example called “Smart door”. The main idea of this example is to have an automatic interaction between the app and the lock of the door. Imagine we’re developing an application that can automatically lock and unlock the door when the user goes in and go out their home, respectively. However, the main problem of this implementation is to keep the connection between the two, the phone and the lock of the door. While using their phone, users do a variety of actions on the phone: open / close applications, toggle the Bluetooth setting, enter the airplane mode, reboot the phone, etc. These interactions can lead to our app is killed by the system, forever. In this case, the app will not be able to reconnect to the lock when the user returns home, and the user may not be able to unlock the door. To deal with this issue, Apple provides a method called State Preservation and Restoration (CoreBluetooth background processing). State Preservation and Restoration is built-in to CoreBluetooth that allows our app can be relaunched into the background when it’s terminated by the system.At the bottom line, iOS takes a snapshot of all the Bluetooth-related objects that were going on in our app. Subsequently, if there is any Bluetooth event which related to the Bluetooth-related objects our app were interacting with comes to the phone, our app will be waked up from the grave. That’s amazing! Implement State Preservation and RestorationTo demonstrate State Preservation and Restoration technique on iOS, I’m going to reuse the source code from the previous post Play Central And Peripheral Roles With CoreBluetooth but we’ll add some more code to the projects to make it become magical.First, I set my iPad act as a Peripheral with a uuid “1FA2FD8A-17E0-4D3B-AF45-305DA6130E39”, which is generated via uuidgen command on Mac. Then, make it start advertising with local name “iPad”. If there is a connection established by a central manager, the in/out logs will print so we know whether the connection is made successfully. When the “Send Notify” button is touched, the app will notify a data string “Say something cool!” via the “463FED21-DA93-45E7-B00F-B5CD99775150” that is defined as an encrypted notifiable characteristic of the app to the connected central manager. The next thing we need to do is go back to the Central Manager app and create a Restore Identifier for the CBCentralManager objects to be taken over by the operating system when the application is terminated, I chose “YourUniqueIdentifierKey” string. Next, we will implement the willRestoreState provided by Apple. 123456789101112131415161718public func centralManager(_ central: CBCentralManager, willRestoreState dict: [String : Any]) { LocalNotification.shared.showNotification(id: \"willrestorestate\", title: \"Manager will restore state\", body: \"\", timeInterval: 1.0) let systemSoundID: SystemSoundID = 1321 AudioServicesPlaySystemSound (systemSoundID) if let peripherals = dict[CBCentralManagerRestoredStatePeripheralsKey] as? [CBPeripheral] { peripherals.forEach { (awakedPeripheral) in print(\"\\(Date.now). - Awaked peripheral \\(String(describing: awakedPeripheral.name))\") guard let localName = awakedPeripheral.name, localName == \"iPad\" else { return } self.connectedDevice = Device.init(peripheral: awakedPeripheral) } }} Here, when the centralManager(_:, willRestoreState) is called, I will play a soundtrack and show a pop-up with the name of awaked peripheral to inform that the app is actually awaked by the system. Inside the method, we also can get a dictionary full of state information. When we retrieved with the CBCentralManagerRestoredStatePeripheralsKey key, this holds things like an array of CBPeripheral, containing all peripherals that were connected or pending connection at the time the application was terminated by the system. Here, I iterate through the array of peripherals, check if there is my interested peripheral, then initialize a Device and set it back to the connectedDevice variable so that I can receive updated values from the peripheral. I also add the code that will popup a local notification at the appDidFinishLaunching delegate and at peripheral(:didUpdateValueFor:chacracteristic) method for testing. 123456func peripheral(_ peripheral: CBPeripheral, didUpdateValueFor characteristic: CBCharacteristic, error: Error?) { if let data = characteristic.value { let str = String.init(data: data, encoding: .utf8) ?? \"\" LocalNotification.shared.showNotification(id: \"DidUpdateValue\", title: \"Peripheral did update value from grave!\", body: \"\\(str)\", timeInterval: 1.0) }} 12345678func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) -&gt; Bool { let _ = BluetoothManager.sharedInstance let _ = LocalNotification.shared LocalNotification.shared.showNotification(id: \"didfinishlaunch\", title: \"App did finish launching\", body: \"Options: \\(launchOptions?[UIApplicationLaunchOptionsKey.bluetoothCentrals] ?? \"nil\")\", timeInterval: 1.0) return true} It’s time to run our experiment! I’m going to use two methods to simulate background app termination by the system.The first one is using XCode. Run the app from Xcode. Stop the app by pressing the “Stop” button from Xcode. Restart the app from Xcode. The second one is doing the following steps: Press the home button to enter the app to background. Long press the power button until you see “slide to power off”. Release the power button and long press the home button for about 5s (until you see your home screen reappeared). In the below demonstration, you will see I use both of them for testing. Let’s see something cool happens! Here is the log printed from Xcode. 123456789102018-08-18 19:46:35.6560 App did finish lauching with option nil2018-08-18 19:46:35.6620 Manager will restore state2018-08-18 19:46:35.6650. - Awaked peripheral Optional(\"iPad\")2018-08-18 19:46:35.6660 Manager did update state 52018-08-18 19:46:35.6950 App did become active2018-08-18 19:46:35.7080 Found iPad2018-08-18 19:46:35.7100 Did connect.2018-08-18 19:46:51.5170 App will resign active2018-08-18 19:46:52.1100 App did enter backgroundMessage from debugger: Terminated due to signal 9 First, I connected to the iPad device, then simulated the termination by Xcode (Relaunch the app from Xcode), after that you see the centralManager(_:, willRestoreState) delegate is triggered by the popup. Later, I simulated the termination by using the second method, when the home screen reappeared, one thing for sure that the app was terminated. Next, I pressed the “Send notify” button from the iPad (Which was playing as a Peripheral) to send a BLE event to the app. Surprisingly, the centralManager(_:, willRestoreState) was called immediately as we can see a local notification showed up, then another one showed the BLE data received from the peripheral (The “Say something cool!” string). It really worked! The app now can last forever! But wait a minute, it’s not so simple as so. This approach still has some limitations that we will discuss later on this post. As you may notice that there is a difference between the two ways I used to simulate background termination, when the app was relaunched from the first way, the option value of the delegate application(application:didFinishLaunchingWithOptions:) always nil, while we could extract the [UIApplicationLaunchOptionsKey.bluetoothCentrals by using the second way (The value of launchOptions?[UIApplicationLaunchOptionsKey.bluetoothCentrals] will return “YourUniqueIdentifierKey” string). I don’t know the reason why it happened. But one thing for sure that the second approach is better than the first one since it matches with the Apple doc. *”When your app is relaunched by system, you can retrieve all the restoration identifiers for the central manager objects the system was preserving for your app”.* So, in application(application:didFinishLaunchingWithOptions:), we’re able to get a list of UUID that represent all of the CBCentralManager objects that were active when application was terminated and that Core Bluetooth and iOS took over while you were terminated. Use UIApplicationLaunchOptionsBluetoothCentralsKey to get any central we may have instantiated before being zapped. Loop through the array of centralManagerUUID and find the one matched the Restoration Identifier we’re interested in. LimitationsWhen the user force kill the app from the multiple task viewIf the user force quit the app from the multiple task view, there is no chance so that the app can wake up from the restoration event. But luckily, there is another technology we can leverage to put the app back into the background named “iBeacon”. In the next post, I will guide you how to implement this interesting technology into our app. When the user reboots phoneIf the user resets the phone, the app will be killed forever. By leveraging the CoreLocation, we can solve the problem. In the next part, I will show you how to do that. Final thoughtsIn this post, we walked through the iOS app life cycle, also I showed you how to keep the app survive even it was terminated by the system. The contents of this post are really interesting and they are formed from my real working experiments.Hope you will find this post useful.","link":"/2018/07/23/Best-practice-How-to-deal-with-Bluetooth-Low-Energy-in-background/"},{"title":"Best practice: iBeacon","text":"Welcome to the next part of the series of “How to deal with BLE in the background“.In the previous part, I guided you how to keep your app alive as long as possible when your app enters to background mode by using State Preservation and Restoration technique supported by Apple. However, there are some usecases this technique can not handle, as described below (refer to Apple document: Conditions Under Which Bluetooth State Restoration Will Relaunch An App)As you can see, there is a common case when users force quit the app from the multiple task view (Whether accidentally or intentionally), the Restoration technique can not awake your app. Let’s imagine that your app has a feature allows users to press a button on your BLE-connected devices to find where their phone is, but if your app is not running or is not able to wake up to handle the BLE signal sent from your devices, this feature would be useless.In this post, I will show you a technique using iBeacon to deal with this case, which makes your app another chance to wake up despite it is terminated by users. Let’s drive-in! Welcome to the world of iBeaconiBeacon is a protocol first introduced by Apple in WWDC 2013. “iBeacon is based on Bluetooth low energy proximity sensing by transmitting a universally unique identifier picked up by a compatible app or operating system. The identifier and several bytes sent with it can be used to determine the device’s physical location, track customers, or trigger a location-based action on the device such as a check-in on social media or a push notification” (Wiki).iBeacon application is very diverse like location-based services, mobile commerce or advertising, to name a few.“The Automatic Museum Guide” is a project that is very impressed me built on iBeacon technology. The app allows visitors to explore exhibits by showing the appropriate contents by tracking their location and their distance with the beacon. That’s a brilliant idea! How it worksApple has standardized the content of iBeacon advertisement data. It consists of a 16 byte UUID, the major and minor version. These three factors are unique for each beacon. A last field in the packet is TX power used to determine how close you are to the beacon.A beacon broadcasts this packet in its range, far from 20m to 300m, at regular intervals of time. These packets are automatically detected by nearby phones, then the app will perform a pre-defined action like showing a notification or pop-up a promotion code. Although iBeacon is based on Bluetooth low energy technology, one of the main differences between the two is iBeacon is one-way transmit technology, by which I mean only the phone can receive data from iBeacon devices. iOS integration: start advertising as an iBeaconFirstly, we need a beacon so that we can do the next step. I’m going to use my iPad to act as a beacon by using a CLBeaconRegion object in CoreBluetooth on iOS.The main UI just simply contains two main buttons that will start and stop the advertisement of the iBeacon, respectively. 123456let region = CLBeaconRegion(proximityUUID: self.uuid!, major: self.major, minor: self.minor, identifier: self.identifier)let peripheralData = region.peripheralData(withMeasuredPower: nil)peripheral.startAdvertising(((peripheralData as NSDictionary) as! [String : Any])) Then, we implement the peripheralManagerDidStartAdvertising(CBPeripheralManager, Error?) delegate to check if the beacon advertises successfully. 1234567func peripheralManagerDidStartAdvertising(_ peripheral: CBPeripheralManager, error: Error?) { if error == nil { print(\"Successfully started advertising our beacon data.\") } else { print(\"Failed to advertise our beacon. Error = \\(String(describing: error))\") }} To stop advertising 1peripheralManager?.stopAdvertising() Leverate iBeacon technology to make our app last foreverFirstly, Inside the didFinishLaunchingWithOptions method of AppDelegate class, I will show a notification to get notified whenever our app is relaunched. 1234func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -&gt; Bool { NotificationHandler.shared.showNotification(title: \"App did launch\", body: \"\") return true} After the main view appears, I then tell the location manager to start monitoring the given region and to start ranging iBeacons within that region 1234func startMonitoring() { locationManager.startMonitoring(for: beaconRegion) locationManager.startRangingBeacons(in: beaconRegion)} By default, monitoring notifies you when the region is entered or exited regardless of whether your app is running. Ranging, on the other hand, monitors the proximity of the region only while your app is running. That’s all for setting up. In the following demonstration, you will see I open the app then terminate it from the multiple task view. After that, I press the “Start advertising” button on my iPad (The beacon). You will see the app was relaunched immediately even it had been killed (The “App did launch” notification showed up). That’s amazing. Note: Don’t expect to receive an event right away, because only boundary crossings generate an event. In particular, if the user’s location is already inside the region at registration time, the location manager doesn’t automatically generate an event. Instead, your app must wait for the user to cross the region boundary before an event is generated and sent to the delegate. ConclusionsOne of the most interesting things of iBeacon is iBeacon applications can be waked up event it has been terminated by the user. It means iBeacon applications can last forever. To download the completed projects, please click to the following Github links: Act as an iBeacon: https://github.com/uynguyen/iBeaconDevice Central manager app: https://github.com/uynguyen/CentralManager-iBeacon Feel free to shot me an email if you have any questions. References[1] Region Monitoring and iBeacon","link":"/2018/08/18/Best-practice-iBeacon/"},{"title":"Best practice: iOS vs Android Bluetooth","text":"Bluetooth technology has become an integral part of modern mobile applications, enabling seamless wireless communication between devices. Whether it’s for connecting to a wireless headset, transferring files, or interacting with smart home devices, Bluetooth plays a crucial role in enhancing user experience. For mobile developers, understanding how to implement Bluetooth functionality is essential. In this post, we’ll dive into a detailed comparison of the Bluetooth development frameworks for iOS and Android. We’ll explore the key differences and similarities between these two platforms, covering everything from initial setup to data transfer and error handling. By the end of this comparison, you’ll have a clear understanding of how to leverage Bluetooth technology in your mobile applications, regardless of whether you’re developing for iOS or Android. To have a better visualization, I made an image below to summarize of the flow to establish a connection on Android and iOS At first glance, the two flows appear quite similar. However, the Android flow includes extra steps. Although the connection process is more complex on Android compared to iOS, it provides greater control over the returned data. Let’s break down the flow into three major steps for discussion: Scanning, Getting Ready, Interacting, and Closing. Each of these steps involves specific actions and considerations that contribute to the overall functionality and efficiency of the connection process. ScanningIn the scanning phase, the processes are quite similar between Android and iOS, from initiating a scan to creating a connection. The main difference is that there is more information about the peripheral in the scan result on Android than on iOS. The most interesting value is the MAC address of the device. iOS does not expose this value and instead provides a random UUID.UUIDs on iOS are generated per application and per device pairing, and their lifespan is tied to the session or until the device is forgotten, so do not rely on it to identify or reconnect to your devices. iOS does not expose the MAC address for several reasons, primarily related to privacy and security. By hiding the MAC address, Apple ensures that apps and third parties cannot misuse this information for tracking or profiling users and also helps prevent illegal activities by attackers. One possible solution to overcome this limitation is to include your own unique identifier in the advertising packet, which will be available on all platforms. Another important note is that the Android OS prevents scan start-stops more than approximately 5 times in 30 seconds (please note that this value varies from device to device). Calling the startScan method too frequently in a short time will lead to no devices being discovered. The last common value is the signal strength value, RSSI (Received Signal Strength Indicator), which indicates how far the device is from the phone. The range is from -30 to -99; the closer the value is to -30, the closer the device. Getting ReadyOnce your device has been discovered, the next step is to make it ready so you can perform read and write actions. There are two different approaches to making a device “ready.” The first approach is action on-demand, which involves doing nothing until necessary. This means you don’t need to discover services/characteristics or set notifications until your application performs read or write commands. The advantage is a shorter connection phase, as your application doesn’t need to discover all services and characteristics, set notifications, or handle errors if any fail. The disadvantage is that the first read or write operation will take more time. The second approach involves discovering all Bluetooth profiles upfront and making the device ready for any command. The downsides and upsides are the opposite of the first approach. There is nothing right or wrong with each approach; it’s just a matter of preference. So choose the one that suits you best. For me, I prefer to go with the second approach, as described in the image. The setup phase on iOS is quite simple. Your application just needs to discover all services. For each service, you then call to discover all its characteristics. Finally, set notifications if the characteristics support value changes. You might want to keep a reference to each characteristic item (CBPeripheral) so you can perform read and write operations. On the other hand, the “make ready” flow is quite complicated for Android. If you’re an iOS developer, you might not interact much with the GATT Descriptor in your application. First, you need to get familiar with the GATT Descriptor and MTU (Maximum Transmission Unit) concepts. GATT Descriptor provides extra information about the characteristic they are associated with. For example, when you read a temperature value from a BLE thermometer, the characteristic might have a descriptor indicating the unit of measurement in Celsius or Fahrenheit. The most common GATT Descriptor is the Client Characteristic Configuration Descriptor (CCCD), which you will use to enable/disable notifications/indicators for a characteristic.The main difference in notification and indication types is the reliability. Notifications are sent by the peripheral without requiring an acknowledgment from the central device. In contrast, indications require an acknowledgment from the central device. It’s simple to set a notification on iOS by calling CBCharacteristic.setNotify() and the system will do the rest for you. It will automatically identify the notification type and set the correct value. On Android, you must call it yourself. The following sample code demonstrates how you can set a notification for your characteristic on Android: 12345678910111213141516171819202122232425262728final UUID CCCD_UUID = UUID.fromString(\"00002902-0000-1000-8000-00805f9b34fb\");if (!gattServer.setCharacteristicNotification(characteristic, true)) { return false;}final boolean canNotify = (characteristic.getProperties() &amp; BluetoothGattCharacteristic.PROPERTY_NOTIFY) &gt; 0;final boolean canIndicate = (characteristic.getProperties() &amp; BluetoothGattCharacteristic.PROPERTY_INDICATE) &gt; 0;if (!canNotify &amp;&amp; !canIndicate) { // Do not support notification/indication, doing nothing return true;}final BluetoothGattDescriptor cccDescriptor = characteristic.getDescriptor(CCCD_UUID);if (cccDescriptor == null) { // Can't find the descriptor on the characteristic? return false;}if (cccDescriptor.setValue(canNotify ? BluetoothGattDescriptor.ENABLE_NOTIFICATION_VALUE : BluetoothGattDescriptor.ENABLE_INDICATION_VALUE)) { gattServer.writeDescriptor(cccDescriptor); return true;}return false; The final step is optional: request to change the MTU value.MTU (Maximum Transmission Unit) refers to the largest amount of data that can be sent in a single Bluetooth packet. By default, the MTU value in BLE is 23 bytes, in other words, for a single read and write command, the maximum bytes your application/device can deliver is 23 bytes (with a 3-byte header), but it can be negotiated between the central and peripheral devices up to 517 bytes. In iOS, you don’t directly request an MTU size; instead, the MTU is automatically negotiated between the central and peripheral devices during the connection process. On Android, use BluetoothGatt.requestMtu() to request a specific MTU size and handle the response in BluetoothGattCallback.onMtuChanged(). It’s a common mistake to forget to increase the MTU while your device is sending more than 20 bytes per request, leading to missing data in the packet. One important comment regarding establishing connections is that there is a maximum number of devices that can connect simultaneously. There are no offical documents for this number, but many developers have found that on iOS around 7 - 10 devices, while on Android it around 10 - 20 depends on phone model and Android version. 123456789101112private final BluetoothGattCallback gattCallback = new BluetoothGattCallback() { @Override public void onMtuChanged(BluetoothGatt gatt, int mtu, int status) { if (status == BluetoothGatt.GATT_SUCCESS) { // MTU size change successful Log.d(\"MTU\", \"MTU changed to \" + mtu); } else { // MTU size change failed Log.d(\"MTU\", \"MTU change failed with status \" + status); } }}; InteractingUpon completing all the steps above successfully, your device is now ready to use. You can read values from a characteristic, transfer data to a specific one, or read the RSSI value to determine the distance. Make sure you handle the value changes properly by checking from which characteristic the value comes. It is worth mentioning that on iOS, if your application transfers a large amount of data to the device (e.g., transferring a file), you should wait for the next peripheralIsReady event to be triggered before sending the next packet. Continuously sending multiple packets without waiting for this event might put pressure on the queueing buffers, leading to missing packet. 123func peripheralIsReady(toSendWriteWithoutResponse peripheral: CBPeripheral) { // Ready to send next packet} ClosingOnce again, the disconnection step on iOS is very simple. You just need to call the cancelPeripheralConnection method. On Android, you need to do more than one operation: disconnect the device and close the Bluetooth GATT. Remember that calling disconnect only cancels the connection with the peripheral, it does not release all the resources (e.g., available slots in the Bluetooth stack) until you call close. You use disconnect when you want to temporarily end the connection but might reconnect to the device later without needing to fully reset the GATT configuration. You use close when you are done with the Bluetooth connection entirely and want to ensure all resources are cleaned up. ConclusionIn this post, we explored the important points of implementing Bluetooth functionality in mobile applications for iOS and Android. Through our detailed comparison, several key points emerged that highlight both the similarities and differences between these two platforms. iOS Core Bluetooth offers a robust and straightforward framework that integrates seamlessly with the iOS ecosystem. It provides a clean and consistent API. The Android Bluetooth, on the other hand, offers flexibility, extensive capabilities and it supports a wide range of Bluetooth functionalities. While the setup and implementation might be slightly more complex compared to iOS, Android’s Bluetooth API provides powerful tools for handling Bluetooth interactions effectively. RefsThe Ultimate Guide to Android Bluetooth Low EnergyThe Ultimate Guide to Apple’s Core Bluetooth","link":"/2024/06/30/Best-practice-iOS-vs-Android-Bluetooth/"},{"title":"Best practice: iOS background processing - Background App Refresh Task","text":"Unlike Android, iOS has restrictions for the use of background processing in an attempt of improving battery life and user experience. When your apps enter to background mode, it’s time developers get out of control of their app. How and when your app gets a chance to execute your task totally depends on the system. At the heart of iOS, Apple uses its own internally-complex algorithm to determines which apps are allowed to run in the background, based on various factors such as the pattern of user activity, current battery state, etc.In this tutorial, we will learn how to request periodic execution time on iOS. After understanding how it works, we will apply this technique to a BLE-based app in some specific cases in the next tutorial.Let’s rock! Foundational knowledgeBefore taking deep dive into practice, it’s good to understand how iOS manages application states. It’s been the first time Apple officially announces a video that describes top factors contributing to the app launch times at WWDC (WWDC 2020 - Background execution demystified). To summarize, Apple designs iOS in a way allowing applications to keep its content up to date on one hand. On the other hand, iOS must adapt to its major goals: Battery life: allowing background execution while maintaining all-day battery life. Performance: ensure background execution does not have any negative effect on active usage. Privacy: Users should be aware of background tasks based on their particular usage patterns. Respecting user intent: if a user takes a certain action, make sure the system responds to correctly. With these goals in mind, here are the top 7 factors that play a role in system scheduling of background execution. Critical low battery: When the phone is about to run out of battery (&lt; 20%), background execution will be pause by the system to avoid battery usage. Low power mode: When users change to phone to low power mode, the user explicitly indicates that the system should preserve battery for critical tasks only. Background App refresh setting: The user can toggle the setting to allow or not a specified app can run background tasks. App usage: There is a limit of resources on the phone so that the system must priorities which apps it should allocate resources for. Typically, apps that the user uses the most. Apple also mentioned to “On-device predictive engine” that learns which apps the user often uses and when. The on-device predictive engine will rely on this information to priorities background execution. App switcher: Only apps are visible in App Switcher have opportunities to run background tasks. System budget: Ensure background activities do not drain battery and data plans, there is a limit of battery and data of background execution throughout the day. Rate limit: The system performs sone rate-limiting per launch. and some other factors: Airplane mode, device temperature, display, device lock state, etc. CapabilitiesMake sure your app has added these following capabilities Prior to iOS 13It’s quite simple to set up a background fetch prior to iOS 13.Inside the application(_:didFinishLaunchingWithOptions) method, we should add the following command. 1UIApplication.shared.setMinimumBackgroundFetchInterval(UIApplication.backgroundFetchIntervalMinimum) The setMinimumBackgroundFetchInterval specifies the minimum amount of time that must elapse between background fetch executions. However, the exact timing of the event is up to the system. Generally, UIApplicationBackgroundFetchIntervalMinimum is a good default value to use. Once your app has a chance to perform background tasks, the event application(_:,performFetchWithCompletionHandler) will be triggered. 1234func application(_ application: UIApplication, performFetchWithCompletionHandler completionHandler: @escaping (UIBackgroundFetchResult) -&gt; Void) { Logger.shared.debug(\"\\(Date().toString()) perfom bg fetch\") completionHandler(.newData)} Don’t forget to call completionHandler callback. If you do not call this callback, the system does not aware your task has been completed, which leads to limiting your app from waking up on the next events To simulate background fetch, from the tab bar &gt; Debug &gt; Simulate background fetch. Note that it works only when running on real devices. iOS 13+, Advance Background processing - WWDC 2019 and Background execution demystified - WWDC 2020At WWDC 2019, Apple introduced a new framework for scheduling background work: BackgroundTasks. This new framework does better support for tasks that are needed to be done in the background. There are two kinds of tasks supported by BackgroundTasks framework: BGAppRefreshTaskRequest, and BGProcessingTaskRequest. With the presence of the new framework, Apple marked deprecated on the old one from iOS 13, and no longer support on MacOS.Firstly, we have to register the identifiers of background tasks executed in our app. Open info.plist file, and add the following information. 12345&lt;key&gt;BGTaskSchedulerPermittedIdentifiers&lt;/key&gt;&lt;array&gt; &lt;string&gt;YOUR_REFRESH_TASK_ID&lt;/string&gt; &lt;string&gt;YOUR_PROCESSING_TASK_ID&lt;/string&gt;&lt;/array&gt; Forget the above step leading to a crash at runtime. 12020-10-11 08:24:40.648838+0700 TestBgTask[275:5188] *** Terminating app due to uncaught exception 'NSInternalInconsistencyException', reason: 'No launch handler registered for task with identifier com.example.bgRefresh' BGAppRefreshTaskRequest is used when you need to execute a task in the background in a short time.Refresh tasks like fetching social media feed, new emails, latest stock prices, etc are appropriate to schedule by BGAppRefreshTaskRequest. 30s is the time the system allows your task to execute per launch. Several minutes of run times to finish your work when you register a BGProcessingTaskRequest. Tasks such as Core ML training on the device should be registered by a BGProcessingTaskRequest. To register background tasks, inside the application(_:didFinishLaunchingWithOptions) method, we should add the following command. 1234567891011121314151617181920212223242526272829303132333435363738394041424344 func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -&gt; Bool { if #available(iOS 13, *) { BGTaskScheduler.shared.register(forTaskWithIdentifier: appRefreshTaskId, using: nil) { task in Logger.shared.info(\"[BGTASK] Perform bg fetch \\(appRefreshTaskId)\") task.setTaskCompleted(success: true) self.scheduleAppRefresh() } BGTaskScheduler.shared.register(forTaskWithIdentifier: appProcessingTaskId, using: nil) { task in Logger.shared.info(\"[BGTASK] Perform bg processing \\(appProcessingTaskId)\") task.setTaskCompleted(success: true) self.scheduleBackgroundProcessing() } } } @available(iOS 13.0, *) func scheduleAppRefresh() { let request = BGAppRefreshTaskRequest(identifier: \"YOUR_REFRESH_TASK_ID\") request.earliestBeginDate = Date(timeIntervalSinceNow: 5 * 60) // Refresh after 5 minutes. do { try BGTaskScheduler.shared.submit(request) } catch { print(\"Could not schedule app refresh task \\(error.localizedDescription)\") } } @available(iOS 13.0, *) func scheduleBackgroundProcessing() { let request = BGProcessingTaskRequest(identifier: appProcessingTaskId) request.requiresNetworkConnectivity = true // Need to true if your task need to network process. Defaults to false. request.requiresExternalPower = true // Need to true if your task requires a device connected to power source. Defaults to false. request.earliestBeginDate = Date(timeIntervalSinceNow: 5 * 60) // Process after 5 minutes. do { try BGTaskScheduler.shared.submit(request) } catch { print(\"Could not schedule image fetch: (error)\") } }} One more thing that needs to be done. When the app enters to the background, we will start scheduling background tasks. 1234567func applicationDidEnterBackground(_ application: UIApplication) { Logger.shared.info(\"App did enter background\") if #available(iOS 13, *) { self.scheduleAppRefresh() self.scheduleBackgroundProcessing() }} As always, It’s important to call task.setTaskCompleted(success: true) as quick as possible.You might notice that after calling task.setTaskCompleted(success: true), we need to call self.scheduleAppRefresh() and self.scheduleBackgroundProcessing() again to re-schedule these tasks to the system. Simulate background task and background processingFortunately, Apple supports a way to trigger background execution.After submitting your task to the system, pause the application by any break point. Then, enter the following command to the Xcode console. 1e -l objc -- (void)[[BGTaskScheduler sharedScheduler] _simulateLaunchForTaskWithIdentifier:@\"YOUR_REFRESH_TASK_ID || YOUR_PROCESSING_TASK_ID\"] The output should be 12345672020-10-11 08:53:58.628667+0700 TestBgTask[381:17115] 💚-2020-10-11 08:53:58.628 +0700 Start schedule app refresh(lldb) e -l objc -- (void)[[BGTaskScheduler sharedScheduler] _simulateLaunchForTaskWithIdentifier:@\"com.example.bgRefresh\"]2020-10-11 08:54:01.927263+0700 TestBgTask[381:16973] Simulating launch for task with identifier com.example.bgRefresh2020-10-11 08:54:03.669153+0700 TestBgTask[381:17095] Starting simulated task: &lt;decode: missing data&gt;2020-10-11 08:54:07.560697+0700 TestBgTask[381:17095] Marking simulated task complete: &lt;BGAppRefreshTask: com.example.bgRefresh&gt;2020-10-11 08:54:07.560750+0700 TestBgTask[381:17012] 💙-2020-10-11 08:54:06.045 +0700 [BGTASK] Perform bg fetch com.example.bgRefresh2020-10-11 08:54:07.563846+0700 TestBgTask[381:17012] 💚-2020-10-11 08:54:07.562 +0700 Start schedule app refresh Expectation vs RealityYou might expect that background execution would be evenly distributes through out the day. However, here is what we observe in reality. Because of the 7 factors I introduced at the beginning of this tutorial, the “On-device predictive engine” learns the user usage pattern and understands that the user typically opens the app in the morning, lunchtime, and in the evening. That’s why the system will allow your background tasks to launch just before the user foregrounds the app. Other factors that affect the result are if the user toggled “Low power mode”, or if the phone fell into the critical low battery state. Best advices Background tasks will not be run until the first device unlocks after the reboot. We can check if the user is in low power mode:12ProcessInfo.processInfo.isLowPowerModeEnabledNSProcessInfoPowerStateDidChange We also can check the “background refresh setting” status.12UIApplication.shared.backgroundRefreshStatusUIApplication.backgroundStatusDidChangeNotification Minimize data usage: Using thumbnails instead of full images, and only download what’s really necessary. Minimize power consumption: avoid unnecessary hardware usage such as GPS, accelerometer, etc. Also, make sure you complete the task as soon as possible. Use BackgroundURLSession to offload the work from the app to the system. SummaryIn this post, we take a deep dive into what factors contributed to your background executions, and understand are key differences between BGAppRefreshTaskRequest and BGProcessingTaskRequest. We also take a demo project to see how it actually works in reality.Next time, you can choose what kind of request is most appropriate to your tasks, and how you can respond gracefully to your user’s intent.Hopefully, the information that this post brings in helps you build better applications: freshness and optimization.There is another technique to wake your app up, silent notification. We will talk about it in the next tutorial.Happy weekend! References Background execution demystified WWDC 2020 Advances in App Background Execution WWDC 2019","link":"/2020/09/26/Best-practice-iOS-background-processing-Background-App-Refresh-Task/"},{"title":"ANCS: Apple Notification Center Service","text":"PrefaceANCS, stands for Apple Notification Center Service, is designed by Apple. It allows Bluetooth accessories that connect to iOS devices via BLE a simple way to access notifications that happend on iOS devices. Technical details","link":"/2018/09/20/ANCS-Apple-Notification-Center-Service/"},{"title":"Beta Test and TestFlight","text":"As an iOS developer, you might have heard about TestFlight - a product of Apple that allows you to distribute your apps to beta users. So what can we do with it? Is it useful?In this tutorial, we will walk through steps uploading a build to TestFlight, and invite users to test your app.You also need to refer the previous post Shipping your app to Store to complete this tutorial.Let’s have fun! What is TestFlight?TestFlight is a product of Apple that allows developers to distribute their apps to beta users before rolling to production. With the latest update of TestFlight app on iOS 13, testers can give feedback directly from the app with screenshots, crashes and other useful information provided. Using TestFlight is a great way to help to test your apps and improve the performance before it goes live.TestFlight provides two types of testers: Internal Tester: It takes up to 25 members of your team who have been assigned a specified role to test your app. Each member can test on up to 30 devices. Once a beta build is submitted to App Store Connect and is available for testing, internal testers will be notified so that they can update the app. External Tester: You can invite up to 10,000 testers using just their email address or by sharing a public link. The main difference from the two is to let External Tester test your app, you must submit your app to Apple for review. The reviewing process is the same as an official submission but it’s usually going faster than normal app reviews. By contract, testing your app with internal testers does not require review by Apple. Select build for testingAfter completing the final step at Shipping your app to Store, your app is successfully submitted to App Store Connect. Now, navigate to your Apple developer page and sign in with your Apple Id, then select “My Apps” to see all available apps &gt; Select a specified app &gt; From the top toolbar &gt; Select TestFlight &gt; You will see all builds that are available for testing.The following image gives you a quick look of TestFlight dashboard From the main window, you can see all available versions of your app; when it expires; how many invitations sent; how many installations succeeded. etc.To add new users, click on “App Store Connect Users” at the left sidebar &gt; Press “+” button &gt; Then fill in your tester information including there App Id. After that, you can add your tester to your build. TestFlight AppTesters need install TestFlight app on their device. This app is free and available on App Store. After adding your testers to the build, testers will use their invitation email or a public link to enroll in the testing.Open the TestFlight app, the tester needs to sign in with their App Id. After that, they will see all available apps that they can install which just be the same as App Store. A small note that you will see a small orange dot near the name of the app to indicate this build installing from TestFlight. Easy, huh? From now on, whenever a build of this app is available, your tester will receive a notification and an email from TestFlight. They then can update this app via TestFlight and enjoy the latest version. After testingWhen you are done testing, you can stop the app from testing, and then go to publishing an app for the process of submitting your app to the App Store. Your beta build will become unavailable in TestFlight after 90 days by default.In this post, we had a quick look at TestFlight and how to distribute your beta test to your testers. In practice, beta testing is a common term in the software development process. Having knowledge of how to distribute your app will be useful in some situations.Happy coding!!!","link":"/2020/04/14/Beta-Test-and-TestFlight/"},{"title":"Big Endian vs Little Endian","text":"In computer science, a bit is the smallest piece of information. It represents a digit of the binary numeral system. A string of 8 bits called a byte. There are two ways to store a string of data in computers: Big Endian and Little Endian. If your tasks are working with data in a piece of bytes, you ought to know how to deal with bytes in these two formats. In this post, I will explain how data is stored in computers, what are the main differences between these two, then provide some useful code to work with bytes in Swift and Objective-C. Basic conceptsTo understand Big Endian and Little Endian, you need to know what the Least Significant Byte (LSB) and the Most Significant Byte (MSB) are. The LSB is the right-most bit in a string, it is called that because it has the least effect on the value of the binary number. In contrast, the left-most byte is the MSB that carries the greatest numerical value.After understanding these two, it is easy to distinguish between Big Endian and Little Endian: In Big Endian, the MSB of the data is placed at the byte with the lowest address. In Little Endian, the LSB of the data is placed at the byte with the lowest address. That’s all! The advantages of Big Endian and Little Endian in a computer architectureAccording to Wiki, Big endian is “the most common format in data networking”, many network protocols like TCP, UPD, IPv4 and IPv6 are using Big endian order to transmit data. Little endian is mainly using on microprocessors. But the point is why do they do that?Well, when working with byte order on iOS, I also ask the question to myself and my colleagues, “why do they do that?”, “Why do they choose Big Endian instead of Little Endian?”. After researching on the internet, and getting answers from a senior firmware engineer in my office, I gradually understand the up-side of these both order ways.The advantages of Little Endian are: It’s easy to read the value in a variety of type sizes. For example, the variable A = 0x13 in 64-bit value in memory at the address B will be 1300 0000 0000 0000. A will always be read as 19 regardless of using 8, 16, 32, 64-bit reads. By contrast, in Big Endian we have to know in which size we have written the value to read it correctly. It’s easy to cast the value to a smaller type like from int16_t to int8_t since int8_t is the byte at the beginning of int16_t. Easily to do mathematical computations “because of the 1:1 relationship between address offset and byte number (offset 0 is byte 0), multiple precision math routines are correspondingly easy to write.” Some main advantages of Big Endian are We can always test whether the number is positive or negative by looking at the byte at offset zero, so it’s easy to do a comparison. The numbers are also stored in the order in which they are printed out, so binary to decimal routines are particularly efficient. Byte order on iOSBoth Swift and Objective-C support methods that help us read and write data in the two ways Litte Endian and Big Endian. The following sections demonstrate how we use these methods to interact with data on memory. Byte order in Objective-C1234567891011121314NSString *strData = @\"001E653A\";NSData *data = [NSData dataWithHexString:strData];uint8_t *bytes = (uint8_t *)data.bytes;/* Functions for loading little endian to host endianess. */uint16_t firstInLittle = OSReadLittleInt16(bytes, 0); // 0x1E00 = 7680uint16_t secondInLittle = OSReadLittleInt16(bytes, 2); // 0x3A65 = 14949uint16_t firstInBig = OSReadBigInt16(bytes, 0); // 0x001E = 30uint16_t secondInBig = OSReadBigInt16(bytes, 2); // 0x653A = 25914 /* Functions for storing host endianess to little endian. */uint8_t byte16[2];OSWriteLittleInt16(byte16, 0, firstInLittle); // byte16 = [0x00, 0x1E] Byte order in Swift123456789101112let strData = \"3A651E00\"if let data = strData.hexadecimal() { let bytesArr = [UInt8](data) /* Functions for loading native endian values. */ let little = _OSReadInt16(bytesArr, 0) // 0x653A = 25914 let big = first.bigEndian // 0x3A65 = 14949 /* Functions for storing native endian values. */ let bytes = [UInt8](repeating: 0, count: 2) _OSWriteInt16(UnsafeMutableRawPointer(mutating:bytes), 0, second) // bytes = [0x65, 0x3A]} Final thoughtsIn this post, I showed you how differences between endianness formats and provided some useful code to work with bytes in iOS. If you have any suggestions, just let me know.Happy weekend.","link":"/2018/04/30/Big-Endian-vs-Little-Endian/"},{"title":"Bluetooth Low Energy On iOS","text":"The Core Bluetooth (CB) framework allows iOS and MacOS apps communicate with BLE devices. Your apps can discover, explore, and control the BLE devices, such as heart rate monitors, trackers or hybrid watches. Image 1. BLE devices (Source from Google) On MacOS 10.9 and iOS 6, Mac and iOS devices also play the roles of BLE peripherals to serve data to other devices, including other Mac and iOS devices. In this tutorial, I will introduce the key concepts of the Core Bluetooth framework and how to use the framework to discover, connect, and retrieve data from compatible devices. Feel free to leave out your comments on my post. ## At a glance BLE was introduced in early 2010 and based on Bluetooth 4.0 specification. BLE uses the same 2.4 GHz radio frequency as classical Bluetooth. In theory and in ideal conditions (Without obstacles), BLE’s range get over 100m but in fact, the maximum distance is 10m. Image 2. BLE in reality (Source from Google) This technology is power-friendly because it uses less power than other wireless technologies. Thanks to its low power consumption, BLE is used to integrate into electrical devices that required less power consumption such as heart rate monitors, trackers, watches, shoes to make them smarter.So, what are the cons of BLE technology? It’s data transfer rate. In order to decrease power consumption, BLE chips only transmit data in some time called interval (Whereas Classical Bluetooth can transfer data at any time they want), and the amount of transferred data in an interval is also limited in a few dozen of bytes. Some more information about maximum throughput on iOS and MacOS (Provided by PunchThrough) iPhone 6, 6+, 6S, 6S+: 12Normal Connection Interval of 30mSecs: 2,667 bytes/secConnection Interval for HID Over GATT is Present 11.25mSecs: 7,111 bytes/sec MacBook Pro - OS X (Varies on models): 1Maximum Connection Interval range of (11.25 - 15mSecs): 7,111 bytes/sec - 5334 bytes/sec To get more technical details about Bluetooth technology, please refer to Bluetooth Special Interest Group (SIG). Basic Concepts1. The playersThere are two major roles involved in all BLE communication: The Central and The Peripheral: Peripheral: are devices having data that is needed by other devices. Central: typically use the information served up by a peripheral to accomplish some tasks. For examples, reading heart rate or temperature information from monitors (A peripheral).Image 3. The Central and the Peripheral (Source from [Apple doc](https://developer.apple.com/library/content/documentation/NetworkingInternetWeb/Conceptual/CoreBluetooth_concepts/AboutCoreBluetooth/Introduction.html)) 2. The connection parametersThe connection parameters for a BLE connection is a set of parameters that determine when and how the Central and a Peripheral perform data transferring. The Central will actively set the connection parameters used, but the Peripheral can send another parameter that the Central can then accept or reject. Both sides will continue to request connection parameters until they find a reasonable number that they accept.There are 3 different parameters: Connection interval: This value determines how often the Central and the Peripheral transfer data to each other. Slave latency (Latency, shortly): If we set a non-zero latency value, the Peripheral can skip requests from the Central when the Central asks for data up to the slave latency number of times. However, if the Peripheral want to transmit data to the Central, it can send data at any time. This allows a peripheral to stay sleeping for a longer time to decrease power consumption. Connection supervision timeout: This value determines the timeout from the last package exchange until the transference is considered lost. The Central will not start trying to reconnect before the timeout has passed. For example, if you set {interval, latency, timeout} = {15, 0, 720} as connection params for the peripheral: In every 15 (ms), the peripheral will be wake-up and listen to requests from the central, also transmit data if needed. Latency equal 0, it means that the Peripheral have to answer the Central at any time the Central requests in an interval (15 ms). After 720 (ms) from the last packet was sent, if the Central still does not receive the packet, the Central will determine that the packet was lost and requests the Peripheral re-send the last packet. 3. Bluetooth Low Energy Protocol StackCoreBluetooth hides many of the low-level details of the specification from developers, making it much easier to develop apps that interact with BLE devices. Advertising and General Advertising Profile (GAP)BLE devices let other devices know that they exist by advertising using the GAP. Advertising packets contain some basic information such as device name, serial number, or RSSI value, and also a list of the services it provides. The limited size of advertising packets is 128 bit.RSSI stands for Received Signal Strength Indicator. RSSI value represents the strength of the transmitting signal. We can estimate the current distance between the central and the peripheral based on the value. The greater the value, the closer the device is. Image 4. Advertising and discovery in BLE General Attribute Profile (GATT)GATT is the layer that defines services and characteristics which is used to transmit data between the Central and the Peripheral, also enables read, write, notify operations on them.In most case, the Peripheral is also called GATT server since it provides the services and the characteristics whereas the Central is the GATT client. ServicesServices are identified by unique numbers known as UUIDs. Standard services like Device Information Service (0x180A), which exposes manufacturer and basic information about the device (Firmware version, serial number, model number), have a 16-bit UUID and custom services have a 128-bit UUID. (E.g: 0x3dda0000957f7d4a34a674696673696d, etc.) CharacteristicsA characteristic contains a characteristic declaration, characteristic properties (ReadWrite, ReadOnly, Notify, WriteWithoutResponse and so on), and a value. Characteristics allow us to access the value and the information that they contain. A service can have more than one characteristic.The following picture shows the relationship between Profile, Services, Characteristics. Image 5. Relationship between Profile, Services, Characteristics 4. Bluetooth Concepts and CoreBluetooth on iOSIn the CoreBluetooth framework A Central is represented by the CBCentralManager class and is used to discover, establish a connection and control the peripheral. A peripheral is represented by the CBPeripheral class, the services relating to a specific peripheral are represented by the CBService class and characteristics of a peripheral’s service are represented by the CBPeripheral class. The following image shows the structure of a Services and its Characteristics on iOS: Image 6. Relationship between CBPeripheral, CBService and CBCharacteristic objects on iOS SummaryBLE is a revolutionary technology of Classical Bluetooth. In reality, BLE is used to integrate into small devices like lockers, trackers, watches, shoes and some kind of jewelry (rings) to make them smarter, towards IoT environment.In the next section, I will guide you how to use CoreBluetooth to create your own services on an iOS device, also use CoreBluetooth on another device to discover, connect and control your BLE services. If you liked this post and would like to see more in the future, please let me know. References[1] Bluetooth Special Interest Group[2] Apple document: Core Bluetooth Concepts[3] Maximizing BLE Throughput on iOS and Android","link":"/2017/10/13/Bluetooth-Low-Energy-On-iOS/"},{"title":"Building your personal page with Hexo","text":"As I build this personal site, my first aim is to enjoy my hobby of writing. I write whatever I learn on along with my daily working, and share it. I hope my share will help someone when they need it. In return, I will have a deep of understanding what I write, and sometimes, receive “a cup of coffee” (Buy me Coffee) from a friend I’ve never met. ☺️ Power is gained by sharing knowledge, not hoarding it Some friends come to me asking how to build a page like mine. I’m happy to share with you how I build it.After this tutorial, you can build your own site within 5 minutes.I hope to see your page launching soon! Set up toolsNodeJs for macNavigate to NodeJS page, download, and install NodeJs package for macOS.For those who don’t know what NodeJs is, NodeJs is an open-source, cross-platform (OS X, Window, Linux), Js runtime environment for writing service-side in Javascript.By using the non-blocking I/O model, NodeJS is a great choice for real-time applications, chat, data streaming, etc.With a large community, NodeJs package ecosystem is more and more various and efficiency making NodeJS become one of the best development trends in recent years. You can find more info of NodeJs on the internet if you find it interesting. HexoHexo is a blog framework powered by NodeJs. Simple and fast features of Hexo make it become a dominate among other blog frameworks such as Hugo, Wordpress, Grav, etc.I choose Hexo to build my blog because I get used to with NodeJS commands. Moreover, Hexo provides many themes that you can easily integrate to your blog with a full of customization.After installing NodeJs successfully, open your terminal and type these following lines 12345npm install hexo-cli -g [1]hexo init blog [2]cd blog [3]npm install [4]hexo server [5] Here is the step-by-step: Install hexo command line as a global command. Create your blog folder. Move to the folder. Install node dependencies. Run your server. Hexo will be run at localhost:4000 by default. Now open http://localhost:4000 in your browser to see the result. Personalize your websiteAt the root of your folder, there is a _config.yml file that contains your page configs. You can modify something like page title, page author, article format, etc. For more information, please refer to Hexo documents. Start writingTo create new artical, type 1hexo new \"My first blog\" Here, you create a post named “My first blog”. Reload your browser, you will see the result. Please note that Hexo uses Markdown syntax for editing, so please make sure you’re familiar with Markdown syntax. ThemesThe community of Hexo provides a lot of themes that you can choose by your favorite and personalize this theme as yours. It saves your time a lot thank to the great community.Navigate to Hexo themes and find the one you like, follow their instruction to download to your blog folder.Next, modify the _config.yml file, search and replace the themes config with your new theme name. 1theme: whatever DeploymentBy using the command line hexo generate, Hexo will automatically generate all your static files which you can upload to your server and distribute it to your users.In case you don’t own a server, no worry! There are a lot of free-host servers out there. You might have heard about Github page. Basically, Github page provides a free host and domain for your page, like mine “uynguyen.github.io”. If you want to use Github page as your host, please follow the instructions to create your github page repository.After having your own repository, install npm install hexo-deployer-git that allows you to deploy your site.Next, edit the _config.yml file, from the “deploy” section &gt; add your deployment target information 12345deploy: type: git repo: &lt;repository url&gt; branch: [branch] message: [message] From now on, once you finish writing, you can publish your posts via command 1hexo clean &amp;&amp; hexo deploy You can also use Heroku for deployment instead of using github. For more information, please refer to Hexo deployment ConclusionIf you want a simple - personal page to share your ideas and contents, Hexo and Github page become such a great tool for you. With its simplicity and its community, It’s easy to set up, allowing you to just focus on what matters: Your sharing.I hope you find this post useful.","link":"/2020/04/27/Building-your-personal-page-with-Hexo/"},{"title":"Bluetooth security: Pairing and Bonding","text":"In modern times, Bluetooth plays a crucial role in connecting devices seamlessly. From fitness trackers to smart home devices, Bluetooth Low Energy (BLE) allows devices to communicate efficiently while reducing power consumption. However, with the rise of wireless communication, ensuring security has become a key concern. Two core concepts of Bluetooth security are Pairing and Bonding, which are often misunderstood in the context of BLE. Ensuring that devices pair and bond securely is critical for protecting sensitive data. Improper implementation of these processes can lead to several types of attacks. For example, attackers can intercept communications and steal valuable information. In this blog, we’ll explore what pairing and bonding are, why they are important for security, and how they work in practice, particularly for mobile applications. Low level: Security Manager (SM)At the core of BLE security is the Security Manager (SM), a crucial component that manages various security functions. The SM handles the exchange of security keys and ensures that all data transmitted between devices is encrypted and protected from unauthorized access. Key responsibilities of the SM include managing pairing, bonding, encryption and authentication, and key management. The SM provides different authentication methods for different levels of security: Just Works: No authentication involved. Used for low-security applications. Passkey Entry: A passkey (PIN) is entered on one or both devices to authenticate. Numeric Comparison: Both devices display a number, and the user must confirm that they match. Out-of-Band (OOB): Another wireless technology, like NFC, is used to exchange information, providing enhanced security. Establish pairing and bonding sequencePairing is the process of establishing a secure communication link between two Bluetooth devices. This step is essential to ensure that the devices can share data securely. During the pairing process, the devices exchange information, authenticate each other, and create encryption keys to protect the data being transmitted. Bonding is the next step after pairing. Once two devices successfully pair, they can store the encryption keys and related security information for future use. It ensures that devices don’t need to pair again the next time they connect. By storing these keys, devices can reconnect more quickly and securely in the future. In a high level, steps in the pairing and bonding process include: PAIRING Initiating: One device sends a pairing request to the other. Exchanging Security Parameters: Devices share their capabilities, including available authentication methods. Authentication: Depending on the available methods (Just Works, Passkey Entry, Numeric Comparison, or Out-of-Band), the devices authenticate themselves. Key Generation: Encryption keys are generated and used to secure the communication. Establishing Encryption: Devices begin encrypted communication after the keys are successfully exchanged. BONDING Storing Security Information: After pairing, both devices save encryption keys for future connections. Reconnection: During future interactions, devices can use the saved keys to re-establish a secure, encrypted link without repeating the pairing process. Below is a summary of the flow in the example of a mobile device (central) and a peripheral (e.g., smartwatches, monitors, etc.). Mobile application sideiOS does not provide an explicit bonding API. However, the bonding process occurs transparently when you connect to a BLE device that requires it, and the OS will prompt the user for necessary authentication. The pairing request is usually triggered by accessing secured characteristics. In contrast, you have more control over the pairing and bonding proces in Android. 1234567891011121314151617181920212223242526272829BluetoothDevice device = bluetoothAdapter.getRemoteDevice(deviceAddress);// Checking bond stateint bondState = device.getBondState();if (bondState == BluetoothDevice.BOND_BONDED) { // Already bonded} else { // Create bond device.createBond();}...// Moniroting updatesBroadcastReceiver receiver = new BroadcastReceiver() { @Override public void onReceive(Context context, Intent intent) { final String action = intent.getAction(); if (BluetoothDevice.ACTION_BOND_STATE_CHANGED.equals(action)) { int bondState = intent.getIntExtra(BluetoothDevice.EXTRA_BOND_STATE, BluetoothDevice.ERROR); if (bondState == BluetoothDevice.BOND_BONDED) { // Device is bonded } else if (bondState == BluetoothDevice.BOND_BONDING) { // Bonding in progress } else if (bondState == BluetoothDevice.BOND_NONE) { // Bonding failed } } }}; On Android, there is no public API to programmatically remove a bonded device. However, there is a private API method available that can be accessed using reflection to remove a bond. Kindly note that, because this is a private API, it is unsupported by Google, and using it in production code may result in unpredictable behavior on certain devices or your application being rejected during Google’s review process. 123456789public static boolean removeBond(BluetoothDevice device) { try { Method removeBondMethod = BluetoothDevice.class.getMethod(\"removeBond\"); return (boolean) removeBondMethod.invoke(device); } catch (Exception e) { e.printStackTrace(); } return false;} Best practiceWhile working with devices that need encrypted data, I ran into some issues. Below are the key points I’ve learned, which might help save you time: To support auto-connect from the iOS system, the device must contain either the HID profile or be subscribed to the ANCS profile of the phone. On Android, the OS does not auto-reconnect to the device when bonding; it’s the job of your services. The iOS system automatically shows the pairing pop-up immediately after successfully calling connect to the device if it contains the HID profile. Removing all encrypted characteristics of the HID profile from your device prevents the system from automatically showing the pairing pop-up. When reading a custom encrypted characteristic of the GATT profile, the pairing request pop-up will appear. The OS will still auto-connect to the device after pairing it with our encrypted characteristic, even if the HID device is unencrypted. Use Strong Authentication Methods: Prefer Numeric Comparison or Passkey Entry over Just Works. Update Encryption Protocols: Ensure that your devices use modern, strong encryption protocols. ConclusionBluetooth pairing and bonding are foundational processes that enable secure communication between devices. By understanding these mechanisms, developers can significantly enhance the security of their Bluetooth connections. As the number of connected devices grows, ensuring strong Bluetooth security will continue to be a priority for safeguarding personal-sensity data. Refs Kevin Townsend, Carles Cufí, Akiba, Robert Davidson - Getting Started with Bluetooth Low Energy_ Tools and Techniques for Low-Power Networking-O’Reilly Media (2014) How iOS and Android Handle Connections with BLE Human Interface Devices, Punch Through BLE Pairing and Bonding","link":"/2024/08/31/Bluetooth-security-Pairing-and-Bonding/"},{"title":"Core Bluetooth on WatchOS","text":"Ever thought about adding a Watch App to your product? Wondering how to make CoreBluetooth work on your Watch App? You’re in the right place! This tutorial is your go-to guide. In this post, we’ll take you step by step through the process of smoothly bringing in data from Bluetooth gadgets into your Apple Watch apps. Discover how to harness the potential of Bluetooth devices to enhance your Apple Watch user experience. We’ll also provide insights into overcoming common challenges when dealing with Core Bluetooth on watchOS. Whether you’re a seasoned professional or a beginner, this tutorial simplifies the process for you. Environments: XCode 15.0.1, iOS 17.0.3, WatchOS 10.1.1, Swift 5. Set up projectStart by going to your project settings, then select File &gt; New Target &gt; Watch OS &gt; App, and fill in the required fields. Once done, Xcode will seamlessly integrate a new watch app project into your existing workspace. Bluetooth configEssentially, all methods and Bluetooth events on WatchOS closely resemble those on iOS. If you already have a BluetoothManager class that handles various Bluetooth functions, such as initiating scanning or connecting to a peripheral, and manages Bluetooth delegates, you’re in good shape. 123456789101112131415161718192021class BluetoothManager : NSObject, CBCentralManagerDelegate { private var central: CBCentralManager! override init() { super.init() central = CBCentralManager( delegate: self, queue: nil, options: [:] ) } func startScanning() { central.scanForPeripherals(withServices: nil, options: [CBCentralManagerScanOptionAllowDuplicatesKey: true]) } func connect(periperal: CBPeripheral) { central.connect(periperal) } // The rest omitted} To save time and avoid duplicating code, you can easily share the file containing the BluetoothManager class with both your iOS and watch app targets. With this setup, you can seamlessly use the BluetoothManager class in your watch app just like you would in your iOS app. 1234567891011121314struct ContentView: View { var body: some View { VStack { Image(systemName: \"globe\") .imageScale(.large) .foregroundStyle(.tint) Text(\"Hello, world!\") } .padding() .onAppear(perform: { BluetoothManager.shared.startScanning() }) }} Important notes To test your project’s Bluetooth functionality, it’s essential to run it on a real Apple Watch since the simulator doesn’t support Bluetooth. Keep in mind that the connection time on the Apple Watch can be influenced by the device’s battery status, even if low power mode is not enabled. Ensure that you manually add the necessary capability to the Watch App plist file. This step is crucial; otherwise, your app won’t be able to scan, connect, or execute any Bluetooth commands when it’s in the background. 1234&lt;key&gt;UIBackgroundModes&lt;/key&gt;&lt;array&gt; &lt;string&gt;bluetooth-central&lt;/string&gt;&lt;/array&gt; Unlike Bluetooth on iOS, where you can leverage State preservation and restoration to awaken the app if it has been terminated by the system due to Bluetooth events (see Best practice: Best practice: How to deal with Bluetooth Low Energy in background), it’s important to note that there is no equivalent State preservation and restoration mechanism on watchOS. The connection time on iOS and WatchOS is quite equal. I measured the Connect API by performing 200 calls (same devices, same testing environment). The average on iOS is approximately 0.69 seconds, while on WatchOS, it is 0.78 seconds. ConclusionIn a nutshell, by learning how to connect your Apple Watch to Bluetooth devices, you’ve boosted your watch’s features. This tutorial has guided you through using Core Bluetooth on watchOS, handling common problems along the way. Whether you’re a pro or a beginner, we’ve broken it down for you. Now, your Watch App not only works well but also impresses users. As you keep making apps, use these skills to create cool and smooth experiences. Happy coding! References[1] WWDC 2021[2] WWDC 2022[3] Core Bluetooth in watchOS Tutorial","link":"/2024/03/23/Core-Bluetooth-on-WatchOS/"},{"title":"Crash early in Swift","text":"Last night, I read a chapter of a book as one of my favorite books: &quot;The pragmatic programmer&quot; (By Andrew Hunt and David Thomas). This chapter discusses how to use assertion to make the code easier for debugging. We all know that assertion is an essential tool for writing tests, but It does more than that. Let’s go with me to meet this guy: Assertion. Crash, don’t trashDo you ever have one of the following conversations to yourself or with your colleagues in a technical discussion? “This case will never happen so we don’t need to process this one.” “This class must be “Dog”, it can never be “Cat”, let’s force unwrap this object.” “This error will never occur, just ignore it.” “You idiot! why do we handle this case when your code never reach out to this line?” But what if “this case” happen somehow? Does the app still response in the way that we expect? Is there any chance that the unexpected situation will damage our essential database?At the very beginning of this chapter, the author introduces some situations that I can see myself in those examples: “This code won’t be used 30 years from now, so two-digit dates are fine.” “This application will never be used abroad, so why internationalize it?” “count can’t be negative.” “This printf can’t fail.” 1IF IT CAN'T HAPPEN, USE ASSERTIONS TO ENSURE THAT IT WON'T If we believe something cannot happen, or something true, use assertions to ensure your belief is true! If the condition of assertion is not met, it will immediately crash the app. It’s very useful during development because it leads us exactly to the problems. Before to continue, let’s talk about the Swift Optimization levelsDepend on whether the build is in Release mode or Debug mode, the Swift compiler will turn on or off the assertions (Lines with assert statements are omitted), it’s good to know the Swift optimization levels before we continue.There are 3 types of optimization level for a build in Xcode None (Onone): The default for debug builds. Compile without any optimization. Fast (O): The default for release builds. Compile with optimizations. Unchecked (Ounchecked): Compile with optimizations and remove runtime safety checks, including checking array out of bounds, unwrapping nil, precondition and preconditionFailure. That’s why we should not use the Ounchecked mode in release build because it can lead to memory corruptions and the app might behave inappropriately. Updates: As you can see there is no longer the -Ounchecked mode in Xcode10, instead a new option introduced Optimize for Size. The main difference between the O mode and Osize mode is “When compiling with -O the compiler tries to transform the code so that it executes with maximum performance. However, this improvement in runtime performance can sometimes come with a tradeoff of increased code size. With the new -Osize optimization mode the user has the choice to compile for minimal code size rather than for maximum speed” (swift.org) Apply Assertion to SwiftTruly to say, before reading this chapter of the book, I thought “Assertion” only used when writing unit test. The fact that developers use Assertion in developing to make the developing process safer and easier for tracing a bug.Swift provides 5 types of assertion function that differ from each other in terms of how they affect the flow of codes: assert() &amp; assertionFailure(): Use them when we want to verify our code, but if it is actually an issue, it wouldn’t necessarily exit the app. The compiler will ignore assert() and assertionFailure() statements for a release version (In -O mode). For example, I use assert to ensure there are no unexpected requests in my business flow. By doing so, I guarantee that if there is a “strange guy” appears in my flow, the flow will be broken and the app will be terminated. Also, the debugger will lead me directly to the problem so that I can identify logic problems and clear out bugs as early as possible. precondition() &amp; preconditionFailure(): Use these functions to detect a condition that must be fulfill before continuing to process, even in release version (-O mode). For example, let’s say that we need to load a config file when the app launch. If there is no config file, then we should stop the app immediately rather than continuing the execution.123guard let fileConfig = Bundle.main.path(forResource: \"config\", ofType: \"json\") else { preconditionFailure(\"Unable to load config file.\")} fatalError(): The same as precondition() and preconditionFailure() functions, except fatalError() works for all optimisation levels in all configurations, it means your app ALWAYS be terminated if the fatalError line is reached. In the following example, I use fatalError() to force every inherited class must override the parseData(files:) from its super class. Highlighted advice from the author &quot;All errors give you information. You could convince yourself that the error can't happen, and choose to ignore it. Instead, Pragmatic Programmers tell themselves that if there is an error, something very, very bad has happened.&quot; If an error happens, can we recover it? If we can not handle some unexpected problems, then crash early to protect our vital data (Especially in banking apps that require high security for database). &quot;Don't put assertion in the code of real error handling.“ It is a misunderstanding if we put assertion everywhere around the code, particularly in the code of real error handling. Assertion is not supposed to be used this way. If we simply to terminate a running program, it will affect to the user experiences, resulting in users will no longer open your app. The simplest principle to check if we should exit the program when errors occur is When your code discovers that something that was supposed to be impossible just happened, your program is no longer viable. Anything it does from this point forward becomes suspect, so terminate it as soon as possible. A dead program normally does a lot less damage than a crippled one. &quot;The condition passed to an assertion should not have a side effect&quot;. It is embarrassing if we put a code to check errors actually causing to other errors. 😖 For example, the following code (In Java) is added assert to make sure the next element is not nil, but it actually creates a new error. Can you find it?12345while (iter.hasmoreElements () { Test.ASSERT(iter.nextElements() != null); object obj = iter.nextElement(); // ....} ConclusionIn this article, we walked through these five methods for an early exit in Swift. In general, the right way to pick which one to use depends on the context of the error: Whether the error can be recoverable or not? If the answer is no, then crashing is the best way we can do to protect our app from unpredictable behaviors. Sometimes, the app is in a situation where it would be too dangerous to continue.Hope you found this post useful then you can apply this idea to your next project.Thanks for reading! 🚀","link":"/2019/01/19/Crash-early-in-Swift/"},{"title":"Chuyện ở Đại Học (Phần 1)","text":"Tối hôm qua vô tình lướt Facebook thì trang Confession của trường mình hiện lên bài post của một bạn k17, bạn tâm sự về chuyện học ở Đại Học.Bạn tâm sự rằng bạn đang stress và căng thẳng vì lượng kiến thức ở Đại Học quá nhiều làm bạn không theo kịp, trong khi đó các bạn cùng khoá lại có vẻ như tiếp thu nhanh hơn bạn. Điều đó làm bạn thêm tự ti và muốn bỏ cuộc.Trước giờ mình không có thói quen comment lên các Fan page hay Confession, mà vì đọc được bài post của bạn mình thấy sao giống với mình 5 năm về trước quá, vì vậy mình muốn viết một bài chia sẻ ngắn để chia sẻ với các bạn về con đường mình đã đi qua cách đây 5 năm, cũng là con đường mà các bạn sẽ đi, dù ít hay nhiều. 1. “Học Công Nghệ Thông Tin mà Visual Basic là cái gì mà cũng không biết thì nghỉ cha cho rồi!”Đó là câu trả lời của thằng bạn học Quốc Phòng với mình khi mình hỏi quyển sách dày cui nó cầm trên tay là sách gì. Lúc đó buồn lắm chứ, cảm giác như mình là sinh vật ngoài hành tinh khác rớt xuống chỗ này vậy.Sau đó vào kí túc xá, (Lúc này gặp thím Trương - Thằng này giỏi từ cấp 3, thi Tin trường quận huyện tỉnh gì đó nó thi hết rồi), nó hỏi mình chứ “Ông biết con trỏ hem, ông biết đệ quy hem, ông biết thuật toán Dijktra, chu trình Hamilton hem” (WTH !!!). Chả hiểu nó nói gì, mình chỉ biết nhe răng cười. :))Vào lớp học, (Lúc này gặp thím Tú), mình còn đang loay hoay debug cái Hello World thì thím Tú đã bay lên bảng code một cách thần thánh: i++, j++ (WTF !!!).“Ê mày, i++ là sao mày” - Uy said =]].Đó, background lập trình của mình là vậy đó :). Rồi mình cũng lê lết qua được 4 năm Đại Học đấy thôi, nên tin vui cho các bạn là dù biết hay không biết nên tảng lập trình, vào Đại Học thì mọi người sẽ cùng một điểm xuất phát lại hết nhé, chỉ là mấy bạn biết trước sẽ có nhiều lợi thế hơn thôi. Mà cũng phải thôi, tại những năm cấp 3 người ta đã bớt thời gian đi chơi, xem phim, la cà để chuyên tâm nghiên cứu rồi còn gì.Mình có một người bạn từng nói là mình giống như mục tiêu của nó vậy đó, nó sẽ cố gắn phấn đấu cho đến khi qua được mặt mình, để xem thử ai là người đạt được ước mơ của mình sớm hơn. Mình trả lời lại là *”Mình không lấy người khác ra để làm mục tiêu cho mình, mình có những mục tiêu riêng. Mặt khác, mỗi người sinh ra đã có những xuất phát điểm, những nỗ lực khác nhau rồi, tôi không biết con đường bạn đã đi như thế nào và bạn cũng vậy. Vậy sao lại so sánh được?”* 2. Những kiến thức nền ở Đại HọcSau đây là list những môn học đại cương trong 3 kì đầu. Toán đại cương: Toán rời rạc: Các bạn sẽ học về Vector, các phép toán trên Vector, đại số Bool, các bảng chân trị, bảng logic, khái niệm cơ bản về đồ thị … Xác suất thống kê: Các bạn sẽ được học về các phép toán tính xác suất, các phép đếm, thống kê … Đại Số B1, B2: Học về cách phép toán xử lý trên ma trận, định thức, không gian vector … Giải tích B1, B2: Học về vi phân, tích phân, đạo hàm … Những môn này cực kì quan trọng cho những môn khoa học máy tính sau này nên tập trung học cho chắc nhé. Toán rời rạc quan trọng nếu sau này bạn chuyên về thuật toán, giải thuật, lý thuyết đồ thị, automata, trình biên dịch, xử lý ngôn ngữ tự nhiên. Xác suất thống kê cần nếu bạn làm nhiều về trí tuệ nhân tạo, \bData Science, Machine Learning. Đại số tuyến tính ma trận, vector etc. có ứng dụng trong Cryptography, phân tích độ phức tạp thuật toán. Tin học đại cương: Điện Tử Căn Bản: Môn này học cái gì mình quên rồi, và cũng không biết tại sao mình lại qua môn. Lý Thuyết Mạch Số: Môn này học về các cổng logic AND, OR, XOR, NOT. Các hệ cơ số đếm, các phép toán xử lý trên bit bla bla. Nhập Môn Lập Trình: Môn này nhẹ nhàng thôi, học về mấy cái cực cơ bản như viết “Hế lô bà con”, học các syntax cơ bản: lặp, điều khiển, rẽ nhánh … Lý Thuyết Đồ Thị: Môn này là môn mình thích nhất trong 4 năm Đại Học vì được học với Cô Vân dễ thương. Các bạn sẽ được học về các phép duyệt đồ thị (BFS, DFS), các thuật toán tìm đường đi ngắn nhất (Dijkstra, Floyd + Bellman), các khái niệm về đồ thị (Liên thông, đẳng cấu bla bla), chu trình Euler và Hamilton … Bạn nên đọc thêm quyển: Introduction To Algorithm [THOMAS H. CORMEN, CHARLES E. LEISERSON, RONALD L. RIVEST, CLIFFORD STEIN] Nhập Môn Công Nghệ Thông Tin 1,2: Hai môn này chủ yếu “Cưỡi ngựa xem hoa” cho vui thôi, sẽ giới thiệu cho các bạn về ngành Công Nghệ Thông Tin, các chuyên ngành và các hướng nghiên cứu. Hai môn này nhẹ nhàng, đừng tạo áp lực làm gì. Cơ Sở Dữ Liệu: Học về các khái niệm cơ bản trong hệ thống thôn tin và cơ sở dữ liệu, các hệ thống CSDL và mô hình dữ liệu quan hệ, sử dụng SQL để truy vấn cơ sở dữ liệu, thiết kế cơ sở dữ liệu, phân tích chất lượng của một lược đồ cơ sở dữ liệu. Kiến Trúc Máy Tính và Hợp Ngữ: Học về các cách thiết kế kiến trúc của máy tính, tổng quan về máy tính, kiến trúc MIPS, x86, x32, cách thiết kế CPU của máy tính, các hệ cơ số và cách lưu trữ trên máy tính … Bạn nên tìm đọc thêm quyển Computer Architecture: A Quantitative Approach [John L.Hennessy and David A.Patterson] Hệ Điều Hành: Môn này quan trọng, các bạn cần học thật tốt môn này. Môn này các bạn sẽ được học về cách hệ điều hành làm việc, học về Kernel của OS, hệ thống tập tin FAT32 và FAT64, cách mà OS quản lý và điều phối các tiến trình, đồng bộ hoá giữa các tiến trình, quản lý bộ nhớ trên OS … Bạn nên tìm đọc thêm quyển Operating System Concepts [Silberschatz, Galvin, Gagne]. Mạng Máy Tính: Môn này quan trọng, nên đầu tư nhiều thời gian tìm hiểu. Môn này các bạn học về mạng máy tính, cách mà các hệ thống máy tính làm việc với nhau, cách một gói tin được truyền đi trong hệ thống mạng, các khái niệm về mạng máy tính (IP, subnet mark, …), mô hình 7 tầng OSI, sau đó học vào chi tiết từng tầng trong mô hình mạng. Bạn nên tìm đọc thêm quyển Computer Networking: A Top-Down Approach [7th Edition, Kurose &amp; Ross] Lập Trình Hướng Đối Tượng: Môn này các bạn bắt buộc phải nắm vững, học tốt môn này thì bạn có thể học nhanh bất kì ngôn ngữ lập trình nào. Và nên nhớ, sau cùng thì ngôn ngữ cũng chỉ là cái để hiện thực hoá cái ý tưởng của mình thôi. Không nên đặt nặng vấn đề ngôn ngữ lập trình lên hàng đầu mà bỏ qua cơ sở để xây dựng ngôn ngữ đó. Bạn nên tìm đọc thêm Head First Design Pattern [Head First],Design Patterns [Gang Of Four] Kỹ Thuật Lập Trình: Môn này sẽ dạy bạn các khái niệm trong lập trình (Con trỏ, vùng nhớ, ma trận, stack, heap …) và các chiêu thức lập trình rất hay (Quy hoạch động (Dynamic Programming), quay lui (Backtracking), mà cái mình thích nhất là vét cạn (Greedy)) Ahihi. Cấu Trúc Dữ liệu &amp; Giải Thuật: Môn này sẽ dạy bạn các loại cấu trúc dữ liệu trong lập trình (Tree, Stack, Heap, Queue …). Cách sử dụng từng loại dữ liệu trong từng trường hợp cụ thế. Đồng thời còn dạy bạn các giải thuật cơ bản (Sort, Search …), đánh giá độ phức tạp giữa các giải thuật. Khi nào dùng cái này, khi nào dùng cái kia, cái nào tốt hơn, phải đánh đổi cái gì bla bla. Để học tốt môn này thì ngoài giáo trình trên trường, mình nghĩ các bạn nên đọc thêm quyển Introduction To Algorithm [Steven S.Skiena] hoặc Introduction To Algorithm [THOMAS H. CORMEN, CHARLES E. LEISERSON, RONALD L. RIVEST, CLIFFORD STEIN] để tăng nội công. Ngoài ra để trở thành một lập trình viên có tâm, code ít bug, người khác đọc code của bạn không bị ức chế thì nên đọc thêm những quyển sau: Clean Code [Robert C.Martin], Code Complete [Steve McConnell], Refactoring [Martin Fowler, Steve McConnell], Pragmatic Programmer [Andrew Hunt, David Thomas]. 3. Việc chọn chuyên ngành:Sau 3 học kì đầu các bạn sẽ được chọn chuyên ngành phù hợp với nguyện vọng của mình.Các bạn sẽ ĐƯỢC CHỌN chuyên ngành chứ không bị ép buộc hay sợ hết slot gì hết nhé, vì có một số bạn inbox hỏi mình chỗ này nên nhân đây mình nói luôn.Khoa mình hiện có 6 chuyên ngành: Công Nghệ Phần Mềm (Software Engineering): Học về quy trình phát triển phần mềm; Học về cách phân tích yêu cầu phần mềm, thiết kế phần mềm, hiện thực hoá phần mềm và kiểm thử phần mềm. Hệ Thống Thông Tin (Information System): Học cách phát triển, xây dựng các hệ thống thông tin phức tạp, thông minh, tối ưu; Nghiên cứu bảo mật thông tin, rút trích thông tin đa ngôn ngữ. Mạng Máy Tính và Viễn Thông (Computer Networks and Telecommunication): Phát triển các ứng dụng mạng, hệ điều hành cho các thiết bị mạng, phát triển hệ thống. Khoa Học Máy Tính (Computer Science): Khai thác dữ liệu, phân tích và thiết kế thuật toán để tối ưu bài toán, phát triển các hệ thống trí tuệ nhân tạo (AI)… Công Nghệ Tri Thức (Knowledge Engineering): Nghiên cứu về xử lý ngôn ngữ tự nhiên (Giọng nói á) hoặc đa phương tiện (File âm thanh); nghiên cứu về mật mã và an ninh thông tin. Thị Giác Máy Tính và Khoa Học Robot (Computer Vision and Robotics): Tích hợp kỹ thuật trong đồ hoạ máy tính và xử lý ảnh số vào thiết bị di động và robot. Hỗ trợ phát hiện, nhận dạng, truy vấn, tái tạo các đối tượng trong các môi trường khác nhau. Đến giai đoạn này thì các bạn sẽ tự đăng kí môn học cho phù hợp với chuyên ngành của mình. Ví dụ bạn chọn chuyên ngành “Công Nghệ Phần Mềm” thì bạn phải tích luỹ đủ N tín chỉ thuộc các môn phần mềm và phải hoàn thành N môn học bắt buộc trong công nghệ phần mềm.Một lời khuyên cho các bạn là không nên chỉ chọn học những môn trong phạm vi chuyên ngành của mình, nên chọn học thêm những môn học ở những chuyên ngành khác mà nó hay, nó bổ ích, nó hỗ trợ cho chuyên ngành chính của mình. Ví dụ như bạn chọn Công nghệ Phần mềm thì có thể học thêm các môn khác của Khoa Học Máy Tính như “Phân Tích Độ Phức Tạp Thuận Toán”, “Phân Tích và Thiết Kế Giải Thuật” hay “Chuyên Đề Hệ Điều Hành Linux” hay “Bảo Mật Cơ Sở Dữ Liệu” hay “Khai Thác Dữ Liêu và Ứng Dụng” hay “Máy Học” … Chung quy lại là phải biết lựa môn mà học.Để tìm hiểu thêm về các chuyên ngành, các bạn tham khảo tại đây Chuyên ngành CNTT 4. Điểm số có thực sự quan trọng?*”Xuỳ, học là học kiến thức thôi chứ điểm thì có quan trọng gì.”*Mình nói thẳng luôn là câu này chỉ là câu nguỵ biện của mấy bạn lười làm bài thôi, nếu các bạn làm bài đầy đủ thì điểm của các bạn cũng sẽ xứng đáng với những gì bạn bỏ ra thôi.Quay lại vấn đề, điểm số ở Đại Học có thật sự quan trọng? Quan điểm của mình là nó không quá quan trọng, nhưng cũng không phải là thứ có thể phớt lờ.Điểm số, trong Đại Học, một mặt là để bạn khỏi bị đóng tiền học ngu rớt môn, mặt khác nó lại có ý nghĩa quan trọng hơn đối với những bạn cần học bổng để chi trả học phí hay sinh hoạt hàng tháng. Xa xôi hơn là để sau này các bạn có thể Apply các học bổng du học nước ngoài.Điểm số, ngoài Đại Học, là cái mà nhà tuyển dụng sẽ nhìn vào đầu tiên (Đối với người mới ra trường) để xem xét xem bạn có qua được vòng gởi xe không. Thử đặt mình vào vị trí nhà tuyển dụng, bạn mới ra trường, họ không biết gì về bạn, họ lấy gì để đánh giá năng lực và con người bạn? Mình không biết thật sự các nhà tuyển dụng sẽ đánh giá như thế nào, nhưng mình nghĩ điểm GPA sẽ phần nào nói lên con người bạn, rằng bạn có phải là một người có trách nhiệm (Với việc học) của mình không? Rằng bạn có đủ điều kiện để tới vòng test kỹ thuật, vòng phỏng vấn không? Điểm số giống như là tấm vé để bạn đi vào một hội trường, lúc đó năng lực thật sự của bạn sẽ được thể hiện. Mà ngay cả tấm vé mời bạn còn chưa có thì lấy cơ hội đâu để thể hiện bản thân?Vậy điểm số có quan trọng không? 5. Hoạt động ngoại khoá, có ăn được không?Nói về hoạt động ngoại khoá, mình nói thẳng là mình không tham gia quá nhiều hoạt động Đoàn - Hội. Mình chỉ lọc ra một vài hoạt động thật sự có ý nghĩa (Cho mình và cho người khác) để tham gia. Ví dụ như hiến máu nhân đạo, vui hội trăng rằm, về với ngoại thành … Đi mấy cái này vừa bổ ích, vừa có trải nghiệm lại giúp đỡ được người khác.Các hoạt động ngoại khoá này sẽ là điểm nhấn quan trọng trong hồ sơ xin học bổng học tập hoặc học bổng du học.Ngoài các hoạt đông trong trường, các bạn có thể tìm thêm các hoạt động khác từ các tổ chức từ thiện. Mình đã từng tham gia hoạt động từ thiện của tổ chức phi chính phủ Habitat kết hợp với ĐHQG TP.Hồ Chí Minh, tập đoàn POSCO Hàn Quốc và sinh viên Hàn Quốc để xây nhà tình thương cho người nghèo ở Vũng Tàu. Các hoạt động này rất ý nghĩa và còn giúp bạn có thêm bạn bè, các mối quan hệ sau này.Các bạn tham khảo thêm tại đây: Habitat for Humanity Vietnam. 6. Học bổng, kiếm ở đâu?Mỗi kì trường mình đều có rất nhiều học bổng hỗ trợ các bạn: Học bổng khuyến khích học tập dành cho những bạn có điểm học tập cao (Lấy từ trên lấy xuống đến khi hết chỉ tiêu). Hồi lúc năm nhất mình nhận thì giá trị của nó là 2tr5 thì phải, sau đó đến năm tư thì nó tăng lên được gần 4tr 1 kì (Chắc do lạm phát :))). Khoảng tiền này cũng đủ để các bạn chi trả (Phần nào) học phí.Thật ra để lấy được suất học bổng này mình nghĩ là không quá khó. Điểm trung bình của các bạn chỉ cần trên 8.0 là đã có cơ hội nhận rồi. Về vấn đề điểm rèn luyện. Mình nghĩ cũng không cần thiết phải dành quá nhiều thời gian để tham gia các hoạt động Đoàn - Hội làm gì, chỉ cần tham gia một vài hoạt động chính (Xem lại mục hoạt động ngoại khoá) và không vi phạm gì đến các ‘giới răng’ của trường (Vắng sinh hoạt công dân, xác nhận lưu trú bla bla gì đó) là đủ điều kiện rồi. Ngoài ra khoa mình cũng có liên kết với các doanh nghiệp để có các suất học bổng khác. Các công ty lớn như KMS, ELCA, CSC, Global Cybersoft, NTTData, GameLoft, VNG… đều có liên kết với khoa mình để trao học bổng hằng kì (Hàng năm) cho sinh viên khoa mình. Giá trị các suất học bổng dao động từ 3tr - 5tr tuỳ công ty.Để được các suất học bổng này thì điểm trung bình của các bạn không cần quá cao (Chỉ cần từ 7.5+). Thường thì các suất học bổng này nhắm tới các bạn sinh viên khó khăn trong khoa nên sẽ có yêu cầu (Optional) nộp thêm một giấy xác nhận gia đình có hoàn cảnh khó khăn ở địa phương. Giấy này thì bạn về UBND quê của bạn xin tờ giấy xác nhận nhé.Các suất học bổng này ngoài giá trị vất chất (Tiền đó), một số công ty còn offer cho bạn các cơ hội thực tập (KMS, theo mình biết), hoặc sẽ có thư mời bạn làm việc ngay sau khi tốt nghiệp. Quá sướng phải hem? Thêm thông tin cho các bạn là khoa mình cũng có Quỹ học bổng từ các cựu sinh viên trong khoa dành cho các bạn có hoàn cảnh thực sự khó khăn (Cái này hình như không yêu cầu điểm cao, 7.0+).Các bạn sẽ được phỏng vấn với các Thầy/Cô chủ nhiệm Quỹ học bổng, Thầy/Cô sẽ quyết định số phận của bạn :). Theo mình biết thì học bổng này được cấp hàng tháng trong suốt 4 năm học với yêu cầu là bạn phải hoàn thành tốt chương trình học hay sao đó.Để thêm thông tin thì bạn vào đây: Quỹ học bổng cựu sinh viên khoa CNTT. Phía sau là những suất học bổng lớn hơn, đòi hỏi bạn phải có nhiều thành tích hơn (GPA phải thật cao: 8.5+, English tốt: Essay, một số học bổng đòi hỏi bạn phải test kỹ thuật, cống hiến cho xã hội: hoạt động ngoại khoá, bonus thêm: Công trình nghiên cứu, bài báo khoa học, giải thưởng quốc tế bla bla).Lúc này những hoạt động ngoại khoá của bạn mới thực sự phát huy tác dụng, những hoạt động phục vụ xã hội, nhắm đến cộng đồng sẽ được ban điều hành đánh giá cao, phần nào biét được nhân cách con người bạn. Các học bổng lớn người ta nhìn nhận con người ở nhiều khía cạnh chứ không chỉ học không, kiểu giống như Tài và Đức phải đi với nhau vậy đó.Mình list dưới đây chỉ là những học bổng mình đã đạt được thôi nhé, trường mình còn rất nhiều các học bổng khác tương đương, bạn có thể tìm thêm trên trang web của trường: Odon Vallet Scholarship 2016 from Recontres du Vietnam – Vallet Foundation for students with outstanding achievements. (Giá trị 15tr) Sunflower Mission Engineering and Technology Scholarship from eSilicon Corporation and Sunflower Mission foundation. (Giá trị 300$) Pony Chung scholarship is sponsored by Pony Chung foundation, Hyundai Development Company and Vietnam National University. (Giá trị 500$ + Cơ hội được học bổng sau Đại Học ở Hàn Quốc) Lawrence S.Ting scholarship from Lawrence S.Ting Memorial Fund for students with outstanding achievements. (Giá trị 10tr)Phần Essay xin học bổng, để hôm nào rảnh mình viết về kinh nghiệm với Essay sau, giờ làm biếng rồi =]].3s quảng cáo bằng khen của Sunflower (Cái bằng khen này đẹp nên khoe :))): 7. Học như thế nào?Quan trọng nhất vẫn là chính bạn, sẽ không có một phương pháp học tập nào phù hợp với bạn hết. Bạn phải tự tìm ra nó.Nhưng lời khuyên của mình dành cho các bạn là nên có một nhóm học tập, đối với mình thì nhóm này không cần phải là những super trong lớp, chỉ cần các bạn chịu khó học chung với nhau (Nhớ nhé, học nhiều hơn chơi), chia sẻ kiến thức với nhau, lâu lâu cho copy code xí =]], vì lượng kiến thức ở Đại Học rất nhiều, đặc biệt là ngành của mình, nên bạn phải có đồng bọn để học chung, với rủ rê cúp học đi xem phim, đi hát Karaoke chẳng hạn. Hồi đó mình ở chung kí túc xá với thím Trương, nó cũng chịu học nên mình đu bám nó để nó chỉ bài cho; hai đứa cắm đầu chạy deadline ngày đêm, nhờ vậy mà cũng khá lên được. (y)Trong Software Engineering có một khải niệm gọi là Trade-off, nghĩa là bạn phải biết đánh đổi giữa được và mất, giữa chi phí bộ nhớ và thời gian, giữa môn này và môn kia, trong những hoàn cảnh cụ thể, bạn lựa chọn cái nào thì đó là quyết định của bạn :).*”You can not write perfect softwares. Because a perfect software does not exist. No one in the brief history of computing has ever written a piece of perfect software. It’s unlike that you’ll be the first. And unless you accept this as a fact, you’ll end up wasting time and energy chasing an impossible dream”* (Pragmatic Programmer).Các bạn cũng tập tư duy phản biện, tức là khi người ta đưa ra một bài toán hay một solution cho bài toán, các bạn phải biết đặt lại câu hỏi, “Tại sao phải làm cách này mà không phải làm cách kia?”, “Cách này có ưu, nhược điểm gì so với cách kia?”, “Làm như thế này sau này có dễ mở rộng hay dễ bảo trì không?”, “Có cách nào thông minh hơn không?” … đại loại là những câu hỏi như vậy.Việc đặt câu hỏi sẽ giúp bạn hiểu rõ hơn về vấn đề, người nói chuyện với bạn cũng biết là bạn đã hiểu rõ vấn đề nên mới có thể đặt câu hỏi ngược lại, chứ cứ ngồi dạ dạ rồi làm theo mà không biết đúng sai thì lúc đó bạn chưa có cái gọi là Critical thinking.Một vấn đề nữa là trước khi đặt câu hỏi, các bạn nên tự tìm hiểu thật kỹ về vấn đề này, khi nào tìm không ra hoặc không biết keyword để tìm thì mình mới nên đi hỏi người khác. Mình vừa tiết kiệm thời gian cho người khác (Nhiều khi hỏi ngu quá bị chửi thì cũng đừng trẻ trâu mà gân cổ lên cãi), vừa giúp mình tập tính tự nghiên cứu. Sau này ra đời, sếp giao cho cái task, không biết đường tìm hiểu thì đi hỏi ai? Quay lại hỏi thằng hồi đó học chung à? =]]Sau đây là một số kênh các bạn có thể tham khảo: Medium, Stack overflow, Quora. Ngoài ra còn có các group học tập trên facebook của khoa, các bạn nên follow các trang này để cập nhập thông tin.Phương pháp tiếp thu kiến thức trong 1 môn học: cố gắng học kiến thức cơ bản (thuật toán chạy như thế nào, giao thức chạy thế nào, ưu nhược điểm của từng loại cơ sở dữ liệu, …) thay vì tập trung nhiều vào syntax và thư viện.Và, phải dành thời gian đọc thêm sách, học trên trường kiến thức cho mọi người là như nhau. Vậy cái gì để phân biệt bạn với những người còn lại? Là kiến thức bạn tự lượm nhặt riêng ở ngoài lớp học. Đọc thêm sách sẽ giúp bạn có cái nhìn sâu hơn về vấn đề đã học trên lớp. Nhiều khi thầy trên lớp nói cũng chưa hẳn là đúng hết. Đọc sách thì chưa bao giờ là vô bổ cả :). Sách thì mình có list ra một vài cuốn nổi tiêng ở mục 2.Kiến thức nền ở Đại Học rồi.Nên nhớ mình là một Engineer chứ không phải là một Coder. 8. “Lương anh có đủ sống hem?”Câu này là câu hỏi cuối cùng sau khi các bạn đã moi hết các kinh nghiệm học tập của mình. Mình đều trả lời là “Hem” =]]Như thế nào là đủ? Đủ sống thôi hả? Vậy thì chắc đủ sống rồi vì mình vẫn còn sống mà viết cái bài này này.Có một câu nói mình thấy rất đúng đó là Theo đuổi đam mê, con nợ sẽ theo đuổi bạn “Theo đuổi đam mê, thành công sẽ theo đuổi bạn“. Khi bạn làm việc hết mình với năng lực của mình thì người khác sẽ nhận thấy nó, sẽ đánh giá đúng những gì bạn đã bỏ ra, và bạn sẽ nhận lại được những gì xứng đáng thôi.Lại thêm một câu chuyện từ một cuộc phỏng vấn, sau khi hỏi mình mức lương mình mong muốn nhận, chị nhân sự dễ thương mới chia sẻ với mình rằng: 1234Sự nghiệp mỗi người sẽ trải qua 3 giai đoạn:Mởi tốt nghiệp: Lúc này bạn hoàn toàn trắng tay, hãy tập trung lượm nhặt kiến thức, nâng cao trình độ, theo chân người giỏi để học cái trí, cái tài của người ấy. Tạo thương hiệu cá nhân riêng của mình, cái tên của bạn.Kiếm tiền: Khi đã có trong tay kiến thức, bạn bắt đầu lao mình vào kiếm tiền.Sống với đam mê: Lúc này tiền đối với bạn không còn quan trọng nữa, cái quan trọng hơn cả là được làm cái bạn thích, làm cái bạn đam mê, làm cái bạn sinh ra để làm. Sau cùng thì chị trả lời là “Mức lương em đưa ra cao quá công ty chị hem trả nổi” =]].Mình kể câu chuyện trên với đám bạn thân, chúng nó nói đấy là thuyết âm mưu để tẩy não sinh viên đó =]].Riêng mình thì thấy chị nói cũng đúng mà, “Follow your passion and success will follow you.”Vào ngày tốt nghiệp các bạn sẽ được thầy trưởng Khoa cam kết 100% sẽ tìm được việc sau khi tốt nghiệp nhé, nên các bạn khỏi lo thất nghiệp hay lương bổng nhé (Việc đó cũng có thể là đánh văn bản dạo không chừng :3) 9. KếtNói chung, quãng đường Đại Học mà mình đã đi qua, và các bạn sẽ đi qua có lẽ là quãng thời gian đẹp nhất của đời người.Lúc trước mình vẫn hay nghe các anh khoá trên nói “Đi làm buồn hơn đi học” hay “Giờ ước gì được quay lại 1 tháng lúc học Quốc Phòng, chắc lúc đó quẩy banh cái TT. Quốc Phòng”. Lúc đó mình cũng “Dạ, em cũng thấy vậy”, mà lúc đó đã có trải nghiệm gì đâu mà Dạ như đúng rồi =]].Bây giờ, đã qua rồi cái thời sinh viên đó, giờ mới thật sự hiểu được tâm trạng của người nói.Nói dài nói dai, nói tóm lại là 4 năm sẽ trôi qua rất mau, nên các bạn cứ sống chậm lại thôi, từ từ mà tận hưởng deadline với bạn bè. Sau cùng nhìn lại thì nó cũng chẳng là gì cả. NOT A BIG DEAL !!! Cái mà các bạn có được là kỉ niệm thời sinh viên đầy nhiệt huyết :).By the way, một phút mặc niệm cho sự đóng góp của các thanh niên: Đạp Xích Lô (DevOps &amp; Security Engineer), Cảnh Nguyễn (Back-end Engineer) đã góp ý chỉnh sửa bài viết.","link":"/2017/09/25/Chuyen-o-Dai-Hoc-Phan-1/"},{"title":"Create and Distribute Private Libraries with Cocoapods","text":"CocoaPods is a dependency manager for Swift and Objective-C projects. This tool not only allows us to easily integrate those dependencies but also allows us to create our own libraries. In this post I’m going to guide you how to create a private library and distribute it to your private team without publishing the library. Init repositoriesGo to Github or Bitbutket, then create two repositories. One for our source code that is shared between our team, the other one for Podspec, which defines all the information about that Pod. Image 1. Create Github repo to store our source code Image 2. Create Github repo to store our Podspec files Following the instructions on Github page, it guides you how to add your project to these repositories. 123456$ echo \"# MyAwesomeKit-Spec\" &gt;&gt; README.md$ git init$ git add README.md$ git commit -m \"first commit\"$ git remote add origin git@github.com:uynguyen/MyAwesomeKit-Spec.git$ git push -u origin master Create our own libraryOpen XCode and create a new Cocoa Touch Framework named MyAwesomeKit. After that, create a simple class called HaHaHaManager, this class defines our public methods for clients. To make it easier, I define a simple method, which takes 2 numbers as arguments then return their addition: 123456public class HaHaHaManager { public init() { } public func awesomeFunction(a: Int, b: Int) -&gt; Int { return a + b }} Note: Since we are creating a public Framework, we have to overide the default constructor of the HaHaHaManager class, make it become public. Otherwise, our clients who use this Framework can not create an instance of this class because the default scope of classes in Swift is internal. After then, push our code to the repository that we created at the first step. Make sure you add a tag as a version for this commit. 1234$ git add .$ git commit -m \"Our first commit\"$ git tag MyAwesomeKit_1.0.0$ git push -u origin master --tags Add your Private Repository to your CocoaPods InstallationUse the following command to create your new private repository to your CocoaPods 1$ pod repo add REPO_NAME SOURCE_URL 1$ pod repo add MyAwesomeKit https://github.com/uynguyen/MyAwesomeKit Make sure you have the correct access rights to the repository. You can config ssh to access the repo via ssh key. See also: Generating a new SSH key and adding it to the ssh-agentTo check if your installation is successful, use the following commands: 12$ cd ~/.cocoapods/repos/MyAwesomeKit$ pod spec lint . --allow-warnings This command is used to validate specifications. --allow-warnings flag indicates that we skip all warnings when validate the Pod file. (Missing some options such as lisence, author or description). Generate our Podspec fileType the command to generate our Podspec file. This file contains all information about our code, including git repository, the version of the library, dependencies, etc. 1$ pod spec create MyAwesomeKit You will see something like this 123456789101112131415Pod::Spec.new do |s| s.name = \"MyAwesomeKit\" s.version = \"1.0.0\" s.summary = \"An awesome KIT can do anything for you\" s.homepage = \"https://github.com/uynguyen/MyAwesomeKit\" s.author = { \"Uy Nguyen\" =&gt; \"uynguyen.itus@gmail.com\" } s.source = { :git =&gt; \"git@github.com:uynguyen/MyAwesomeKit.git\", :tag =&gt; \"MyAwesomeKit_#{s.version}\" } s.platform = :ios, '8.0' s.requires_arc = true s.dependency 'AFNetworking', '~&gt; 3.1.0' [1] s.source_files = \"MyAwesomeKit/**/*.{swift}\" [2] s.frameworks = 'UIKit', 'CoreText' [3] s.library = 'z', 'c++' s.module_name = 'MyAwesomeKit'end Here’s what’s going on: 1: Your other Podspecs depenencies. For more than one dependency, add new line to define it. 2: The source files that will be included. (Replace it by .m, .mm, .c or .cpp if you need) 3: The framewords that are linked with your library. For other options, please refer to Podspec Syntax Reference Push to Spec Repo 1$ pod repo push MyAwesomeKit MyAwesomeKit.podspec --allow-warnings The structure of your folder will be like 12345.├── MyAwesomeKit-Spec └── MyAwesomeKit └── 1.0.0 └── MyAwesomeKit.podspec Whenever you update the library, you have to run the update command to update your Pod repos 1$ pod repo update Use our awesome KitIt’s time to use our powerful Kit. Open XCode and create new project named MyAwesomeApp. After that, type the below command to init the Pod file 1$ Pod init Open the Pod file, add the following code to install our library. 123456789101112131415161718# Uncomment the next line to define a global platform for your projectsource 'git@github.com:uynguyen/MyAwesomeKit-Spec.git'source 'https://github.com/CocoaPods/Specs.git'platform :ios, :deployment_target =&gt; '8.0'target 'MyAwesomeApp' do # Comment the next line if you're not using Swift and don't want to use dynamic frameworks use_frameworks! pod 'MyAwesomeKit', '1.0.0' # Pods for MyAwesomeApp target 'MyAwesomeAppTests' do inherit! :search_paths # Pods for testing end target 'MyAwesomeAppUITests' do inherit! :search_paths # Pods for testing endend Let see our results (Pray and hope to it works well) ConclusionWe have just published our first private Pod to our team. From now on, our team can use this library privately. Moreover, it’s easy to update and distribute the library when it gets upgrade. Thanks to CocoaPod!If you have any questions or comments about the post, feel free to kick an email to me. References[1] Private Pods","link":"/2017/09/25/Create-and-Distribute-Private-Libraries-with-Cocoapods/"},{"title":"Design patterns","text":"","link":"/2018/06/01/Design-patterns/"},{"title":"Bluetooth Integration with App Clips: A How-To Guide","text":"Nowadays, users demand quick and easy access to services they need, without downloading the full version of an app. App Clips - a feature introduced by Apple on iOS 14 - offers a solution to this demand by enabling users to access a small part of an app. By integrating your Bluetooth-enabled app to App clip, you can take user experience to the next level. This opens up new possibilities, such as allowing users to connect to nearby devices, perform a specific feature, and more. In this tutorial, I’ll guide you through integrating Bluetooth into your App Clip. Whether you’re a seasoned developer or a newbie, you will find everything you need to get started. So, let’s dive in! App Clips“An App Clip is a small part of your app that’s discoverable at the moment it’s needed and lets people complete a quick task from your app — even before installing your full app.”. App Clips are designed to be lightweight and fast, providing quick access to your app’s core features and services.There are many benefits of using App Clips. Firstly, it offers a lightweight part of your app for users to try out an app’s feature without committing to a full download. Secondly, Appclips can be launched through various channels such as NFS tags, QR codes, links from Safari, or Messages.Here are some use cases and example apps using AppClips: Ticketing: AppClip can be used to quickly purchase and access tickets for events such as concerts, movies, or sporting events. Ride-requesting: AppClip can be used to easily make a request for a ride service. E.g Lyft. Retail: App Clips can be used to quickly access product information, make a purchase, or redeem a coupon at a retail store Food ordering: users can quickly access the restaurant’s menu and place an order. E.g: Panera Bread. Parking: Users can simply scan a QR code or tap an NFS tag to launch the Appclipa and pay for their parking spot. Please be aware that an Apple paid account is required in order to develop an AppClip. ConfigurationOpen a hostingBefore launching the App Clip, the system ensures that the App Clip includes its code signature on your website. If you have your own website you can add the following lines to your Apple App Site Association (AASA) on your server and go to the next step. 1234567{ &quot;appclips&quot;: { &quot;apps&quot;: [ &quot;[YOUR_TEAM_ID].[YOUR_APP_CLIP_BUNDLE_ID]&quot; ] }} Firebase Hosting can be a great option for those who don’t have their own server. With Firebase Hosting, you can easily configure your site without any cost as it provides a free tier for hosting. Install the Firebase command-line tool via the following command sudo npm install -g firebase-tools Next, log in to your Firebase account firebase login After successfully logging in, navigate to the directory that contains the file you want to upload, and then run firebase init to select the hosting option. Add the following lines to firebase.json file. 1234567891011121314...&quot;headers&quot;: [ { &quot;source&quot;: &quot;/.well-known/apple-app-site-association&quot;, &quot;headers&quot;: [ { &quot;key&quot;: &quot;Content-Type&quot;, &quot;value&quot;: &quot;application/json&quot; } ] }],&quot;appAssociation&quot;: &quot;NONE&quot;,... Next, create public/.well-known/apple-app-site-association file. 1234567{ &quot;appclips&quot;: { &quot;apps&quot;: [ &quot;[YOUR_TEAM_ID].[YOUR_APP_CLIP_BUNDLE_ID]&quot; ] }} Finally, upload files to firebase firebase deploy Once the deployment is successful, you will be provided with the URL for your website. This URL will be used to configure the launch of your AppClip. Add Appclip targetFirst, open your Xcode project and navigate to the File menu. From there, select New and then Target. This will bring up a dialog box that allows you to choose the type of target that you want to create. Next, select the option for App Clip and click Next. This will take you to a screen where you can configure various settings for your App Clip, such as its name, identifier, and deployment target. Once you have configured these settings, click Finish to create the new App Clip target. This will add the necessary files and resources to your project and allow you to start developing your App Clip. To configure your AppClip to launch properly, you will need to follow a few simple steps.First, select your AppClip target from Xcode, then navigate to Signing &amp; Capabilities and select Associated Domains. From there, you can add your hosting URL to the list of domains that your AppClip is associated with. For example, let’s say that your hosting URL is awesomeapp-54431.web.app. In this case, you would add appclips:awesomeapp-54431.web.app to the list of domains. Once you have completed these steps, everything should be set up properly and you can begin implementing your AppClip functions. This may involve writing code to interact with various APIs, designing user interfaces, and more. The exact details will depend on the specific requirements of your AppClip and the features that you want to include. ImplementationI will develop a very simple application that allows to scan nearby Bluetooth devices and display them on a list when launching the Appclip to demonstrate how to utilize Bluetooth in Appclip. You may modify the application to fit your needs, such as automatically identifying a pre-selected device by address and automatically connecting to the device to execute a specific task. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950struct ContentView: View { // The rest are omitted ... var body: some View { NavigationView { VStack { Image(\"logo\").resizable() .scaledToFit() .frame(width: 120).padding(.top, 10) TitleLargeText(\"Awesome App\").padding(.bottom, 5).padding(.top, 10).padding(.bottom, 10) Spacer() LabelLargeText(\"Nearby Devices\").frame(maxWidth: .infinity, alignment: .leading).padding(.horizontal, 20) List(devices.map { $0.name ?? \"Unknown name\" }, id: \\.self) { deviceName in LabelMediumText(deviceName) } VStack { HStack { LabelMediumText(\"Powered By\") Link(destination: URL(string: \"https://uynguyen.github.io\")!, label: { LabelMediumText(\"Uy Nguyen\", underline: true) }) }.padding(.top, 5) } } .frame(maxWidth: .infinity, maxHeight: .infinity, alignment: .top) .background(Color.black).onContinueUserActivity(NSUserActivityTypeBrowsingWeb, perform: handleUserActivity) .navigationBarTitle(\"\") .navigationBarHidden(true) } } func handleUserActivity(_ userActivity: NSUserActivity) { // You can extract params from the url, validate if the url is valid, etc. guard let incomingURL = userActivity.webpageURL, let components = URLComponents(url: incomingURL, resolvingAgainstBaseURL: true), let queryItems = components.queryItems else { return } // Everything is ok, let's start scanning BluetoothManager.shared.config { device, rssi in if !(devices.contains(where: { $0.identifier.uuidString == device.identifier.uuidString })) { devices.append(device) } } } ...} TestingQR code &amp; NFCApple supports testing your Appclip without having to publish it by registering a Local Experience.To register local experience, go to phone Settings and select Developer. From there, you can access the Local Experiences menu and click on Register Local Experience.Once you have entered your URL prefix and Bundle ID, you will be able to start filling in the information for your App Clip Card. This is the section that will display to users when they click on the URL or scan the QR code associated with your App Clip.In the App Clip Card section, you will be able to provide users with important information about your App Clip, including its name, banner, and description. This information should be clear and concise so that users can quickly understand what your App Clip does and how it can be useful to them.In addition to this, you will also need to select the type of button that you want to use for your App Clip. There are three different types of buttons available: Open, View, and Play.The Open button is used to launch the App Clip and take users directly to its main interface.The View button is used to display specific content within the App Clip, such as a particular page or feature.Finally, the Play button is used to launch a media player within the App Clip, allowing users to listen to music or watch videos.By following these simple steps and providing users with a clear and engaging App Clip Card, you can help to ensure that your App Clip is successful and well-received by your target audience. In the video below, you can see a demonstration of how scanning the QR code associated with my website, automatically launch the App Clip and initiate the Bluetooth scanning process for nearby devices. This is a simple example of how App Clips can offer a convenient user experience that eliminates the need for users to navigate through multiple screens or download the full app. Notes: If you find that you no longer need an App Clip that you have previously installed on your iOS device, you can easily remove it by following a few simple steps. Simply go to your Settings and select the App Clips option. From there, you can select the App Clip that you want to remove and click on the option to delete it. If you are experiencing issues with your App Clip and it is failing to launch despite being configured correctly, The first things that you should try is invalidating the cache and re-registering your local experiences. This can be done by going to your Settings and selecting the Developer option. From there, you can access the Local Experiences menu and click on the option to Invalidate Cache. Once you have done this, you can then re-register your local experiences and try launching your App Clip again. Safari &amp; iMessageIn addition to launching App Clips via QR codes, Apple also offers support for launching your App Clip when a user shares a link to your website through the Messages app, or views the URL on Safari directly. The recipient can tap the link to instantly launch your App Clip to access your App Clip’s functionality quickly and easily. It’s important to note that Safari’s Smart App Banner and sharing via Messages are only available when the App Clip is published in the App Store. App Clip banner on Safari: requires the user’s device runs iOS 15+. App Clip banner on iMessage: requires the user’s device runs iOS 14+, and contains the sender as a contact in the Contacts app. To enable showing Appclip card in Safari and iMessage, config the following lines on your website. 1234&lt;meta name=&quot;apple-itunes-app&quot; content=&quot;app-id=YOUR_APP_ID, app-clip-bundle-id=YOUR_APP_CLIP_ID, app-clip-display=card&quot; /&gt;&lt;meta property=&quot;og:image&quot; content=&quot;BANNER_URL&quot; /&gt;&lt;meta property=&quot;og:title&quot; content=&quot;Awesome App&quot; /&gt;&lt;meta property=&quot;og:description&quot; content=&quot;Awesome App description&quot; /&gt; Best practice Keep it simple: The purpose of an App Clip is to provide a simplified version of your app’s functionality. Focus on providing only the key features that users are most likely to need in the context where they are using the App Clip. Optimize for speed: App Clips should be lightweight and fast-loading (Apple requires the size of Appclip must be less than 15MB, this is to ensure that App Clips can be quickly downloaded and launched, even on slower network connections.) to ensure that users can quickly access the functionality they need. Minimize the amount of content and assets that are loaded to ensure that the App Clip loads quickly and doesn’t consume too much data. It’s important to keep the number of parameters to a minimum and make sure they’re easy to understand. The more complex the parameters, the more difficult it will be for users to know how to use them. Limit the length of parameters: It’s best to limit the length of parameters to no more than 50 characters. This will help to ensure that users can easily read and understand the parameters. Validate parameters: Make sure that your App Clip validates all parameters that are passed to it. This will help to ensure that your App Clip functions properly and that users are not able to exploit any vulnerabilities. In addition to scanning QR codes, displaying on Safari, and sharing via iMessage, Apple offers several other methods to launch App Clips, such as tapping a link in the Maps app, location-based suggestions from Siri Suggestions, and NFC tags. To ensure that users can easily discover your App Clip, it is important to leverage the appropriate launch method and optimize for discoverability. By doing so, you can increase the chances of users finding and engaging with your App Clip. Next stepIn the upcoming tutorial, I will provide you with detailed instructions on how to publish your App Clip and configure it to run on Safari, Maps, and iMessage. However, please note that App Clips can only be launched when they are published in the App Store. Therefore, I cannot demonstrate the process until my App Clip passes Apple’s review process. 😝 ConclusionIn conclusion, App Clips offer a great opportunity to enhance user experience and simplify the app interaction process. With App Clips, users can quickly access a specified feature without the need to download the full application. This can be particularly useful for users who want to try out your app or have limited data plans or storage. Whether you are a restaurant owner, retail store manager, or any other type of business, you can leverage App Clip to create a better overall experience for your users.So what are you waiting for? Give App Clips a try and see the difference they can make for your app and your business. Refs https://developer.apple.com/app-clips/","link":"/2023/03/25/Bluetooth-Integration-with-App-Clips-A-How-To-Guide/"},{"title":"Securing Bluetooth Communication: Implementing Authentication and Encryption Flows","text":"Bluetooth has become the invisible thread connecting our devices, from smartwatches and health trackers to smart locks and industrial IoT systems. But with convenience comes risk: Bluetooth communication is wireless and easily intercepted, making it vulnerable to eavesdropping, unauthorized access, and replay attacks.To defend against these threats, authentication and encryption are essential. In this post, I’ll introduce a robust Bluetooth security flow, explaining how authentication, key exchange, and encrypted transfer work together. We’ll also compare it to TLS/https since both share similar approach of layered security. Review: How HTTPS WorksBefore diving deeper into Bluetooth authentication, it’s useful to understand how HTTPS (Hypertext Transfer Protocol Secure) protects communication on the web, since both share similar security principles.When you visit a secure website (https://), your browser and the server perform a process called the TLS handshake to establish trust and encryption. This handshake happens in a few key steps: Client Hello – The browser sends a message to the server introducing itself, listing supported encryption methods and a random number (used later in key generation). Server Hello – The server responds with its own random number, selects an encryption method, and sends its SSL/TLS certificate — which includes its public key and is verified by a Certificate Authority (CA). Authentication – The browser verifies that the certificate is valid and trusted (not expired, revoked, or issued to another domain). This step ensures the website is legitimate. Key Exchange – Using the public key from the certificate (or through ECDHE — Elliptic Curve Diffie-Hellman Ephemeral), both sides securely generate a shared session key that only they can compute. Encrypted Communication – Once the session key is established, all data exchanged between the browser and the server is encrypted using symmetric encryption (typically AES or ChaCha20). Integrity &amp; Authentication – Each message includes a cryptographic checksum (MAC or AEAD tag) to prevent tampering or replay attacks. From that point forward, your connection is both encrypted (no one can read your data) and authenticated (you know you’re talking to the real server). In short, HTTPS secures communication using: Certificates to establish identity. Key exchange to derive unique session keys. Symmetric encryption for performance and confidentiality. Integrity checks to detect any modifications. A Secure Bluetooth Authentication FlowNow let’s translate these concepts into a practical Bluetooth security flow. Unlike HTTPS, Bluetooth doesn’t have a built-in certificate authority infrastructure. Instead, we typically rely on Pre-Shared Keys (PSK) or out-of-band pairing mechanisms to establish initial trust. Here’s a robust authentication and encryption flow for BLE communication: Phase 1: Challenge-Response AuthenticationBefore any sensitive data is exchanged, both the mobile app (Central) and the BLE device (Peripheral) must prove they share a common secret — the PSK. 1234567891011121314151617181920┌──────────────┐ ┌──────────────┐│ Central │ │ Peripheral ││ (Mobile) │ │ (Device) │└──────┬───────┘ └──────┬───────┘ │ │ │ 1. Generate Random Challenge (Nc) │ │ 2. Send Challenge ─────────────────────▶ │ │ │ 3. Device generates Nd │ │ 4. Response = HMAC(PSK, Nc||Nd) │ │ │ │ ◀───────────── 5. Send (Nd, Response) │ │ │ │ 6. Verify Response │ │ 7. Generate own Response for Device │ │ ─────────────────────────────────────▶ │ │ │ │ 8. Device verifies │ ▼ ▼ [Mutual Authentication Complete] How it works: Central generates a nonce (Nc) — a random number used only once — and sends it to the Peripheral. Peripheral generates its own nonce (Nd) and computes a response using HMAC-SHA256:1Response = HMAC-SHA256(PSK, Nc || Nd) Peripheral sends back (Nd, Response) to the Central. Central verifies by computing the same HMAC with the shared PSK. If it matches, the device is authenticated. Mutual authentication — The Central then sends its own response back so the Peripheral can verify the Central’s identity too. This challenge-response mechanism ensures: No replay attacks — Each session uses fresh nonces. No PSK transmission — The secret never travels over the air. Mutual authentication — Both sides prove their identity. Phase 2: Key Exchange with ECDHOnce authenticated, we need to establish a session key for encryption. We use Elliptic Curve Diffie-Hellman (ECDH) to derive a shared secret without transmitting it directly. 1234567891011121314151617181920// Generate ephemeral key pair on each sidelet privateKey = P256.KeyAgreement.PrivateKey()let publicKey = privateKey.publicKey// Exchange public keys over BLE// Central sends its public key to Peripheral// Peripheral sends its public key to Central// Both sides compute the shared secretlet sharedSecret = try privateKey.sharedSecretFromKeyAgreement( with: peerPublicKey)// Derive the session key using HKDFlet sessionKey = sharedSecret.hkdfDerivedSymmetricKey( using: SHA256.self, salt: salt, sharedInfo: \"BLE-Session-Key\".data(using: .utf8)!, outputByteCount: 32) Why ECDH? Forward secrecy — Even if the PSK is compromised later, past sessions remain secure because each session uses ephemeral keys. No shared secret transmission — Only public keys are exchanged; the shared secret is computed independently. Efficient — ECC provides strong security with smaller key sizes, ideal for resource-constrained BLE devices. Phase 3: Encrypted Data TransferWith the session key established, all subsequent communication is encrypted using AES-GCM (Galois/Counter Mode): 1234567891011121314151617181920212223// Encrypting data before sendingfunc encrypt(data: Data, using key: SymmetricKey) throws -&gt; Data { let nonce = AES.GCM.Nonce() let sealedBox = try AES.GCM.seal(data, using: key, nonce: nonce) // Combine nonce + ciphertext + tag for transmission return nonce + sealedBox.ciphertext + sealedBox.tag}// Decrypting received datafunc decrypt(data: Data, using key: SymmetricKey) throws -&gt; Data { let nonce = try AES.GCM.Nonce(data: data.prefix(12)) let ciphertext = data.dropFirst(12).dropLast(16) let tag = data.suffix(16) let sealedBox = try AES.GCM.SealedBox( nonce: nonce, ciphertext: ciphertext, tag: tag ) return try AES.GCM.open(sealedBox, using: key)} AES-GCM provides: Confidentiality — Data is encrypted and unreadable without the key. Integrity — The authentication tag detects any tampering. Authentication — Only parties with the session key can decrypt. Sequence Counter: Preventing Replay AttacksEven with encryption, an attacker could capture and replay encrypted packets. To prevent this, we include a sequence counter: 12345678910111213141516struct SecureMessage { let sequenceNumber: UInt32 let encryptedPayload: Data}class SequenceValidator { private var expectedSequence: UInt32 = 0 func validate(_ message: SecureMessage) -&gt; Bool { guard message.sequenceNumber == expectedSequence else { return false // Replay or out-of-order attack detected } expectedSequence += 1 return true }} The sequence number is included in the authenticated data (AAD) of AES-GCM, so any modification is detected. Comparison: HTTPS vs BLE Security Flow Aspect HTTPS/TLS BLE Security Flow Trust Anchor Certificate Authority (CA) Pre-Shared Key (PSK) Authentication Certificate verification Challenge-response with HMAC Key Exchange ECDHE or RSA ECDH Encryption AES-GCM, ChaCha20-Poly1305 AES-GCM Forward Secrecy Yes (with ECDHE) Yes (ephemeral ECDH keys) Replay Protection Sequence numbers in TLS record Sequence counter in payload Both approaches share the same fundamental principles: Authenticate first — Verify identity before trusting. Derive session keys — Never reuse keys across sessions. Encrypt everything — Protect data confidentiality. Verify integrity — Detect tampering. Implementation ConsiderationsOn the Mobile Side (iOS/Swift)Apple’s CryptoKit framework provides all the primitives needed: 1234567891011121314151617181920212223242526272829import CryptoKitclass BLESecurityManager { private let psk: SymmetricKey private var sessionKey: SymmetricKey? private var sequenceNumber: UInt32 = 0 init(psk: Data) { self.psk = SymmetricKey(data: psk) } // Challenge-response authentication func generateChallenge() -&gt; Data { var bytes = [UInt8](repeating: 0, count: 16) _ = SecRandomCopyBytes(kSecRandomDefault, bytes.count, &amp;bytes) return Data(bytes) } func computeResponse(challenge: Data, nonce: Data) -&gt; Data { let message = challenge + nonce let hmac = HMAC&lt;SHA256&gt;.authenticationCode(for: message, using: psk) return Data(hmac) } func verifyResponse(_ response: Data, challenge: Data, nonce: Data) -&gt; Bool { let expected = computeResponse(challenge: challenge, nonce: nonce) return response == expected }} On the Device Side (Embedded)For resource-constrained devices, libraries like mbed TLS or wolfSSL provide lightweight implementations: 12345678910111213141516171819202122232425// Pseudo-code for embedded device#include \"mbedtls/gcm.h\"#include \"mbedtls/ecdh.h\"int verify_challenge_response( const uint8_t *psk, size_t psk_len, const uint8_t *challenge, size_t challenge_len, const uint8_t *nonce, size_t nonce_len, const uint8_t *response, size_t response_len) { uint8_t computed[32]; uint8_t message[challenge_len + nonce_len]; memcpy(message, challenge, challenge_len); memcpy(message + challenge_len, nonce, nonce_len); mbedtls_md_hmac( mbedtls_md_info_from_type(MBEDTLS_MD_SHA256), psk, psk_len, message, sizeof(message), computed ); return memcmp(computed, response, 32) == 0 ? 0 : -1;} Security Best Practices Rotate PSKs periodically — Don’t rely on a single PSK forever. Implement a secure mechanism to update it. Use secure random number generation — Weak randomness undermines the entire security model. Implement timeout mechanisms — Abort authentication if it takes too long (potential DoS attack). Validate all inputs — Check lengths, formats, and bounds before processing. Handle errors securely — Don’t leak information through error messages or timing differences. Consider BLE 4.2+ Secure Connections — The BLE specification includes LE Secure Connections with ECDH. Use it as an additional layer when available. Practical ApplicationsThis security flow is ideal for scenarios where data confidentiality and device authentication are critical: Wearables — Smartwatches and fitness trackers transmitting health data that falls under privacy regulations (HIPAA, GDPR). Smart Home Devices — Locks, garage door openers, and security cameras where unauthorized access could have physical consequences. Medical Devices — Insulin pumps, pacemakers, and continuous glucose monitors where tampering could be life-threatening. Industrial IoT — Sensors and controllers in manufacturing environments where data integrity affects operations and safety. Payment Terminals — Mobile point-of-sale systems that must protect financial transactions. Automotive — Key fobs, diagnostic tools, and in-vehicle infotainment systems connecting to phones. ConclusionSecurity in Bluetooth communication isn’t just about pairing once and trusting forever — it’s about continuous authentication, fresh keys, and encrypted transfers. By layering: PSK-based challenge-response authentication — Proves both parties share a secret. ECDH key exchange — Establishes forward-secret session keys. AES-GCM encryption — Protects confidentiality and integrity. Sequence counters — Prevents replay attacks. We create a security flow that’s resilient to eavesdropping, impersonation, and replay attacks. Just as HTTPS transformed web security by making encrypted communication the default, implementing robust Bluetooth security flows brings similar trust and resilience to the devices we rely on daily. The wireless convenience of Bluetooth doesn’t have to come at the cost of security — with the right architecture, we can have both. The code examples in this post use Apple’s CryptoKit for iOS. Similar implementations are possible on Android using the Java Cryptography Architecture (JCA) or BouncyCastle, and on embedded devices using mbed TLS or wolfSSL.","link":"/2025/04/02/Bluetooth-security-Implement-authentication/"},{"title":"Drag and Drop","text":"","link":"/2019/09/02/Drag-and-Drop/"},{"title":"Dark Hat - v1.0 has been released 🎉","text":"After years of working in BLE technology, I found that despite there are many applications helping to test BLE devices but none of them performs their roles well. That’s why I decided to implement a BLE application on my own - Dark Hat. The core objective of this application is to share a better tool with you - an engineer working in BLE field. Main FeaturesDiscover nearby devices with multiple filters supported to only show devices which mater to the user. Filter by RSSI. Filter by device name. Filter by service UUID: Only retrieve and scan devices having your service UUID. Support many options in a setting that allows users to customize the app to meet their requirements. State management: Auto reconnect when the connection is lost. Preservation and Restoration: The user now can opt-in to test “Preservation and Restoration”. For more detail about this technique, please refer to Best practice: How to deal with Bluetooth Low Energy in background Steps in the connection flow are now controlled by the user: connection timeout, set notification state and more. The main screen shows all info and services that really matter to you.The inline log view helps you have a better observation of what’s happening on your device.The app also offers an option that allows the user to set his own name for characteristics for better visualization, on | off notification, copy UUID to clipboard, and more. The app supports a smart editor that automatically suggests all recent commands - a small improvement but it helps to reduce your time on testing.The characteristic detail screen now offers an option allowing show all responses from multiple characteristics which helps you to catch the whole flow while testing. Easy for sharing: Share your result just in 1 click. ArchitectureAt the heart of this application is an SDK called BLEFramework - implemented by me - that wraps all logic working with Apple’s BLE framework and provides simple interfaces for high-level layers - the application. By doing this way, we can separate the complex logic from the UI application, making it easy for development and maintenance.Additionally, I plan to move all UI views to a cross-platform technology (maybe React Native) to support Android in a unique, single view layer. All I just need to do is create another SDK supports for Android platform. Next stepsI have a road map to add more amazing features to the app, to name a few: realtime streaming data, speed measurement, multiple connections, control by script, iBeacons.Can’t wait to deliver all these cool features to users.If you have any idea or feedback, feel free to kick an email to uynguyen.itus@gmail.com or dark.hat.ble@gmail.com, I would love to hear from you.","link":"/2021/07/25/Dark-Hat-v1-0-has-been-released-yay/"},{"title":"Documenting a Software Architecture","text":"It’s clear that documenting architectures is one of the most boring important tasks of Software Engineering. A two-sided activityThere are many good reasons why we have to document our software projects: Other members can understand and evaluate the design of this software. We can understand what we implemented when we return to it after a certain of time. We can do analysis on the design to evaluate the performance of this system, prevent errors occur before we start the implementation phase. Documenting architectures also have some downsides, like: The documents will gradually out of date with the code. Keeping the architecture documentscurrent is often an overlooked activity, especially under the pressures in a project. Documenting is time consuming and expensive. So when should we document software architectures?There are a lot of factors to consider if we need to document or not. Projects with little prospect of a long life probably don’t need a lot of documentation. The other factor to consider when documenting is the needs of project stakeholders, including the various roles like developers, testers, managers, etc. In a small team, the documentation can be minimal and can be replaced by interpersonal communication, it saves our time. In a large team, however, the documentation becomes more important for describing the system, especially companies that work in multiple countries and in many offices. Therefore, it is important to think carefully before documentation because it takes time to develop and maintain along with projects.In this post, I will introduce you to the most popular language to document software architectures: Unified Modeling Language. Unified Modeling Language (UML)UML is a modeling language of Software Engineering. It provides a standard way to visualize the design of a system or an application. UML includes both structural and behavioral diagrams for representing a software system: A structual diagram describes static architectures of its system. A behavioral diagram shows the interactions between entities inside a system. Note that I have never used Component diagrams, Package diagram, Deployment diagrams, Profile Diagram, Composite Structure diagrams, Communication diagrams, Interaction Overview diagrams and Timing diagrams so I’m going to skip these diagrams in this post. Structual diagramsClass diagramsA class diagram describes the structure of a system by showing relationships between its classes. It also shows attributes and methods of each class. The main purpose of class diagrams is to get the general overview of the system. Where vis = visibility Syntax Visibility type + Public If a variable or a method is static, it has to be underlined. # Protected - Private ~ Package The following lines introduce some major replationships in Class diagrams. Mark Meaning Implementation Class B implement the behaviors that are defined in Class A. Inheritance Class B has IS-A relationship with class A, or we can say Class B is a type of Class A. Dependency It exists between two elements if changes to the definition of one element may cause changes to the other. Association A binary association (with two ends) is normally represented as a line. It indicates that Class A contains one or more properties belonged to class B, or vice versa. Aggregation It is a special case of Association. We can say Class A is aggregated with Class B if Object X as an instance of class A is destroyed but Object Y as an instance of class B is still exist. Here, the lives of both Employee and Department are independent of each other. Employees may exist without a department. Composition It is a special case of Aggregation but it is stronger than Aggregation relationship. If Object X as an instance of class A is destroyed, the Object Y as an instance of class B will also be destroyed. We also say Composition is HAS-A relationship. Here, If we delete the verhicle object then all the engines are automatically deleted. The engines do not have their independent life cycle, it depends on the verhicle object’s life. A class diagram example. Instance diagrams (Object diagrams)Basically, an instance diagram is similar to the class diagram which it depends upon. However, an instance diagram is just a snapshot of the system at some point in time, and it shows what values those objects contain at this specified time. Instance diagrams are often used to make prototypes of a system, and to get more understand the system in a practical view.Symbols and notations of instance diagrams can be utilized in class diagrams. Example Transfer from a class diagramt to an instance diagram. Behavioral diagramsActivity diagramsAn activity diagram shows the flow from one activity to another activity (An activity is a function performed by the system). Note that messages are not included in activity diagrams.An activity diagram is often used to describe the high level of the system, mainly for business users or non-technical persons. It can also describe the steps in a use case diagram.Basic symbols and components: Basic Symbol Meaning Start point It represents the initial action state. Activity It represents an activity of the process. Condition Use this symbol when an activity requires a decision prior to moving on to the next activity Synchronization It indicates that multiple acitivies are performed synchronously. Time event This refers to an event that stops the flow for a time. Interrupting Edge An event that interrupts the flow. End Point It represents the final action state. Sequence diagramsA sequence diagram shows how objects and components interact with each other to complete a function.Basic symbols and components: Basic Symbol Meaning Actor It shows entities that interact with the system. Object It represents an object in UML. Activation box It represents the time needed to complete a task. Loop It indicates loop statements. Alternative It indicates condition statements. Parallel Each task in the frame represents a thread of execution done in parallel. Synchronous message The sender must wait for a response to a message before it continues. The diagram should show both the call and the reply. Asynchronous message The sender does not need to wait for a response to a message before it continues. Return message Messages are replied to calls. Delete object It indicates that the object will be detroyed. State Machine diagramsThe main purpose of state machine diagrams is to show the state changing of an object during its lifetime. Basic Symbol Meaning State A state represents a situation during the life of an object. Initial State The object’s initial state. Final State The object’s final state. The following example shows the transition state of an order. Use Case diagramsAn use-case diagram shows how the users or other external applications interact with the system. It also shows the scope of the system. Basic Symbol Meaning Actors They represent the users or external systems that interact with our system. Use cases They represent the different uses that a user might have. Associations There are two types of associations: Actor-use case and use case - use case. an Actor - use case association indicates which actors are associated with which use cases. An Use case - Use case association shows the relationship of two use cases: - Include: A use case “include” another if it is a required action by the use case. - Extend: A use case “extend” another if it is an optional use of the use case. - Generalization: The use case inherits the structure, behavior, and relationships of another. Have you ever heard about Business Process Model and Notation (or BPMN)?“Business Process Model and Notation (BPMN) is a standard for business process modeling that provides a graphical notation for specifying business processes in a Business Process Diagram (BPD).” (Wiki).The main objectives of BPMN are: To provide a set of standard notation that is understandable by business stakeholders. Often used to defined business logic because it has more complete concepts of events and it supports asynchronous message exchanges, which are important in business processing. BPMN is similar to activity diagram from UML. An Example of BPMN. A shopping process described by using BPMN (Source from Google image) ## Differences between UML and BPMN, which one to use? We use BMPN to describe the system on a high level, not care too much about computational details. In contrast, UML is used to define the details of this system, how is it constructed? how is it organized? how does it interact with other components? how is data processed? etc. ConclusionIn this post, I showed you the general ideas of some popular UML diagrams, and showed you the main difference between the UML and the BPMN. Of course, there’re still a lot of purposes and notations of those diagrams that I can not list out here because of the scope of this post.If you are interested in UML, you can download the full document of UML here (The latest version of UML is 2.5.1).Thanks for reading. References[1] Essential Software Architecture (2011, Springer-Verlag Berlin Heidelberg)Ian Gorton (auth.), Chapter 8 Documenting a Software Architecture.","link":"/2018/04/11/Documenting-a-Software-Architecture/"},{"title":"Fork and publish your custom lib to npm - React Native Wheel Picker","text":"When developing a new feature of our software, we tend to search if there is a “similar” library or framework available in the community to reuse it. No one like to reinvent the wheel, dont you? 😉 However, the lib that most fits our requirement sometimes does not support a feature you need or just a custom property. You can open a pull request to the original repo, but it might take time and depend on the author whether he approves your changes or not. In that case, you can create your own library from the original one, we named it “Fork” process.In this post, I will shortly summarize steps to publish a library to npm, and tell you about a story that I faced when using React Native Wheel Picker library. It’s quite simple to publish a lib to npm. Just need to do the following steps: Make sure you have a npm account. Go to https://www.npmjs.com to sign up for an account if you don’t have one. Next, sign in to your account on your computer via the command line npm login. To check which user is signed in, use npm whoami. The lib I use for my project support a Wheel Picker component, but it has been deprecated, and it does not support setting the color of the selected item on Android. Besides, I want to create my own lib so that I can easily add more features later. So I decided to fork and custom my own wheel picker. To fork a lib, go to the repo of the lib you want to modify, then press the fork button on the top right corner. After forking successfully, you should see the repo from on your dashboard. Next, clone the code to your computer, and add your new features.In my case, I need to add a new feature that supports setting the color for the selected item (Refer to this PR) When finishing your modification, commit your changes. Update the repo info at the package.json file if needed (Author, version, description, etc.). Finally, run npm publish --access public to deliver your awesome lib. It’s time to check the new lib. If you install the new lib @uynguyen505/react-native-wheel-picker and try to use it, you should see the result as below. Happy weekend! Refs Creating and publishing scoped public packages Forking, Modifying, and Publishing NPM Packages — For those almost-perfect packages","link":"/2022/03/26/Fork-and-publish-your-custom-lib-to-npm/"},{"title":"Grand Central Dispatch in Swift","text":"Grand Central Dispatch, or GCD for short, is a low-level C APIs for managing concurrent tasks. It helps us improve our app performance by executing a block of code in reasonable threads, like perform computationally expensive tasks in the background. GCD provides several options for running tasks such as synchronously, asynchronously, after a certain delay, etc.In this post I will explain more details about GCD and how it works, also provide some interesting points when we work with GCD. Let’s start. IntroductionAt the heart of GCD are dispatch queues which are pools of threads managed by GCD. Apple creates GCD to make developers don’t need to care too much about these queues, they just simply dispatch a block of code to a given queue without caring about which thread is used. GCD ConceptsConcurrencyConcurrency is achieved when more than two tasks are executed at the same time. In fact, the word “Concurrency” does not exactly mean “at the same time” or “happen in parallel”. Under the hook, CPU gives every task a certain time slice to do its works. For example, if there are 5 tasks to be executed in one second, with the same priority, the OS will divide 1,000 milliseconds by 5 (tasks) and will give each task 200 milliseconds of the CPU time. As a result, they will appear to have been executed concurrently. Serial queue and concurrent queueA serial queue will execute its tasks in a first-in-first-out (FIFO) fashion. It’s mean that they can only execute one block of code at a time. They do not run on the main thread, therefore, they do not block the UI.In contrast, a concurrent queue allows to execute multiple tasks in parallel. It means tasks can finish in any order and you won’t know the time it will take. Synchronously (sync) and asynchronously (async) methodsWhen you dispatch a task to a queue, you determine whether the block run synchronously or asynchronously. There are some main differences between the two techniques: A synchronous method returns control to the caller only after the task is completed whereas an asynchronous method returns control to the caller immediately. Since asynchronous methods return control immediately so they don’t block the current thread. Note that the world “synchronous” does not mean the program have to wait for the code to finish before continuing. It just means that the concurrent queue will wait until the task has finished before it executes the next block of code on the queue.The code below demonstrates how to use async and sync executions.1234567891011121314151617DispatchQueue.global().sync { [1] print(\"A\") DispatchQueue.global().async { for i in 0...5 { print(i) } }}DispatchQueue.global().sync { [2] print(\"B\") DispatchQueue.global().async { for i in 6...10 { print(i) } }} Generally, we can not predict the output when we run the code above because everytime we run the program, the numerous of different outputs will be printed. We can only say that “B” will always be printed after “A” as the caller need to wait for the block [1] returns control so that it can execute the next block [2].If we edit these inner blocks to sync, we guarantee that the output will always be A 0 1 2 3 4 5 B 6 7 8 9 10.Three main types of queuesThere are three main types of queues in GCD: Main queue: Tasks are dispatched to this queue will be performed on the main thread, where UI-related works are called. The Main queue is a serial queue. Important note, the sync method can not be called on main thread because it will block the thread completely and lead the application to deadlock. Therefore, all tasks submitted to the main queue must be submitted asynchronously. 1234567override func viewDidLoad() { super.viewDidLoad() let mainQueue = DispatchQueue.main mainQueue.sync { // -&gt; This code will lead to Deadlock print(\"Inner block called\") }} Global queues: They are concurrent queues and are shared by the system. We use global queues for any task that does not involve the UI. For example, downloading an image from the internet then display it to the user after it is downloaded, fetching database from a server, etc.When we work with global queues, we don’t specify the priority but we use a Quality of Service (QoS) to help the GCD determine the priority of the tasks. It is important to keep in mind that apps use various resources like CPU, memory, network interface, etc. Thus, we should choose the right QoS of the queue in order to remain responsive and efficient of the app. The OS will base on the given QoS to make smart decisions about when and where to execute them.There are four types of QoS: User-interactive: This indicates that the tasks need to be executed immediately in order to remain responsive on UI. We use it for UI updates or performing animations. User-initiated: Work that the user has initiated and requires immediate results (In a few seconds or less). We use it to perform an action when users click something in the UI. Utility: the tasks may take some time to complete and does not require an immediate result (Takes a few seconds to a few minutes) such as downloading data. Background: This represents tasks that the user is not directly aware of. Normally, we use it for fetching data or any tasks that don’t require user interaction. Custom queues: When you create a custom queue, you can specify which type of queue it is (Serial or concurrent). By default, they’re serial queues. DeadlockThe word Deadlock refers to a situation in which a set of different threads sharing the same resource are waiting for each other release the resource to finish its tasks.When working with the GCD, if we do not fully understand the GCD’s concepts, we may create a deadlock in our code. For example, the code below is making a deadlock. 123456789func deadLock() { let myQueue = DispatchQueue(label: \"myLabel\") myQueue.async { myQueue.sync { print(\"Inner block called\") } print(\"Outer block called\") } } First, we create a custom queue with a given label. Then we dispatch asynchronously a block of code calling another block of code synchronously. It is clear that the inner and the outer blocks are executing on the same queue. By default, a custom queue is serial so the inner block will not start before the outer block finishes. On the other hand, the outer block can not finish because the inner block is holding the control of the current thread (Synchronously). Hence, a deadlock occurs.There are two ways to fix the problem. The first one is changing the type of the queue to concurrent. By doing this way, we ensure that the inner block does not have to wait for the outer block has finished so that it can start. 1let myQueue = DispatchQueue(label: \"myLabel\", attributes: .concurrent) The second one is changing the inner block to async. This time, the outer block will not wait for the inner block has completed so that it can start. 123456myQueue.async { myQueue.async { print(\"Inner block called\") } print(\"outer block called\")} There is a recommend on Apple document about Deadlock at Dispatch queues and thread safety chapter&quot;Do not call the dispatch_sync function from a task that is executing on the same queue that you pass to your function call. Doing so will deadlock the queue. If you need to dispatch to the current queue, do so asynchronously using the dispatch_async function.&quot; LivelockThere is another lock concept besides deadlock called Livelock. Unlike deadlock, the livelock does not block the current thread. They’re just unable to make further progress. Or to more accurately, livelock is “a situation in which two or more processes continuously change their states in response to changes in the other process(es) without doing any useful work”.There is a good human example of livelock on StackOverflowA husband and wife are trying to eat soup, but only have one spoon between them. Each spouse is too polite, and will pass the spoon if the other has not yet eaten.There are other types of lock when we work with concurrency like bound resources, mutual exclusion, starvation. Because of the scope of this post, I will not explain all of them here. Please refer to other sources for more details. Important notes On iPhones, discretionary and background operations, including networking, are paused when Low Power Mode is enabled. When using Xcode 9 with iOS 11, a warning will be emitted when a user-interface object is accessed from a non-main thread. The user interactive priority should be rare in your program. If everything is high priority, nothing is. ConclusionIn this post, I showed you some interesting points about GCD in Swift. In next post, we will discuss more about other advanced concepts of concurrent programming like DispatchGroup, Operation Queue, Group Tasks, etc. Then we will implement a tiny project to mix them together.If you have any comments, don’t be hesitate to contact me. References[1] Apple’s documentation: Concurrency Programming Guide[2] iOS 8 Swift Programming Cookbook by O’Reilly, Chap.7: Concurrency and Multitasking.","link":"/2018/01/04/Grand-Central-Dispatch-in-Swift/"},{"title":"Memory leak","text":"As a Software Engineer, you definitely have heard about the Memory leak concept. Memory leak is a situation where blocks of memory are located by the program remain in the memory despise they are no longer referenced. Leaks waste space by filling up pages of memory with inaccessible data. As a result, the size of memory using in your apps keep increasing, affect the user experiences and the performance of your app. Even worse, your app will be crashed randomly because a process will be terminated by the system if it consumes too much memory.In this topic, we will discuss how the memory is managed in iOS and how to use the memory efficiently. Read on. Automatic Reference CountingARCMost of the modern programming languages (such as Java, C#, Go, etc.) have a built-in process which automatically finds unused objects and deletes them to free up memory. The primary purpose of this technology is to reduce memory leak and let programmers focus on their business logic without caring too much about memory management.As a high-level programming language, Swift also has Automatic Reference Counting (ARC) to manage memory using in our apps. How ARC worksWhenever we create a new instance of a class, ARC will allocate a space of memory to store information about that instance. This memory holds information about the type of the instance, any stored properties associated with that instance. Especially, this memory holds the information of how many properties, constants, and variables are currently referring to that instance. ARC will never deallocate that instance as long as at least one active reference to that instance still exists.Once the number of objects referring to that instance comes to zero, ARC will deallocate that instance and free the memory held by that instance.By applying this technique, Apple ensures that class instances do not keep holding space in memory when they are no longer needed, generally avoids the problem of memory leaks. Memory leakIn most cases, ARC does its job well. We don’t usually worry about memory management. However, leaks still happen in iOS by accident. This is when two objects hold strong references to one another so that each object keeps the other one from being deallocated. Let’s take an example, there are two classed named Person and Car. 1234567891011121314151617181920212223242526272829class Person { let name: String var car: Car? lazy var greeting: () -&gt; String = { return \"Hello, my name is \\(self.name). I have \\(self.car?.name ?? \"no cars\")\" } init(name: String) { self.name = name } deinit { print(\"Person \\(self.name) is being destroyed.\") }}class Car { let name: String var owner: Person? init(name: String) { self.name = name } deinit { print(\"car \\(self.name) is being destroyed.\") }} Every Person instance has a name property of type String and an optional Car property that initially nil because a person may not always have a car.Likewise, every Car instance has a name property of type String and an optional Person property that initially nil because a car may not always have an owner.Next, let’s define two variables called Foo and BMW of Person and Car classes, respectively. Now, we link the two instances together so that the person has a car, and the car has an owner. 123456# Main blockvar foo: Person? = Person(name: \"Foo\")var car: Car? = Car(name: \"BMW\")foo!.car = carseat!.owner = fooprint(foo!.greeting()) The next code snippet will release these two instances by setting them to nil. 12foo = nilseat = nil As you might know, once setting a variable to nil, it means there are no references to this class instance, ARC will deallocate the space of this object to free up memory. As an expectation, we should see the deinit methods of Student and Car are called. However, those two methods are never called, there are no any messages, indicates objects are released, printed to the console. This means that the foo and the car are never deinitialized.The reason why these two objects are not released because these two objects hold strong references to one another so that each object keeps the other one from being deallocated, resulting in they are never deinitialized. This situation is called strong reference cycle in programming. Break strong reference cyclesThere are two ways to break strong reference cycles in Swift. Depending on which situation we are facing, we will choose a sensible approach to solve the problem. Both methods let an instance reference to one another without keeping a strong hold on it. Weak referenceWeak references should be used when the object it refers to might become nil in the future. As such, the captured objects are optional types.In the example above, it’s appropriate for a car to be able to have no owner at some point in its lifetime, and so a weak reference is an appropriate way to break the reference cycle in this case.Let’s make some changes to make the magic happen 123456789101112class Car { let name: String weak var owner: Person? init(name: String) { self.name = name } deinit { print(\"Car \\(self.name) is being destroyed.\") }} Let’s run the code, there are still no messages printed to the console, it means the two objects are not released. What the heck!Let’s trace back to our code to check what’s wrong with it.Do you see that? There is another problem with the code: The closure. Unowned referenceIn the above example, the Person class not only creates a strong reference cycle with the Car class but also between itself and the greeting closure. Here is how the cycle looks:To resolve this problem, we will use “Unowned reference”. Unowned references should be used when the closure and the object it refers to will always have the same lifetime as one another. This means the two objects will be deallocated at the same time. As a result, an unowned reference can never become nil.Let’s make some changes to make the magic happen (Again). 12345678910111213141516class Person { let name: String var car: Car? lazy var greeting: () -&gt; String = { [unowned self] in return \"Hello, my name is \\(self.name). I have \\(self.car?.name ?? \"no cars\")\" } init(name: String) { self.name = name } deinit { print(\"Person \\(self.name) is being destroyed.\") }} Let’s run the code, you should see the following messages printed to the console. 123Hello, my name is Foo. I have BMWPerson Foo is being destroyed.Car BMW is being destroyed. The two objects foo and car have been released and the leak has been resolved.Here is how the cycle looks so far: Tools to detect strong reference cyclesEncountering memory leaks is usually a nightmare for an iOS developer because it is too difficult to figure out the root cause. Luckily, we have multiple tools are supported by Apple to track down memory leaks. Allocations and Leaks InstrumentFrom the toolbar of XCode, choose Product &gt; Profile &gt; Allocations to start a new instrument profile for tracking memory allocations. Allocations instrument tracks all of the objects that app allocates during its lifetime.Now, press the red button on the top left in the panel to start recording.There is so many information related to memory mapping showed in the tool. To identify memory leak, we just need to focus on two main columns: #Persident and #Transident. Persident column: keeps a count of the number of objects of each type that currently exist in memory. Transident column: shows the number of objects that have existed but have since been deallocated. As you can see, the #Persident column keep increasing whenever you press to the “Create a leak” button to execute the main block. When you see something like this happend to your app, it’s time to revise your classes to find out where the leak is. Debug Memory GraphDebug Memory Graph is a tool first introduced in Xcode 8. It is able to grab leaks such as retain cycles.From the debug navigator, click debug mode &gt; View Memory Graph Hierarchy to visualize the memory mappingYou should see somethings like this.From the visualization, we can see there are two strong reference cycles come from the Person-Car relationship and from inside the Person itself. ConclusionEvery iOS developer should have a deep understanding of how ARC works to avoid memory leaks. Undeniably, a good management of memory contributes to the app performance and the user experience. Hopefully, all of the concepts we walk through in this article will help you build apps that have the best performance. Feel free to leave your comments here. References[1] The Swift Programming Language (Swift 4.0.3), App Inc., Automatic Reference Counting chapter.","link":"/2018/09/12/Memory-leak/"},{"title":"Protobuf In Practice","text":"I have worked on Bluetooth products, including wearable devices and smart locks, in many years. Facilitating the transfer of messages between system components is a crucial aspect due to differences in programming languages, the necessity for consistency, and limitations on data transfer size. To address these challenges, we utilize Protocol Buffers.Protocol Buffers, also known as Protobuf, is a free and open-source cross-platform data format used to serialize structured data developed by Google. It is designed to be efficient, extensible, and user-friendly. In this tutorial, we will cover the basics of creating a simple Protocol Buffers message, defining a schema, and generating code in various programming languages. InstallationTo install the protobuf compiler, follow the instructions outlined in protobuf-compiler-installation.The basic usage can be summarized by the image below. Steps to set up: Install the protobuf compiler. On Mac, use brew: brew install protobuf Validate if the installation completed successfully: protoc --version. Installing the Code Generator Plugin: Protobuf supports several different programming languages. You need to find and install the code generator for the specific language depending on which programming languages are used in your project. For example, for Swift, use swift-protobuf: brew install swift-protobuf. For JavaScript, use npm install -g protoc-gen-js. Define your schemes: Visit Programming Guides to learn how to use the protocol buffer language to structure your protocol buffer data example.proto12345message Person { optional string name = 1; optional int32 id = 2; optional string email = 3;} Compile .proto files to generate code for specific languages. 1234nguyenuy@192  ~/Desktop/protobuf  protoc --js_out=. example.protonguyenuy@192  ~/Desktop/protobuf  protoc --java_out=. example.protonguyenuy@192  ~/Desktop/protobuf  protoc --cpp_out=. example.protonguyenuy@192  ~/Desktop/protobuf  protoc --dart_out=. example.proto Distribute (import) the generated files into your projects. Install the runtime plugin. For instance, in an iOS project, include the SwiftProtobuf framework in the Podfile. For Flutter projects, add protobuf to the pubspec.yaml file. For ReactJS projects, include google-protobuf in the package.json file. Implement serialization and deserialization:Example in Python 12345678910111213person = example_pb2.Person()# Set valuesperson.name = \"Uy Nguyen\"person.id = 1person.email = \"uynguyen.itus@gmail.com\"# Serialize the message to bytesserialized_data = person.SerializeToString()# Parse the bytes back into a messagenew_person = example_pb2.Person()new_person.ParseFromString(serialized_data) Example in Java 1234567891011Person person = Person.newBuilder() .setName(\"Uy Nguyen\") .setId(1) .setEmail(\"uynguyen@gmail.com\") .build();// Serialize the message to bytesbyte[] serializedData = person.toByteArray();// Parse the bytes back into a messagePerson newPerson = Person.parseFrom(serializedData); Example in Swift 12345678910var p = Person()p.id = 1p.email = \"uynguyen.itus@gmail.com\"p.name = \"Uy Nguyen\"// Serialize the message to byteslet data = try? p.serializedData()// Parse the bytes back into a messagelet converted = try? Person(serializedData: data!) Below is how the generated files look in different languages. Pros Binary Format: Protobuf uses a binary format for serialization, which is more compact than JSON text-based format. This results in smaller message sizes, making it more efficient in terms of both bandwidth and storage. Performance: Due to its binary format and efficient encoding, Protobuf serialization and deserialization processes are generally faster than JSON. This can be particularly important in scenarios with high-throughput or low-latency requirements, such as systems applying BLE. Code Generation: Protobuf relies on code generation to create data classes in various programming languages based on the defined schema. This can lead to type-safe and efficient code, reducing the chances of runtime errors related to data structure mismatches. Support for Multiple Languages: Protobuf supports code generation in a variety of programming languages, making it suitable for projects with different technologies. This allows different services written in different languages to easily communicate using the same data structures. Cons Human Readability: Protobuf binary format is not human-readable, which can make debugging and troubleshooting more challenging compared to JSON. JSON plain text format allows developers to inspect the data easily. Debugging Complexity: Due to the binary nature of protobuf, debugging can be more complex when compared to JSON. Specialized tools are often needed to inspect the content of protobuf encoded messages. Less Common in Web Technologies: JSON is more prevalent in web development and is natively supported by many web APIs. If interoperability with web technologies is a top priority, JSON might be a more natural choice. Complexity in Nested Structures: Dealing with nested structures in protobuf messages can sometimes be less intuitive than in JSON. Care must be taken when designing nested structures to avoid unnecessary complexity. SummaryIn summary, while protobuf offers significant advantages in terms of efficiency and performance, its adoption should be considered based on the specific requirements and constraints of the project. It’s essential to consider the pros and cons and choose the serialization format that best aligns with your project’s goals and constraints. Ref Protocol Buffers Documentation","link":"/2024/01/12/Protobuf/"},{"title":"Play with Android Things","text":"","link":"/2019/02/07/Play-with-Android-Things/"},{"title":"React Native In My Real World","text":"React Native was introduced in January of 2015 at React.js Con: The first public preview. In March of 2015, React Native is open and available on Github. After releasing, React Native quickly becomes popular and is constantly updated by thousands of developers in the world. Currently, React Native is one of the most stars repositories on Github. ThreadsPerformanceNative modules123$ react-native run-ios --simulator 'iPad Pro (9.7 inch)'$ react-native run-ios --device 'qa'$ react-native run-ios --configuration Release --device 'qa' 123456789#import &lt;React/RCTBridgeModule.h&gt;@interface RCT_EXTERN_MODULE(SDKWrapper, NSObject)RCT_EXTERN_METHOD(supportedEvents)RCT_EXTERN_METHOD(startScanning)RCT_EXTERN_METHOD(stopScanning)RCT_EXTERN_METHOD(playAnimation)RCT_EXTERN_METHOD(connectToDevice:(NSString *)serialNumber:(RCTPromiseResolveBlock)resolve:(RCTPromiseRejectBlock)reject) //PromiseRCT_EXTERN_METHOD(disConnectToDevice:(RCTPromiseResolveBlock)resolve:(RCTPromiseRejectBlock)reject) //Promise@end 123456789101112public class SDKWrapper extends ReactContextBaseJavaModule { public SDKWrapper(ReactApplicationContext reactContext) { super(reactContext); } @Override public String getName() { return \"SDKWrapper\"; } @ReactMethod public void startScanning() {. . .}} 123456import {NativeModules} from 'react-native'; const {SDKWrapper} = NativeModules; ....SDKWrapper.doSomething();SDKWrapper.saySomething();.... Pros and consPros Native performance Learn once, run everywhere Flex box Hot reloading Platform detection in code Cons Not stable, hard to keep up Lack of documentation Single dedicated device thread Calling callback Conclusion","link":"/2017/12/01/React-Native-In-My-Real-World/"},{"title":"Integrate Google Sign In on MacOS App in Swift","text":"As an iOS developer, you might have chances to write applications on Mac os. And sometimes, your applications require users to authenticate before they can use your app. Enabling Google Sign in helps you save a lot of time to implement authentication flow. Unfortunately, it is a lack of documentation on how to integrate Google Sign in on Macos app, particularly in Swift. I once had a chance to implement this feature to my app. Now I want to share with you how we can do it. Let’s get started. Setting upLet’s first create your mac os application, name whatever you like. Then, run pod init command to init the Pod workspace.Next, add the following line to your Pod file. 123456use_frameworks!pod 'GTMAppAuth' # GTMAppAuth is an alternative authorizer to GTMOAuth2, supports for authorizing requests with AppAuth.pod 'SwiftyJSON' # JSON parserpod 'PromiseKit' # Make async requestspod 'Kingfisher' # Cached imagepod 'SnapKit' # Autolayout Then run pod install to download all these dependencies. Get an OAuth client IDBefore getting started to the example, firstly go-ahead to Google Console and create a new project. Then press the “Create credentials” &gt; “OAuth client ID” &gt; “Other” application type &gt; Follow the instructions to get your credentials.After you create the OAuth client ID, take note of the client ID and the client secret, which you will need to configure Google Sign-in in your app. You can optionally download the configuration file containing your project information for future reference. Config projectMake sure that you configure your app to allow incoming and outcoming network by going to Signing &amp; Capabilities &gt; App Sanbox &gt; Check both Incoming Connections &amp; Outcoming Connections. If you do not do that, you will get the following error because your app does not have permission to perform requests. 122019-12-11 22:22:49.472046+0700 GoogleSignInDemo[3955:65750] Metal API Validation Enabled2019-12-11 22:22:51.444494+0700 GoogleSignInDemo[3955:66166] dnssd_clientstub ConnectToServer: connect() failed path:/var/run/mDNSResponder Socket:11 Err:-1 Errno:1 Operation not permitted Next, open the Info.plist and add a new value for CFBundleURLTypes, which reverses DNS notation form of your client ID. Safari will use this DNS notation to open your app after authentication process is performed successfully. 1234567891011&lt;key&gt;CFBundleURLTypes&lt;/key&gt;&lt;array&gt; &lt;dict&gt; &lt;key&gt;CFBundleTypeRole&lt;/key&gt; &lt;string&gt;Editor&lt;/string&gt; &lt;key&gt;CFBundleURLSchemes&lt;/key&gt; &lt;array&gt; &lt;string&gt;com.googleusercontent.apps.REPLACE_BY_YOUR_CLIENT_ID&lt;/string&gt; &lt;/array&gt; &lt;/dict&gt;&lt;/array&gt; Making authorizationLet’s first create our service object, class GoogleSignInService, which handles all requests related to Google Sign in. It also contains all of your project’s credentials. 123456789class GoogleSignInService: NSObject, OIDExternalUserAgent { static let kYourClientNumer = \"REPLACE_BY_YOUR_CLIENT_ID\" static let kIssuer = \"https://accounts.google.com\" static let kClientID = \"\\(Self.kYourClientNumer).apps.googleusercontent.com\" static let kClientSecret = \"REPLACE_BY_YOUR_CLIENT_SECRET\" static let kRedirectURI = \"com.googleusercontent.apps.\\(Self.kYourClientNumer):/oauthredirect\" static let kExampleAuthorizerKey = \"REPLACE_BY_YOUR_AUTHORIZATION_KEY\" // The rest omitted} Discover Google service’s endpoint and define a request. 1234567891011OIDAuthorizationService.discoverConfiguration(forIssuer: URL(string: Self.kIssuer)!) { // The rest omitted let request = OIDAuthorizationRequest(configuration: config, clientId: Self.kClientID, clientSecret: Self.kClientSecret, scopes: [OIDScopeOpenID, OIDScopeProfile, OIDScopeEmail], redirectURL: URL(string: Self.kRedirectURI)!, responseType: OIDResponseTypeCode, additionalParameters: nil) // The rest omitted} Take a look at the scopes param, this param defines which user’s info your app can access to. Google Sign In offers 5 different scopes, including: NSString *const OIDScopeOpenID = @”openid”; NSString *const OIDScopeProfile = @”profile”; NSString *const OIDScopeEmail = @”email”; NSString *const OIDScopeAddress = @”address”; NSString *const OIDScopePhone = @”phone”; You can select which ones fit your app’s requirements.Finally, start the authentication process. 1234567OIDAuthState.authState(byPresenting: request, externalUserAgent: self, callback: { (state, error) in guard error == nil else { seal.reject(error!) return } // You got the OIDAuthState object here}) After the authentication process performs successfully, you will get an OIDAuthState object which will be used as a param to init the GTMAppAuthFetcherAuthorization object.Normally, you should save this GTMAppAuthFetcherAuthorization object to a key chain and re-use it for the next REST API calls. 123456private func saveState() { // The rest omitted if auth.canAuthorize() { GTMAppAuthFetcherAuthorization.save(auth, toKeychainForName: Self.kExampleAuthorizerKey) }} Making requestsAfter saving the service object to the key chain, you now can retrieve it to make any requests. I will make a request to fetch the current user profile. 12345678910111213func loadProfile() -&gt; Promise&lt;GoogleSignInProfile&gt; { return Promise { (seal) in // The rest omitted if let url = URL(string: \"https://www.googleapis.com/oauth2/v3/userinfo\") { let service = GTMSessionFetcherService() service.authorizer = auth service.fetcher(with: url).beginFetch { (data, error) in // Process the data here // data = [\"locale\", \"family_name\", \"given_name\", \"picture\", \"sub\", \"name\", emai] } } }} Troubleshoot After logging in, if your Safari can not redirect back to your app. Just clean up your project (Shift + Cmd + K) then run again. Other web browsers (Chrome, Firefox, etc) can not open your app so that make sure you launch the sign-in web on Safari.1NSWorkspace.shared.open([url], withAppBundleIdentifier: \"com.apple.Safari\", options: .default, additionalEventParamDescriptor: nil, launchIdentifiers: nil) { Final thoughtsYou can find the completed demo hereNow you can use Google Sign in inside your macOS to reduce your efforts for authentication. To get the full source code, please download via the Github link.In case you have any problems do not hesitate to contact me.","link":"/2019/12/11/Integrate-Google-Sign-In-on-MacOS-App-in-Swift/"},{"title":"Play Central And Peripheral Roles With CoreBluetooth","text":"IntroductionAs I mentioned in the previous post, CoreBluetooth allows us to create applications that can communicate with BLE devices such as heart rate monitors, body sensors, trackers, or hybrid devices.There are two roles to play in the CoreBluetooth concepts: Central and peripheral. Central: Obtain data from peripherals. Peripheral: Publish data to be accessed by a central. We can make a Bluetooth device plays as a peripheral from either firmware-side or software-side. In this post, I will show you how to create a peripheral by using our own identifiers. Also using another device, as a central, to connect and explore our services. Let’s get it started. Set up a PeripheralTo create a service, you need to have a unique identifier called UUID. A standard service has a 16-bit UUID and a custom service has a 128-bit UUID. Go ahead and type the following command to generate a unique uuid from your terminal. 1$ uuidgen As you can see, the command returns an uuid in hexa format (128 bit): A56E51F3-AFFE-4E14-87A2-54927B22354C. We will use this string to set up our own service. 123456789101112131415161718192021class ViewController: UIViewController, CBPeripheralManagerDelegate { let kServiceUUID = \"A56E51F3-AFFE-4E14-87A2-54927B22354C\" // Other properties ... override func viewDidAppear(_ animated: Bool) { super.viewDidAppear(animated) peripheralManager = CBPeripheralManager(delegate: self, queue: nil) [1] } func peripheralManagerDidUpdateState(_ peripheral: CBPeripheralManager) { print(\"peripheralManagerDidUpdateState \\(peripheral.state.rawValue)\") if peripheral.state == .poweredOn { let serviceUUID = CBUUID(string: kServiceUUID) [2] self.service = CBMutableService(type: serviceUUID, primary: true) [3] } // Other code }} Here is what these methods do: [1] You create an instance of PeripheralManager class, which will play as a peripheral in our example. Note that there is a queue param in the constructor. The events of the peripheral role will be dispatched on the provided queue. If we pass nil, the main queue will be used. [2] To set up a service, we need to create an instance of CBUUID class. The constructor gets a unique uuid as a param, which differentiates our service among others. [3] We create an instance of CBMutableService class. The constructor receives two params: The first one is our unique uuid, which was defined at [2]; the second param indicates that whether our service is primary or not. If not, our service will not be found when the app is in the background. Note that you can add services as many as you want. To be simple, I only create one service in this post.OK, let’s move to the next step. We will define characteristics for our service by using the below code. 12345let characteristic = CBMutableCharacteristic.init( type: CBUUID(string: kCharacteristicUUID), [1] properties: [.read, .write, .notify], [2] value: nil, [3] permissions: [CBAttributePermissions.readable, CBAttributePermissions.writeable]) [4] Here is what’s going on: [1] Like a service, a characteristic also needs a unique uuid to be differentiated among others. [2] We set up properties for the char. There is a variety of characteristic permissions, but I often use some of them: Read: Used for characteristics that don’t change very often, e.g version number. Write: Modify the value of the characteristic. Indicate and notify: The peripheral continuously notify the updated value of the characteristic to the central. The central does not have to constantly ask for it. IndicateEncryptionRequired: Only trusted devices can enable indications of the characteristic value.For other properties, please refer to Apple document [3] The value of the characteristic. Important note: If you provide a value for a characteristic, the characteristic must be read-only. Otherwise, you will get a run-time exception look like.2018-03-03 12:48:32.938615+0700 Peripheral[4238:3046876] *** Terminating app due to uncaught exception 'NSInternalInconsistencyException', reason: 'Characteristics with cached values must be read-only'Therefore, you must specify the value to be nil if you expect the value to change during the lifetime of the published service (write). [4] All characteristic should include the “readable” permission so that centrals could read its value. If we want a central can send commands to peripherals, we need to set the “writeable” permission to the characteristic. Now we have one service and one characteristic. Let’s publish it. 1234self.service?.characteristics = []self.service?.characteristics?.append(characteristic)self.peripheralManager.add(self.service!) After adding a service to the peripheral manager, the delegate method peripheralManager(_ peripheral: CBPeripheralManager, didAdd service: CBService, error: Error?) will be called. 1234567func peripheralManager(_ peripheral: CBPeripheralManager, didAdd service: CBService, error: Error?) { if let error = error { print(\"Add service failed: \\(error.localizedDescription)\") return } print(\"Add service succeeded\")} We’re almost done, just one more step: Start advertising the peripheral so that it can be found by other centrals. 12peripheralManager.startAdvertising([CBAdvertisementDataLocalNameKey: \"TiTan\", CBAdvertisementDataServiceUUIDsKey : [self.service!.uuid]]) After advertising, the delegate method peripheralManagerDidStartAdvertising will be triggered to indicate whether the peripheral did advertise successfully or not. 1234567func peripheralManagerDidStartAdvertising(_ peripheral: CBPeripheralManager, error: Error?) { if let error = error { print(\"Start advertising failed: \\(error.localizedDescription)\") return } print(\"Start advertising succeeded\")} At this point, we’ve already defined and published our service(s). From now on, the peripheral can be discovered by centrals via CoreBluetooth. Set up a CentralFirst, we need to create an instance of the CBCentralManager class. 12345678class ViewController: UIViewController, CBCentralManagerDelegate, UITableViewDelegate, UITableViewDataSource, CBPeripheralDelegate { override func viewDidLoad() { super.viewDidLoad() // Do any additional setup after loading the view, typically from a nib. centralManager = CBCentralManager(delegate: self, queue: nil) ... }} Like a peripheral manager, there is a queue param in the constructor. The events of the central role will be dispatched on the provided queue. If we pass nil, the main queue will be used.We need to wait for the central manager to be ready, then we will start scanning nearby devices. 1234567func centralManagerDidUpdateState(_ central: CBCentralManager) { print(\"peripheralManagerDidUpdateState \\(central.state.rawValue)\") if central.state == .poweredOn { self.centralManager.scanForPeripherals(withServices: nil, options: nil) }} If it find a peripheral, the delegate method func centralManager(_ central: CBCentralManager, didDiscover peripheral: CBPeripheral, advertisementData: [String : Any], rssi RSSI: NSNumber) will be called. 123456789101112func centralManager(_ central: CBCentralManager, didDiscover peripheral: CBPeripheral, advertisementData: [String : Any], rssi RSSI: NSNumber) { if let name = peripheral.name { if (!checkIfExisted(name)) { let tupleDeviceInfo = (device: peripheral, rssi: RSSI) self.scannedDevices.append(tupleDeviceInfo) } DispatchQueue.main.async { self.tbvScannedDevices.reloadData() } }} Inside the method, we will check if the peripheral is valid, after that we will add it to the current list, then reload the table view. Note that the RSSI value represents the strength of the transmitting signal. We can estimate the current distance between the central and the peripheral based on the value. The greater the value, the closer the device is.Build and run the project, you will see the list of discovered devices like this. Now, let’s connect to our peripheral (The “Titan” device) by clicking on the corresponding row.Once a connection is made successfully, the delegate method func centralManager(_ central: CBCentralManager, didConnect peripheral: CBPeripheral) will be called. Otherwise, the method centralManager(_ central: CBCentralManager, didFailToConnect peripheral: CBPeripheral, error: Error?) will be triggered. 123456func centralManager(_ central: CBCentralManager, didConnect peripheral: CBPeripheral) { self.centralManager.stopScan() peripheral.delegate = self self.peripheral = peripheral self.peripheral?.discoverServices(nil) [1]} 123centralManager(_ central: CBCentralManager, didFailToConnect peripheral: CBPeripheral, error: Error?) { // Fail to connect peripheral} Notice that after connecting to the peripheral, we need to discover the services of the peripheral to use it ([1]).The delegate method func peripheral(_ peripheral: CBPeripheral, didDiscoverServices error: Error?) will be called after discovering services. 1234567891011func peripheral(_ peripheral: CBPeripheral, didDiscoverServices error: Error?) { if let err = error { print(\"didDiscoverServices fail \\(err.localizedDescription)\") return } // [1] Start discovering all chars for service in (peripheral.services)! { peripheral.discoverCharacteristics(nil, for: service) }} We did not finish yet =.= After discovering services, we also need to discover all characteristics of the services at [1].Like others, the method func peripheral(_ peripheral: CBPeripheral, didDiscoverCharacteristicsFor service: CBService, error: Error?) will be called after discovering characteristics for a service. 123456789101112func peripheral(_ peripheral: CBPeripheral, didDiscoverCharacteristicsFor service: CBService, error: Error?) { if let error = error { print(\"didDiscoverCharacteristicsFor Error \\(error.localizedDescription)\") return } for char in service.characteristics! { if char.properties.contains(.notify) { peripheral.setNotifyValue(true, for: char) [1] } ... }} As you can see, we need to set notify to the characteristic that contains the notify property to receive updates from it. [1]Finally, we’ve done for setting up a connection between the peripheral and the central. Now let’s explore the data. Read and write data from peripheralYou have to specify which characteristic you want to read. 1self.peripheral?.readValue(for: discovererChars[kCharacteristicUUID]!) From the peripheral side, you will receive a read request inside the method 12345func peripheralManager(_ peripheral: CBPeripheralManager, didReceiveRead request: CBATTRequest) { print(\"Read request\") request.value = myValue.data(using: .utf8) peripheral.respond(to: request, withResult: .success)} After the peripheral response to read requests, the delegate method func peripheral(_ peripheral: CBPeripheral, didUpdateValueFor characteristic: CBCharacteristic, error: Error?) will be called from the central side. 1234 func peripheral(_ peripheral: CBPeripheral, didUpdateValueFor characteristic: CBCharacteristic, error: Error?) { let value = String.init(data: characteristic.value!, encoding: .utf8)! ...} If the value is successfully retrieved, you can access it through the characteristic’s value property, like above.Sometimes we want to write the value of a characteristic, which is writeable. We can write the value to it by calling the peripheral’s writeValue method like this. 1self.peripheral?.writeValue(data, for: discovererChars[kCharacteristicUUID]!, type: .withResponse) There is an argument called type, you specify what type of write you want to perform. In the example above, the write type is .withResponse, which instructs the peripheral to let your app know whether or not the write succeeds.From the peripheral side, you will receive a write request inside the method 1234func peripheralManager(_ peripheral: CBPeripheralManager, didReceiveWrite requests: [CBATTRequest]) { print(\"Write request\") peripheral.respond(to: requests[0], withResult: .success)} After the write request receives the response, the method peripheral(_ peripheral: CBPeripheral, didWriteValueFor characteristic: CBCharacteristic, error: Error?) will be called. 12345func peripheral(_ peripheral: CBPeripheral, didWriteValueFor characteristic: CBCharacteristic, error: Error?) { if let err = error { print(\"Did write value with error \\(err.localizedDescription)\") }} Encypted characteristic valuesSometimes we want to secure sensitive data. We can config the appropriate characteristic properties and permissions. Something like this 12345let encryptedChar = CBMutableCharacteristic.init( type: CBUUID(string: kCharacteristicUUID), properties: [.read, .notify, .notifyEncryptionRequired], value: nil, permissions: [.readable]) By doing this way, we ensure that only trusted devices have permissions to access these data.In my example, once a connection is made, CoreBluetooth tries to pair the peripheral (iPad) with the central (iPhone) to create a secure connection. Both devices will receive an alert indicating that the other device would like to pair. After paring, the central can access to the encrypted characteristic values of the peripheral. Some important notes The client-server model of BLE is called a publish and subscribe model. The peripheral only consumes power when it’s advertising its services, or receiving or responding to a central’s request. You can pass a list of service UUIDs inside the scanForPeripherals method. When you specify a list of service UUIDs, the central manager returns only peripherals that advertise those services, allowing you to scan only for devices that you may be interested in. You need to grant permissions to let your app uses Bluetooth LE accessory, and acts as a Bluetooth LE accessory for peripheral sides. (Go to project -&gt; Capabilities for setting). You also need to add one more information property to your info.plist, let’s add an entry with key Privacy - Bluetooth Peripheral Usage Description and value App communicates using CoreBluetooth (Or whatever you want to describe). A quick look to my appLet’s try some light exercise from my example. Summarize the programming flow for BLETo summarize the general programming workflow of CoreBluetooth on iOS, please take a look at the picture below. Final thoughtsIn this post, I guided you how to use the CoreBluetooth to create a peripheral as well as how to create a central to connect and obtain data from a peripheral. In the future, we can see that all devices around us are connected together via Bluetooth, towards the IoT world.You can download the completed project of the central here or the peripheral here.If you have any questions or comments, feel free to leave it on my post. Any comments are welcome. References[1] Core Bluetooth Programming Guide from Apple","link":"/2018/02/21/Play-Central-And-Peripheral-Roles-With-CoreBluetooth/"},{"title":"Review Book: Clean Code","text":"This is a book I have been gifted a long time ago from an old colleague, also he is one of my close friends. This is one of the software books that I like the most but have no chance to buy when I was a student. IntroductionAbout the author, Robert C. Martin, he is considered one of the oldest engineers in the software industry. He has many years of experience working in the software field from various positions, from a developer, manager, to CEO. He is best known for writing software guides that describe software principles, software patterns, and practices of software. He has published many books like Clean Coder, Clean Code, Clean Architecture, etc. Clean Code is one of the software books that many software engineers in the world encourage reading.The author said that *”Over time the mess becomes so big and so deep and so tall, they can not clean it up”*. We need to read, think a lot before writing code. We should avoid writing the code in a hurry. Hurry to write the lousy code will lead to spending more time later for maintaining. Clean Code focuses on the technical aspects: instructing the programmer how to organize the code and write clean code. You won’t be learning any new frameworks, but it will provide you with a fundamental set of coding style rules. It’s worth reading the book. The book contentsThe contents of the book are divided into three parts: The first chapters will explain the principles, patterns, and practices of writing clean code. The second part consists of many case studies, each case study is an exercise in transforming the code that has some problems into code that has fewer problems. The last part is the play-off. Why clean code?Bjarne Stroustrup (Inventor of C++): Elegant, Efficiency.Grady Booch (Author of Object Oriented Analysis): Readability.David Thomas (Founder of OTI): Easy for other people to enhance it.Warn Cunningham (Inventor of Wiki): Make the language look simple.Me: To be able to remember what you write in a month ago. Clean code evaluation criteriaGeneral Don’t repeat yourself: Duplication may be the root of all evil in software. Many principles and practices have been created for the purpose of controlling or eliminating it. Sometimes we can use Template method pattern to remove higher-level duplication. Naming variables, methods, arguments, classes, files The name of a variable, function or class should answer the question why it exists, what it does and how it is used. Use searchable names. Classes and objects should have noun or noun phrase names. Methods should be a verb or verb phrase. Inconsistency: Be careful with the conventions you choose, and once chosen, continue to follow them. Comments Comments should say things that the code can not say for itself: Explain the idea in code, if it can not, then write comments. Comments should be reserved for technical notes about the code and design. Use correct grammar and punctuation. Don’t comment-out code, delete it. Functions Functions should be small: Fewer than 100 lines. It makes the function easier to read and understand. Functions should do only one thing. Functions should have a small number of arguments (Fewer than 4 arguments). Don’t pass boolean values as arguments. Functions that are never called should be deleted. Separate error processing from normal processing. Encapsulate conditionals. Error handling Error handling is important, but if it obscures logic, it’s wrong. Don’t return Null: Consider throwing an exception or returning a SPECIAL CASE object instead. If you code this way, you will minimize the chance of NullPointerException and your code will be cleaner. Don’t pass Null as arguments. Boundaries Wrapping third-party APIs: Minimize your dependency upon it. When there are new releases of the third-party package, we should run the test to see whether there are behavioral differences. Avoid letting too much of our code know about the third-party particulars: Let’s use an Adapter to deal with it. Classes A class should be small: We measure it by responsibilities. (We know it as SRP principle) A code should be placed where a reader would naturally expect it to be. (Where should be the PI constant go? Should it be in the Match class? Or maybe in the Circle class?). Be aware when creating static methods. A static method does not operate on a single instance. All the data that method uses come from its arguments, and not from any instances of this class. Also, make sure that there is no chance that you want it to behave polymorphically. Concurrency There are some basic definitions we should know when we talk about concurrency and threads: Bound resources, mutual exclusion, starvation, deadlock, and livelock. Concurrency does not always improve performance. It sometimes incurs some overhead and bugs come from it are not usually repeatable. Limit the access of the data that is shared between more than two threads. Use copies of data if there is a chance. Keep the synchronized sections as small as possible because Locks create delays and add overhead. They are expensive. Multithreaded code behaves differently in different environments: Run tests in every potential deployment environment. What I like The knowledge in this book is useful. It totally could be applied to reality. After reading the book, my coding style has changed a lot. The book is easy to understand and follow. You will read a lot of code, you will have challenges to think about what’s right about that code and what’s wrong with it. After each chapter, the author summarizes the main ideas. It helps me remember the main points longer. What I dislike The author uses Java code as examples in the book. Sometimes to understand the author’s ideas we have to find out more about Java concepts. (Spring framework, JUnit framework, type of exceptions, etc.) The author’s ideas are duplicated in some chapters. GenerallyOf course, in the scope of the article, I can not fully describe the ideas of ​​the author. This is a good book that I recommend, especially for junior developers who recently graduated. Since at the school, teachers may not teach us how a code is called clean, your coding styles are not evaluated. In fact, Your code can run properly but is not clean.If you can afford to buy this book so that you can refer to when you need, it will be very useful.“You are reading this book for two reasons. First, you are a programmer. Second, you want to be a better programmer.”","link":"/2017/10/20/Review-Book-Clean-Code/"},{"title":"Review book: Building Applications With iBeacon","text":"In the previous post, I basically give you a quick look at iBeacon - A Bluetooth protocol built on top of BLE by Apple, and made a simple demo of how iBeacon can wake up an application after being terminated by the user. However, I did not mention other foundation concepts in Beacon, it also did not give you a deep look at the advantages and disadvantages of this powerful technology.Today, I would like to introduce you to a good book giving a solid knowledge in Beacon field, especially iBeacon: Building Applications With iBeacon published by O’Reilly.After reading this book, I ensure that you will get a good knowledge in iBeacon field and your mind will be more open to the next coming up ideas.Let’s drive-in! Main contentThe book mainly focuses on developers who are looking for an efficient way to integrate beacon protocol to their applications. To use the book efficiently, I recommend you should have some BLE background knowledge as iBeacon is built on top of BLE.In the beginning, the book describes a brief history of proximity technologies in particular. It also explains why and when to use in some specified circumstances.The two key main why using iBeacon are, first and foremost, GPS technologies struggle to do better than a few meters, and GPS is often limited indoors. iBeacons can enable a determination within centimeters. The second one is iBeacons offer high precision micro-location, along with the ability to act on what a mobile device is near. No other technology yet offers that combination.To convince the reader, the book compares GPS versus Beacon, in other word location versus proximity; giving some limitations of current GPS technology, the writer makes some area in which Beacon is far superior to GPS.Next, the book explains how Beacon protocol works under the hook; introduces you to the foundational terms, and how they interact with each other.Finally, in some chapters, the book guides you on how to set up your own beacons on Mac OS, mobile devices, or tiny computers such as Ras. Pi or Arduino. Key concepts The relationship between iBeacons, generic beacons, BLE beacons, and BLE devices is described as below iBeacons are a subset of the BLE beacon specification, All iBeacons are BLE beacons, and all BLE beacons are BLE devices. However, there are beacons that are not Bluetooth-based, and there are BLE devices that do not beacon. An iBeacon needs to be configured with its identifying numerical tuple (UUID, major number, and minor number).Beacon identifier = UUID + Major + Minor. In Core Location, a region is a space in which a specified combination of UUID, major number, and minor number are received. Core Location supports three types of filtering a region: UUID only: any installed iBeacon that matches the uuid. UUID plus major number: Like the UUID-only option, it is likely to match several iBeacons, most likely installed at one particular location. UUID plus major and minor numbers: This option will match only one specific iBeacon. The following code illustrates how to define those three regions in Swift, respectively.123let region1 = CLBeaconRegion(uuid: \"uuid1\", identifier: \"Your region's name 1\")let region2 = CLBeaconRegion(proximityUUID: \"uuid2\", major: 1, identifier: \"Your region's name 2\")let region3 = CLBeaconRegion(proximityUUID: \"uuid3\", major: 1, minor: 0, identifier: \"Your region's name 3\") iOS and iBeacon: Apple provides two main actions when working with iBeaconMonitoringMonitoring provides a capability of subscription on the appearance of a region, which is combined with one or more beacons.An event in and out will be fired when a device enters or exits a region, respectively. Performed in both the foreground and the background on iOS, is used to determine when a device has entered or left an iBeacon’s coverage area. One of the most benefits of using beacon is regions are tracked by the operating system, not the application. Even when applications are not running (terminated by the OS or force stop by the user), the OS can relaunch the app to handle the events. After bringing back to the background, the app has a few seconds to execute its tasks (Around 10s). The location manager defines a method for didEnterRegion, which is called when a device crosses the boundary to enter a region The location manager defines a method for didExitRegion, which is called when a device crosses the boundary to leave a region. Monitoring limitation iOS can only monitor for up to 20 regions in one single app as describes in Apple documentation Regions are a shared system resource, and the total number of regions available system-wide is limited. For this reason, Core Location limits to 20 the number of regions that may be simultaneously monitored by a single app” Apple doc. The system also takes some time to trigger the exit event, in practice it is around 30 ~ 40s. RangingUses its transmissions to estimate the distance from a mobile device to a beacon. A common use of ranging operations is to determine which iBeacon is closest to this area.The location manager will trigger the didRangeBeacons method after ranging successfully, a list of iBeacons that have ranging data will be passed to the delegated method, along with the region in which they were detected. It also provides the received signal strength indicator (RSSI) to estimate a range in meters (It is a property of the CLBeacon object). Ranging limitation: One main downside of ranging operations requires much more activity in the Bluetooth hardware and consume significant power, because the Bluetooth interface is much more active when ranging What I like I never thought iBeacon topic would be written as a whole book but the author did it very well: The book describes iBeacon in a deep explanation. Make clear of foundational terms that are commonly used in beacon technology. Analyses the pros and cons of iBeacon with examples. Introduce other applications of beacon that I never thought about before, which opens my mind a lot: Indoor Location and Proximity: Map replacement, transit assistance, indoor direction finding, where is my car?, museum guides, retail store enhancement. Proximity-Triggered Actions: Mobile advertisements, ticket validation, treasure hunt, patient information integration. Queue management: Queue measurement, restaurant table pager, transaction completion in retail. Easy to understand: the content is well-organized, it’s easy to follow the content flow. What I dislikeThere is nothing to complain about the book, from content to form. GenerallyMany technologies exist to help phones interact with the world around them. This book introduces you to iBeacons, a Bluetooth technology that allows a device to discover nearby subjects with relatively high accuracy. There is no doubt that the applications of beacon are increasingly widely applied in many fields, especially in marketing and advertising.From my point of view, you should read the book so that you can unlock your mind about iBeacon. Maybe your next startup is built on top of Beacon, who knows?In the next tutorial, I will take you into practice with iBeacon on iOS, also will introduce you to some techniques to deal with iBeacon in deep analysis.If you have any questions or comments on this post, feel free to contact me!","link":"/2020/06/14/Review-book-Building-Applications-With-iBeacon/"},{"title":"Integrate Google Drive to iOS app","text":"At Fossil, I’ve had the chance to experiment with Google Drive integration, as a cloud bases storage. The main advantage of using Google Drive is to share with other members easily, with a good web-based UI to modify the contents of folders, and it’s free. However, I struggled when trying to make Google Drive work due to lack of documents and articles related to Google Drive APIs, especially in Swift. Additionally, the code and examples on Google’s sites are out of date. Therefore, I decided to write this article with a hope of saving your time when you want to integrate Google Drive to your apps. Let’s get started. Create your app and Google API accessIn order to use Google APIs, firstly we have to go to Google Console Dashboard to create a project. So head to Google cloud console, click the drop-down menu to create a new project.Your Google Drive API is disabled by default when you create new projects. To enable Google Drive API manually, click on “APIs &amp; Services” item on the left bar side, it will lead you to another page where you can enable Google services for your apps.Click “Enable APIs and services” button, then type to search for “Google drive”, next select Google Drive from results, finally click “Enable” to activate the app.That’s all you need to create an app using Google API. Add credential for your iOS appCredentials allow your iOS to access your enabled APIs. Click to “Credentials” button on the left sidebar to add your iOS app. Next, input your app information including your app name and bundle id, please note that you need to type exactly the bundle id, otherwise it will not work.After creating new credential successfully, you should be able to download the plist file that will contain the keys necessary for setting up your Xcode project. Keep this file in a safe place, we will use it in the next step. 1234567891011121314&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\"&gt;&lt;plist version=\"1.0\"&gt;&lt;dict&gt; &lt;key&gt;CLIENT_ID&lt;/key&gt; &lt;string&gt;YOUR_CLIENT_ID&lt;/string&gt; &lt;key&gt;REVERSED_CLIENT_ID&lt;/key&gt; &lt;string&gt;YOUR_REVERSED_CLIENT_ID&lt;/string&gt; &lt;key&gt;PLIST_VERSION&lt;/key&gt; &lt;string&gt;1&lt;/string&gt; &lt;key&gt;BUNDLE_ID&lt;/key&gt; &lt;string&gt;com.example&lt;/string&gt;&lt;/dict&gt;&lt;/plist&gt; Project configurationGoogle APIs Client Library is a library written by Google for accessing Google APIs. Go ahead and add the following library to your Pod file. 12pod 'GoogleAPIClientForREST/Drive', '~&gt; 1.2.1'pod 'GoogleSignIn', '~&gt; 4.1.1' You will find YOUR_REVERSED_CLIENT_ID and YOUR_CLIENT_ID in the client configuration plist file that you downloaded previously. Select your target project, go to “Info” tab, add a new item at the “URL Types” section, then input YOUR_REVERSED_CLIENT_ID at the “URL Schemes” box.In case you don’t know what URL Schemes use for, every each item in the URL Schemes section allows you to define a custom URL scheme for your app. For example, your app might let users tapping a custom URL in an email to launch your app in a specified context. By default, Apple supports common schemes associated with system apps like mail, sms, facetime, etc. For more information, please refer to Defining a Custom URL Scheme for Your AppIf you don’t add YOUR_REVERSED_CLIENT_ID as a custom URL scheme, your app will get the following crash when trying to authorize with Google API. So make sure you don’t miss this important step.Next, open the AppDelegate.swift file, add your client id to Google Sign In instance. 1234func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -&gt; Bool { GIDSignIn.sharedInstance().clientID = \"YOUR_CLIENT_ID\" return true} Then, open your ViewController where you allow user to sign in with their Google account and implement the two delegate GIDSignInUIDelegate and GIDSignInDelegate from Google Sign in. 123456789101112131415extension ViewController: GIDSignInDelegate { func sign(_ signIn: GIDSignIn!, didSignInFor user: GIDGoogleUser!, withError error: Error!) { if let _ = error { } else { print(\"Authenticate successfully\") } } func sign(_ signIn: GIDSignIn!, didDisconnectWith user: GIDGoogleUser!, withError error: Error!) { print(\"Did disconnect to user\") }}extension ViewController: GIDSignInUIDelegate {} Finally, assign Google sign in delegate to your view controller. 123456private func setupGoogleSignIn() { GIDSignIn.sharedInstance().delegate = self GIDSignIn.sharedInstance().uiDelegate = self GIDSignIn.sharedInstance().scopes = [kGTLRAuthScopeDrive] GIDSignIn.sharedInstance()?.signInSilently()} You might notice the GIDSignIn.sharedInstance().scopes line of code. This line of code defines which permissions the user grants for your app to access their data when authenticating. In this case, we use the kGTLRAuthScopeDrive scope that allows our app to view and manage all the files in the user’s Google Drive, including team drive. The signInSilently method will attempt to sign in a previously authenticated user silently. If you do all the above steps properly, you should be able to authenticate your app with Google API. ![](/Post-Resources/GoogleDrive/GoogleSignIn.png \"Google Sign in\") ![](/Post-Resources/GoogleDrive/GrantPermission.png \"Grant permission\") Common APIsWork with “My Drive”Searching12345678public func search(_ name: String, onCompleted: @escaping (GTLRDrive_File?, Error?) -&gt; ()) { let query = GTLRDriveQuery_FilesList.query() query.pageSize = 1 query.q = \"name contains '\\(name)'\" self.service.executeQuery(query) { (ticket, results, error) in onCompleted((results as? GTLRDrive_FileList)?.files?.first, error) }} Listing12345678 public func listFiles(_ folderID: String, onCompleted: @escaping (GTLRDrive_FileList?, Error?) -&gt; ()) { let query = GTLRDriveQuery_FilesList.query() query.pageSize = 100 query.q = \"'\\(folderID)' in parents and mimeType != 'application/vnd.google-apps.folder'\" self.service.executeQuery(query) { (ticket, result, error) in onCompleted(result as? GTLRDrive_FileList, error) }} Uploading123456789101112131415private func upload(_ folderID: String, fileName: String, data: Data, MIMEType: String, onCompleted: ((String?, Error?) -&gt; ())?) { let file = GTLRDrive_File() file.name = fileName file.parents = [folderID] let params = GTLRUploadParameters(data: data, mimeType: MIMEType) params.shouldUploadWithSingleRequest = true let query = GTLRDriveQuery_FilesCreate.query(withObject: file, uploadParameters: params) query.fields = \"id\" self.service.executeQuery(query, completionHandler: { (ticket, file, error) in onCompleted?((file as? GTLRDrive_File)?.identifier, error) })} Downloading12345678910111213public func download(_ fileItem: GTLRDrive_File, onCompleted: @escaping (Data?, Error?) -&gt; ()) { guard let fileID = fileItem.identifier else { return onCompleted(nil, nil) } self.service.executeQuery(GTLRDriveQuery_FilesGet.queryForMedia(withFileId: fileID)) { (ticket, file, error) in guard let data = (file as? GTLRDataObject)?.data else { return onCompleted(nil, nil) } onCompleted(data, nil) }} Deleting123456789public func delete(_ fileItem: GTLRDrive_File, onCompleted: @escaping ((Error?) -&gt; ())) { guard let fileID = fileItem.identifier else { return onCompleted(nil) } self.service.executeQuery(GTLRDriveQuery_FilesDelete.query(withFileId: fileID)) { (ticket, nilFile, error) in onCompleted(error) }} Work with “Team Drive”The only thing we need to do in order to work with “Team Drive” is to set the corpora param of the query to teamDrive. By default, the user corpora is applied. That means the query only applied to the folders onwed by the user. By setting to teamDrive, we indicate that the query will affect to team drive of the user. We can combine multiple corpora in a single query if you need to do so. Final thoughtsGoogle Drive is an ideal storage to integrate with our applications. In this article, we covered how to config Google Drive API and how to execute common APIs. I hope you learned something today.You can find all the source code demo on my Github 🙂 References[1] Google Developer https://developers.google.com/drive/api/v3/about-sdk","link":"/2019/02/15/Integrate-Google-Drive-to-iOS-app/"},{"title":"Remote Notification","text":"Push notification allows your app to reach users more frequently, and can also perform some tasks. In this tutorial, we will learn how to config apps to get remote notifications, display contents and then perform some actions when the user presses in.Let’s get started. APNsAPNs, which stands for Apple Push Notification service, is a service that delivers messages to your applications. The notification information sent can include badges, sounds, custom content, or custom text alerts. Note that you need a paid developer account so that you can configure your app with the Push Notification capability. You also need a physical device for testing if you want to launch remote notifications as push notifications are not available in the simulator. You only can simulate notifications on simulators. ConfigurationFirstly, you need to add the push notifications entitlement to your project,Head over the Project Setting &gt; Signing Capabilities &gt; + Capability &gt; Add Push Notification If you want to send notifications to real devices, you need to do some extra steps to have a notification key: Sign in to Apple developer Under the Keys section &gt; Add new keys &gt; Enter your key name &gt; Select Apple Push Notifications service (APNs) &gt; Continue. Download the key and store it to any location you want to save this key. Notice the file name of the key file has a pattern AuthKey_[Key ID].p8 Request user permissionsNext, the app needs to ask the user to get permission to show notifications.Open the AppDelegate.swift and add the following code 123456789101112131415161718192021222324func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -&gt; Bool { // The rest omitted self.registerPushNotifications() ...}func registerPushNotifications() { UNUserNotificationCenter.current() .requestAuthorization(options: [.alert, .sound, .badge]) { granted, error in guard granted else { return } // If the user allows showing notification, then register the device to receive a push notification self.registerForRemoteNotification() }}func registerForRemoteNotification() { UNUserNotificationCenter.current().getNotificationSettings { settings in guard settings.authorizationStatus == .authorized else { return } DispatchQueue.main.async { UIApplication.shared.registerForRemoteNotifications() } }} If the process complete successfully, the didRegisterForRemoteNotificationsWithDeviceToken: callback will be called including your device token (A unique value to identify your device, note that it is different every time you re-install the app).If an error occurs, the didFailToRegisterForRemoteNotificationsWithError: will be triggered. 12345678func application(_ application: UIApplication, didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data) { print(\"Did register remote notification successfully \\(deviceToken.hexadecimalString)\")}func application(_ application: UIApplication, didFailToRegisterForRemoteNotificationsWithError error: Error) { print(\"Did failed register remote notification \\(error.localizedDescription)\") // e.g Did failed register remote notification no valid “aps-environment” entitlement string found for application} Notice the Alert, sound, and badge is the common combination when requesting authorization.There are other options you can find on Apple doc.Another warning is that if you run your app in a simulator, you will get the didFailToRegisterForRemoteNotificationsWithError event as remote notification are not supported on simulators. Handle notifications while the app is in foregroundAfter registering to remote notification successfully, if you want to handle notifications while your app is in the foreground, you need to implement the userNotificationCenter:willPresent:withCompletionHandler in your class. 1234public func userNotificationCenter(_ center: UNUserNotificationCenter, willPresent notification: UNNotification, withCompletionHandler completionHandler: @escaping (UNNotificationPresentationOptions) -&gt; Void) { ... completionHandler([.alert, .sound, .badge])} If you do not implement this function, notifications will not show if your app is in the foreground. It’s time to send notificationThere are 2 ways to test your implementation. If you don’t have a physical device, don’t worry, you still can simulate notifications in a simple way, or you can send real notifications to real devices. Simulate APNsCreate a file with ext .apns. eg. SimulateNoti.apns, then copy your content to this file 1234567891011{ \"Simulator Target Bundle\": \"YOUR_APP_BUNDLE_ID\", &lt;--- CHANGE TO YOUR APP BUNDLE ID \"aps\": { \"alert\": { \"title\" : \"Your title\", \"subtitle\" : \"Your subtitle\", \"body\" : \"Your body\" }, \"sound\": \"default\" }} Dragging and dropping this onto the target simulator will present the notification Push to real devicesFirst, you need a remote notification client tool that helps you to push a notification. A great tool to test is Push notification tester. Let’s navigate to this website to download and launch the app. After launching the app successfully, Switch to TOKEN tab in Authentication section. Press SELECT P8 and select your P8 file which is downloaded from the previous step, then Fill in the rest information KEY ID, TEAM ID. The KEY ID is a part of the P8 file name AuthKey_[Key ID].p8. For the TEAM ID, you can find it on your membership page. In Body section, fill in your app bundle Id (e.g com.example.yourapp) and your device token which is generated from didRegisterForRemoteNotificationsWithDeviceToken: callback. Compose your content. Here is a common body for push notification.e.g 12345678910{ \"aps\": { \"alert\": { \"title\" : \"Your title\", \"subtitle\" : \"Your subtitle\", \"body\" : \"Your body\" }, \"sound\": \"default\" }} For all available options in a notification, please refer to Apple doc: generating_a_remote_notification Press the Send button to deliver your notification to the selected device. A message will be appeared on the top of the button to show the result. Silent notificationFrom my perspective, the most interesting feature of Push notification is “Silent notification”, which can wake your app up to perform some tasks while your app is in the background, even if your app was terminated by the user. Many engineers out there are finding a way to keep their app lives in the background as many as they can. There are several ways to achieve it by using restoration and preservation, core location, iBeacon. Silent push notification is one among of them. I will have another post talking about silent notification and my experiment so we will have more details and info. To send a silent notification, simply change the JSON content to 12345{ \"aps\": { \"content-available\": 1 }} After pressing the Send button, there is no notification showing on your app. Final thoughtBy using push notifications wisely, you can engage users coming back to your app again. However, if you overdo the notifications, it can lead to negative effects such as users turn off permissions to your app or rate your app 1* with complaints on the store (Same as our story in the past :)).Notifications not only help to deliver your messages to users but also can be used for other advanced purposes like wake your app up by using silent notifications. In the next post, we will have a deep look at this amazing feature.If you have any doubts or comments, let me know.Happy sharing! Refs Apple doc: Generating a remote notification Raywenderlich: Push notification tutorial","link":"/2021/04/08/Remote-Notification/"},{"title":"Review book: Swift Apprentice - Raywenderlich","text":"While I was searching for a book to boost my iOS development skill, I found this Swift Apprentice book on Raywenderlich’s book store. Take a quick look at the content of the book, I decided to add the book to my library.Generally, If your iOS skill is mid-level or senior, you’re so confident with your master programming skill, this book is not for you. But if you’re looking for a book to strengthen your knowledge, or you just want to make sure everything you understand about Swift language is right - as my purpose, then take this book with you.You’ll learn about very basic things like function, method, constants, control statement, etc. You’ll also have a chance to get in-depth knowledge about Stack/Heap allocation, protocol-oriented programming, and generic programming, which make your daily job more convenient, and you will find yourself like a master in Swift language.Let’s drive-in! About the authorFor those who don’t know who Raywenderlich is, it is a community site focused on creating programming tutorials and books (Mainly focus on mobile development on Android and iOS). Their content covers all levels from beginning to advanced topics.I often access Raywenderlich site to get example code and to make my knowledge up to date. Their tutorials are extremely great, technically accurate and are updated to the newest technologies.Swift Apprentice is one of their collection of iOS programming. Keynotes Lazy property: If you have a property that might take some time to calculate, you don’t want to slow things down until you actually need the property, let’s use the lazy stored property. It is useful for such things as downloading a user’s profile picture or making a serious calculation. The heap vs. the stack:The Stack is used to store anything on the immediate thread of execution; it’s managed and optimized by the CPU. When a function creates a variable, the stack stores that variable and then destroys it when the function exits. Since the stack is so strictly organized, it’s very efficient, and thus quite fast.The heap, on the other side, is used to store instances of reference types. The heap is generally a large pool of memory from which the system can request and dynamically allocate blocks of memory. Lifetime is flexible and dynamic. It doesn’t automatically destroy its data (the stack does so). Additional work is required to free the memory on the Heap, which makes creating and removing data on the heap a slower process, compared to on the stack.When an instance of a class is created, your code requests a block of memory on the heap to store the instance itself.When an instance of a struct is created (that is not part of an instance of a class), the instance itself is stored on the stack, and the heap is never involved. When to use a class versus a struct: Values vs. objects: Use structures as values and classes as objects with identity. To make it simple, just keep in mind that there are no two objects are considered equal simply because they hold the same state. In contrast, instances of value types, which are values, are considered equal if they are the same value. e.g, no two students are considered equal, even if they have the same name; Two points (x, y) are equal if x1 and y1 the same to x2 and y2, respectively, so we implement Point as a struct.Speed: If these instances will only exist in memory for a short time — go towards using a struct. If your instance will have a longer lifecycle in memory, let’s think of a class.Another approach is to use only what you need. If your data will never change or you need a simple data store, then use structures. If you need to update your data and you need it to contain logic to update its own state, then use classes. Often, it’s best to begin with a struct. If you need the added capabilities of a class sometime later, then you just convert the struct to a class. Two-Phase initialization:• Phase one: Initialize all of the stored properties in the class instance, from the bottom to the top of the class hierarchy. If you use properties and methods before phase one is complete, the compiler will throw errors.• Phase two: We can now use properties and methods of the object. Protocols in the Standard Library: Equatable, Comparable, Hashable, CustomStringConvertible. Generic function parameters: 123func swapped&lt;T, U&gt;(_ x: T, _ y: U) -&gt; (U, T) { (y, x)} Wildcard pattern: 1234if case (_, 0, 0) = coordinate { // x can be any value. y and z must be exactly 0. print(\"On the x-axis\") // Printed! } Value-binding pattern:123if case let (x, y, 0) = coordinate { print(\"On the x-y plane at (\\(x), \\(y))\") // Printed: 1, 0 } “Is” type-casting pattern”:12345switch element { case is String: print(\"Found a string\") default: break} Rethrows: By using rethrows instead of throws, functions indicate that they will only rethrow errors thrown by the functions called inside itself but never errors of its own. Protocol-oriented benefits:By using protocols instead of implementations, we focus on what the object can do instead of how the object does, which makes the application more extendable and testable.Multiple inheritances: One of the real benefits of protocols is that they allow a form of multiple inheritance. Swift is a protocol-oriented language. What I like Well organized. Real examples: There are examples for each topic to make sure readers deeply understand what they just mentioned. Easy to understand: As the content are well-organized, it’s easy to follow the content flow. Stop and think: There are short exercises and challenges throughout the book to give you some programming practice and test your knowledge along the way. Keypoints: They summarize key points at the end of each chapter. What I dislikeI tried to look over the books several times to find a spot that I dislike but there is nothing to complain about, from content to form. GenerallySwift is fun and is filled with programming paradigms. After reading this book, I hope you now feel more comfortable enough with the language to move on to building bigger things. With the language fundamentals we’ve gained, we’re ready to explore advanced frameworks such as Animation, UIKit, etc. to build iOS apps, macOS apps and more.I hope you find this book interesting.Happy weekend!","link":"/2020/02/26/Review-book-Swift-Apprentice-Raywenderlich/"},{"title":"Series React Native and BLE: Part 1 - Building BLE framework for iOS","text":"I have been working in mobile development on both native projects and cross platforms (React Native, Flutter), and I also have experience working on BLE. Sometimes I get emails asking about the communication of RN/Flutter to BLE. Thus, I decided to introduce this series React Native and BLE to guide you on how to develop a native BLE framework and connect it to React Native.Of course, there will be another series for Flutter and BLE after finishing the series of React Native.In this series, I will guide you through a completed process from development to distribution. Create an iOS / Android framework. Script to build and distribute your framework. Import the frameworks to your React Native project. Use your native framework in React Native. Distribute your app. And other cool stuff I want to share with you … If you love what I do, consider supporting me at buy a coffee for Uy Nguyen :)Let’s go. Xcode 13, iOS 15, Swift 5, React 17.0.1, React Native 0.64.1. Prepare iOS frameworkThe first step is creating a BLE framework. You also don’t have to create a framework, you can include your source code inside the iOS project directly if you want to.However, the reason why I recommend moving all BLE logic to a framework is that it’s reusable, you can share your framework to other projects such as Flutter or Native projects without having to duplicate the logic.Another reason is that it will improve the compile time of Xcode, breaking your app into several frameworks can speed up the build times. This is because the Xcode build system doesn’t have to recompile frameworks for which Swift files have not changed. From the top left bar of Xcode, select File &gt; New &gt; Project &gt; From the &quot;Framework &amp; Library&quot; section, select &quot;Framework&quot; &gt; Enter your framework name (I use &quot;BLEFramework&quot;) Now, you can develop your BLE logic in the project you just created. I’m not going to detail implementing all single methods of the framework as it depends on your business logic and your architecture. You can find my previous tutorials to have an idea of how to implement a BLE framework. Bluetooth Low Energy OniOS, Play Central And Peripheral Roles With CoreBluetoothI will take a simple method in my BLE framework as an example: the startScanning method. 12345678910/**Class: CentralManager*//*** @discussion Start scanning nearby peripherals and returns to the `ScanningDelegate`*/public func startScanningFor(delegate: ScanningDelegate, filter: DeviceFilter = DeviceFilter()) throws { //... BLE implementation.} OK now we have a BLE framework, let move to the next step: Building and distributing your framework. Building and distributingThere are many ways to distribute a framework like using CocoaPod, or manually by sending a complied file, etc. In this post, I will provide you with a script to turn your framework into a universal framework that hides all your logic, and can be used for both physical devices and simulators. Make sure you turn “Build Libraries for Distribution” flag in the “Build Settings” to YES. The flag indicates that the compiler should generate one of the stable interfaces so the framework can be used when newer versions of Xcode or the Swift compiler are released. Next, create a bash file, put it in the root of the ios folder, and copy the following commands to the file. Then execute the script. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546### SCRIPT TO BUILD A SWIFT UNIVERSAL FRAMEWORKPRODUCT_NAME=\"REPLACE_BY_YOUR_TARGET_NAME\"BUILD_CONFIGURATION=\"Release\"DERIVED_DATA_PATH=\"$(pwd)/build\"RELEASE_DIR=\"$(pwd)/RELEASE\"BUILD_SCHEME=\"${PRODUCT_NAME}\"FRAMEWORK_NAME=\"${PRODUCT_NAME}.framework\"RELEASE_DEVICE_PATH=\"${RELEASE_DIR}/device/${FRAMEWORK_NAME}\"RELEASE_SIMULATOR_PATH=\"${RELEASE_DIR}/simulator/${FRAMEWORK_NAME}\"rm -rf \"${DERIVED_DATA_PATH}\"rm -rf \"${RELEASE_DIR}\"mkdir -p \"${DERIVED_DATA_PATH}\"mkdir -p \"${RELEASE_DIR}\"mkdir -p \"${RELEASE_DIR}/simulator\"mkdir -p \"${RELEASE_DIR}/device\"# Build library for simulatorfastlane ios build scheme:\"${BUILD_SCHEME}\" \\ configuration:\"${BUILD_CONFIGURATION}\" \\ sdk:iphonesimulator \\ build_dir:\"${DERIVED_DATA_PATH}\" \\ --verboseSIMULATOR_FRAMEWORK_PATH=\"${DERIVED_DATA_PATH}/Build/Products/${BUILD_CONFIGURATION}-iphonesimulator/${FRAMEWORK_NAME}\"mv \"${SIMULATOR_FRAMEWORK_PATH}\" \"${RELEASE_SIMULATOR_PATH}\"# Build library for iphoneosfastlane ios build scheme:\"${BUILD_SCHEME}\" \\ configuration:\"${BUILD_CONFIGURATION}\" \\ sdk:iphoneos \\ build_dir:\"$DERIVED_DATA_PATH\" \\ --verboseDEVICE_FRAMEWORK_PATH=\"${DERIVED_DATA_PATH}/Build/Products/${BUILD_CONFIGURATION}-iphoneos/${FRAMEWORK_NAME}\"mv \"${DEVICE_FRAMEWORK_PATH}\" \"${RELEASE_DEVICE_PATH}\"# Merge SDKsxcodebuild -create-xcframework -output \"${RELEASE_DIR}/${PRODUCT_NAME}.xcframework\" \\ -framework \"${RELEASE_DEVICE_PATH}\" \\ -framework \"${RELEASE_SIMULATOR_PATH}\"open \"${RELEASE_DIR}\" Once you run the script successfully, you should see the result as below In which: YOUR_TARGET_NAME.xcframework: The universal framework can be used for both physical devices and simulators. device folder: contains YOUR_TARGET_NAME.framework which can be used only on physical devices. simulator folder: contains YOUR_TARGET_NAME.framework which can be used only on simulators. Now we have a BLE framework for our application, let’s move to the next step - Create a new React Native project. Init React Native projectTo create a React Native project without using Expo (I recommend to not using Expo because we’re going to add a lot of Native code for Android and iOS to our project, for more details you can refer to what is the difference between expo and react native), open terminal and type 1react-native init projectName Wait a while to set up your project. After running successfully, you should see the folder structure as below: 12345|---projectName |---ios |---projectName.xcworkspace |---android |---...Other files, folders Open the projectName.xcworkspace file, we will config the native code in the next step. Wire them togetherFirst, drag and drop the YOUR_TARGET_NAME.xcframework to your Xcode workspace.As my SDK is built in Swift, I’m going to create a Swift class as a bridge so that we can communicate from the SDK to React Native.From Xcode project, select File &gt; New &gt; File &gt; Swift File &gt; Enter your file name (e.g BLEManager) &gt; Add. A dialog will pop up to ask if you want to create a bridging header, select yes. For those who don’t know what the bridging header is used for, the bridging header is where you define all the Objective-C classes that are exposed to Swift. To use RCT classes, make sure you #import all related headers to your ...-Bridging-Header.h. Otherwise, you will get complied errors. 1234#import &lt;React/RCTBridgeModule.h&gt;#import \"React/RCTEventEmitter.h\"#import \"React/RCTViewManager.h\"#import &lt;React/RCTLog.h&gt; Next, add the interface RCTEventEmitter to the class BLEManager we just created in the previous step. 1234567891011121314151617181920212223242526272829@objc(BLEManager) &lt;--- Remember to add this [1]public class BLEManager: RCTEventEmitter, ScanningDelegate { static let didFoundDeviceEvent = \"didFoundDevice\" @objc &lt;--- Remember to add this public static let shared = BLEManager() override init() { super.init() _ = BLEWrapper.shared } @objc(startScanning) &lt;--- Remember to add this func startScanning() { BLEWrapper.shared.startScanning(self) } public func managerDidFoundDevice(_ manager: CentralManager, device: Device, rssi: Int) { self.sendEvent(withName: Self.didFoundDeviceEvent, body: [\"name\": device.localName, \"rssi\": rssi]) [2] } public override static func requiresMainQueueSetup() -&gt; Bool { return true } override public func supportedEvents() -&gt; [String]! { return [Self.didFoundDeviceEvent] [3] }} [1] Make sure you decorate your class and functions by the @objc keyword to ensure the class and functions are exported properly to the Objective-C runtime.[2] Once a peripheral is discovered, send an event to Javascript.[3] Register supported the event from the native module. Finally, to expose the methods of your native module, create a new file BLEManager.m and add the following code. 12345@interface RCT_EXTERN_MODULE(BLEManager, RCTViewManager)RCT_EXTERN_METHOD(startScanning)@end That’s all. Javacsript now can invoke the startScanning function and listen to the didFoundDeviceEvent event. TestingIt’s time to test our implementation, React Native provides NativeEventEmitter and NativeModules instances that allow you to work with native modules.from the root folder, open App.js and import the necessary things. 12345import { NativeEventEmitter, NativeModules,} from 'react-native';const {BLEManager} = NativeModules; &lt;-- You can then access the BLEManager native module In componentDidMount method, add the following to it 123456789101112componentDidMount() { let beaconManagerEmitter = new NativeEventEmitter(BLEManager); [1] this.didFoundDevice = beaconManagerEmitter.addListener( [2] 'didFoundDevice', data =&gt; { console.log(data); }, ); setTimeout(() =&gt; { BLEManager.startScanning(); [3] }, 3000); // Just to make sure the Bluetooth is on, we will improve it later} [1] Create a new NativeEventEmitter instance and listen to the didFoundDevice event [2][3] Because we do not support the Bluetooth state changes event yet, so we temporarily delay 3s before calling scanning just to make sure the Bluetooth is on. We will improve it later by supporting more events and methods. OK, let’s build and run your project. If you see your console log print the results from the scanning process, congratulation, you make it right! Next stepIn this post, I showed you how to create a BLE framework and how to use a BLE native module in a React Native project such as invoking a method from Javascript to Swift and handling an event from Swift to Javascript. In the next tutorial, we will do the same on Android platform.If you face any troubles, feel free to contact me. I would love to help.Happy holiday. Refs[1] React Native - Native module ios","link":"/2021/12/25/Series-React-Native-and-BLE-Part-1-Building-BLE-framework-for-iOS/"},{"title":"Shipping your iOS app to Store","text":"Submitting your app to the Apple Store isn’t as simple as pressing a “magic” button then it does everything, but it’s not as complicated as you think either. It’s maybe your first time launching your first app, and you don’t have a chance to get familiar with the submitting process before. This step-by-step tutorial will show you the main flow to submit apps from zero to a hero. Kindly note that you need to have a Paid Developer Account to get it done.Jump in! Certificates, app Ids and provisioning profilesIn other to submit your app to App Store, you need to understand what certificates, app IDs and provisioning profiles are. Basically, A distribution certificate identifies your team/organization within a distribution provisioning profile and allows you to submit your app to the Apple App Store. The following image describes the relationship between them. Create a Distribution Certificate On your Mac, Open Key Chain Access app. Go to Certificate Assistant &gt; Request a Certificate From a Certificate Authority. Fill in your email to the email box. The Keychain Access will create a private key, which is stored in the keychain, and a .certSigningRequest file which will be uploaded to Apple. Apple will issue a certificate for you based on the .certSigningRequest. The Certificate contains the public key. After that, you can download the file and open it. The public key will be pushed to the Keychain and paired with the private key to make the “Code Signing Identify”. Just so you know what is CSR A CSR or Certificate Signing request is a block of encoded text that is given to a Certificate Authority when applying for an SSL Certificate. It is usually generated on the server where the certificate will be installed and contains information that will be included in the certificate such as the organization name, common name (domain name), locality, and country. It also contains the public key that will be included in the certificate. A private key is usually created at the same time that you create the CSR, making a key pair. After having the .certSigningRequest file, go to the Apple developer page, sign in to your Apple Account &gt; Certificates, Identifiers &amp; Profiles &gt; Press the “+” button to create a new certification &gt; Remember to select the “iOS Distribution (App Store and Ad Hoc)” option. Next, select to upload your .certSigningRequest file you just created at the step 3. Finally, you now can download the Certificate file to your Mac, open it and the key will be pushed to the keychain automatically. That’s all for creating a Distribution Certificate, let’s move on to the next step, create your app id. Create App Id Press the “+” button on the page “All Identifiers” Fill in your app information, including your bundle Id. Please note that this bundle id must match your bundle id in XCode. You can also use wildcard pattern to define bundle Id for more than one app Ids. Create Provisioning Profile Press the “+” button on the page “Profiles”, then select “App Store” option. Select your app Id that you just created in the previous step, Create App Id. Select your Certificate that you just created in the previous step, Create a Distribution Certificate Now you have a profile that links your Certificate and your app Ids. Download this file and open it. The Provisioning Profiles will be pushed to XCode automatically. UploadingIt’s time to upload your app to Store.Let’s back to your project, from the Top Tool Bar &gt; Product &gt; Archive, XCode will rebuild your project. After that, the XCode Organizer will launch and show all archives you’ve created in the past.Select the current build, then click on “Distribute App” in the right-hand panel. The next window allows you to select your credentials including the Distribution Certificate and the Provisioning Profiles you created in the first section. Finally, press the upload button, XCode will do the rest for you. An email will be sent to notify you right after Apple completes the processing process, it usually takes some minutes.Your app has been successfully uploaded to your iTunes Profile, let’s go to the final step. SubmitingNavigate to App Store Connect, select “My Apps”. you will see your app appear on the page. You need to prepare the following information to fill in on these pages: App Name, Privacy Policy URL, Age Rating, Category. Screenshot in different sizes: This might take your time the most, your screenshots need to meet Apple requirements at Screenshot specifications. Kindly note that users will see these screenshots related to their current devices, so make sure your photos are fancy and extractive as most as you can. Fastlane also supports take screenshots automatically, you can find the document if you’re interesting. Fastlane tools can automate this process making it fast, and consistent while giving you beautiful results! Version description, keywords, support URL. If your app requires sign in, fill in account information with username and password. App notes: Some important notes you want to send the previewer to make sure it works properly. (e.g we strongly recommend using the service with a Wifi connection for best quality) Attachment: It’s best to have a short demo of your app. Contact information: If there are any issues, Apple will contact you via this information. You’re done. Now precess the “Submit” button to start the reviewing process. Reviewing processYour reviewing process takes some time to complete, it may be a couple of days to couple weeks depends on your app category, features, and … the reviewer.If your app violates Apple rules such as using unapproved private APIs, lack of permission description, crashing or poor performance, it will get rejected. In the end, we have to accept that Apple has the final word on allowing anything into the App Store. Just because you think your app is great does not mean that Apple will allow it into App Store. I myself experienced this strickly-randomly-emotionally process when submitting my application. The first submission went smoothly without any troubles. The second one, which is updated some UI, got rejected because Apple thinks my app contains a feature that is not allowed in the App Store. With many emails and phone calls, I finally had to remove this feature from my app. (?!) Final wordsIn this post, I guided you on how to submit your app to Store in a very detailed step. Hope this post saves your time in delivering your amazing apps to users. Can’t wait.In next post, I will show your steps to upload your app to Google Play.Happy coding.","link":"/2018/12/13/Shipping-your-iOS-app-to-Store/"},{"title":"Swift Summit conference in San Francisco 2017","text":"Swift Summit Conference 2017 was held at the Palace Of Fine Arts, San Francisco, which is one of ten palaces at the heart of the Panama-Pacific Exhibition. At the conference, Swift developers from around the world shared new knowledge, tools and ideas on iOS platform and Swift language. Image 1. I was there, at the Swift Summit conference 2017 The conference hosted more than 20 technical sessions and developer labs. Especially, there was an exhibitor hall with top tech companies like Facebook, IBM, Lyft, Capital One, etc. There, I met other developers, talked about new technologies and received swags from sponsors. Image 2. My bag (And another one of my friend's) was full of swags from the conference :)). Ten days to enjoy the US, two days to enjoy the conferenceAs it had been the first time I go to San Francisco, I was not comfortable with the weather there. I remember that in the first morning day I went to the Palace of Fine Arts, the weather was 13c degree at that time. I was freezing to death!When I first entered the main hall, I felt better because of the warm light. The organizers prepared a lot of food and fruits on a table in the center of the hall. My friends and I went around to visit tech companies, tried using their new technologies, and received their swags.The size of the conference was not as I expected. It was quite small, about one hundred people, I guess. But the organizers and the speakers prepared contents very well. Below are some key sessions that I attribute the best during two conference days. Asynchronous programmingAsynchronous methods, (Async for short), are the methods that not immediately returning results like most method, the async methods take some time to produce results.Before attending this session, I often use callback to deal with asynchronous methods like scanning bluetooth devices or retrieving some resources from the internet. In fact, callback is a bad programming technique. Callback will make our code hard to read, hard to debug and take much more time to maintain later. In the end, our code will turn into something that we call the callback hell.In this session, the speaker introduced a framework that helps us to simplify asynchronous programming, PromiseKit. It is easy to learn, easy to use and result in clearer, more readable code.For more details about this session, please refer to another one of my posts: Asynchronous Programming in Swift BuglifeBugLife is an open framework help our users to submit a bug report from their phone, and it immediately shows up in our issue dashboard. The best benefits that I found when I use BugLife are it is free and is easy to integrate to our apps without breaking a sweat.For more details about how to use this framework, please refer to another one of my posts: BugLife in real life MixpanelMixpanel is a library help us to track user behaviors and other events that occur on our apps. Many technology companies use Mixpanel to analyze their data to get to know their users deeper. From the results, they can make decisions to improve their app to please users. Image 3. Developers were attending a developer Lab. Swift on the Server: State of the UnionThis session described the current state of Swift on the server, and make some predictions about what the next year will hold. Unfortunately, I fell asleep in this session so I dont catch many ideas from the speaker.For more details about how to use this framework, please refer to another one of my posts: Swift on the server side iOS Architectures in ContextWhy we have to care about choosing an architecture?Nowadays, we have so many software architectures to choose, if we do not choose a fit architecture for our apps, one day we will find ourselves in being unable to find and fix any issues inside our apps. During this session, the speaker discussed on some iOS architectures like MVC, MVP, MVVM, VIPER, etc. With many years of experience working on software architectures, he evaluated on both upside and downside one by one.For me, this session was quite difficult to grab all ideas of the speaker since I don’t have many experiences in designing software architectures. After that, I had to spend more time to read other documents and technical blogs to get understand what he said. Image 4. The scene around the conference After all …Late on the second day, we had a Halloween party in the hall of the palace. This is my first time attending a technology conference in a technology-led country, the US. After two days attending the conference, I have updated some new technologies and also applied some technologies to projects at my company. Truly to say, there are some sessions that are a little boring and only introductory. Also the jet lag made me feel tired so I did not fully concentrate on some sessions. That’s a regret.In the end, this is still the best trip ever! Image 5. An unforgetable trip","link":"/2017/11/29/Swift-Summit-conference-in-San-Francisco-2017/"},{"title":"Series React Native and BLE: Part 2 - Building BLE framework for Android","text":"When it comes to mobile technology, iOS and Android are the two dominant operating systems that power the majority of smartphones and tablets worldwide. As developers, it is essential that we have the knowledge and tools to work with both platforms effectively. This is especially true when it comes to utilizing Bluetooth technology, which is a crucial component of many modern mobile applications.In part 1 of this tutorial series, we created a BLE (Bluetooth Low Energy) framework that could be connected to the UI using React Native. However, this framework only worked on iOS, which meant that we needed to develop a separate solution for Android.In part 2 of this tutorial series, we will be focusing on defining a new SDK for Android and linking it to the UI, just as we did on iOS. This will allow us to fully support both operating systems and provide a seamless Bluetooth experience for all users, regardless of their device of choice. Create new Android SDKThe very first step is to create your own Bluetooth library. Normally, engineers tend to use an open-source library such as RxAndroidBle or Android-BLE-Library powered by Nordic. However, the main goal of this tutorial is to guide you on how to create a new Android module and link it to React Native. This not only applies to Bluetooth but also to any library that you need to use in your app. The other goal is to gain foundational knowledge of Android BLE in case you need to modify something or create your own feature that has not been supported in the market. By creating your own Bluetooth library, you have the freedom to customize and tailor the library to your specific needs. This can provide significant advantages over using pre-existing libraries, as you can optimize the library for your particular use case and avoid potential compatibility issues. From your project, go to File &gt; New &gt; New Module &gt; Fill in the information.A new library will be added to your project. One major different thing from Android and iOS is that from Android 6.0, Google requires the Location Permission to be enabled for Bluetooth Low Energy Scanning (See more Android 6.0 Changes). Next, add the following permissions to your AndroidManifest.xml at android/app/src/main/AndroidManifest.xml 123&lt;uses-permission android:name=\"android.permission.BLUETOOTH\" /&gt;&lt;uses-permission android:name=\"android.permission.BLUETOOTH_ADMIN\" /&gt;&lt;uses-permission android:name=\"android.permission.ACCESS_FINE_LOCATION\" /&gt; note:123456Android 12 update:From Android 12 (API level 31+):- Google requires new permission for scanning nearby devices: + If your app looks for Bluetooth devices, such as BLE peripherals, declare the BLUETOOTH_SCAN permission. + If your app communicates with already-paired Bluetooth devices, declare the BLUETOOTH_CONNECT permission.- If your app does not use Bluetooth scan results for physical location, you can skip declaring location permission by adding `android:usesPermissionFlags` For demo purposes, the SDK exposes only 2 simple APIs startScan to start scanning nearby devices and isBluetoothOn to check if the Bluetooth is turned on. 12345/*Start scanning nearby devices.Accept `callback` as param and return found devices via `callback`*/fun startScan(callback: (device: Device) -&gt; Unit) 1234/*Check if BLE is ready for scanning*/fun isBluetoothOn() : Boolean To request permission on React Native, we’re going to use this module https://github.com/zoontek/react-native-permissions to get the permissions the app needs. Build and release Android SDK moduleNext, let’s distribute the module so that other applications can use it.From the root folder, run ./gradlew kTrackingSDK:assembleRelease to generate an .aar file.The output file will be located at ./KTrackingSDK/build/outputs/aar, then you can import the .aar file to the android project. Connect to React Native partNow, we’ve already had the Bluetooth lib. The next step is to link the module to the React Native part. Firstly, React Native part needs to understand the Native module. Add the following config to your /src/main/java 1234567891011121314151617181920212223242526272829class BLEManager(context: ReactApplicationContext) : ReactContextBaseJavaModule(context) { init { Log.d(\"BLEManager\", \"Init package\") BLEManagerLib.shared.config(context) } override fun getName(): String { return \"BLEManager\" } @ReactMethod fun isBluetoothOn(promise: Promise) { promise.resolve(BLEManagerLib.shared.isBluetoothOn()) } @ReactMethod fun startScanning() { Log.d(\"BLEManager\", \"Start scanning\") BLEManagerLib.shared.startScan { val params: WritableMap = Arguments.createMap() params.putString(\"name\", it.name) params.putInt(\"rssi\", it.rssi) params.putString(\"address\", it.address) this.reactApplicationContext .getJSModule(RCTDeviceEventEmitter::class.java) .emit(\"didFoundDevice\", params) } }} Creating new file to define the BLEManagerPackage 1234567891011class BLEManagerPackage: ReactPackage { override fun createNativeModules(reactContext: ReactApplicationContext): MutableList&lt;NativeModule&gt; { val modules = ArrayList&lt;NativeModule&gt;() modules.add(BLEManager(reactContext)) return modules } override fun createViewManagers(reactContext: ReactApplicationContext): MutableList&lt;ViewManager&lt;View, ReactShadowNode&lt;*&gt;&gt;&gt; { return ArrayList() }} Next, add it to the package list in MainApplication.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class MainApplication extends Application implements ReactApplication { ... @Override protected List&lt;ReactPackage&gt; getPackages() { Log.d(\"BLEManager\", \"Running\"); @SuppressWarnings(\"UnnecessaryLocalVariable\") List&lt;ReactPackage&gt; packages = new PackageList(this).getPackages(); /* Add your custom modules here */ packages.add(new BLEManagerPackage()); /* */ return packages; } ...}Finally, the app needs to ask users to grant permission.```js// somewhere in your codeimport { check, PERMISSIONS, request, RESULTS } from 'react-native-permissions';checkPermission = () =&gt; { check(PERMISSIONS.ANDROID.ACCESS_FINE_LOCATION) .then((result) =&gt; { if (result !== RESULTS.GRANTED) { requestLocation(() =&gt; { // On granted }, () =&gt; { // On denied }); } }) .catch((error) =&gt; { // … });}requestLocation = (grantedCallback, deniedCallback) =&gt; { request(PERMISSIONS.ANDROID.ACCESS_FINE_LOCATION).then(result =&gt; { switch (result) { case RESULTS.DENIED: console.log('User denied permission',); deniedCallback(); break; case RESULTS.GRANTED: console.log('The permission is granted'); grantedCallback(); break; } });} ResultSince we use the same code for both Android and iOS in the React Native part, there is no need to modify the React Native code from the previous tutorial. As long as you follow to the protocol we defined, everything should function as intended. By maintaining a consistent protocol across both platforms, we can ensure that the code is easily portable and that any changes made to one platform will not affect the other. This can significantly streamline the development process and reduce the risk of errors or compatibility issues. ConclusionAfter spending countless hours researching and experimenting, we have finally learned how to create our own Bluetooth library and use it in our React Native project. With this newfound knowledge, the process of adding new features has become significantly easier and more efficient. We only need to implement the logic in Native Code instead of having to develop the UI part twice. This has not only saved us a tremendous amount of time and effort but also allowed us to focus more on enhancing the functionality of our app. We can now dedicate more resources to developing new features, optimizing existing ones, and improving the overall user experience. Moreover, our newfound ability to create custom libraries has opened up a whole new world of possibilities for our development team. We can now leverage our knowledge of React Native to create even more advanced and innovative features, all while maintaining a streamlined development process. Happy coding! Refs Android Native Modules. Android Bluetooth permissions.","link":"/2022/02/13/Series-React-Native-and-BLE-Part-2-Building-BLE-framework-for-Android/"},{"title":"Two weeks at Fossil Group in the US","text":"Last week, I had a chance to visit the US again.","link":"/2019/05/19/Two-weeks-at-Fossil-Group-in-the-US/"},{"title":"Schedule task in background from foreground service","text":"If you’re running your service on Android, be aware that Android has introduced stricter background execution restrictions in recent versions. Starting from Android 8.0 (API level 26) and above, background services have limitations on their execution time, especially when the app is in the background. Make sure you are aware of these restrictions and adapt your service accordingly. TimerWhen using Timer to schedule tasks, it relies on a single background thread. If the screen turn off, the device may enter a low-power state or go to sleep mode, and this can effect the execution of tasks scheduled with Timer. In such cases, the device’s power-saving features might pause or delay the task execution, leading to unexpected behavior. 1234567private final Timer syncTimer = new Timer();syncTimer.scheduleAtFixedRate(new TimerTask() { @Override public void run() { // Do your task }}); In my case, my app needs to schedule a repeated task in background to sync data and check if the user still has permission to access the Bluetooth device. In the first attempt, we used Timer, and it didn’t work as expected since the Timer does not run when the device falls into doze mode (Doze mode is a power-saving feature introduced in Android 6.0 (Marshmallow) that helps extend battery life by reducing the device’s power consumption when it is idle and not in use. It optimizes app behavior to minimize background activity, network access, and CPU usage during periods of inactivity. When a device is in Doze mode, it restricts background processing, network access, and wake locks to save battery power.).Thus, we need to find an alternative, and there are two other candidates I would like to share to you: AlarmManager and WorkManager. Alarm managerIf you need to schedule tasks that should run even when the app is not actively running, you can use the AlarmManager class. It allows you to schedule tasks at specific times or intervals, even if your app is in the background or not running. The AlarmManager class in Android is a system service that allows you to schedule tasks or events to be executed at specific times or intervals, even when your app is not actively running. It provides a way to perform actions or trigger code execution at specified times, such as setting alarms, scheduling recurring tasks, or executing background operations. The key features of AlarmManager include: Timing Accuracy: AlarmManager provides accurate timing for scheduling tasks. It uses the device’s system clock to determine when the specified time or interval has elapsed. Flexibility in Scheduling: You can schedule tasks to run once (set()), repeat at fixed intervals (setRepeating()), or repeat at specific intervals with flexibility (setInexactRepeating()). This flexibility allows you to schedule tasks according to your specific requirements. Execution Persistence: The scheduled tasks registered with AlarmManager persist even if the device is restarted. This ensures that the tasks will be executed as scheduled even after system reboots. Device Wake-up Capability: AlarmManager can wake up the device from sleep mode to execute the scheduled tasks. This is useful for scenarios where you need to perform background operations that require the device to be awake. Compatibility and Backward Support: AlarmManager has been available since the early versions of Android and provides backward compatibility with older Android versions. This ensures that your scheduled tasks can run on a wide range of devices. Here’s a basic example of using AlarmManager to schedule a task: First, you’ll need to set up the necessary permissions in your AndroidManifest.xml file: 1&lt;uses-permission android:name=\"android.permission.WAKE_LOCK\"/&gt; Next, create a class to handle the task that will be executed when the alarm triggers, and use it 123456789101112131415161718192021public class MyAlarmReceiver extends BroadcastReceiver { @Override public void onReceive(Context context, Intent intent) { // Do your task }}Intent intent = new Intent(this, MyAlarmReceiver.class);PendingIntent pendingIntent = PendingIntent.getBroadcast(this, 0, intent, 0);// Get the AlarmManager serviceAlarmManager alarmManager = (AlarmManager) getSystemService(Context.ALARM_SERVICE);// Set the repeating alarmalarmManager.setRepeating( AlarmManager.RTC_WAKEUP, System.currentTimeMillis() + ALARM_INTERVAL_MS, ALARM_INTERVAL_MS, pendingIntent); Work managerWorkManager is an Android Jetpack library introduced by Google to simplify and manage background tasks in Android applications. It is designed to make it easier for developers to schedule deferrable, periodic, and one-off tasks that need to be executed even when the app is not running or the device is in a low-power state. Using WorkManager, you can perform tasks such as uploading data to a server, syncing data from a remote server, periodic data refreshes, database cleanup, and more, while ensuring efficient and battery-friendly background execution. It abstracts away the complexity of dealing with various Android versions and power-saving features, making it a powerful and recommended solution for background processing in modern Android applications. First, Open your app’s build.gradle file and add the Guava dependency to the dependencies block: 12implementation \"androidx.work:work-runtime:2.8.1\"implementation 'com.google.guava:guava:30.1-android' Next, create a class to handle the task that will be executed and use it 123456789101112131415161718192021222324class SyncDataWorker extends Worker { public SyncDataWorker( @NonNull Context context, @NonNull WorkerParameters params) { super(context, params); } @Override public Result doWork() { // Do your task return Result.success(); }}// somewhere in your codePeriodicWorkRequest periodicWorkRequest = new PeriodicWorkRequest.Builder( SyncDataWorker.class, TIME_IN_MILLISECONDS, TimeUnit.MILLISECONDS) .setConstraints(new Constraints.Builder() .setRequiredNetworkType(NetworkType.CONNECTED) // Set it if your task requires network to be completed .build()) .build();WorkManager.getInstance(context).enqueue(periodicWorkRequest); When using WorkManager and the device screen is off, there are a few limitations and considerations to keep in mind: Delayed Execution: When the device screen is off, Android may enter low-power states like Doze mode or app standby mode to conserve battery. In these states, background tasks, including those scheduled by WorkManager, may be delayed. WorkManager tries to execute tasks during maintenance windows, but there can still be delays in task execution. Network Access Restrictions: Android may restrict network access for background tasks when the screen is off. If your task relies on network connectivity, it may experience delays or have limited access to network resources. You can use constraints like setRequiredNetworkType() in WorkManager to specify network requirements for your tasks. Background Execution Limits: Starting from Android 8.0 (API level 26), Android introduced stricter background execution limits. Background apps, including those running background tasks scheduled by WorkManager, have restrictions on their ability to run CPU-intensive tasks or access certain resources. While WorkManager is designed to handle these limitations and ensure efficient task execution, it may still be subject to restrictions imposed by the operating system. Device-Specific Behavior: Different Android devices and manufacturers may have their own power-saving features or optimizations that can affect background task execution when the screen is off. These optimizations can vary, leading to different behaviors and limitations. It’s important to test your app on various devices to ensure consistent behavior. To optimize the execution of background tasks when the device screen is off, consider the following: Use appropriate constraints: Specify constraints such as network requirements (setRequiredNetworkType()), charging status (setRequiresCharging()), and more to ensure tasks are executed under the desired conditions. Respect battery optimizations: Encourage users to exclude your app from battery optimizations or whitelist it in any power-saving settings on their device. This can help ensure that your app and its background tasks are not excessively restricted. Optimize task execution: Structure your tasks to be as efficient as possible, minimizing the impact on battery life and resources. Break down larger tasks into smaller, manageable units and consider using WorkManager’s ListenableWorker or CoroutineWorker for better performance. By considering these factors and designing your background tasks and scheduling strategies accordingly, you can optimize their execution even when the device screen is off and work within the limitations imposed by the Android system. Which one to use?The choice between AlarmManager and WorkManager depends on your specific use case and requirements. Here are some factors to consider when deciding which one is better suited for your needs: Timing and Flexibility AlarmManager: It offers precise timing for executing tasks at specific times or intervals, even when the app is not actively running. AlarmManager is suitable for time-critical tasks that require exact execution timing. WorkManager: It provides more flexibility and optimization for background tasks. WorkManager considers factors like battery optimizations, network availability, and device idle state to execute tasks efficiently. It is well-suited for tasks that don’t require strict timing precision, such as syncing data or periodic updates that can accept some delay. Power Efficiency and Battery Optimization AlarmManager: It allows for more immediate execution and can wake up the device from sleep mode. However, if used improperly, it can have a significant impact on battery life. WorkManager: It leverages system optimizations to minimize battery usage. WorkManager batches tasks, respects device idle states, and adapts to power-saving features. It provides a more power-efficient approach for executing background tasks. Compatibility and Backward Support AlarmManager: It has been available since early versions of Android and offers backward compatibility with older Android versions. It can be used in a wide range of Android devices. WorkManager: It is part of the Android Jetpack library and is backward compatible down to Android API level 14 (Ice Cream Sandwich). WorkManager is designed to work consistently across different Android versions and devices. Error Handling and Retry Mechanism AlarmManager: It doesn’t provide built-in mechanisms for handling task failures or automatic retries. WorkManager: WorkManager can automatically retry failed tasks with configurable constraints. In general, if you need precise timing, immediate execution, or the ability to wake up the device from sleep mode, AlarmManager might be the better choice. On the other hand, if you require power efficiency, flexible task scheduling, error handling, and compatibility across different Android versions, WorkManager is a more suitable option.In some cases, you may even use both AlarmManager and WorkManager together, depending on the specific requirements of your app. For example, you can use AlarmManager for time-sensitive tasks and WorkManager for power-efficient background processing. ConclusionIn summary, while using Timer might lead to unpredictable behavior when the screen turns off due to single-thread execution and lack of power-saving optimizations, WorkManger and AlarmManager can handle tasks execution more efficiently and reliably, even when the screen is off or the device is in a low-power state. For scheduling background tasks, it’s generally recommended to use WorkManager or AlertManager than using Timer.","link":"/2023/07/22/Schedule-task-in-background-from-foreground-service/"},{"title":"WWDC 2020 - Top reasons why app get killed in background","text":"Ever wonder why your app gets killed from the system when it enters the background? This post is going to summarize the top reasons introduced by Apple in WWDC 2020, and what you can do to prevent your app from being killed in the background. By applying these tips, we can improve our app’s experience because your app does not have to re-launch from the scratch.Let’s rock! Top reasonsThe following describes the top 6 reasons why your app is killed while it is in the background: Crashes: Segmentation fault, illegal instructions, asserts and uncaught exceptions. Watchdog:A long hang during app transitions such as deadlock, infinite loop or unending synchronous tasks on the main thread. In approximately 20s, your app must transition from one state to another. Otherwise, it will be killed. 123+ application(_:didFinishLaunchingWithOptions)+ applicationDidEnterBackground(_:)+ applicationWillEnterForeground(_:) Excessive CPU usage:High sustained CPU load in the background. If your app really needs to do heavy works in the background, you should consider moving the task into the background processing task which gives your app several minutes of running while charging without CPU resource limits. Memory limit exceeded:Your app is using too much memory (same on background and foreground). Remember that the limitation differentiates from device to device. Before iPhone6s, 200M is the memory limitation (The older, the smaller). Memory pressure exit (aka Jetsam):It happens when the system needs to free up memory of background applications for the foreground applications (and other running applications like music or navigation app). To prevent this, try reducing the memory as small as possible, less than 50M (e.g clear out image views). However, we can’t eliminate the risk of jetsam entirely. The best advice to overcome it is leveraging the build-in UI State Restoration to restore the app state right before it had been killed in the background. The following video describes how Jetsam happens on iOS devices. Let say we open the Amazon app for shopping, we then select a favorite item to see its detail. Say we have to leave the app in the background for a moment, then we start opening other apps (Google Maps, Music, Photos, Spotify, etc.). At some point, we open the Amazon app again. As we notice, the app launches from the scratch. This is because the app is terminated by the system. Obviously, the Amazon app did not do anything wrong, it’s just because the system needs to free up memory for other applications that are running in the foreground. Background task timeout:The last common reason is using background tasks improperly. 12UIApplication.beginBackgroundTask(exprirationHandler:)UIApplication.endBackgroundTask(_:) When your app moves from foreground to background, and you want to complete some important tasks, iOS provide you some extra runtime (only a few seconds) by calling the UIApplication.beginBackgroundTask method. When the task is finished, remember to call UIApplication.endBackgroundTask to notify the system that the task gets done. If you forget to call endBackgroundTask explicitly, the timeout will be triggered 30s after suspending the app, and the termination happens. So you should carefully handle background tasks and do not kick off any additional expensive works when your app enters background mode because we only have a few seconds of runtime. While debugging, XCode will generate a log message to notify if there is a task that has been held too long without ending. When seeing this message, you should do an audit to see what went wrong with the background task calls. 12345678Background task still not ended after expiration handlers were called: &lt;_UIBackgroundTaskInfo: 0x28190d140&gt;: taskID = 8, taskName = Called by AppGetKilled, from $s12AppGetKilled13SceneDelegateC23sceneDidEnterBackgroundyySo7UISceneCF, creationTime = 70784 (elapsed = 26). This app will likely be terminated by the system. Call UIApplication.endBackgroundTask(_:) to avoid this.Background Task 5 (\"Called by AppGetKilled, from $s12AppGetKilled13SceneDelegateC23sceneDidEnterBackgroundyySo7UISceneCF\"), was created over 30 seconds ago. In applications running in the background, this creates a risk of termination. Remember to call UIApplication.endBackgroundTask(_:) for your task in a timely manner to avoid this. ConclusionIn this post, I summarized the top 6 reasons why an app can be terminated in the background, how we can do to prevent the problems, and how to recover the app gracefully from unpredictable problems like Jetsam.You can find the full document and video at WWDC 2020 - Why is my app getting killed","link":"/2021/02/25/WWDC-2020-Top-reasons-why-app-get-killed-in-background/"},{"title":"Web Bluetooth","text":"Have you ever wanted to create a web application that enables users to communicate with your device using Bluetooth? Until the introduction of Web Bluetooth, this was only possible through native mobile apps. However, with the advent of Web Bluetooth you can now turn your idea into a reality.Web Bluetooth is a game-changing technology that allows web developers to connect their applications directly to Bluetooth devices, opening up a wide range of possibilities for IoT, wearables, and other Bluetooth-enabled devices. By leveraging the power of Web Bluetooth, you can create web applications that can communicate with devices without the need for a separate native app.So if you have been dreaming of creating a web application that can interact with Bluetooth devices, now is the time to explore the possibilities of Web Bluetooth and take your development skills to the next level. What is Web Bluetooth?Web Bluetooth is a set of APIs that provide ability to connect and perform actions such as read value, write data, listen to notifications, etc. with BLE peripherals using the Generic Attribute Profile (GATT). This can enable a wide range of use cases, such as controlling IoT devices, syncing fitness data from a smartwatch, or transferring data between a smartphone and a computer.Web Bluetooth is supported by several major web browsers, including Chrome, Firefox, and Opera, and it also includes a set of industry-standard protocols for secure and efficient communication. However, it is important to note that not all Bluetooth devices may be compatible with Web Bluetooth, as support for the technology varies across different devices and manufacturers. Upside of Web Bluetooth Cross-platform: Web Bluetooth allows developers to create web applications that can communicate with Bluetooth devices on multiple platforms, including desktop and mobile devices. Ease of use: Web Bluetooth simplifies the process of connecting to Bluetooth devices, reducing the need for complex native apps or software. Accessibility: Web Bluetooth enables web developers to create applications that can communicate with Bluetooth devices without requiring users to install separate apps or plugins. Flexibility: Web Bluetooth can be used to connect with a wide range of Bluetooth devices, including IoT devices, wearables, and smart home devices. Downside of Web Bluetooth Browser support: While most modern browsers support Web Bluetooth, some older browsers may not be compatible. Security: Web Bluetooth can present security risks if not implemented properly. For example, if an application has access to a user’s Bluetooth device, it may be able to access other sensitive information on the device. Limited functionality: Web Bluetooth may not offer the same level of functionality as native Bluetooth apps. This can limit the types of applications that can be developed using the technology. Battery life: Bluetooth can be a power-intensive technology, which can drain the battery life of mobile devices. Developers need to be mindful of this when designing applications that rely on Bluetooth connectivity. Supported APIsThe APIs supported by Web Bluetooth are similar to those available on iOS and Android, which makes it straightforward to work with for developers who are already familiar with Bluetooth technology on mobile devices.You can review the flow to estashlish a connection to a peripheral at Play Central And Peripheral Roles With CoreBluetooth navigator.bluetooth.requestDevice(): This API is used to request access to a nearby BLE device. When a user clicks a “Connect” button on your web application, this API is called to scan for available devices and present a dialog box to the user. 123456789101112131415161718192021222324/**// Discovery options match any devices advertising:// . The standard heart rate service. OR// . Service uuid0, and devices with name \"ExampleName1\", and devices with name starting with \"Prefix1\" OR// . Both service uuid1 and uuid2. OR// . Devices with name \"ExampleName2\". OR// . Devices with name starting with \"Prefix2\". OR//// And enables access to the battery service if devices// include it, even if devices do not advertise that service.**/const device = await navigator.bluetooth.requestDevice({ acceptAllDevices: true, filters: [ { services: [\"heart_rate\"] }, { services: [uuid0], name: \"ExampleName1\", namePrefix: \"Prefix1\" }, { services: [uuid1, uuid2] }, { name: \"ExampleName2\" }, { namePrefix: \"Prefix2\" } ], optionalServices: [ \"battery_service\", ],}); BluetoothDevice.gatt.connect(): This API is used to establish a connection with the GATT server on the selected BLE device. Once a connection is established, your web application can interact with the device’s services and characteristics. 1const server = await device.gatt.connect(); BluetoothDevice.gatt.disconnect(): This API is used to disconnect from the BLE device once the interaction is completed. 1const server = await device.gatt.disconnect(); Get services &amp; characteristics:BluetoothDevice.gatt.getPrimaryService(serviceUuid): This API is used to retrieve a primary service from the GATT server on the selected BLE device.BluetoothRemoteGATTService.getCharacteristic(characteristicUuid): This API is used to retrieve a specific characteristic from a service. 12345const services = await server.getPrimaryServices();services.forEach(async (e) =&gt; { const chars = await e.getCharacteristics(); // Doing your logic}); Read &amp; write value:BluetoothRemoteGATTCharacteristic.readValue(): This API is used to read the value of a characteristic.BluetoothRemoteGATTCharacteristic.writeValue(value): This API is used to write a value to a characteristic. 1234await char.writeValue( fromHexString(value));await char.readValue(); Listen to disconnected event: This event listener is triggered when the device disconnects from the GATT server. 123device.addEventListener('gattserverdisconnected', () =&gt; { // Your callback}); Listen to value changed: This event listener is triggered when the value of a characteristic changes. This can be used to receive real-time updates from the device. 123device.addEventListener('characteristicvaluechanged', () =&gt; { // Your callback}); Listen to notification 12await char.stopNotifications();await char.startNotifications(); A simple exampleAt Web Bluetooth example, I have created a simple website that showcases a set of APIs. This demo website provides developers with an easy-to-use interface for testing and understanding the functionality of the APIs. By accessing this demo website, developers can quickly gain insights into how the APIs can be integrated into their applications. By default, the web scan all nearby devices. To scan for specified devices with predefined uuid, select Filters and enter your service uuid to the filter box. Here is the UI after the connection has been established successfully. More samplesYou can find more examples and ideas via this video WebBluetooth demos for Bluetooth.rocks from Niels Leenheer on Vimeo. Limitations For security purposes, we can not automatically scan and connect to a specified device. The user decides whether the web app is allowed to connect, and to which device it is allowed to connect. HTTPS Connection: Web Bluetooth requires a secure HTTPS connection to function properly. This means that the web application must be hosted on a secure server with a valid SSL certificate. If the application is not hosted on a secure server, the user will not be able to connect to Bluetooth devices. Platforms: Web Bluetooth is supported in Chrome on desktop and mobile (Require Android 6+, does not support iOS), Opera, and some versions of Microsoft Edge. It’s important to note that Web Bluetooth may not work in older or outdated browsers. Customization: Unfortunately, it’s not possible to customize the scan dialog of Web Bluetooth to show additional information beyond the default options. The Web Bluetooth API is designed to provide a simple and consistent interface for developers, and the scan dialog is intentionally kept simple to maintain this simplicity. Performance: It’s widely recognized that the stability of Bluetooth connections on native Android apps is often not as reliable as on iOS, and can be affected by factors such as the phone model, manufacturer, and version of Android being used. As a result, it’s important to note that Web Bluetooth does not function as well as native apps, especially on Android devices. Tips &amp; best practicesHere are some tips and best practices for optimizing the performance of Web Bluetooth applications: Minimize data transfers: Bluetooth communication is slow compared to other communication channels. Therefore, it’s important to minimize the amount of data that your application sends and receives over Bluetooth. For example, you can reduce the number of read and write operations and only transfer the data that is necessary for your application. Use notifications instead of polling: Instead of continuously polling the value of a characteristic, use notifications to receive updates when the value changes. This approach can reduce the number of read operations and improve the performance of your application. Disconnect when not in use: Disconnect from the GATT server when you’re not actively communicating with the device. This can reduce power consumption and improve the battery life of the device. Use caching: Caching can be used to store data that is frequently accessed by your application. This can reduce the number of read operations and improve the performance of your application. Optimize the scanning process: Scanning for devices can be a resource-intensive operation. Therefore, it’s important to optimize the scanning process by reducing the scanning time and filtering the results to only include relevant devices. Test your application on different devices: Test your application on different devices to ensure that it performs well across different platforms and hardware configurations. Final thoughtDespite these limitations, Web Bluetooth remains a promising technology with many potential use cases. Developers who are interested in using Web Bluetooth should carefully consider these limitations and design their applications accordingly. Refs https://www.smashingmagazine.com/2019/02/introduction-to-webbluetooth/ https://googlechrome.github.io/samples/web-bluetooth/","link":"/2022/10/30/Web-Bluetooth/"},{"title":"Review book: RxSwift Reactive Programming with Swift","text":"In the ever-evolving world of iOS development, mastering reactive programming can set you apart as a developer. One of the best resources to dive into reactive programming with Swift is the book “RxSwift: Reactive Programming with Swift.” This comprehensive guide provides everything you need to understand and leverage RxSwift in your applications. Let’s explore what makes this book an essential read for Swift developers. What is Reactive Programming?Reactive programming is a paradigm that allows you to work with asynchronous data streams and events in a declarative manner. Instead of manually managing callbacks and state changes, reactive programming enables you to declare how data should flow and respond to events. This results in cleaner, more maintainable code, especially for complex applications. Getting Started with RxSwiftThe book starts with the fundamentals of reactive programming, introducing core concepts such as Observables, Subscribers, and the Observer Pattern. It guides you through setting up RxSwift in your project using popular dependency managers like CocoaPods and Swift Package Manager. Core ConceptsThe book delves deeply into RxSwift’s core concepts: Observables and Observers: Learn how Observables emit items and how Observers subscribe to these streams. This is the backbone of reactive programming. Operators: RxSwift provides a rich set of operators for transforming and combining streams. The book covers various operators, including: Creation Operators: create, just, from Transformation Operators: map, flatMap, concatMap Filtering Operators: filter, distinctUntilChanged, throttle Combination Operators: merge, combineLatest, zip Subjects: Understand different types of Subjects such as PublishSubject, BehaviorSubject, ReplaySubject, and AsyncSubject and their use cases. Advanced Topics and Best Practices Once you’re comfortable with the basics, the book introduces more advanced topics: Schedulers: Manage concurrency and thread management with RxSwift’s schedulers, including MainScheduler and ConcurrentDispatchQueueScheduler. Error Handling: Discover strategies for handling errors within reactive streams using operators like catchError and retry. Memory Management: Learn best practices for managing subscriptions and avoiding memory leaks with tools like DisposeBag. Integrating RxSwift with UIKit: One of the strengths of RxSwift is its ability to integrate seamlessly with UIKit. The book demonstrates how to bind RxSwift Observables to UIKit components such as UITableView and UICollectionView. It also covers handling user inputs reactively, making your UI code more responsive and easier to manage. Testing and Debugging: Testing and debugging reactive code can be challenging. “RxSwift: Reactive Programming with Swift” provides practical advice on writing unit tests for RxSwift code and using tools like TestScheduler. It also offers tips for debugging reactive streams, helping you ensure your applications run smoothly. Real-World Applications: The book is filled with real-world examples and case studies. You’ll see how RxSwift can be applied to practical problems like network requests, form validation, and managing complex UI interactions. These examples help solidify your understanding and show how to use RxSwift effectively in your projects. Pros Clear Explanations: The book is praised for its clear and structured explanations, making complex reactive programming concepts more accessible. Practical Examples: It provides a range of practical examples that help in understanding how to use RxSwift effectively. Comprehensive Coverage: Covers both basic and advanced topics, catering to readers with varying levels of experience. Cons Swift Version: Depending on the publication date, some content might be based on older versions of Swift or RxSwift, which might require some adjustments if you’re using the latest versions. Depth of Coverage: Some readers might find that while the book covers a lot of ground, certain advanced topics might require additional resources to fully master. ConclusionThis is an invaluable resource for iOS developers looking to master reactive programming. With its clear explanations, practical examples, and comprehensive coverage of both basic and advanced topics, it’s a must-read for anyone serious about using RxSwift in their applications. Whether you’re new to reactive programming or looking to deepen your knowledge, this book will guide you every step of the way.","link":"/2020/09/26/Review-book-RxSwift-Reactive-Programming-with-Swift/"},{"title":"What is refactoring?","text":"","link":"/2018/02/27/What-is-refactoring/"},{"title":"Silent notification","text":"In the ever-evolving world of mobile app development, keeping users engaged and informed is key. For iOS developers, background notifications are a powerful tool that enhances user experience without interrupting their current activities. But what exactly are background notifications, and how do they work? Let’s dive into the details. What Are Background Notifications?Background notifications, or silent notifications, are a type of notification in iOS that allows apps to wake up and perform tasks in the background without alerting the user with a visible notification. Unlike standard notifications that appear on the screen and require user interaction, background notifications are designed to silently update the app’s content or perform background operations. These notifications are particularly useful for apps that need to keep data fresh or perform periodic tasks without bothering the user. For instance, a weather app can use background notifications to update weather information, or a news app can fetch the latest articles in the background. How Do Background Notifications Work?Background notifications rely on the Apple Push Notification Service (APNs), which is a service provided by Apple that delivers notifications to iOS devices. Here’s a simplified overview of how they work: App Registration: The app registers with APNs and receives a unique device token. Server Request: The app’s server sends a push notification request to APNs, specifying the device token and including the payload of the notification. Notification Delivery: APNs delivers the notification to the device. For background notifications, this payload includes the content-available key set to 1, indicating that the notification is intended to wake the app in the background. App Wake-Up: Upon receiving a background notification, iOS wakes up the app to handle the data or perform background tasks. This is done without displaying any visual alert to the user. Handling the Notification: The app’s code processes the notification in the background, updating content or performing necessary actions. Key Considerations Efficiency and Limitations: Background notifications should be used efficiently to avoid unnecessary use of battery and network resources. iOS may limit the frequency and size of background notifications to preserve system performance and battery life. User Privacy and Permissions: Even though background notifications do not display alerts, they still require user permission to receive notifications. Ensure that your app clearly communicates why it needs this permission. Handling Background Tasks: When handling background notifications, it’s crucial to manage tasks efficiently. iOS provides specific APIs for background tasks to ensure that operations are completed in a timely manner. Testing and Debugging: Testing background notifications can be challenging. Use debugging tools and simulators to test different scenarios and ensure your app handles notifications as expected. Practical Use Cases News Apps: Keep users updated with the latest headlines without prompting them with alerts. Social Media Apps: Update content feeds or notify the app about new messages or friend requests silently. Productivity Apps: Sync data or refresh content in the background to ensure users always have the latest information when they open the app. ConclusionBackground notifications in iOS are a powerful feature that enhances the functionality and user experience of mobile apps. By allowing apps to perform tasks in the background without disrupting the user, they enable more seamless and efficient interactions. However, they should be used thoughtfully to balance performance, battery life, and user experience.If you’re developing an iOS app, consider integrating background notifications to provide a more dynamic and responsive experience. With the right implementation, you can keep your app’s content fresh and your users engaged, all while maintaining a smooth and uninterrupted user experience.","link":"/2021/08/06/Silent-notification/"},{"title":"Working In Thread Safe on iOS","text":"As you might know, the word “Thread safe” is referred to a computer science concept in the context of multi-thread programs. A code is called “Thread safe” if any shared data is accessed by only one thread at any given time. Notice these shared data are called critical sections in an operating system.The point is Swift collection types like Array and Dictionary are not thread-safe when declared mutable (With var keyword).In this post, we will discuss some techniques to make our code thread safe in iOS. Case studyLet’s say we have an array which contains crucial data. In reality, it can be an amount of money in a credit card, transaction states, etc. They are really important so if we don’t protect these values accurately, we will face significant errors at runtime.To simulate a race condition, I’m going to use DispatchQueue.concurrentPerform to create 10 concurrent threads running at the same time. 12345678910111213class ViewController: UIViewController { var array = [Int]() override func viewDidAppear(_ animated: Bool) { super.viewDidAppear(animated) // Do any additional setup after loading the view, typically from a nib. DispatchQueue.concurrentPerform(iterations: 10) { index in self.array.append(index) } } // The rest of code} The result of the above code is unpredictable. You will fall into 2 cases: Most of the times you run this code, you will get a run-time crash like thisThe fundamental problem is because Swift collections like Array and Dictionary are not thread-safe but we let multiple threads modify the array at the same time. Stackoverflow If you luckily don’t get this crash, the elements of the array will look random like this:Element count 5Element count 9Element count 10The point is we do not always get 10 elements as expected. How it happened?It’s not safe to let one thread modify the value while another is reading it. SolutionsThe way to avoid race conditions is to synchronize data, or the critical sections. Synchronizing data usually means to “lock” it so that only one thread can access that part of the code at a time.Since Swift does not support built-in concurrency solutions, we’re going to use Grand Central Dispatch to implement thread safe instead. Using serial queueBy leveraging serial queues, we can prevent race conditions on a resource. As I introduced how a serial queue works in a previous post, Grand-Central-Dispatch-in-Swift, a serial queue allows just only one process run at a time so the array is safe from concurrent processes. 123456789101112131415161718class SafetyArray&lt;T&gt; { var array = [T]() let serialQueue = DispatchQueue(label: \"com.uynguyen.queue\") var last: T? { var result: T? self.serialQueue.sync { result = self.array.last } return result } func append(_ newElement: T) { self.serialQueue.async() { self.array.append(newElement) } } } Although we protect the array from being accessed by multiple threads, using serial queue is not the best solution. Reading the last value is not optimized because multiple read requests have to wait for each other as it is in a serial queue. Reads should be able to happen concurrently, as long as we do not make a write at the same time. Using concurrent queue with the barrier flagThe main idea of this solution is using a concurrent queue instead of a serial queue.Swift supports us to dispatch a block of code to a concurrent queue with a flag called barrier. The barrier flag ensures that the concurrent queue does not execute any other tasks while executing the barrier process. Once the barrier process done, then the queue allows running other tasks simultaneously by default implementation. 123456789101112131415161718class SafeArray&lt;T&gt; { var array = [T]() let concurrentQueue = DispatchQueue(label: \"com.uynguyen.queue\", attributes: .concurrent) var last: T? { var result: T? self.concurrentQueue.sync { result = self.array.last } return result } func append(_ newElement: T) { self.concurrentQueue.async(flags: .barrier) { self.array.append(newElement) } } } We continue to use the sync method for reading the last element, but all readers will run in parallel this time since we are using a concurrent queue. The trade offWorking with multiple threads is a hard part of coding. Although we have to protect critical sections from multiple accesses, we should keep in mind that *”Keep the synchronized sections as small as possible because Locks create delays and add overhead. They are expensive”*. Clean code.Some tips to deal with concurrency: Concurrency does not always improve performance. It sometimes incurs some overhead and bugs come from it are not usually repeatable. Limit the access of the data that is shared between more than two threads. Use copies of data if there is a chance. Multithreaded code behaves differently in different environments: Run tests in every potential deployment environment. Final thoughtsThread safe is one of the most important concepts in computer science, especially in a system which allows accessing data simultaneously. Understand how to make code thread safe, we can avoid serious errors occurring at runtime.Happy coding.","link":"/2018/06/05/Working-In-Thread-Safe-on-iOS/"},{"title":"Hello World","text":"Welcome to Uy Nguyen’s blog!I love writing, so I build this site to write any stupid crap things in my life, my job or whatever related to Software Engineering. In this way, I remember these topics longer. I also want to share what I learned to anyone who needs it.Feel free to kick an email if you need to reach me. “Be a Software Engineer, not a Coder.” - Uy Nguyen","link":"/2017/08/01/hello-world/"},{"title":"What&#39;s new in iPad OS 14?","text":"To see #5 top updates in iPadOS 14.","link":"/2020/06/26/What-s-new-in-iPad-OS-14/"},{"title":"What&#39;s new of Appclip on iOS 17?","text":"With the introduction of iOS 17, applications now have the ability to launch App Clips from other apps using the App Clip’s invocation URL. This functionality opens up various possibilities. For instance, if you’ve developed a suite of apps, you can enable them to launch App Clips from one another, providing users with access to specific functionalities without the need for a full app installation. Furthermore, your app could extend the offer to launch App Clips from other developers if your workflows involve interactions with those apps. This collaborative approach enhances user convenience, allowing them to seamlessly navigate between apps and leverage diverse functionalities. The interconnectivity fostered by this feature promotes a more integrated and user-centric experience within the iOS ecosystem. https://developer.apple.com/videos/play/wwdc2023/10178/","link":"/2023/11/09/What-s-new-of-Appclip-on-iOS-17/"},{"title":"Advanced iOS Concurrency: Operations [1]","text":"There are two techniques to deal with Concurrency in iOS: GCD - Grand Central Dispatch and Operations. Most of the time, GCD provides most of the concurrency capabilities you need. Yet, sometimes you’ll want some extra advanced customizations. It’s time to use Operations. This tutorial will introduce Operations in Swift, also explain when and why we use Operation instead of GCD.Let’s switch the gears! There is a big gap between knowing the path and walking through the path. Introduce OperationsOperation is a class allowing you to submit a block of code that should be run on a different thread, it is built on top of GCD. Basically, both GCD and operation roles are similar. However, operations have other benefits that give us more control over the task. OOP design: as the operation is a Swift class, you can subclass it and override its methods if need. It will be easy to use and re-use in the future. State management: An Operation has its own state machine that is changed during its lifecycle. The operation itself handles the changes of its states. We can not modify these states of an object. Dependency among operations: If you want to start a task after other tasks have finished executing, then the operation should be your choice. An operation will not start executing until all of the operations that it depends on have successfully finished their jobs. Cancel the submitted task: By using operations, we have the capability of canceling a running operation. It’s very useful in a case where we want to stop operations that are irrelevant at a certain time. For example, to cancel downloading data when the user scrolls the table making some cells disappear. Dependency and the capability of canceling making operations much more controllable over GCD. Take to practiceLet’s assume that we’re building an application that will fetch some posts of mine. After downloading the cover images, they will be applied a simple filter, then displayed in a table view.Go ahead and create a project. The project simply contains only one main screen with a table view that displays posts with a title and a cover image. To simplify the source of data, I created a JSON file that contains 100 rows describing a post with key as title and value as the url linked to the cover image. 123456789[ // input.json {\"Building your personal page with Hexo\": \"https://uynguyen.github.io/Post-Resources/Hexo/Cover.png\"}, {\"Beta Test and TestFlight\": \"https://uynguyen.github.io/Post-Resources/TestFlight/Cover.png\"}, {\"iOS: Mix and Match\": \"https://uynguyen.github.io/Post-Resources/MixMatch/mix-match-banner.png\"}, {\"Best practice: Core Data Concurrency\": \"https://uynguyen.github.io/Post-Resources/CoreDataConcurrency/banner.png\"}, {\"Two weeks at Fossil Group in the US\": \"https://uynguyen.github.io/Post-Resources/Fossil_Group/Fossil_Group.jpg\"}, ...] Inside the MainViewController, let’s read the input file 12345678910111213141516171819202122class ViewController: UIViewController { @IBOutlet weak var tbPosts: UITableView! var urls = [(title: String, url: String)]() override func viewDidLoad() { super.viewDidLoad() self.setup() // ... } func setup() { let inputUrl = Bundle.main.url(forResource: \"input\", withExtension: \"json\")! do { let data = try Data(contentsOf: inputUrl) if let jsonDict = try JSONSerialization.jsonObject(with: data) as? [[String: String]] { self.urls = jsonDict.map { ($0.first!.key, $0.first!.value) } } } catch { } } By using a simple function of CoreImage, the grayScale(input:) method will transform a UIImage to a black-white image with the Tonal filter 12345678910111213141516171819func grayScale(input: UIImage) -&gt; UIImage? { let context = CIContext(options: nil) var inputImage = CIImage(image: input) let filters = inputImage!.autoAdjustmentFilters() for filter: CIFilter in filters { filter.setValue(inputImage, forKey: kCIInputImageKey) inputImage = filter.outputImage } let cgImage = context.createCGImage(inputImage!, from: inputImage!.extent) let currentFilter = CIFilter(name: \"CIPhotoEffectTonal\") currentFilter!.setValue(CIImage(image: UIImage(cgImage: cgImage!)), forKey: kCIInputImageKey) let output = currentFilter!.outputImage let cgimg = context.createCGImage(output!, from: output!.extent) return UIImage(cgImage: cgimg!)} It’s time to set up the table view, we use URLSession to download the image from the input url, then display to the cell after downloading successfully. 1234567891011121314151617181920extension ViewController: UITableViewDataSource { // The rest omitted func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell { let cell = tableView.dequeueReusableCell(withIdentifier: \"CellId\", for: indexPath) as! PostTableViewCell let input = urls[indexPath.row] URLSession.shared.dataTask(with: URL(string: input.url)!, completionHandler: { (data, res, error) in guard error == nil, let data = data, let image = UIImage(data: data) else { return } DispatchQueue.main.async { cell.lblPostTitle.text = input.title cell.imgPostImage.image = self.grayScale(input: image) } }).resume() return cell }} Build and run the project, you should see the images appear on the list. Let’s try to scroll the table. Can you feel laggy?You might notice where the issue comes from. To set up a cell, we first download the image from the internet, then apply a Tonal filter to the image. These two actions are performing in the main thread, putting too much pressure on the thread that should only use for user interaction. Using GCDWe can dispatch the code of downloading and filtering image to another separated queue 12345678910111213DispatchQueue.global(qos: .background).async { URLSession.shared.dataTask(with: URL(string: input.url)!, completionHandler: { (data, res, error) in guard error == nil, let data = data, let image = UIImage(data: data) else { return } let filteredImage = self.grayScale(input: image) DispatchQueue.main.async { cell.lblPostTitle.text = input.title cell.imgPostImage.image = filteredImage } }).resume()} By executing the code on a background queue, we offload work to the main queue and make the UI much more responsive.Rebuild the project, you will see the differences.Even we resolve the issue of user interaction, the performance of the app is still not optimized.What can be done to make this better?As the user scrolls the table, cells come and gone. There’s no sense in continuing to download and process an image of an invisible cell. It’s better to cancel the block of code to improve the performance and reduce the battery consumption of the app. But how we can cancel a task that is running in GCD?Here is the Operation come to. Switch gear to OperationLet’s break the task to set up a table view cell into two tasks: one is to download the image and another is to apply the filter. 12345678910111213141516171819class DownloadImageOperation: Operation { let url: URL var outputImage: UIImage? init(url: URL) { self.url = url } override func main() { guard !isCancelled else { return } URLSession.shared.dataTask(with: self.url, completionHandler: { (data, res, error) in guard error == nil, let data = data else { return } self.outputImage = UIImage(data: data) }).resume() }} 123456789101112131415161718192021222324252627282930313233343536class ImageFilterOperation: Operation { let context = CIContext(options: nil) var processedImage: UIImage? func grayScale(input: UIImage) -&gt; UIImage? { var inputImage = CIImage(image: input) let filters = inputImage!.autoAdjustmentFilters() for filter: CIFilter in filters { filter.setValue(inputImage, forKey: kCIInputImageKey) inputImage = filter.outputImage } let cgImage = context.createCGImage(inputImage!, from: inputImage!.extent) let currentFilter = CIFilter(name: \"CIPhotoEffectTonal\") currentFilter!.setValue(CIImage(image: UIImage(cgImage: cgImage!)), forKey: kCIInputImageKey) let output = currentFilter!.outputImage let cgimg = context.createCGImage(output!, from: output!.extent) return UIImage(cgImage: cgimg!) } override func main() { guard !isCancelled else { return } let dependencyImage = self.dependencies .compactMap { $0 as? DownloadImageOperation } .first if let image = dependencyImage?.outputImage { guard !isCancelled else { return } self.processedImage = self.grayScale(input: image) } }} To use Operation, we simply subclass the Operation class and override the main method where our task is placed. By default, operations run in the background, so there are no worries about blocking the main thread.Back to the task to set up the table view cell, you might notice that there is a dependency between these two tasks, we only do the filter process after downloading the image. In other words, the ImageFilterOperation operation depends on the DownloadImageOperation operation. Operation Dependencies is one of the “killer functions” of Operation along with the capability of canceling a running operation. By linking the two operations, we ensure that the dependent operation does not begin before the prerequisite operation has completed. Additionally, the linking makes a clean way to pass data from the first one to the second one. 1234e.glet dependencyImage = self.dependencies .compactMap { $0 as? DownloadImageOperation } .first It’s time to do the improvement.Let’s first define an OperationQueue to the ViewController. The OperationQueue class is what we use to manage Operations. 123456789101112131415161718192021222324class ViewController: UIViewController { private let queue = OperationQueue() // The rest omiited // ... func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell { let cell = tableView.dequeueReusableCell(withIdentifier: \"CellId\", for: indexPath) as! PostTableViewCell let input = urls[indexPath.row] let downloadOpt = DownloadImageOperation(url: URL(string: input.url)!) let grayScaleOpt = ImageFilterOperation() grayScaleOpt.addDependency(downloadOpt) grayScaleOpt.completionBlock = { DispatchQueue.main.async { cell.lblPostTitle.text = input.title cell.imgPostImage.contentMode = .scaleToFill cell.imgPostImage.image = grayScaleOpt.processedImage } } self.queue.addOperation(downloadOpt) self.queue.addOperation(grayScaleOpt) return cell }} Here, we init two new instances of the DownloadImageOperation and the ImageFilterOperation classes. Then, we set grayScaleOpt operation depend to downloadOpt that will make sure the grayScaleOpt only be executed after the downloadOpt has completed. Finally, we add these two operations to the OperationQueue. Once an operation is added to the queue, the operation will be scheduled. If the queue finds an available thread on which to run the operation, the job will be executed until it has completed or been canceled. When the operation completes, the completionBlock is called. “Operations have important effects on your application’s performance. For instance, if you want to download a lot of content from the Internet, you might want to do so only when it is absolutely necessary. Also, you might decide to ensure that only a specific number of operations can run at the same time. If you do decide to limit the number of concurrent operations in a queue, you can change the maxConcurrentOperationCount property of your operation queue. This is an integer property that allows you to specify how many operations, at most, can run in a queue at a given time.” (iOS 8 Swift Programming Cookbook) Learning the above theories is enough, now re-build the project to see the result. Ops! Nothing appears, the image is not downloaded! Something went wrong ???In the next tutorial, we will find out what happened to our code and why the Operation did not work properly as expected.Thank you for reading.","link":"/2020/05/16/iOS-Concurrency-Operations/"},{"title":"iOS: Mix and Match","text":"As Swift has been becoming a flagship language for iOS development, most of the new iOS projects nowadays are built in Swift. However, there are many useful libraries are developed in other low-level programming languages such as Objective-C and / or C++ to boost performance. On the other hand, not all engineering positions are open to new projects, most of them are hired to maintain and develop new features based on the current code base that are built-in Objective-C.Having the knowledge to mix the two languages within a single project is good for your iOS development skills as you will face it someday in your career path. In this post, I’m going to show you not only how to use Objective-C and Swift in one single project but also how to use a set of programming languages in a single one, including C++/ Objective-C/ Swift and React Native. Hope you will find this post interesting.Let’s drive-in. C++ &lt;- Objective-C++For those who have not heard about Objective-C++,Objective-C++ is Objective-C is actually a source code that mixes Objective-C classes and C++ classes in one single file.You just need to change your .m file to .mm to get the magic worked.First, I will create a C++ library that will be used by Objective-C++ classes. 1234class CPlusPlusMath { public: int multiplyTwoNumbers(int a, int b);}; The implementation 123int CPlusPlusMath::multiplyTwoNumbers(int a, int b) { return a * b;} Then, you need to create a bridging header file to your project because our new project is in Swift language. The bridging header is where you define all the Objective-C classes that are exposed to Swift. When we add a new Objective-C class to the Swift code-based project, XCode automatically offers to add this file to the project.Next, you rename the .m file to .mm to change it from Objective-C code to Objective-C++.From now on, you can call to our C++ lib (or other ones) inside this Objective-C++ file 12345678#import \"CPlusPlusMath.hpp\"@implementation ObjMath- (long)multiplyTwoNumbers:(int) num1 num2:(int) num2 { CPlusPlusMath *a = new CPlusPlusMath(); return a-&gt;multiplyTwoNumbers(num1, num2);} Objective-C++ &lt;-&gt; SwiftThe interesting thing is we can call Objective-C(++) code from Swift code and vise versa.To use Objective-C classes from Swift, we need to declare their headers to the bridging header file. Let’s go ahead and include our mathematical library to this file. 12345//// Use this file to import your target's public headers that you would like to expose to Swift.//#include \"ObjMath.h\" That’s all you need to do to build the first line from Objective-C to Swift. 1234func multiply(num1: Int, num2: Int) -&gt; Int { let objMath = ObjMath() return objMath.multiplyTwoNumbers(Int32(num1), num2: Int32(num2))} Next, we need to build the other line from Swift to Objective-C.We use objc keyword before any classes and methods we want to expose to Objective-C classes. A small note is that these exposed classes need to be inherited from the NSObject class. Otherwiser, we will get the complile error Only classes that inherit from NSObject can be declared @objc. 123456789@objcclass SwifthMath: NSObject { @objc func add(num1: Int, num2: Int) -&gt; Int { return num1 + num2 } // The rest omited} Swift &lt;-&gt; React NativePlease find my series at React Native and BLE Limitation Swift objects can have a subclass of an objective-c class, like NSObject. But a swift class cannot be a base class for an objective-c class. TroubleshootConclusionsMany developers are still using Objective-C for many reasons, and they definitely use C++ libraries in their projects, especially in Game development where C++ reaches full its performance.I hope that this post will give you a quick look at how to Mix and Match multiple languages in a single project.You can find the demonstration project at GithubThanks for reading.","link":"/2020/01/30/iOS-Mix-and-Match/"},{"title":"iOS: Introducing Stack Views Programmatically","text":"As your iOS development skill is growing, I believe you use UIScrollView, UICollectionView, UITableView, and other native views regularly and proficiently in your applications. Yet, some iOS developers still don’t know what exactly UIStackView is, what it uses for or in which situation should we use UIStackView.In this tutorial, I will introduce you to UIStackView - A view helps us to simplify our iOS layouts. Let’s imagine you’re going to build an application that allows the user to add or remove views in run time. Remember how we will accomplish this task? We first have to remove all constraints in the relative area and update them all over again. Or remember the case where you implement the sign-in / sign-up view, you add many text fields and manually set constraints between those views. In such situations, UIStackView appears to be more useful than other views. To demonstrate how to apply UIStackView to your projects, we’re going to build a simple application that allows the user to control smart devices in their home; Users can add or remove which room they want it to show in their list of control. The main key here is all actions of the user are executed in runtime dynamically. Additionally, instead of using Storyboard in this project, I’m going to use code dynamically along with the help of the AutoLayout framework (SnapKit - it is just a matter of preference). Let’s put aside other complex implementation, the application contains only two views: A login view and a home page. Also, there will be no logic code at all. Key propertiesTo understand how a Stack View work, we first need to have a look at its properties. No matter what kind of the Stack View is (Horizontal or Vertical), there are four main properties: Axis, Spacing, Alignment, and Distribution. The following image summarizes the relative among those attributes. Axis: determines the stack’s orientation, including Horizontal and Vertical. Spacing: determines the minimum space between the stack’s views. Alignment: determines the layout of the stack’s views perpendicular to its axis.Both horizontal and vertical stack views have the Fill and Center options. Fill: Stack’s arranged views will be resized so that they fit the stack view perpendicularly to its axis. The leading and trailing edges of vertically stacked items or the top and bottom edges of horizontally, respectively. Center: As the name suggests, center the stack’s views horizontally (Vertical stack) or vertically (Horizontal stack). Fill Center There are some alignment options applied only for horizontal stack views: Top: As the name suggests, center the stack’s views horizontally (Vertical stack) or vertically (Horizontal stack). Bottom: As the name suggests, center the stack’s views horizontally (Vertical stack) or vertically (Horizontal stack). First baseline: A layout where the stack view aligns its arranged views based on their first baseline. Last baseline: A layout where the stack view aligns its arranged views based on their last baseline. Top Bottom First baseline Last baseline Similarly, there are some alignment options worked for vertical stack views only: Leading: The stack view aligns the leading edge (Left) of its arranged views along its leading edge. Similar to top alignment for horizontal stacks. Trailing: The stack view aligns the trailing edge (Right) of its arranged views along its leading edge. Similar to bottom alignment for horizontal stacks. Leading Trailing Distribution: determines the layout of the stack’s views along its axis. The subviews are all resized based on this setting. Fill: This is set as the default distribution when a Stack View is created. When we put views inside a UIStackView with Fill set as the distribution, it will keep trying to stretch the size one of the views to fill the space.So the question is, what criteria will it base on to choose the view to resize? Content Hugging Priority (CHP) will be. To determine which view will be stretched, the stack view will rely on CHP for evaluation, the lower its priority, the more likely it is to be chosen. If all the views have the same CHP, the first one will be picked. Fill Equally: Each control in a UIStackView will be of equal size. Fill Proportionally: All the controls need to have an intrinsic content size, Stack view will ensure the controls maintain the same proportion. Equal Spacing: This distribution type will maintain equal spacing between the subviews. Equal Centering: This distribution type will maintain an equal space between the center of the subviews. Fill Fill Equally Fill Proportionally Equal Spacing Equal Centering Note: UIStackView is a non-rendering view, which means you can not set the background-color property, or override the draw method, etc. Take to practiceNow, with that knowledge in mind, we’re going to apply it to an existed project that currently does not use UIStackView to arrange its view at all. By applying UIStackView into practice, we will really get an understanding of how a UIStackView works and what problems it can resolve. Auto arrange viewsThe first thing UIStackView brings to us is the freedom from setting constraints for all views.The login view is quite simple, it contains two text fields, a login button and some text labels. Without using UIStackView, we have to manually set constraints for all those text fields. 12345678910111213141516171819view.addSubview(lblLogin)lblLogin.snp.makeConstraints { (make) in make.centerX.equalToSuperview() make.centerY.equalToSuperview().offset(-250) make.left.equalToSuperview().offset(20) make.right.equalToSuperview().offset(-20) make.height.equalTo(30)}view.addSubview(lblUsername)lblUsername.snp.makeConstraints { (make) in make.centerX.left.right.equalTo(lblLogin) make.top.equalTo(lblLogin.snp.bottom).offset(30) make.height.equalTo(30)}view.addSubView(btnLogin)//...// The rest omitted But it’s still not a nightmare. Imagine now you want to add some other views, such as a label and a switch view to allow the user to remember the login session. We now have to alter all other views to insert those new views to the right place on the screen! The task will be easier and simpler if we use StackView. Now let see how we can do it.First, let’s add a new property to the Log in view controller. 12345678910111213lazy var stackView: UIStackView = { let stack = UIStackView() stack.axis = .vertical stack.spacing = 20.0 stack.alignment = .fill stack.distribution = .fillEqually [self.lblUsername, self.txtUserName, self.lblPassword, self.txtPassword, self.btnLogin].forEach { stack.addArrangedSubview($0) } [1] return stack}() Notice at [1], this is how we add arraged views to a stack view. Then, we just need to set contraints for the stackView. 12345678910override func viewDidLoad() { super.viewDidLoad() // ... view.addSubview(stackView) stackView.snp.makeConstraints { (make) in make.centerX.left.right.equalTo(lblLogin) make.top.equalTo(lblLogin.snp.bottom).offset(30) make.height.equalTo(280) }} In the future, if we want to add new views, we just need to put it to the arranged views array. As below. 123456789lazy var keepLoginStackView: UIStackView = { let stackView = UIStackView() stackView.axis = .horizontal stackView.alignment = .trailing stackView.distribution = .fill [self.lblRememberMe, self.swKeepLogin].forEach { stackView.addArrangedSubview($0) } return stackView}() 12345// ...self.txtPassword,self.keepLoginStackView,self.btnLogin].forEach { stack.addArrangedSubview($0) }// ... Can you see the differences? The codebase now is cleaner and more maintainable than the old one, isn’t it? Dynamic viewsNow switch to the case where we will implement the Home page of the application.When the user presses the right button of the screen, a new view, which represents for a room to be controlled in this case, will be placed on the main page. The user can also remove any rooms in the list by pressing the “Remove” button. Inside each room, there is a “Hide” / “Show” button that allows hiding and showing the room image. Remember in the past where you have to implement a similar feature in your app without using UIStackView, what will you do? Somewhat painful! We first need to remove all constraints in the relative area and update them all over again. Here is what we’re going to do with UIStackView, the main page contains a vertical stack view embedded inside a scroll view. Whenever the Add button is pressed, a new TaskView view will be added to this stack view. 1234567func addMoreView() { let view = TaskView(delegate: self, data: room[Int.random(in: 0..&lt;room.count)]) let constraint1 = view.heightAnchor.constraint(lessThanOrEqualToConstant: 400.0) constraint1.isActive = true self.taskStackView.addArrangedSubview(view) self.view.layoutIfNeeded()} We also need to set height constraints for this new view. Because the height of the view might be changed when the show/hide button is pressed, we need to define this constraint as lessThanOrEqualToConstant:value so that the stack view can adjust this height constraint. 12345678910func onRemove(_ view: TaskView) { if let first = self.taskStackView.arrangedSubviews.first(where: { $0 === view }) { UIView.animate(withDuration: 0.3, animations: { first.isHidden = true first.removeFromSuperview() }) { (_) in self.view.layoutIfNeeded() } }} When the remove button on a task view is clicked, this view will be removed from the stack view. We can access all arranged views of a stack view by accessing arrangedSubviews property. We first loop for all arranged views and find the appropriate view which have the same address with the sender, then remove it from the super view. Additionally, I make a small animation, UIView.animate(withDuration:animations:), so that the transition looks more smooth and fancier than the last one.By using the same approach, you can do the same thing when the user clicks on Show / Hide button to show/hide the image view. Let’s take a try by yourself. Final thoughIn this tutorial, I introduced you to UIStackView - a subclass of UIView helping to manages the position and size of its arranged views. We also worked through a demonstration that takes UIStackView into practice. Now you get the idea of how the UIStackView works and what the UIStackView uses for, next times try to use UIStackView in your app to leverage its power. I will do, won’t you?You can download the completed demo at Github,Happy coding!","link":"/2020/07/18/iOS-Introducing-Stack-Views/"},{"title":"iOS 18: What&#39;s news in CoreBluetooth?","text":"AccessorySetupKit, introduced in iOS 18, revolutionizes how third-party Bluetooth and Wi-Fi accessories integrate with iOS devices. This framework delivers a seamless setup experience, enhancing convenience for users and expanding capabilities for developers.While AccessorySetupKit supports discovery for Bluetooth, Wi-Fi, and Local Network devices, this post will focus specifically on BLE (Bluetooth Low Energy). The setup process for Wi-Fi and Local Network devices follows a similar approach. Key FeaturesBelow, we’ll explore the key functionalities that make AccessorySetupKit a major change for accessory management. Streamlined Pairing Process: Users can now pair or unpair accessories and toggle Bluetooth directly within the app, eliminating the need to go through system settings. This streamlined approach enhances the user experience and reduces setup time. Unified Access Management: Once an accessory is paired, it appears in the new “Accessories” section within the Privacy settings. Here, users can manage permissions and view connected devices, providing a centralized location for accessory management. Enhanced Developer Control: Developers can define scanning filters and provide custom images and names for devices, ensuring branded setup experience. Setup flowYou can find the example project provided by Apple on WWWDC24.To simulate the accessories, I used CoreBluetooth and defined my Bluetooth profile with two different UUIDs: 1FA2FD8A-17E0-4D3B-AF45-305DA6130E39 and 1FA2FD8A-17E0-4D3B-AF45-305DA6130E38, then started advertising them.Next, you need to modify the scanning UUID service in your Info.plist file to match your Bluetooth profiles. This informs the system of the accessory types your app supports.Apple supports different filter types, such as: 123456789101112131415161718&lt;dict&gt; &lt;key&gt;NSAccessorySetupBluetoothCompanyIdentifiers&lt;/key&gt; &lt;array&gt; #Matches the key of an advertised manufacturing data field &lt;/array&gt; &lt;key&gt;NSAccessorySetupBluetoothServices&lt;/key&gt; &lt;array&gt; #Matches either an advertised service UUID field or the key (service UUID) of an advertised service data field &lt;/array&gt; &lt;key&gt;NSAccessorySetupBluetoothNames&lt;/key&gt; &lt;array&gt; #Match any substring within the advertised name &lt;/array&gt; &lt;key&gt;NSAccessorySetupKitSupports&lt;/key&gt; &lt;array&gt; &lt;string&gt;Bluetooth&lt;/string&gt; &lt;/array&gt;&lt;/dict&gt; Next, create an ASAccessorySession. This session is essential for managing the accessory setup process, enabling you to present the accessory picker to users and handle various accessory-related events efficiently. 1private var session = ASAccessorySession() Then, present the Accessory Picker. This allows you to display the picker interface, enabling users to easily select and pair their accessories with the app. 123456789101112131415161718192021222324252627let pickerDevice1: ASPickerDisplayItem = { let descriptor = ASDiscoveryDescriptor() descriptor.bluetoothServiceUUID = ### return ASPickerDisplayItem( name: ###, productImage: UIImage(named: ###)!, descriptor: descriptor )}()let pickerDevice2: ASPickerDisplayItem = { let descriptor = ASDiscoveryDescriptor() descriptor.bluetoothServiceUUID = ### return ASPickerDisplayItem( name: ###, productImage: UIImage(named: ###)!, descriptor: descriptor )}()session.showPicker(for: [pickerDevice1, pickerDevice2]) { error in if let error { print(\"Failed to show picker due to: \\(error.localizedDescription)\") }} The user will now see a list of discovered devices and can select one to begin the pairing process, following the standard flow. 1234567891011121314151617private func handleSessionEvent(event: ASAccessoryEvent) { switch event.eventType { case .accessoryAdded, .accessoryChanged: guard let device = event.accessory else { return } # Save your device case .activated: guard let device = session.accessories.first else { return } # Save your device case .accessoryRemoved: # Clean up case .pickerDidPresent: # Your logic case .pickerDidDismiss: # Your logic default: ### }} What’s importants?AccessorySetupKit streamlines the setup process for users, making it more intuitive and efficient while eliminating the complexity often associated with connecting third-party accessories.For developers, it provides a standardized integration framework, ensuring consistent user experiences and simplified codebases. By adopting AccessorySetupKit, developers can deliver a seamless and cohesive experience that aligns third-party accessories with the high standards users associate with Apple products. RefsMeet AccessorySetupKit, WWWDC 2024iOS 18 AccessorySetupKit: Everything BLE Developers Need To Know","link":"/2024/11/03/iOS-18-What-s-news-in-CoreBluetooth/"}],"tags":[{"name":"Android","slug":"Android","link":"/tags/Android/"},{"name":"Bluetooth","slug":"Bluetooth","link":"/tags/Bluetooth/"},{"name":"Swift","slug":"Swift","link":"/tags/Swift/"},{"name":"iOS","slug":"iOS","link":"/tags/iOS/"},{"name":"Concurrency","slug":"Concurrency","link":"/tags/Concurrency/"},{"name":"Operations","slug":"Operations","link":"/tags/Operations/"},{"name":"Core Data","slug":"Core-Data","link":"/tags/Core-Data/"},{"name":"BLE","slug":"BLE","link":"/tags/BLE/"},{"name":"iBeacon","slug":"iBeacon","link":"/tags/iBeacon/"},{"name":"Objective-C","slug":"Objective-C","link":"/tags/Objective-C/"},{"name":"CoreBluetooh","slug":"CoreBluetooh","link":"/tags/CoreBluetooh/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"WatchOS","slug":"WatchOS","link":"/tags/WatchOS/"},{"name":"Vendor","slug":"Vendor","link":"/tags/Vendor/"},{"name":"Study","slug":"Study","link":"/tags/Study/"},{"name":"Design Patterns","slug":"Design-Patterns","link":"/tags/Design-Patterns/"},{"name":"Appclip","slug":"Appclip","link":"/tags/Appclip/"},{"name":"UML","slug":"UML","link":"/tags/UML/"},{"name":"Software Architecture","slug":"Software-Architecture","link":"/tags/Software-Architecture/"},{"name":"DispatchQueue","slug":"DispatchQueue","link":"/tags/DispatchQueue/"},{"name":"Memory management","slug":"Memory-management","link":"/tags/Memory-management/"},{"name":"ReactNative","slug":"ReactNative","link":"/tags/ReactNative/"},{"name":"CrossPlatform","slug":"CrossPlatform","link":"/tags/CrossPlatform/"},{"name":"macOS","slug":"macOS","link":"/tags/macOS/"},{"name":"Cocoa","slug":"Cocoa","link":"/tags/Cocoa/"},{"name":"books","slug":"books","link":"/tags/books/"},{"name":"study","slug":"study","link":"/tags/study/"},{"name":"Books","slug":"Books","link":"/tags/Books/"},{"name":"Notification","slug":"Notification","link":"/tags/Notification/"},{"name":"Conference","slug":"Conference","link":"/tags/Conference/"},{"name":"Web Bluetooth","slug":"Web-Bluetooth","link":"/tags/Web-Bluetooth/"},{"name":"UI","slug":"UI","link":"/tags/UI/"},{"name":"UIStackView","slug":"UIStackView","link":"/tags/UIStackView/"}],"categories":[]}